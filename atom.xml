<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://list-jiang.github.io/</id>
  <title>𝓛𝓲𝓼𝓽·𝓙𝓲𝓪𝓷𝓰</title>
  <subtitle>远方无限 砥砺前行</subtitle>
  <author>
    <name>List Jiang</name>
  </author>
  <updated>2022-02-17T08:42:49.490Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://list-jiang.github.io/atom.xml"/>
  <link rel="alternate" href="https://list-jiang.github.io/"/>
  <rights>Copyright © 2019-present List·Jiang</rights>
  <category term="基础"/>
  <category term="网络 - TCP - IP"/>
  <category term="GitHub"/>
  <category term="JSON"/>
  <category term="教程"/>
  <category term="Markdown"/>
  <category term="Python"/>
  <category term="TypeScript"/>
  <category term="Node.js"/>
  <category term="前端"/>
  <category term="CSS"/>
  <category term="Emmet"/>
  <category term="HTML"/>
  <category term="jQuery"/>
  <category term="JavaScript"/>
  <category term="Linux"/>
  <category term="笔记"/>
  <category term="Spring"/>
  <category term="软件"/>
  <category term="Git"/>
  <category term="服务器"/>
  <category term="VS Code"/>
  <contributor>
    <name>List Jiang</name>
  </contributor>
  <contributor>
    <name>廖雪峰</name>
  </contributor>
  <contributor>
    <name>阮一峰</name>
  </contributor>
  <contributor>
    <name>小灰</name>
  </contributor>
  <contributor>
    <name>Mr.Hope</name>
  </contributor>
  <contributor>
    <name>Mr.Hope &amp; 廖雪峰</name>
  </contributor>
  <entry>
    <title type="html">关于网站</title>
    <id>https://list-jiang.github.io/about/site/</id>
    <link href="https://list-jiang.github.io/about/site/"/>
    <updated>2021-12-07T13:14:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关于网站"> 关于网站</h1>
<p>网站使用 <a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">VuePress</a> 建站工具构建，使用主题 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<h2 id="仓库链接"> 仓库链接</h2>
<ul>
<li><a href="https://github.com/List-Jiang/list-jiang.github.io.git" target="_blank" rel="noopener noreferrer"><strong>𝓛𝓲𝓼𝓽·𝓙𝓲𝓪𝓷𝓰 的个人博客</strong></a></li>
</ul>
<h2 id="免责声明"> 免责声明</h2>
<p>此博客包含 <a href="https://github.com/ruanyf" target="_blank" rel="noopener noreferrer">阮一峰</a> 和 <a href="https://weibo.com/liaoxuefeng" target="_blank" rel="noopener noreferrer">廖雪峰</a> 两位老师的博客和书籍。</p>
<p>在这里给他们致以诚挚的感谢。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">𝓛𝓲𝓼𝓽·𝓙𝓲𝓪𝓷𝓰 介绍</title>
    <id>https://list-jiang.github.io/about/</id>
    <link href="https://list-jiang.github.io/about/"/>
    <updated>2022-01-20T07:46:03.000Z</updated>
    <content type="html"><![CDATA[<i>Not supported content</i>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">斐波那契数列解法</title>
    <id>https://list-jiang.github.io/base/data-structure/fib/</id>
    <link href="https://list-jiang.github.io/base/data-structure/fib/"/>
    <updated>2021-12-08T06:40:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="斐波那契数列解法"> 斐波那契数列解法</h1>
<div><pre><code>    <span>// 迭代</span>
    <span>static</span> <span>int</span> <span>test1</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>return</span> n <span>>></span> <span>1</span> <span>&lt;=</span> <span>0</span> <span>?</span> <span>Math</span><span>.</span><span>max</span><span>(</span>n<span>,</span> <span>0</span><span>)</span> <span>:</span> <span>test1</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>test1</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 递归</span>
    <span>static</span> <span>int</span> <span>test2</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n<span>==</span><span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>int</span> a <span>=</span> <span>0</span><span>;</span>
        <span>int</span> b <span>=</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span><span>--</span>n<span>></span><span>0</span><span>)</span><span>{</span>
            b <span>=</span> b <span>+</span> a<span>;</span>
            a <span>=</span> b <span>-</span> a<span>;</span>
        <span>}</span>
        <span>return</span> b<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-08T06:40:05.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">操作系统</title>
    <id>https://list-jiang.github.io/code/basic/OS/</id>
    <link href="https://list-jiang.github.io/code/basic/OS/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>操作系统 (Operating System，OS) 是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)。</p>

<p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如:</p>
<ol>
<li>
<p>文件系统</p>
<p>提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</p>
</li>
<li>
<p>设备驱动程序</p>
<p>提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让您能吃到鸡蛋，但不用养一只鸡。</p>
</li>
<li>
<p>用户接口</p>
<p>操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</p>
</li>
<li>
<p>系统服务程序</p>
<p>当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</p>
</li>
</ol>
<p>打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。</p>
<p><img src="./assets/OS.gif" alt="操作系统结构示意图" loading="lazy"></p>
<p>目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-26T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">持续集成</title>
    <id>https://list-jiang.github.io/code/basic/ci/</id>
    <link href="https://list-jiang.github.io/code/basic/ci/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。</p>
<p>持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。</p>
]]></summary>
    <content type="html"><![CDATA[<p>持续集成 (Continuous Integration) 指的是，频繁地 (一天多次) 将代码集成到主干，每次集成都通过自动化的构建 (包括编译，发布，自动化测试) 来验证，从而尽早地发现集成错误。</p>
<p>持续集成的目的让产品可以快速迭代，同时还能保持高质量。就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整，使得问题不会放大到其他部分和后面的环节。</p>

<h2 id="介绍"> 介绍</h2>
<p>持续集成 (CI) 是一种需要频繁提交代码到共享仓库的软件实践。频繁提交代码能较早检测到错误，减少在查找错误来源时开发者需要调试的代码量。 频繁的代码更新也更便于从软件开发团队的不同成员合并更改。 这对开发者非常有益，他们可以将更多时间用于编写代码，而减少在调试错误或解决合并冲突上所花的时间。</p>
<p>提交代码到仓库时，可以持续创建并测试代码，以确保提交未引入错误。 您的测试可以包括代码语法检查 (检查样式格式) 、安全性检查、代码覆盖率、功能测试及其他自定义检查。</p>
<p>创建和测试代码需要服务器。 您可以在推送代码到仓库之前在本地创建并测试更新，也可以使用 CI 服务器检查仓库中的新代码提交。</p>
<h3 id="要点"> 要点</h3>
<p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<h3 id="优点"> 优点</h3>
<ol>
<li>
<p>提高开发效率</p>
</li>
<li>
<p>快速发现并定位 Bugs</p>
</li>
<li>
<p>更快速发布更新</p>
</li>
</ol>
<hr>
<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>
<h2 id="持续交付"> 持续交付</h2>
<p><strong>持续交付 (Continuous Delivery) 指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong> 如果评审通过，代码就进入生产阶段。</p>
<p>持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<p>持续交付意味着所有的变更都可以被部署到生产环境中，如果代码没有问题，可以继续手动部署到生产环境中。</p>
<h2 id="持续部署"> 持续部署</h2>
<p><strong>持续部署 (Continuous Deployment) 是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</strong></p>
<p>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</p>
<h2 id="流程"> 流程</h2>
<p>一个大型项目严格的流程如下:</p>
<ol>
<li>
<p>提交</p>
<p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 (commit)。</p>
</li>
<li>
<p>测试 (第一轮)</p>
<p>代码仓库对 commit 操作配置了钩子 (hook) ，只要提交代码或者合并进主干，就会跑自动化测试。</p>
<p>测试分为好几种,</p>
<ul>
<li>单元测试: 针对函数或模块的测试</li>
<li>集成测试: 针对整体产品的某个功能的测试，又称功能测试</li>
<li>端对端测试: 从用户界面直达数据库的全链路测试</li>
</ul>
<p>第一轮至少要跑单元测试。</p>
</li>
<li>
<p>构建</p>
<p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建 (build)，再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源 (样式表、JS 脚本、图片) 等等。</p>
<p>常用的构建工具如下,</p>
<ul>
<li>Jenkins</li>
<li>Travis</li>
<li>Codeship</li>
<li>Strider</li>
</ul>
<p>Jenkins 和 Strider 是开源软件， Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>
</li>
<li>
<p>测试 (第二轮)</p>
<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>
<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>
</li>
<li>
<p>部署</p>
<p>通过了第二轮测试，当前代码就是一个可以直接部署的版本 (artifact)。将这个版本的所有文件打包 (tar filename.tar *) 存档，发到生产服务器。</p>
<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接 (symlink) 指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible， Chef， Puppet 等。</p>
</li>
<li>
<p>回滚</p>
<p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>
</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">计算机</title>
    <id>https://list-jiang.github.io/code/basic/computer/</id>
    <link href="https://list-jiang.github.io/code/basic/computer/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。</p>
<p>计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。</p>
]]></summary>
    <content type="html"><![CDATA[<p>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。</p>
<p>计算机的核心就是: 接受使用者输入指令与资料，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的资讯。</p>

<div><p>提示</p>
<p>也就是说一般商店用的简易型加减乘除计算机、手机、卫星定位系统(GPS)、提款机(ATM)、个人电脑、笔记本电脑(包括 notebook 与 netbook)，还有平板电脑与智能手机等，都叫计算机。</p>
</div>
<h2 id="组成"> 组成</h2>
<p>计算机由硬件和软件组成:</p>
<h3 id="硬件"> 硬件</h3>
<p>硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等；</p>
<p>严格意义上讲，硬件可以分为三个部分:</p>
<ul>
<li>输入单元: 包括键盘、鼠标、读卡器、扫描器、手写板、触控屏等等一堆；</li>
<li>主机部分: 这个就是系统单元，被主机机壳保护住了，里面含有主板、CPU 、内存、硬盘等；</li>
<li>输出单元: 例如显示器、打印机等等</li>
</ul>
<p>计算机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的晶片，里头含有微指令集，如果您想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。由于 CPU 的工作主要在于管理与运算，因此在 CPU 内又可分为两个主要的单元，分别是: 算数逻辑单元与控制单元。其中算数逻辑单元主要负责程式运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。</p>
<p>既然 CPU 的重点是在进行运算与判断，那么要被运算与判断的资料是从哪里来的? CPU 读取的资料都是从内存来的! 内存内的资料则是从输入单元所传输进来! 而 CPU 处理完毕的资料也必须要先写回内存中，最后资料才从内存传输到输出单元。</p>
<h3 id="软件"> 软件</h3>
<p>软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-26T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">开发简介</title>
    <id>https://list-jiang.github.io/code/basic/debug/</id>
    <link href="https://list-jiang.github.io/code/basic/debug/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。</p>
]]></summary>
    <content type="html"><![CDATA[<p>开发是根据用户要求建造出合理程序的过程。过程一般是用某种程序设计语言来实现的。通常采用开发工具可以进行开发。</p>

<h2 id="具体分工"> 具体分工</h2>
<p>对于一个应用或者是一个网站的开发，分为 UI 设计、前端开发和后端开发三部分。</p>
<h3 id="ui-设计"> UI 设计</h3>
<p>UI 即 User Interface (用户界面) 的简称。泛指用户的操作界面。UI 设计主要指界面的样式，美观程度。而使用上，对软件的人机交互、操作逻辑、界面美观的整体设计则是同样重要的另一个门道。</p>
<p>UI 可以让软件变得有个性有品味，还要让软件的操作变得舒适、简单、自由，充分体现软件的定位和特点。</p>
<div><p>提示</p>
<p>在开发中，UI 设计主要指<strong>界面元素设计</strong>和<strong>交互设计</strong>两部分。</p>
</div>
<h3 id="前端开发"> 前端开发</h3>
<p>前端开发是创建 Web 页面或 App 等前端界面呈现给用户的过程。前端开发通过 HTML，CSS 及 JavaScript 以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。</p>
<div><p>提示</p>
<p>在开发中，前端开发直接<strong>使用 UI 设计提供的素材</strong>并参照 UI 设计提供的<strong>界面图与交互逻辑</strong>对其设想进行<strong>实现</strong>。</p>
</div>
<h3 id="后端开发"> 后端开发</h3>
<p>根据正在处理的应用程序的大小和范围，后端开发人员要做的事情有很大的不同。在 Web 开发世界中，大多数后端开发人员从事于构建他们正在工作的应用程序背后的实际逻辑。其负责是网站后台逻辑的设计和实现还有用户及网站的数据的保存和读取。</p>
<div><p>提示</p>
<p>在开发中，后端开发提供与其他服务器<strong>交互数据</strong>，为用户<strong>检索或转换数据</strong>并<strong>对用户数据加以收集与储存</strong>。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-27T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">计算机编码介绍</title>
    <id>https://list-jiang.github.io/code/basic/encoding/</id>
    <link href="https://list-jiang.github.io/code/basic/encoding/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>计算机，不能直接存储文字，存储的是编码。</p>
<p>计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: <code>0-9</code>、<code>a-z</code>、<code>A-Z</code>，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: <code>A</code> 用 <code>110</code> 表示，<code>B</code> 用 <code>111</code> 表示等。</p>
]]></summary>
    <content type="html"><![CDATA[<p>计算机，不能直接存储文字，存储的是编码。</p>
<p>计算机只能处理二进制的数据，也就是说计算机只能处理数字。如果要处理文本，比如: <code>0-9</code>、<code>a-z</code>、<code>A-Z</code>，就必须先把文本转换为数字才能处理。对于这些字符，可以定义一套规则来显示，比如: <code>A</code> 用 <code>110</code> 表示，<code>B</code> 用 <code>111</code> 表示等。</p>

<h2 id="字符编码"> 字符编码</h2>
<p>最早的计算机在设计时采用 8 个比特(bit)作为一个字节(byte)，所以，一个字节能表示的最大的整数就是 255(二进制 11111111=十进制 255)，如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 <code>65535</code>，4 个字节可以表示的最大整数是 <code>4294967295</code>。</p>
<p>由于计算机是美国人发明的，因此，最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是 122。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 ASCII 编码冲突，所以，中国制定了 GB2312 编码，用来把中文编进去。</p>
<p>您可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode 标准也在不断发展，但最常用的是用两个字节表示一个字符(如果要用到非常偏僻的字符，就需要 4 个字节)。现代操作系统和大多数编程语言都直接支持 Unicode。</p>
<p>现在，捋一捋 ASCII 编码和 Unicode 编码的区别: ASCII 编码是 1 个字节，而 Unicode 编码通常是 2 个字节。</p>
<p>字母 A 用 ASCII 编码是十进制的 65，二进制的 01000001；</p>
<p>字符 0 用 ASCII 编码是十进制的 48，二进制的 00110000，注意字符 <code>'0'</code> 和整数 <code>0</code> 是不同的；</p>
<p>汉字中已经超出了 ASCII 编码的范围，用 Unicode 编码是十进制的 20013，二进制的 01001110 00101101。</p>
<p>您可以猜测，如果把 ASCII 编码的 A 用 Unicode 编码，只需要在前面补 0 就可以，因此，A 的 Unicode 编码是 00000000 01000001。</p>
<p>新的问题又出现了: 如果统一成 Unicode 编码，乱码问题从此消失了。但是，如果您写的文本基本上全部是英文的话，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把 Unicode 编码转化为“可变长编码”的 UTF-8 编码。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果您要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间:</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td>x</td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>从上面的表格还可以发现，UTF-8 编码有一个额外的好处，就是 ASCII 编码实际上可以被看成是 UTF-8 编码的一部分，所以，大量只支持 ASCII 编码的历史遗留软件可以在 UTF-8 编码下继续工作。</p>
<p>搞清楚 ASCII、Unicode 和 UTF-8 的关系，现在可以总结计算机系统通用的字符编码工作方式:</p>
<p>在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。</p>
<p>用编辑器编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件:</p>
<i>Not supported content</i><p>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器:</p>
<p>所以您看到很多网页的源码上会有类似 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code> 的信息，表示该网页正是用的 UTF-8 编码。</p>
<h2 id="ascii-码"> ASCII 码</h2>
<p>美国发布的，用 1 个字节 (8 位二进制) 来表示一个字符，共可以表示 2<sup>8</sup>=256 个字符。</p>
<p>美国的国家语言是英语，只要能表示 0-9、a-z、A-Z、特殊符号。</p>
<h2 id="ansi-编码"> ANSI 编码</h2>
<p><strong>每个国家为了显示本国的语言，都对 ASCII 码进行了扩展</strong>。用 2 个字节 (16 位二进制) 来表示一个汉字，共可以表示 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>65536</span></span></span></span> 个汉字。例如:</p>
<ul>
<li>中国的 ANSI 编码是 GB2312 编码(简体)，对 6763 汉字进行编码，含 600 多特殊字符。另外还有 GBK(简体)。</li>
<li>日本的 ANSI 编码是 JIS 编码。</li>
<li>台湾的 ANSI 编码是 BIG5 编码(繁体)。</li>
</ul>
<h3 id="gbk"> GBK</h3>
<p>对 GB2312 进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了 2.1 万左右。并提供了 1890 个汉字码位。<code>K</code> 的含义就是“扩展”。</p>
<h2 id="unicode-编码-统一编码"> Unicode 编码(统一编码)</h2>
<p>用 4 个字节 (32 位二进制) 来表示一个字符，想法不错，但效率太低。例如，字母 A 用 ASCII 表示的话一个字节就够，可用 Unicode 编码的话，得用 4 个字节表示，造成了空间的极大浪费。A 的 Unicode 编码是 <code>0000 0000 0000 0000 0000 0000 0100 0000</code></p>
<h2 id="utf-8-unicode-transform-format-编码"> UTF-8 (Unicode Transform Format)编码</h2>
<p>根据字符的不同，选择其编码的长度。比如:一个字符 A 用 1 个字节表示，一个汉字用 2 个字节表示。</p>
<p>毫无疑问，开发中，都用 <strong>UTF-8</strong> 编码吧，准没错。</p>
<div><p>提示</p>
<p><strong>中文能够使用的字符集两种:</strong></p>
<ul>
<li>
<p>第一种:UTF-8。UTF-8 是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、老挝语……</p>
</li>
<li>
<p>第二种:GBK (对 GB2312 进行了扩展)。gb2312 是国标，是中国的字库，里面<strong>仅</strong>涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。</p>
</li>
</ul>
<p>字库规模: UTF-8 (字全) &gt; gb2312 (只有汉字)</p>
<p>保存大小: UTF-8 (更臃肿、加载更慢) &gt; gb2312 (更小巧，加载更快)</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-27T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文件名与文件扩展名</title>
    <id>https://list-jiang.github.io/code/basic/file-extension/</id>
    <link href="https://list-jiang.github.io/code/basic/file-extension/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文件名"> 文件名</h2>
<p>文件名就是文件的名称，是为了方便人们区分计算机中的不同文件，而给每个文件设定一个指定的名称。</p>
<p>文件名不能包含控制字符: <code>&lt;</code> <code>&gt;</code> <code>/</code> <code>\</code> <code>|</code> <code>:</code> <code>&quot;</code> <code>*</code> <code>?</code></p>
<h2 id="文件扩展名"> 文件扩展名</h2>
<p>文件扩展名 (filename extension) 也称为文件的延伸文件名、后缀名，是操作系统用来标记文件类型的一种机制。通常来说，一个扩展名是跟在主文件名后面的，由一个分隔符分隔。</p>
<p>文件扩展名是早期操作系统 (如 VMS / CP / M / DOS 等) 用来标志文件格式的一种机制，其更重要的作用是让系统决定当用户想打开这个文件的时候用哪种软件运行，如 Windows 系统中 exe 文件是可执行文件，doc 文件默认用 Microsoft Word 打开的 Word 文件。</p>
<div><p>误区</p>
<ol>
<li>
<p>文件扩展名是一个文件的必要构成部分。❌</p>
<p>任何一个文件可以有或没有扩展名。对于打开文件操作，没有扩展名的文件需要选择程序去打开它，有扩展名的文件会自动用设置好的程序(如有)去尝试打开，文件扩展名是一个常规文件的构成部分，但一个文件并不一定需要一个扩展名。</p>
</li>
<li>
<p>文件扩展名表明了该文件是何种类型。❌</p>
<p>文件扩展名可以人为设定，扩展名为 TXT 的文件有可能是一张图片，同样，扩展名为 MP3 的文件，依然可能是一个视频。</p>
</li>
</ol>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-26T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">开源协议</title>
    <id>https://list-jiang.github.io/code/basic/license/</id>
    <link href="https://list-jiang.github.io/code/basic/license/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织 (Open Source Initiative) 认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了您在使用开源软件时的权利和责任，也就是规定了您可以做什么，不可以做什么。</p>
<p>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。</p>
]]></summary>
    <content type="html"><![CDATA[<p>开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织 (Open Source Initiative) 认可的开源许可协议来保证开源工作者的权益。</p>
<p>开源协议规定了您在使用开源软件时的权利和责任，也就是规定了您可以做什么，不可以做什么。</p>
<p>开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一。</p>

<p>对于准备编写一款开源软件的开发人员，也非常建议先了解一下当前最热门的开源许可协议，选择一个合适的开源许可协议来最大限度保护自己的软件权益。</p>
<h2 id="gnu-gpl"> GNU GPL</h2>
<blockquote>
<p>GNU General Public License，GNU 通用公共许可证</p>
</blockquote>
<p>只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件。</p>
<p>遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的。</p>
<p>GPL 开源协议的主要特点:</p>
<ul>
<li>
<p>复制自由</p>
<p>允许把软件复制到任何人的电脑中，并且不限制复制的数量。</p>
</li>
<li>
<p>传播自由</p>
</li>
</ul>
<p>允许软件以各种形式进行传播。</p>
<ul>
<li>
<p>收费传播</p>
<p>允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的；因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。</p>
</li>
<li>
<p>修改自由</p>
<p>允许开发人员增加或删除软件的功能，但软件修改后必须依然基于 GPL 许可协议授权。</p>
</li>
</ul>
<h2 id="bsd"> BSD</h2>
<blockquote>
<p>Berkeley Software Distribution，伯克利软件发布版) 协议</p>
</blockquote>
<p>BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件:</p>
<ul>
<li>如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议。</li>
<li>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议。</li>
<li>不允许用原始软件的名字、作者名字或机构名称进行市场推广。</li>
</ul>
<p>BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。</p>
<h2 id="apache-许可证版本"> Apache 许可证版本</h2>
<blockquote>
<p>(Apache License Version) 协议</p>
</blockquote>
<p>Apache 开源协议</p>
<p>Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。</p>
<p>现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件:</p>
<ul>
<li>该软件及其衍生品必须继续使用 Apache 许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议。</li>
</ul>
<h2 id="mit"> MIT</h2>
<blockquote>
<p>(Massachusetts Institute of Technology) 协议</p>
</blockquote>
<p>目前限制最少的开源许可协议之一(比 BSD 和 Apache 的限制都少)，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。</p>
<p>使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等。</p>
<h2 id="gun-lgpl"> GUN LGPL</h2>
<blockquote>
<p>(GNU Lesser General Public License，GNU 宽通用公共许可证)</p>
</blockquote>
<p>LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议。</p>
<p>LGPL 允许商业软件通过类库引用(link)的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。因此 LGPL 协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<h2 id="如何选择开源协议"> 如何选择开源协议</h2>
<p>世界上的开源协议有上百种，很少有人能彻底搞清它们之间的区别，即使在最流行的六种开源协议——GPL、BSD、MIT、Mozilla、Apache 和 LGPL——之中做选择，也很复杂。</p>
<p>乌克兰程序员 Paul Bagwell 画了一张分析图，说明应该怎么选择开源协议，大家看了一目了然，真是清爽。</p>
<i>Not supported content</i>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-27T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">开源与免费</title>
    <id>https://list-jiang.github.io/code/basic/open-source-and-free/</id>
    <link href="https://list-jiang.github.io/code/basic/open-source-and-free/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>开源软件和免费软件是两个概念:</p>
<ul>
<li>
<p>开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</p>
</li>
<li>
<p>免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</p>
</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>开源软件和免费软件是两个概念:</p>
<ul>
<li>
<p>开源软件是指公开源代码的软件。开源软件在发行的时候会附上软件的源代码，并授权允许用户更改、传播或者二次开发。</p>
</li>
<li>
<p>免费软件就是免费提供给用户使用的软件，但是在免费的同时，通常也会有一些限制，比如源代码不公开，用户不能随意修改、不能二次发布等。</p>
</li>
</ul>

<h2 id="免费软件"> 免费软件</h2>
<p>免费软件的例子比比皆是，QQ、微信、迅雷、酷狗、360 等都是免费软件，您可以随意使用，尽情蹂躏；但是，如果您嫌弃它们复杂，自己删除了一些无用的功能，然后在网上发布了一个精简版本供大家下载，那么您就离法院的传票不远了。</p>
<h2 id="开源软件"> 开源软件</h2>
<p>开源软件是不抵触商业的，开源的目的也不是做慈善事业，而是通过更多人的参与，减少软件的缺陷，丰富软件的功能，同时也避免了少数人在软件里留一些不正当的后门。开源软件最终还会反哺商业，让商业公司为用户提供更好的产品。</p>
<p>Android 就是大众最熟知的一款开源操作系统，它除了用在手机上，还用在汽车、平板电脑、电视、智能手表等其它硬件平台，小米、华为、OPPO、三星等都是 Android 的受益者，他们都赚得盆满钵满。</p>
<p>很多著名的开源项目背后都有商业公司支撑，它们的开发者也都有正式的工作，享受和我们一样的社会福利；如果一个成功的开源项目背后没有商业公司，这反而是不健康的，社会需要开源和商业之间的互补来促进技术的革新。</p>
<p>开源软件和商业公司的裙带关系:</p>
<ul>
<li>
<p>Android 由全球最大的互联网公司 Google 支持；</p>
</li>
<li>
<p>市场占有率最高的关系型数据库 mysql 已经被上市公司 Oracle 收购；</p>
</li>
<li>
<p>linux 不但被 Microsoft、IBM、Intel、SAMSUNG 等巨头免费赞助，还接收它们贡献的源代码；</p>
</li>
<li>
<p>Python 目前属于 python.org 开源组织，它收到了 Facebook、Google、Amazon、Redhat、Microsoft 等商业公司的赞助。</p>
</li>
</ul>
<h2 id="开源软件的盈利模式"> 开源软件的盈利模式</h2>
<p>伟大的开源软件的背后都有巨量的资金流入，没有资金支撑的开源软件是无法长久的。那么，开源软件究竟是如何盈利的呢?</p>
<ol>
<li>
<p>双重许可</p>
<p>有些开源软件不但有一个免费的基础版本，还有一个收费的商业版本。免费版本能够促进传播，让用户爱上该软件；收费版本功能更加丰富，还提供技术支持。这种情况在开源界非常普遍。</p>
<p>例如 MySQL 就同时推出面向个人和企业的两种版本，即开源版本和专业版本，分别采用不同的授权方式: 开源版本完全免费以便更好的推广，而从专业版的许可销售和支持服务获得收入。</p>
</li>
<li>
<p>技术支持</p>
<p>很多软件在使用上不收取费用，但当用户在使用产品遇到困难，需要技术支持的时候，就需要付费了。技术支持收费的这项服务，也是一些开源公司的生计之路。</p>
<p>例如，最大的开源软件公司 Redhat 被 IBM 收购，卖了 340 亿美元。Redhat 虽然提供免费的 Linux 发行版(当然也有收费的版本)，但是当使用者遇到技术障碍，或者想升级硬件的时候，Redhat 可以提供付费支持。</p>
<p>举个例子，纽交所在用免费的红帽 Linux 系统交易股票。英特尔最近升级了处理器，纽交所想用新处理器提高效率，但这需要有人为新硬件部署新的系统和应用程序。同样的事每隔几年会发生一次。纽交所可以养一个团队自己完成所有系统维护、开发工作，也可以花钱请红帽的工程师来做。相当数量的企业用户都选择了后者。</p>
</li>
<li>
<p>附加服务</p>
<p>JBoss 就是这种模式的典型代表。JBoss 应用服务器完全免费，而通过提供技术文档、培训、二次开发支持等技术服务而获得收入。</p>
<p>开源软件出版商 O’Reilly 公司也是这种模式，它不遗余力地联系开源软件的权威人士，组织各种开源软件的会议，虽然知识是免费的，但承载知识的书籍却是收费的。</p>
</li>
<li>
<p>应用服务托管(ASP)</p>
<p>例如 PHP Live ! 就是一种构架于 PHP、MySQL 之上的开源软件，它可为企业用户提供实时交谈服务。目前已经有数十家公开提供 PHP Live! 托管服务的应用服务提供商。</p>
</li>
<li>
<p>软硬件一体化</p>
<p>比如 IBM、HP 等服务器供应商巨头，通过捆绑免费的 Linux 操作系统销售硬件服务器。SUN 公司近期将其 Solaris 操作系统开放源码，以确保服务器硬件的销售收入，也是这种模式的体现。</p>
<p>这些巨头每年在开源软件领域的投入巨大，但这一切并非是做善事，它们可以从配置了开源软件的硬件中获得巨额回报。</p>
</li>
<li>
<p>部分组件收费</p>
<p>开源免费的软件可以满足大部分用户的需求，但是也有很多用户需要一些特殊的定制服务，这个时候软件公司就会收取一定的费用。</p>
</li>
<li>
<p>版权收费</p>
<p>虽然代码是开源的，但很多作者会采用一些开源协议来限制自己版权问题，如果用户想要去版权，是需要另外付费的。</p>
</li>
<li>
<p>捐款/赞助</p>
<p>很多开源软件都有一些捐款渠道，喜爱该软件的用户，或者该软件的受益者都可以进行资金支持。</p>
<p>例如，Python 就有一个软件基金协会，它收到了来自 Facebook、Amazon、Google、Redhat、Microsoft 等巨头的赞助。</p>
<p>这些公司也不傻，他们为什么会赞助 Python 呢? 因为这些公司大量使用了 Python 语言，他们希望 Python 能够持续发展，如果 Python 倒了，他们也会跟着倒霉。</p>
</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-06-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">路径</title>
    <id>https://list-jiang.github.io/code/basic/path/</id>
    <link href="https://list-jiang.github.io/code/basic/path/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。</p>
<p>路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。</p>
]]></summary>
    <content type="html"><![CDATA[<p>无论是我们想直接访问一个文件，还是在一个文件中希望访问另一个文件，都涉及到一个获取文件的操作。而无论是在 Windows 中还是在 Linux 中，文件的具体位置都用文档的路径标注。</p>
<p>路径常常涉及到物理路径，相对路径，绝对路径，根目录的概念，现加以说明。</p>

<h2 id="物理路径"> 物理路径</h2>
<p>物理路径的英文全称是: Physical path，它就是指硬盘上文件的路径，比如下面的文件位置表示方法:</p>
<div><pre><code>d:\wwwroot\html\a.html
d:\wwwroot\html\photo\b.html
d:\wwwroot\html\photo\c.html
d:\wwwroot\html\photo\ours\d.html
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p><code>D:</code> 与 <code>d:</code> 均可。盘符不分大小写。</p>
</blockquote>
<p>一般来说物理路径可用于访问本地文件，即不通过 WEB 服务器(如: 本地调试)等的情况下。</p>
<h2 id="相对路径"> 相对路径</h2>
<p>相对路径的英文全称是 Relative Path，我们可以从以下三个方面来了解它的用法 (以“物理路径”中的位置情况为例):</p>
<ul>
<li>
<p>如何表示同级目录的文件</p>
<p>b.html 和 c.html 在同一个文件夹下，如果 b.html 需要链接到 c.html，可以在 b.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>./c.html<span>"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>代码中的 <code>./</code> 代表同级目录。</p>
<p><code>./</code>是相对路径，也可以省略不写，省略不写，即直接以文件夹或文件名称开头的路径也是相对路径。</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>./c.html<span>"</span></span><span>></span></span>同目录下文件间互相链接<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>如何表示上级目录的文件</p>
<p>a.html 是 b.html 和 c.html 的上级目录中的文件，如果 b.html 或 c.html 链接到 a.html，可以在 b.html 或 c.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>../a.html<span>"</span></span><span>></span></span>链接到上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>代码中的 <code>../</code> 代表一级上级目录(间隔一个目录)。</p>
<p>需要注意的是: “<code>../../</code>”代表二级上级目录(间隔两个目录)，比如 a.html 是 d.html 的前两级目录，同时 d.html 需要链接到 a.html，可以在 d.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>../../a.html<span>"</span></span><span>></span></span>链接到上级目录的上级目录中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>如何表示子目录的文件</p>
<p>b.html 和 c.html 是 a.html 的子目录中的文件，如果需要在 a.html 中链接到 b.html， 可以在 a.html 中这样写:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>photo/b.html<span>"</span></span><span>></span></span>链接到子目录(photo)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
如果需要在a.html中链接到d.html，可以在a.html中这样写
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>photo/ours/d.html<span>"</span></span><span>></span></span>链接到子目录(photo/ourd/)中的文件<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<h2 id="绝对路径"> 绝对路径</h2>
<p>绝对路径的英文全称是 Absolute Path，它就是带有网址的路径。比如您有一个域名 www.deerol.com，其域名指向 d:\wwwroot，那么上面的四个文件就可以这么表示:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/a.html<span>"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/b.html<span>"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/c.html<span>"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.deerol.com/html/photo/ours/d.html<span>"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="根目录"> 根目录</h2>
<p>根目录的英文全称是 Root directory，去掉绝对路径前面的域名就是根目录，所以它可以理解为是网站的最上层目录。它的表示方法如下:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/a.html<span>"</span></span><span>></span></span>链接到a.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/b.html<span>"</span></span><span>></span></span>链接到b.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/c.html<span>"</span></span><span>></span></span>链接到c.html<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/html/photo/ours/d.html<span>"</span></span><span>></span></span>链接到d.html<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在服务器上，根目录即代表网站主页所在的目录。网站服务器一般只能访问网站主页所在文件夹内的文件与文件夹。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">基础常识</title>
    <id>https://list-jiang.github.io/code/basic/</id>
    <link href="https://list-jiang.github.io/code/basic/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <summary type="html"><![CDATA[<p>这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。</p>
]]></summary>
    <content type="html"><![CDATA[<p>这些是一些最为基础的内容，是后来补充进博客中的，供访客查阅。</p>

<ul>
<li>
<p><a href="./computer.html">计算机</a></p>
</li>
<li>
<p><a href="./OS.html">操作系统</a></p>
</li>
<li>
<p><a href="./file-extension.html">文件扩展名</a></p>
</li>
<li>
<p><a href="./encoding.html">文件编码</a></p>
</li>
<li>
<p><a href="./path.html">路径</a></p>
</li>
<li>
<p><a href="./glob.html">Glob 模式介绍</a></p>
</li>
<li>
<p><a href="./debug.html">开发简介</a></p>
</li>
<li>
<p><a href="./ci.html">持续集成</a></p>
</li>
<li>
<p><a href="./license.html">许可介绍</a></p>
</li>
<li>
<p><a href="./open-source-and-free.html">开源与免费</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-26T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">TCP/IP</title>
    <id>https://list-jiang.github.io/code/basic/tcpip/</id>
    <link href="https://list-jiang.github.io/code/basic/tcpip/"/>
    <updated>2022-01-24T14:58:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="http-协议"> HTTP 协议</h2>
<h3 id="http-1-1999年"> HTTP/1 1999年</h3>
<p>每次请求， 基于 <code>TCP</code> 协议 client 端重新与 server 端建立一条双向连接，客户端发送完数据，服务端全部接收，并返回响应数据，一次请求正常完成。</p>
<h3 id="http-2-2005年5月-rfc-7540"> HTTP/2 2005年5月 <code>RFC 7540</code></h3>
<p>在 HTTP/1 的基础上优化</p>
<ul>
<li>多路复用
在 HTTP/1 的基础上优化，合并多个 TCP 连接为一个，多个请求复用一个 TCP 连接</li>
<li>服务器推送 <a href="https://www.cnblogs.com/fengxuehuanlin/p/5347347.html" target="_blank" rel="noopener noreferrer">Server Push</a>
server 端不再死死的等待 client 的请求，可以主动向 client 端发送数据</li>
<li>头部压缩
HTTP标头字段被压缩成一系列包含头块碎片帧</li>
</ul>
<h3 id="http-3-2017年"> HTTP/3 2017年</h3>
<h4 id="http-2-进化空间"> HTTP/2 进化空间</h4>
<ul>
<li>HTTP/2 的数据传输是有序的，即发送一串数据，必定是按照顺序来的，如果中间存在丢失，后面的不会发送，会等中间的发送成功了再继续发送。</li>
<li>HTTP/2 TCP与TLS叠加了握手时延，建链时长还有1倍的下降空间</li>
<li>基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。</li>
</ul>
<h4 id="解决方案"> 解决方案</h4>
<ul>
<li>HTTP/3 基于UDP协议重新定义了连接，在 QUIC(quick udp internet connection) 层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于 QPACK 解决了动态表的队头阻塞）；</li>
<li>HTTP/3 重新定义了<code>TLS</code>协议加密<code>QUIC</code>头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个<code>RTT</code>就可以同时完成建链与密钥协商）；</li>
<li>HTTP/3 将<code>Packet</code>、<code>QUIC Frame</code>、<code>HTTP3 Frame</code>分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li>
</ul>
<h2 id="tcp-transmission-control-protocol-协议的-三次握手-四次挥手"> TCP (Transmission Control Protocol) 协议的 <code>三次握手</code>，<code>四次挥手</code></h2>
<h3 id="关键字"> 关键字</h3>
<h4 id="通信动作类型"> 通信动作类型</h4>
<ul>
<li>SYN：Synchronize Sequence Numbers 同步动作</li>
<li>ACK：Acknowledge 确认动作</li>
<li>PSH: Push 数据传输动作</li>
<li>FIN：Finish 结束动作</li>
<li>RST：Rest 重置动作</li>
<li>URG：Urgent 紧急</li>
</ul>
<h4 id="通信动作属性"> 通信动作属性</h4>
<ul>
<li>Seq：Sequence 同步序列号</li>
<li>Ack：Acknowledge number 确认号码</li>
<li>Len：Lenght 数据长度</li>
</ul>
<h3 id="三次握手"> 三次握手</h3>
<p>只说些我知道的数据含义，不知道的就不解释了</p>
<ol>
<li>
<p>client ==&gt; server <code>[SYN] Seq=x</code> <br/>
client 通过 ip 协议将包含上面这个东西的报文发送给 server，<code>x</code> 为客户端自己定义的这次TCP通信的同步序列号。server 通过有且只有 <code>SYN</code> 确定是一个 client 请求 tcp 连接的网络通信,对其做出响应回发报文。</p>
</li>
<li>
<p>server ==&gt; client <code>[SYN, ACK] Seq=y Ack=x + 1</code><br/>
server 通过 ip 协议将包含上面这个东西的报文发送给 client，<code>y</code> 为服务端自己定义的这次TCP通信的同步序列号。Ack 在接收到的 client 的 Seq 的基础上 <code>+1</code> ,用于告诉 client 我这次响应对应的是你的哪个请求（客户端是可以向服务端发起多个请求的，所以客户端对于服务的这个 ip 会存在多个 <code>x</code>）。</p>
</li>
<li>
<p>client ==&gt; server <code>[ACK] Seq=1 Ack=y + 1 Len=0</code><br/>
client 通过 ip 协议将包含上面这个东西的报文发送给 server,  Ack=<code>y+1</code> 用于告诉 server 我接收到了你的哪个响应, Seq 带的是后面要发送数据的起始序列，Len表示这次传输的数据长度，便于服务端确认客户端发起的下次请求有没有丢包，如果丢包了，下次客户端发起的 TCP 通信的 Seq 会比预期值大，就叫客户端从丢失的包开始重发。
<img src="./assets/tcp1.jpg" alt="三次握手图" loading="lazy"></p>
</li>
</ol>
<h3 id="四次挥手"> 四次挥手</h3>
<p>ip.addr==120.25.85.114 &amp;&amp; tcp.port==8089
ip.addr==169.254.243.16 &amp;&amp; tcp.port==8080</p>
<p>断开 TCP 请求既有可能是客户端发起，也有可能是服务端发起，此处用 A 指代断开TCP连接动作发起方，B 指代被动方
此处有个坑：如果我们测试的时候使用的地址为远程服务地址，这里会存在第 2 步丢失的情况，如下图。原因是
<img src="./assets/tcp2.png" alt="" loading="lazy">
我们可请求本地服务，通过端口通信方向来确定是服务端还是客户端</p>
<ol>
<li>A ==&gt; B <code>[FIN, ACK] Seq=352 Ack=232</code> <br/>
A 向 B 发起关闭 TCP 连接通信动作，包含一个 Seq 与一个 Ack。如果是客户端发起的关闭连接，这两个值为客户端接收服务的返回报文的最后一次确认通信时发送的值</li>
<li>B ==&gt; A <code>[ACK] Seq=232 Ack=353</code> <br/>
B 回应 A 的关闭 TCP 连接通信，Seq 为 A 发过来的 Ack 值，Ack 值为发过来的 Seq + 1。</li>
<li>B ==&gt; A <code>[FIN, ACK] Seq=232 Ack=353</code> <br/>
B 向 A 发起关闭 TCP 连接通信动作，Seq 为 A 发过来的 Ack 值，Ack 值为发过来的 Seq + 1。</li>
<li>A ==&gt; B <code>[ACK] Seq=353 Ack=233</code> <br/>
A 回应 B 的关闭 TCP 连接通信。Seq 为 B 发过来的 Ack 值，Ack 值为发过来的 Seq + 1。
四次挥手后，A 等待 2MSL (<code>Maximum Segment Lifetime 报文最大有效时间</code>) 后关闭， B 接收到了就立刻关闭，如果超过 1MSL 没有接收到 A 的第四次挥手通信包，就重发第三次。</li>
</ol>
<blockquote>
<p>上面这些传输过程中的数字都是为了确保双方的身份，具体数字大小没有含义。</p>
</blockquote>
<h4 id="三次握手的必要性"> 三次握手的必要性</h4>
<p>一次的话就是udp了
两次的话，服务端无法确认请求连接的 <code>tcp通信包</code> 里面的 ip 是不是无效的恶意数据。很容易造成大量资源被黑客浪费。
三次的话，server 确认在网络世界中，有一个 client 是处理了服务器的响应数据的。
四次的话，已经是资源浪费了。</p>
<h4 id="四次挥手的必要性"> 四次挥手的必要性</h4>
<p>一个Tcp连接是在两台计算机都存了对应的数据的，那么Tcp断开的话需要双方都确认才行，不然的话，一个说断了，一个没断。那么没断的那个势必会出错。那么最起码需要三次。
三次的话，那么第二次的发送时间不好处理，因为此时如果有数据包未处理完成的话会造成数据的丢失，所以四次。那个超市 2MSL 是为了处理第四次通信包丢失的情况。</p>
<blockquote>
<p>?? 没有完美的，都是取舍。</p>
</blockquote>
<h3 id="wireshark"> WireShark</h3>
<p>一款基于网关监听的网络包分析工具，配置监听的网关后，就可以看到所有经过这个网关的网络包，再自己根据场景设置筛选规则即可得到我们需要查看的网络包传输记录。</p>
<ol>
<li>配置监听网关<br/>
捕获 -&gt; 选项 -&gt; 选择网关（访问 <code>127.0.0.1</code> 的话需要选择<code>Adapter for loopback traffic capture</code>）</li>
<li>配置筛选规则<br/>
基本的有：<code>ip.addr</code>,<code>ip.src</code>,<code>ip.target</code>,<code>tcp.port</code></li>
</ol>
<p><img src="./assets/wireshark-demo1.jpg" alt="wireshark基础使用" loading="lazy"></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="网络 - TCP - IP"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2022-01-21T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">cache</title>
    <id>https://list-jiang.github.io/code/github/actions/cache/</id>
    <link href="https://list-jiang.github.io/code/github/actions/cache/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>这个 Action 允许您缓存依赖项和构建输出内容以缩短 Workflow 执行时间。</p>
<p>日常最多使用的就是缓存依赖项，在每个工作流程中，将安装后的依赖通过安装后生成的依赖版本文件的哈希值进行缓存。</p>
<p>当前工作流程的版本文件哈希值与历史缓存中的某一项完全相同时，直接载入这些依赖项缓存，这样就可以免去安装步骤。</p>
<div><p>缓存依赖</p>
<p>关于缓存依赖的文档，详见 <a href="https://docs.github.com/cn/actions/guides/caching-dependencies-to-speed-up-workflows" target="_blank" rel="noopener noreferrer">缓存依赖项以加快工作流程
</a></p>
</div>
]]></summary>
    <content type="html"><![CDATA[<p>这个 Action 允许您缓存依赖项和构建输出内容以缩短 Workflow 执行时间。</p>
<p>日常最多使用的就是缓存依赖项，在每个工作流程中，将安装后的依赖通过安装后生成的依赖版本文件的哈希值进行缓存。</p>
<p>当前工作流程的版本文件哈希值与历史缓存中的某一项完全相同时，直接载入这些依赖项缓存，这样就可以免去安装步骤。</p>
<div><p>缓存依赖</p>
<p>关于缓存依赖的文档，详见 <a href="https://docs.github.com/cn/actions/guides/caching-dependencies-to-speed-up-workflows" target="_blank" rel="noopener noreferrer">缓存依赖项以加快工作流程
</a></p>
</div>

<h2 id="配置项"> 配置项</h2>
<h3 id="path"> path</h3>
<p>要缓存和还原的文件，目录和通配符模式的列表。</p>
<div><p>相关信息</p>
<p>支持的 glob 模式，请参见 <a href="https://github.com/actions/toolkit/tree/main/packages/glob" target="_blank" rel="noopener noreferrer">@actions/glob</a>。</p>
</div>
<h3 id="key"> key</h3>
<p>用于保存缓存与还原缓存的的密钥</p>
<h3 id="restore-keys"> restore-keys</h3>
<p>当 key 没有命中缓存是用于恢复缓存键值的有序列表</p>
<h2 id="输出"> 输出</h2>
<p><code>cache-hit</code>: 一个布尔值，表明是否找到与该键完全匹配的值</p>
<h2 id="缓存范围"> 缓存范围</h2>
<p>缓存的作用域为特定的键和分支。默认分支缓存可用于其他分支。</p>
<h2 id="案例"> 案例</h2>
<p>Yarn:</p>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/cache@v2
  <span># 使用此 id 获得 `cache-hit`</span>
  <span># (`steps.yarn-cache.outputs.cache-hit != 'true'`)</span>
  <span>id</span><span>:</span> yarn<span>-</span>cache
  <span>with</span><span>:</span>
    <span>path</span><span>:</span> node_modules/
    <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>yarn<span>-</span>$<span>{</span><span>{</span> hashFiles('<span>**/yarn.lock')</span> <span>}</span><span>}</span>
    <span>restore-keys</span><span>:</span> <span>|</span><span>
      ${{ runner.os }}-yarn-</span>

<span>-</span> <span>name</span><span>:</span> Install Dependencies
  <span>if</span><span>:</span> steps.yarn<span>-</span>cache.outputs.cache<span>-</span>hit <span>!=</span> 'true'
  <span>run</span><span>:</span> yarn install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="创建一个缓存键"> 创建一个缓存键</h2>
<p>缓存键可以包括 GitHub Actions 支持的任何上下文，函数，文字和运算符。</p>
<p>例如，使用 <code>hashFiles</code> 功能可让您在依存关系更改时创建新的缓存。</p>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/cache@v2
  <span>id</span><span>:</span> yarn<span>-</span>cache
  <span>with</span><span>:</span>
    <span>path</span><span>:</span> <span>|</span><span>
      node_modules/</span>
    <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>$<span>{</span><span>{</span> hashFiles('<span>**/yarn.lock')</span> <span>}</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>利用 cache-hit 输出，当对应键命中特定缓存后，可以跳过后续步骤 (例如，安装或构建) 。</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> Install Dependencies
  <span>if</span><span>:</span> steps.yarn<span>-</span>cache.outputs.cache<span>-</span>hit <span>!=</span> 'true'
  <span>run</span><span>:</span> yarn install
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="缓存限制"> 缓存限制</h2>
<p>一个存储库最多可以有 5GB 的缓存。达到 5GB 限制后，将根据上次访问缓存的时间驱逐较早的缓存。过去未访问的缓存也将被自动删除。</p>
<h2 id="地址"> 地址</h2>
<p>地址: <a href="https://github.com/actions/cache" target="_blank" rel="noopener noreferrer">https://github.com/actions/cache</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">checkout</title>
    <id>https://list-jiang.github.io/code/github/actions/checkout/</id>
    <link href="https://list-jiang.github.io/code/github/actions/checkout/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>该操作将检出您的存储库 <code>$GITHUB_WORKSPACE</code>，使您的工作流可以访问它。</p>
]]></summary>
    <content type="html"><![CDATA[<p>该操作将检出您的存储库 <code>$GITHUB_WORKSPACE</code>，使您的工作流可以访问它。</p>

<p>默认情况下，对于触发工作流的 ref / SHA，为了速度仅提取一次提交。如需获取所有分支和标签的所有历史记录，需要设置设置 <code>fetch-depth: 0</code>。</p>
<p>身份验证令牌保留在本地 Git 配置中。这使您的脚本可以运行经过身份验证的 Git 命令。在工作后清理期间将删除令牌。</p>
<p>设置 <code>persist-credentials: false</code> 取消保留。</p>
<h2 id="常用参数"> 常用参数</h2>
<h3 id="ref"> ref</h3>
<p>需要检出的 ref，即可以填入特定分支、commitID 或 tag。默认为触发当前工作流的 ref。</p>
<h3 id="token"> token</h3>
<p>个人访问令牌，又称 Personal access token (PAT)，用于配置机器 Git 配置，以运行需要身份验证的 Git 命令。</p>
<div><p>默认为工作流提供的 <code>${{ github.token }}</code></p>
</div><h3 id="fetch-depth"> fetch-depth</h3>
<p>要获取的提交数。 <code>0</code> 表示所有分支和标签的所有历史记录。</p>
<p>默认为 <code>1</code></p>
<h3 id="submodules"> submodules</h3>
<p>是否检出子模块。<code>true</code> 检出子模块 <code>recursive</code> 会递归检出子模块。</p>
<p>默认为 <code>false</code></p>
<h2 id="其他参数"> 其他参数</h2>
<h3 id="repository"> repository</h3>
<p>带有作者的仓库名，如 <code>Hope-Studio/innenu-app</code>，默认为当前仓库。</p>
<h3 id="persist-credentials"> persist-credentials</h3>
<p>是否将 token 等信息用于本地的 Git 配置，以便后续 Git 命令可以访问。</p>
<h3 id="path"> path</h3>
<p><code>$GITHUB_WORKSPACE</code> 下用于放置存储库的相对路径</p>
<p>默认为 <code>./</code></p>
<h3 id="ssh-key"> ssh-key</h3>
<p>用于获取仓库的 SSH 私钥，用于配置机器 Git 配置，以运行需要身份验证的 Git 命令。</p>
<div><p>提示</p>
<p>默认的 token 有权限拉取工作流所在的仓库。</p>
<p>如果仓库包含了存放于其他代码托管商或私有的 submodules，或是的仓库，可能需要设置上述两选项之一，才能拉取对应 submodule。</p>
</div>
<h3 id="ssh-known-hosts"> ssh-known-hosts</h3>
<p>除了用户和全局主机密钥数据库外的已知主机。可以使用 <code>ssh-keyscan</code> 获得主机的公共 SSH 密钥。 例如，<code>ssh-keyscan github.com</code>。 github.com 的公钥总是隐式添加的。</p>
<div><p>相关信息</p>
<p>当您需要获取其他代码托管商的仓库时，需要设置此选项</p>
</div>
<h3 id="ssh-strict"> ssh-strict</h3>
<p>是否进行严格的 ssh 校验，默认为 <code>true</code>，即不检查 IP，而是检查 Host 给出的密钥指纹是否匹配。</p>
<h3 id="clean"> clean</h3>
<p>是否在拉取代码前执行 <code>git clean -ffdx &amp;&amp; git reset --hard HEAD</code>。</p>
<p>默认为 <code>true</code></p>
<h3 id="lfs"> lfs</h3>
<p>是否下载 Git-LFS 文件。</p>
<p>默认为 <code>false</code></p>
<h2 id="例子"> 例子</h2>
<ul>
<li>
<p>获取所有标签与历史:</p>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>fetch-depth</span><span>:</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>检出特定分支</p>
</li>
</ul>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>ref</span><span>:</span> my<span>-</span>branch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>检出 <code>HEAD^</code></p>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>fetch-depth</span><span>:</span> <span>2</span>
<span>-</span> <span>run</span><span>:</span> git checkout HEAD^
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>并列检出多个 repo</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> Checkout
  <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>path</span><span>:</span> main

<span>-</span> <span>name</span><span>:</span> Checkout tools repo
  <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>repository</span><span>:</span> my<span>-</span>org/my<span>-</span>tools
    <span>path</span><span>:</span> my<span>-</span>tools
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>嵌套检出多个 repo</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> Checkout
  <span>uses</span><span>:</span> actions/checkout@v2

<span>-</span> <span>name</span><span>:</span> Checkout tools repo
  <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>repository</span><span>:</span> my<span>-</span>org/my<span>-</span>tools
    <span>path</span><span>:</span> my<span>-</span>tools
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>检出多个私有 repo</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> Checkout
  <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>path</span><span>:</span> main

<span>-</span> <span>name</span><span>:</span> Checkout private tools
  <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>repository</span><span>:</span> my<span>-</span>org/my<span>-</span>private<span>-</span>tools
    <span>token</span><span>:</span> $<span>{</span><span>{</span> secrets.GitHub_PAT <span>}</span><span>}</span> <span># `GitHub_PAT` is a secret that contains your PAT</span>
    <span>path</span><span>:</span> my<span>-</span>tools
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
<div><p>相关信息</p>
<div><p><code>${{ github.token }}</code> 仅限于当前存储库，因此，如果要签出其他私有存储库，则需要提供自己的 PAT。</p>
</div></div>
<ul>
<li>
<p>检出 PR HEAD commit 而不是 merge commit</p>
<div><pre><code><span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
  <span>with</span><span>:</span>
    <span>ref</span><span>:</span> $<span>{</span><span>{</span> github.event.pull_request.head.sha <span>}</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>当关闭 PR 时将其检出</p>
<div><pre><code><span>on</span><span>:</span>
  <span>pull_request</span><span>:</span>
    <span>branches</span><span>:</span> <span>[</span>main<span>]</span>
    <span>types</span><span>:</span> <span>[</span>opened<span>,</span> synchronize<span>,</span> closed<span>]</span>
<span>jobs</span><span>:</span>
  <span>build</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>使用内置 token 进行提交</p>
<div><pre><code><span>on</span><span>:</span> push
<span>jobs</span><span>:</span>
  <span>build</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@v2
      <span>-</span> <span>run</span><span>:</span> <span>|</span><span>
          date > generated.txt
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add .
          git commit -m "generated"
          git push</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ul>
<h2 id="地址"> 地址</h2>
<p>地址: <a href="https://github.com/actions/checkout" target="_blank" rel="noopener noreferrer">https://github.com/actions/checkout</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Action 配置</title>
    <id>https://list-jiang.github.io/code/github/actions/config/</id>
    <link href="https://list-jiang.github.io/code/github/actions/config/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>GitHub Actions 的配置文件叫做 <code>workflow</code> 文件，存放在代码仓库的 <code>.github/workflows</code> 目录。</p>
<p><code>workflow</code> 文件采用 <code>YAML</code> 格式，文件名可以任意取，但是后缀名统一为 <code>.yml</code>，比如<code>foo.yml</code>。</p>
<p>一个库可以有多个 <code>workflow</code> 文件。GitHub 只要发现 <code>.github/workflows</code> 目录里面有 <code>.yml</code> 文件，就会自动运行该文件。</p>
]]></summary>
    <content type="html"><![CDATA[<p>GitHub Actions 的配置文件叫做 <code>workflow</code> 文件，存放在代码仓库的 <code>.github/workflows</code> 目录。</p>
<p><code>workflow</code> 文件采用 <code>YAML</code> 格式，文件名可以任意取，但是后缀名统一为 <code>.yml</code>，比如<code>foo.yml</code>。</p>
<p>一个库可以有多个 <code>workflow</code> 文件。GitHub 只要发现 <code>.github/workflows</code> 目录里面有 <code>.yml</code> 文件，就会自动运行该文件。</p>

<h2 id="常见字段"> 常见字段</h2>
<p><code>workflow</code> 文件的配置字段非常多。下面是一些基本字段。</p>
<h3 id="name"> name</h3>
<p><code>name</code> 字段是 <code>workflow</code> 的名称。如果省略该字段，默认为当前 <code>workflow</code> 的文件名。</p>
<div><pre><code><span>name</span><span>:</span> GitHub Actions Demo
</code></pre>
<div><span>1</span><br></div></div><h3 id="on"> on</h3>
<p><code>on</code> 字段指定触发 <code>workflow</code> 的时机，通常是某些事件。</p>
<div><pre><code><span># 指定 push 事件触发 workflow。</span>
<span>on</span><span>:</span> push
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>on</code> 字段也可以是事件的数组。</p>
<div><pre><code><span># 指定 push 事件或 pull_request 事件都可以触发 workflow。</span>
<span>on</span><span>:</span> <span>[</span>push<span>,</span> pull_request<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>完整的事件列表，请查看官方文档。
除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p>
<h4 id="on-push-pull-request-tags-branches"> on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;</h4>
<p>指定触发事件时，可以限定分支或标签。</p>
<div><pre><code><span># 指定只有 master 分支发生 push 事件时，才会触发 workflow。</span>
<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="jobs"> jobs</h3>
<p><code>workflow</code> 文件的主体是 <code>jobs</code> 字段，表示要执行的一项或多项任务。</p>
<p><code>jobs</code> 字段里面，需要写出每一项任务的 <code>job_id</code>，具体名称自定义。</p>
<h4 id="jobs-job-id-name"> jobs.&lt;job_id&gt;.name</h4>
<p><code>job_id</code> 里面的 <code>name</code> 字段是任务的说明(可填可不填)。</p>
<div><pre><code><span>jobs</span><span>:</span>
  <span>my_first_job</span><span>:</span>
    <span>name</span><span>:</span> My first job
  <span>my_second_job</span><span>:</span>
    <span>name</span><span>:</span> My second job
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码的 <code>jobs</code> 字段包含两项任务，<code>job_id</code> 分别是 <code>my_first_job</code> 和 <code>my_second_job</code>。</p>
<h4 id="jobs-job-id-needs"> jobs.&lt;job_id&gt;.needs</h4>
<p><code>needs</code> 字段指定当前任务的依赖关系，即运行顺序。</p>
<div><pre><code><span># 这个 workflow 的运行顺序依次为: job1、job2、job3。</span>
<span>jobs</span><span>:</span>
  <span>job1</span><span>:</span>
  <span>job2</span><span>:</span>
    <span>needs</span><span>:</span> job1
  <span>job3</span><span>:</span>
    <span>needs</span><span>:</span> <span>[</span>job1<span>,</span> job2<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="jobs-job-id-runs-on"> jobs.&lt;job_id&gt;.runs-on</h4>
<p><code>runs-on</code> 字段指定运行所需要的虚拟机环境。
它是<strong>必填字段</strong>。目前可用的虚拟机如下。</p>
<p><code>ubuntu-latest</code>，<code>ubuntu-18.04</code> 或 <code>ubuntu-16.04</code></p>
<p><code>windows-latest</code>，<code>windows-2019</code> 或 <code>windows-2016</code></p>
<p><code>macOS-latest</code> 或 <code>macOS-10.14</code></p>
<div><pre><code><span># 代码指定虚拟机环境为 ubuntu-18.04。</span>
<span>runs-on</span><span>:</span> ubuntu<span>-</span><span>18.04</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="jobs-job-id-steps"> jobs.&lt;job_id&gt;.steps</h4>
<p><code>steps</code> 字段指定每个 <code>Job</code> 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p>
<ul>
<li><code>jobs.&lt;job_id&gt;.steps.name</code>: 步骤名称。</li>
<li><code>jobs.&lt;job_id&gt;.steps.run</code>: 该步骤运行的命令或者 action。</li>
<li><code>jobs.&lt;job_id&gt;.steps.env</code>: 该步骤所需的环境变量。</li>
</ul>
<p>下面是一个完整的 <code>workflow</code> 文件的范例。</p>
<div><pre><code><span>name</span><span>:</span> Greeting from Mona
<span>on</span><span>:</span> push

<span>jobs</span><span>:</span>
  <span>my-job</span><span>:</span>
    <span>name</span><span>:</span> My Job
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span>steps</span><span>:</span> <span># steps 字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</span>
      <span>-</span> <span>name</span><span>:</span> Print a greeting
        <span>env</span><span>:</span>
          <span>MY_VAR</span><span>:</span> Hi there<span>!</span> My name is
          <span>FIRST_NAME</span><span>:</span> Mona
          <span>MIDDLE_NAME</span><span>:</span> The
          <span>LAST_NAME</span><span>:</span> Octocat
        <span>run</span><span>:</span> <span>|</span><span>
          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="官方文档"> 官方文档</h2>
<p>关于完整的工作流程语法，详见 <a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">GitHub 操作的工作流程语法</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">github-pages-deploy</title>
    <id>https://list-jiang.github.io/code/github/actions/gh-pages-deploy/</id>
    <link href="https://list-jiang.github.io/code/github/actions/gh-pages-deploy/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>github-pages-deploy-action 用于自动将网站内容部署到 GitHub Pages。</p>
<p>您可以使用这个 Action 将代码推送到您想要的任何分支中，包括 gh-pages 和 docs, 甚至可以处理跨存储库部署。</p>
]]></summary>
    <content type="html"><![CDATA[<p>github-pages-deploy-action 用于自动将网站内容部署到 GitHub Pages。</p>
<p>您可以使用这个 Action 将代码推送到您想要的任何分支中，包括 gh-pages 和 docs, 甚至可以处理跨存储库部署。</p>

<h2 id="重要配置"> 重要配置</h2>
<h3 id="branch"> branch</h3>
<p>此项必填，填入您希望部署到的分支，例如 gh-pages 或 docs</p>
<h3 id="folder"> folder</h3>
<p>此项必填，填入存储库中要部署的文件夹。此项自动识别为相对路径。</p>
<ul>
<li>
<p>如您的构建输出到 dist 目录，可以直接设置 <code>dist</code></p>
</li>
<li>
<p>如果您希望部署根目录，请设置 <code>.</code></p>
</li>
<li>
<p>如果您希望使用绝对路径访问 workflow 所在的 server，请在路径前添加 <code>~</code></p>
</li>
</ul>
<h2 id="可选配置"> 可选配置</h2>
<h3 id="token"> token</h3>
<p>此选项默认为可访问存储库的 Token。</p>
<p>如果您需要更多权限 (例如，部署到另一个存储库) ，可以通过此选项设置个人访问令牌 (PAT) 。</p>
<p>本选项的值应该存储在 secrets 中。</p>
<div><p>提示</p>
<p>建议在生成新的 PAT 时选择所需的最少权限范围</p>
</div>
<h3 id="ssh-key"> ssh-key</h3>
<p>此选项可以填入部署用的 SSH 专用密钥，(本选项的值应该存储在 secrets 中)，也可以将其设置为 <code>true</code> 使用现有的 SSH 客户端配置，使用 SSH 部署。</p>
<h3 id="repository-name"> repository-name</h3>
<p>允许您指定其他存储库路径，只要您有权将其推送。格式应为: <code>用户名/存储库名称</code>。您需要设置 token 为 PAT，此配置选项才能正常运行。</p>
<h3 id="target-folder"> target-folder</h3>
<p>如果要将部署文件夹的内容推送到部署分支上的特定目录中，可以在此处指定。</p>
<h3 id="commit-message"> commit-message</h3>
<p>定制提交信息</p>
<h3 id="clean"> clean</h3>
<p>如果您的项目在构建时生成哈希文件，则可以使用此选项在每次部署时从部署分支的目标文件夹中自动将其删除。</p>
<p>此选项默认情况下处于启用状态，可以通过将其设置为来关闭 <code>false</code>。</p>
<div><p>提示</p>
<p>也就是每次部署默认是全新的，不会保留任何上一次部署的文件。您需要保证部署时您已经拥有了所有需要的文件。</p>
</div>
<h3 id="clean-exclude"> clean-exclude</h3>
<p>如果您需要使用 <code>clean</code> 但想保留某些文件或文件夹，则可以使用此选项。这应该在多行字符串中将每个模式包含为一行。</p>
<h3 id="single-commit"> single-commit</h3>
<p>如果您希望在部署分支只有一次最新的提交，而不是维护完整的历史记录，则可以将此选项切换为 <code>true</code>。</p>
<div><p>注意</p>
<p>使用此选项还将导致从部署分支中移除所有现有历史记录。</p>
</div>
<h2 id="案例"> 案例</h2>
<p>当构建完整网站后，请添加下列步骤:</p>
<div><pre><code><span>-</span> <span>name</span><span>:</span> Deploy 🚀
  <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@4.0.0
  <span>with</span><span>:</span>
    <span># 需要部署到的分支</span>
    <span>branch</span><span>:</span> gh<span>-</span>pages
    <span># 需要部署的文件夹</span>
    <span>folder</span><span>:</span> dist
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="地址"> 地址</h2>
<p>地址: <a href="https://github.com/JamesIves/github-pages-deploy-action" target="_blank" rel="noopener noreferrer">https://github.com/JamesIves/github-pages-deploy-action</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Actions 介绍</title>
    <id>https://list-jiang.github.io/code/github/actions/intro/</id>
    <link href="https://list-jiang.github.io/code/github/actions/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在 GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程。</p>
<p>您可以发现、创建和共享操作以执行您喜欢的任何作业 (包括 CI/CD) ，并将操作合并到完全自定义的工作流程中。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在 GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程。</p>
<p>您可以发现、创建和共享操作以执行您喜欢的任何作业 (包括 CI/CD) ，并将操作合并到完全自定义的工作流程中。</p>

<h2 id="特点"> 特点</h2>
<ul>
<li>
<p>GitHub 把组成持续集成的操作称为 actions。</p>
</li>
<li>
<p>GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
</li>
<li>
<p>如果您需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p>
</li>
<li>
<p>GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外， <a href="https://github.com/sdras/awesome-actions" target="_blank" rel="noopener noreferrer">awesome actions</a> 仓库收集了很多有用的 actions。</p>
</li>
</ul>
<div><p>持续集成</p>
<p>关于持续集成 (CI) 的概念与介绍，详见 <a href="./../../basic/ci.html">基础 → 持续集成</a></p>
</div>
<h2 id="简介"> 简介</h2>
<p>GitHub Actions 帮助您自动完成软件开发周期内的任务。 GitHub Actions 是事件驱动的，意味着您可以在指定事件发生后运行一系列命令。 例如，每次有人为仓库创建拉取请求时，您都可以自动运行命令来执行软件测试脚本。</p>
<h2 id="组件"> 组件</h2>
<p>下面是一起运行作业的多个 GitHub Actions 组件列表。 您可以查看这些组件如何相互作用。</p>
<h3 id="workflow"> workflow</h3>
<p>工作流程 (workflow) 是您添加到仓库的自动化过程。 工作流程由一项或多项作业组成，可以计划或由事件触发。 工作流程可用于在 GitHub 上构建、测试、打包、发布或部署项目。</p>
<p>持续集成一次运行的过程，就是一个 workflow。</p>
<h3 id="event"> event</h3>
<p>事件 (event) 是触发工作流程的特定活动。 例如，当有推送提交到仓库或者创建议题或拉取请求时，GitHub 就可能产生活动。</p>
<p>您还可以使用仓库的 web hook 在发生外部事件时触发工作流程。</p>
<div><p>提示</p>
<p>事件是 workflow 执行的判定。可以通过配置工作流程，来决定在哪些事件被触发执行。</p>
<p>同时工作流也可以读取触发事件的相关信息，以在不同情况下执行不同的任务。</p>
</div>
<h3 id="jobs"> Jobs</h3>
<p>作业 (job) 是在同一运行服务器上执行的一组步骤。</p>
<p>默认情况下，包含多个作业的工作流程将同时运行这些作业。</p>
<p>您也可以配置工作流程按顺序运行作业。例如，工作流程可以有两个连续的任务来构建和测试代码，其中测试作业取决于构建作业的状态。如果构建作业失败，测试作业将不会运行。</p>
<div><p>提示</p>
<p>作业是工作流程中一个完整任务的封装。</p>
<p>一个 workflow 由一个或多个 jobs 构成，一次持续集成的运行，可以完成多个作业，对应多个任务。</p>
</div>
<h3 id="steps"> Steps</h3>
<p>步骤 (step) 是可以在作业中运行命令的单个任务。步骤可以是操作或 shell 命令。</p>
<p>作业中的每个步骤在同一运行器上执行，可让该作业中的操作互相共享数据。</p>
<div><p>提示</p>
<p>每个 job 由多个 step 构成，一步步完成。</p>
</div>
<h3 id="action"> Action</h3>
<p>操作 (Action) 是独立命令，它们组合到步骤以创建作业。</p>
<p>操作是工作流程最小的便携式构建块。 您可以创建自己的操作，也可以使用 GitHub 社区创建的操作。要在工作流程中使用操作，必须将其作为一个步骤。</p>
<h3 id="server"> Server</h3>
<p>运行器 (Server) 是安装了 GitHub Actions 运行器应用程序的服务器。</p>
<p>您可以使用 GitHub 托管的运行器或托管您自己的运行器。运行器将侦听可用的作业，每次运行一个作业，并将进度、日志和结果报告回 GitHub。</p>
<p>对于 GitHub 托管的运行器，工作流程中的每项作业都会在一个新的虚拟环境中运行。</p>
<p>GitHub 托管的运行器基于 Ubuntu Linux、Microsoft Windows 和 macOS。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">GitHub Actions</title>
    <id>https://list-jiang.github.io/code/github/actions/</id>
    <link href="https://list-jiang.github.io/code/github/actions/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">GitHub Actions 介绍</a></p>
</li>
<li>
<p><a href="./config.html">Workflow 配置</a></p>
</li>
</ul>
<h2 id="常用-github-action"> 常用 GitHub Action</h2>
<ul>
<li>
<p><a href="./checkout.html">checkout</a></p>
</li>
<li>
<p><a href="./cache.html">cache</a></p>
</li>
<li>
<p><a href="./gh-pages-deploy.html">GitHub Pages 部署</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li>
<p><a href="https://docs.github.com/cn/actions" target="_blank" rel="noopener noreferrer">文档地址</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" target="_blank" rel="noopener noreferrer">Workflow 触发事件</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">Workflow 配置</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">自动部署</title>
    <id>https://list-jiang.github.io/code/github/deploy/</id>
    <link href="https://list-jiang.github.io/code/github/deploy/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>

<div><p>提示</p>
<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 20.04 进行教学。</p>
</div>
<h2 id="服务器"> 服务器</h2>
<p>为了能供自动部署到服务器，我们需要让服务器的网站目录成为一个 Git 仓库，这样我们可以在 GitHub Actions 中，通过向服务器对应 GitHub 仓库推送网站内容，使服务器网站获得自动更新。下面是服务器侧的部署配置</p>
<h3 id="添加账户"> 添加账户</h3>
<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>
<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>
<h3 id="添加权限"> 添加权限</h3>
<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>
<div><pre><code><span>mkdir</span> -p ~/.ssh/

<span>touch</span> ~/.ssh/authorized_keys

<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件，这样相关用户即可以使用对应私钥，向服务器相关仓库推送代码。</p>
<h3 id="创建仓库"> 创建仓库</h3>
<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>
<div><pre><code><span>cd</span> ~
<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进入文件夹，使用</p>
<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>
<p>接下来执行:</p>
<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore
</code></pre>
<div><span>1</span><br></div></div><p>这是由于 Git 默认拒绝外部对当前分支的推送操作，因为这可能会覆盖或变更工作区文件。</p>
<p>设置完毕后，Git 会允许外部对当前工作区分支进行推送操作。</p>
<h2 id="github-actions"> GitHub Actions</h2>
<p>在 GitHub 一侧，我们需要通过 GitHub Action，在新代码推送时自动构建网站，并部署到 GitHub 的 gh-pages 分支。之后，GitHub Action 将该分支的变动推送服务器的对应仓库，完成网站的自动部署。</p>
<p>之后只需要使用 GitHub Action 通过 Git 推送到 <code>git@&lt;domain&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>
<div><pre><code><span># 自动部署的名称</span>
<span>name</span><span>:</span> GitHub pages deploy

<span># 自动部署的条件</span>
<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span># 构建网站并部署到 GitHub Pages</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span># 运行环境</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest

    <span># 步骤</span>
    <span>steps</span><span>:</span>
      <span># 第一步: 下载源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span># action 配置详见 https://github.com/actions/checkout</span>
        <span>uses</span><span>:</span> actions/checkout@v2.3.4
        <span>with</span><span>:</span>
          <span># 如果本项目包含了子模块 (git submodules)，需要将此项设置为 true</span>
          <span># submodules: true</span>

          <span># 这是获取历史 commit 的深度，默认为 1，即只拉取最后一个 commit</span>
          <span># 这样可以加快拉取速度</span>
          <span>#</span>
          <span># 如果项目使用 VuePress，为了正确通过 Git 历史提交记录生成页面的最后更新时间</span>
          <span># 需要设置为 0 以拉取完整的 git 历史提交</span>
          <span># fetch-depth: 0</span>

          <span># 如果子模块包含私有仓库，需要设置 ssh key 或 token 以保证拥有拉取相应仓库的权限</span>
          <span># 您可以将 ssh-key 设置为 github 绑定公钥对应的私钥</span>
          <span># 也可以新建一个具有相关仓库访问权限的 github token</span>
          <span># token:</span>

      <span># 缓存 node_modules 以避免重复安装</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v2.1.6
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span># 需要缓存的路径</span>
          <span>path</span><span>:</span> node_modules/
          <span># 缓存的 key</span>
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span># 恢复 key</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>

      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span># 只有没有命中缓存才会执行</span>
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span># 严格按照 yarn.lock 安装依赖</span>
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目</span>
      <span>-</span> <span>name</span><span>:</span> Build
        <span># 项目的构建命令</span>
        <span>run</span><span>:</span> yarn run build

      <span># 第四步，部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># action 配置详见 https://github.com/JamesIves/github-pages-deploy-action</span>
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@4.1.3
        <span>with</span><span>:</span>
          <span># 部署到的分支</span>
          <span>branch</span><span>:</span> gh<span>-</span>pages
          <span># 需要部署的文件夹</span>
          <span>folder</span><span>:</span> dist

  <span># 部署到服务器</span>
  <span>deploy-server</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span># 确保在部署到 GitHub Pages 之后执行</span>
    <span>needs</span><span>:</span> deploy<span>-</span>gh<span>-</span>pages
    <span>steps</span><span>:</span>
      <span># 检出网站代码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v2.3.4
        <span>with</span><span>:</span>
          <span># 检出 gh-pages 分支</span>
          <span>ref</span><span>:</span> gh<span>-</span>pages
          <span># 获取全部的历史提交</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>

      <span># 配置环境</span>
      <span>-</span> <span>name</span><span>:</span> Configuration environment
        <span># 写入私钥、配置 Git 用户名，写入服务器地址</span>
        <span># 您需要自行将服务器的私钥写入 secrets 的 SSH_PRIVATE_KEY</span>
        <span>run</span><span>:</span> <span>|</span><span>
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan &lt;your domain> >> ~/.ssh/known_hosts
          git config --global user.name 'Your Name'
          git config --global user.email 'You email'</span>

      <span># 部署到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># 使用 Git 将网站代码强制推送到远程的网站目录</span>
        <span># 并使用 SSH 连接服务器进入网站目录手动切换到最新提交</span>
        <span>run</span><span>:</span> <span>|</span><span>
          git push -f git@&lt;your domain>:&lt;deploy dir> gh-pages
          ssh git@&lt;your domain> "cd &lt;deploy dir> &amp;&amp; git reset --hard HEAD"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">GitHub 简介</title>
    <id>https://list-jiang.github.io/code/github/intro/</id>
    <link href="https://list-jiang.github.io/code/github/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="gayhub-github-是世界上最大的-同性交友-代码托管网站"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>
<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>
<h2 id="基本概念"> 基本概念</h2>
<h3 id="repository"> repository</h3>
<p>仓库。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>
<h3 id="star"> Star</h3>
<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>
<h3 id="fork"> fork</h3>
<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>
<h3 id="issue"> issue</h3>
<p>议题。这是一个类似讨论区的地方。如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者会针对您汇报的情况对您做出回复。同时，项目拥有者还可以为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解您提出 issue。也可以将您的 issue assign (分派) 给特定的项目成员解决。</p>
<div><p>提示</p>
<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 bug repository 并把链接放置在您提出的 issue 中。</p>
</div>
<h3 id="pull-request"> pull request</h3>
<p>发起推送请求，简称 <strong>PR</strong>。如果是您自己的项目，您可以从一个分支向另一个分支发起推送请求。如果您想对别人的(您无权进行推送)项目进行代码的推送请求的化，需要先 fork 这个仓库。在自己 fork 的项目上进行修改，然后提交到自己的项目上，之后，建立一个从自己仓库到对方仓库的 PR。如果对方觉得您的新改动很不错，在经过测试或者 review 后就会接受它，这样原有项目就可拥有这些新的代码了.</p>
<h3 id="watch"> watch</h3>
<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>
<h3 id="review"> review</h3>
<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>
<h2 id="主页"> 主页</h2>
<p><img src="./assets/mainPage.png" alt="个人主页" loading="lazy"></p>
<p><a href="https://github.com" target="_blank" rel="noopener noreferrer">https://github.com</a></p>
<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>
<h2 id="个人主页"> 个人主页</h2>
<p><img src="./assets/profile.png" alt="个人主页" loading="lazy"></p>
<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>
<p>个人主页会有几个主要面板:</p>
<h3 id="overview"> Overview</h3>
<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>
<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>
<p>最下方是近几年您在 GitHub 上的活动记录。</p>
<h3 id="repositories"> Repositories</h3>
<p><img src="./assets/personalRepo.png" alt="个人仓库" loading="lazy"></p>
<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>
<h3 id="projects"> Projects</h3>
<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>
<h3 id="packages"> Packages</h3>
<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>
<h3 id="stars"> Stars</h3>
<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>
<h3 id="followers-following"> Followers / Following</h3>
<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>
<h2 id="仓库主页"> 仓库主页</h2>
<p><img src="./assets/repo.png" alt="仓库主页" loading="lazy"></p>
<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>
<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">GitHub Pages</title>
    <id>https://list-jiang.github.io/code/github/pages/</id>
    <link href="https://list-jiang.github.io/code/github/pages/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>
<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>
]]></summary>
    <content type="html"><![CDATA[<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>
<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>

<h2 id="简介"> 简介</h2>
<p>GitHub Pages 站点共有三种类型: 项目，用户和组织。</p>
<p>项目站点连接到 GitHub 上托管的特定项目，而用户和组织站点已连接到特定的 GitHub 帐户。</p>
<ul>
<li>要发布用户站点，您必须创建一个名为的用户帐户拥有的存储库 <code>&lt;username&gt;.github.io</code>。</li>
<li>要发布组织站点，您必须创建一个名为的组织所拥有的存储库 <code>&lt;organization&gt;.github.io</code>。</li>
</ul>
<p>除非您使用自定义域名，否则用户站点和组织站点均位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>
<p>项目站点的源文件与其项目存储在同一存储库中。除非您使用自定义域，否则项目站点可在 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 访问。</p>
<p>虽然您只能在 GitHub 上为每个帐户创建一个用户或组织站点。但无论是组织还是用户帐户拥有的项目站点都是无限的。</p>
<h2 id="发布源文件到-github-pages"> 发布源文件到 GitHub Pages</h2>
<div><p>警告</p>
<p>GitHub Pages 站点 默认在互联网上公开，即使站点的仓库是私有的。</p>
</div>
<p>如果您的存储库中存在默认发布源，则 GitHub Pages 将自动从该源发布网站。用户和组织站点的默认发布源是存储库的默认分支的根目录。项目站点的默认发布源是 gh-pages 分支的根目录。</p>
<p>您需要跳转到 Settings (设置) 选项卡，下来找到 GitHub Pages 的配置部分。</p>
<div><p>提示</p>
<p>您只能在根目录 (<code>/</code>) 和 文档目录 (<code>/docs</code>) 之间进行选择，而不能将仓库内的任意文件夹作为发布源。</p>
</div>
<h3 id="静态站点"> 静态站点</h3>
<p>GitHub Pages 发布您推送到存储库的所有静态文件，这意味它不支持服务器端语言，例如 PHP，Ruby 或 Python。也就是您只能通过 GitHub Pages 发布 “无后端” 的纯静态站点。</p>
<h3 id="限制"> 限制</h3>
<ul>
<li>
<p>GitHub Pages 网站不得超过 1 GB。</p>
</li>
<li>
<p>GitHub Pages 站点的带宽限制为每月 100GB。</p>
</li>
<li>
<p>GitHub Pages 站点限制为每小时最多构建 10 次。</p>
</li>
</ul>
<h3 id="子模块"> 子模块</h3>
<p>如果 GitHub Pages 站点的仓库包含子模块，则在构建站点时会自动拉取其内容。</p>
<p>只能使用指向公共仓库的子模块，因为 GitHub Pages 服务器无法访问私有仓库。</p>
<p>对子模块 (包括嵌套子模块) 使用 <code>https://</code> 只读 URL。 您可以在 .gitmodules 文件中进行此更改。</p>
<h2 id="取消发布"> 取消发布</h2>
<h3 id="取消发布项目站点"> 取消发布项目站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>如果仓库中存在 gh-pages 分支，请删除 gh-pages 分支。</li>
<li>在仓库名称下，单击 Settings (设置) 。</li>
<li>在“ GitHub Pages”下，使用 Source (源) 下拉菜单并选择 None (无) 。</li>
</ol>
<h3 id="取消发布用户或组织站点"> 取消发布用户或组织站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>删除用作发布源的分支，或删除整个仓库。</li>
</ol>
<h2 id="自定义域名"> 自定义域名</h2>
<p>您可以在对应仓库的 Settings (设置) 选项卡设置自定义域名，同时您需要将自定义域名的 CNAME 记录指向 <code>&lt;用户名&gt;.github.io</code>。</p>
<div><p>提示</p>
<p>自定义域名的控制是由发布源文件夹下的 CNAME 文件控制的，您可以直接创建这个文件写入链接。</p>
<p>同时，GitHub Pages 要求这个文件一直存在，否则自定义域名会失效。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Pull Request</title>
    <id>https://list-jiang.github.io/code/github/pr/</id>
    <link href="https://list-jiang.github.io/code/github/pr/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>对于一个用户的公开仓库，在默认情况下虽然其他用户可以拉取该库的代码，但是他们并不能够直接向这个库进行推送。</p>
<p>GitHub 是一个代码社区，这意味着鼓励大家互相提交与贡献代码。所以这就是 Fork 和 Pull Request 出现的意义。没有人会给一个陌生人添加访问自己仓库的权限，所以我们需要一种方式，能够让大家向仓库所有者发起贡献代码的请求。这就是 pull request 的由来。</p>
<h2 id="提交自己贡献的代码"> 提交自己贡献的代码</h2>
<p>对于代码贡献者来说，他需要用一种方法将自己贡献的代码推送到远程库上，以便发起请求，最好的办法就是 fork 原仓库。</p>
<p><img src="./assets/fork.png" alt="Fork 仓库" loading="lazy"></p>
<div><p>相关信息</p>
<p>相关介绍，请见 <a href="./intro.html#fork">GitHub 简介 → fork</a></p>
</div>
<p>这样，贡献者在自己的账号上获得一个和原仓库完全相同的副本。</p>
<p>既然副本已经创建在自己的账号上，贡献者自然可以:</p>
<ol>
<li>克隆这个项目到本地</li>
<li>在这个项目上贡献自己的代码</li>
<li>将贡献的代码推送到这个副本上</li>
</ol>
<h2 id="发送请求"> 发送请求</h2>
<p>pull request 是请求仓库所有者拉取指定仓库分支代码的请求。</p>
<p>在贡献自己的代码并推送到自己的 fork 仓库后，贡献者即可到原仓库去选择自己仓库的对应分支发送这个拉取请求。仓库所有者随时可以批准这个更改，使其自动添加到自己的库中，或是拒绝这个请求。</p>
<p><img src="./assets/pull-request.png" alt="Pull request" loading="lazy"></p>
<blockquote>
<p>这个仓库我已经删了所以显示 <code>unknown repository</code>，原为 <code>Mister-Hope:master</code></p>
</blockquote>
<p>这个页面允许所有人在主要对话线上交换自己的意见。</p>
<p>在 Pull request 里，一旦请求被创建，仓库所有者应该可以直观地看到哪些文件发生了怎样的改变。</p>
<p><img src="./assets/file-changes.png" alt="文件改动" loading="lazy"></p>
<p>同时，他们也可以对贡献者的代码进行审查，对特定行或片段标注，并陈述自己的意见，同时将这个意见根据程度标注为“探讨”、“改进”或者“必须更改”，以便贡献者进行交流讨论与完善修改。</p>
<p><img src="./assets/pull-request-review.png" alt="代码审查" loading="lazy"></p>
<p>同时，对于一个大型库来说，仓库所有者应该可以看到贡献的代码是否通过了所有测试。</p>
<p><img src="./assets/pull-request-check.png" alt="测试通过情况" loading="lazy"></p>
<p>如果审查者认为没有问题，他可能就会通过这个拉取请求，拉取对应的代码到自己的仓库上。这样您就完成了对这个仓库的贡献。</p>
<h2 id="同步原仓库"> 同步原仓库</h2>
<p>需要注意的是，fork 创建的是一个时刻副本，也就是自己 fork 产生的仓库，会保持 fork 时的状态，原仓库的任何变动都不会自动同步到 fork 的仓库上。</p>
<p>有些时候，在自己 fork 原仓库、自己编写代码并提交的这段时间里，原仓库已经进行了很多提交。这时，我们就需要同步原仓库的更新到自己的副本上，以确保自己贡献的代码并未和新增代码发生冲突、可以正常工作。</p>
<p>这个时候只需反向拉取，在自己的仓库创建原仓库特定分支到自己仓库特定分支的 Pull request，并批准这个 pull request。这样即可很方便的将原仓库特定分支的更新同步到自己的副本上。</p>
<p>您当然可以在本地添加原仓库的远程库，将最新的更改直接 fetch 到本地，在本地测试通过并完成合并后，由本地推送至自己的 fork 仓库。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">GitHub</title>
    <id>https://list-jiang.github.io/code/github/</id>
    <link href="https://list-jiang.github.io/code/github/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速上手"> 快速上手</h2>
<ul>
<li>
<p><a href="./intro.html">GitHub 介绍</a></p>
</li>
<li>
<p><a href="./pr.html">Pull Request</a></p>
</li>
<li>
<p><a href="./semantic.html">语义化提交</a></p>
</li>
<li>
<p><a href="./pages.html">GitHub Pages</a></p>
</li>
<li>
<p><a href="./speedup.html">利用 Gitee 加速 GitHub 克隆</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github" target="_blank" rel="noopener noreferrer">全部文档</a></li>
</ul>
<h3 id="入门指南"> 入门指南</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="快速入门"> 快速入门</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git" target="_blank" rel="noopener noreferrer">设置 Git</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo" target="_blank" rel="noopener noreferrer">创建仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" target="_blank" rel="noopener noreferrer">复刻仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social" target="_blank" rel="noopener noreferrer">社交化</a></li>
</ul>
<h3 id="了解-github"> 了解 GitHub</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts" target="_blank" rel="noopener noreferrer">账户类型</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7" target="_blank" rel="noopener noreferrer">GitHub 上的访问权限</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表</a></li>
</ul>
<h2 id="生态系统"> 生态系统</h2>
<h3 id="github-cli"> GitHub Cli</h3>
<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>
<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>
<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>
<ul>
<li>查看、创建、克隆和复刻仓库</li>
<li>创建、关闭和列出议题和拉取请求</li>
<li>审查、差异和合并拉取请求</li>
<li>创建、编辑、列出和查看 Gist</li>
</ul>
<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href="https://cli.github.com/manual" target="_blank" rel="noopener noreferrer">GitHub CLI 手册</a>。</p>
<h3 id="github-desktop"> GitHub Desktop</h3>
<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>
<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>
<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>
<ul>
<li>以交互方式将更改添加到提交中</li>
<li>快速将合作作者提交到提交中</li>
<li>检出具有拉取请求的分支并查看 CI 状态</li>
<li>比较更改的图像</li>
</ul>
<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href="https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop" target="_blank" rel="noopener noreferrer">安装和配置 GitHub Desktop</a>。</p>
<h3 id="手机版-github"> 手机版 GitHub</h3>
<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>
<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>
<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>
<p>通过 手机版 GitHub，您可以:</p>
<ul>
<li>管理、分类和清除通知</li>
<li>阅读、审查及协作处理问题和拉取请求</li>
<li>搜索、浏览用户、仓库和组织以及与之交互</li>
<li>当有人提及您的用户名时收到推送通知</li>
</ul>
<h4 id="安装-手机版-github"> 安装 手机版 GitHub</h4>
<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href="https://github.com/mobile" target="_blank" rel="noopener noreferrer">手机版 GitHub</a>。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">语义化提交</title>
    <id>https://list-jiang.github.io/code/github/semantic/</id>
    <link href="https://list-jiang.github.io/code/github/semantic/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="semantic"> Semantic</h2>
<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>
<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>
<h2 id="优势"> 优势</h2>
<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>
<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>
<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>
<h2 id="格式"> 格式</h2>
<div><pre><code>&amp;lt;type&gt;(&amp;lt;scope&gt;): &amp;lt;subject&gt;
&amp;lt;body&gt;

&amp;lt;footer&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="header"> header</h3>
<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>
<h3 id="type"> type</h3>
<p>commit 的类型。</p>
<p>规范中规定了如下类型:</p>
<ul>
<li><code>feat</code>: feature, 新增功能</li>
<li><code>fix</code> : bug fix, 修复 bug</li>
<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>readme.md</code></li>
<li><code>style</code>: style, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>
<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>
<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>
<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>
<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>
<li><code>revert</code>: 版本回滚</li>
</ul>
<h3 id="scope"> scope</h3>
<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>
<h3 id="subject"> subject</h3>
<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>
<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>
<h3 id="body"> body</h3>
<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>
<h3 id="footer"> footer</h3>
<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>
<h2 id="semantic-commit-与-changelog-生成"> Semantic commit 与 Changelog 生成</h2>
<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>
<div><p>案例</p>
<p>Node.js 环境下可以使用:</p>
<ul>
<li>
<p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener noreferrer"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>
</li>
<li>
<p><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer"><code>conventional-changelog-cli</code></a> 来快速生成更新日志，如 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">vuepress-theme-hope 的更改日志</a></p>
</li>
</ul>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">加速 GitHub 克隆</title>
    <id>https://list-jiang.github.io/code/github/speedup/</id>
    <link href="https://list-jiang.github.io/code/github/speedup/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>由于天朝墙的存在，GitHub 的访问速度在大部分国内地区都很慢。如果需要克隆体积比较大的项目，可能需要很长时间，也很大概率会在中途因为网络波动、终端问题导致克隆失败。</p>
<p>本文介绍如何使用 Gitee 加快 GitHub 项目克隆。</p>
<h2 id="gitee"> Gitee</h2>
<p>Gitee 又称码云，是一个国内的代码托管商，国内访问 Gitee 的速度是十分 Amazing 的。</p>
<h3 id="注册"> 注册</h3>
<p>Gitee 账户可以很方便的通过 GitHub 账户 + 绑定手机号注册。</p>
<h3 id="添加公钥"> 添加公钥</h3>
<p>完成注册后，您需要上传本地公钥，以保证可以从 Gitee 上拉取或克隆，其步骤与 GitHub 大致相同。</p>
<h3 id="导入-github-仓库"> 导入 GitHub 仓库</h3>
<p>码云的企业专线访问 GitHub 的速度很快，而码云在新建仓库的时候提供了导入选项，这就给我们的加速提供了方式。</p>
<p>我们只需要在码云上新建仓库，选择导入，然后输入自己想要克隆的 GitHub 仓库地址，交给码云完成导入即可。</p>
<p>稍等片刻后，码云即会将 GitHub 的仓库同步到自己的服务器上，此时我们只需要克隆码云上的这个仓库地址，就可以高速克隆这个项目。</p>
<h3 id="远程库地址修改"> 远程库地址修改</h3>
<p>在克隆完毕后，本地的 origin 远程库会默认为 Gitee 的仓库，此时我们需要使用 <code>git remote rename origin gitee</code> 命令，将码云的远程仓库重命名为 <code>gitee</code>，并使用 <code>git remote add origin &lt;github url&gt;</code> 命令重新添加 GitHub 的远程仓库为 origin。</p>
<p>这样我们稍后在做出本地提交后，即可直接推送到 GitHub 仓库。</p>
<h3 id="同步仓库"> 同步仓库</h3>
<p>如果以导入的形式创建码云仓库。则可以随时点击仓库页面上的同步图标，让码云随时拉取最新的 gitee 代码，以便在本地通过 <code>git fetch gitee</code>，通过码云服务器高速拉取最新代码。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-02-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">GitHub Token</title>
    <id>https://list-jiang.github.io/code/github/token/</id>
    <link href="https://list-jiang.github.io/code/github/token/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>

<h2 id="创建个人访问令牌"> 创建个人访问令牌</h2>
<ol>
<li>
<p>访问 <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">新建 Token 页面</a> (当然您需要先登陆 GitHub)</p>
<blockquote>
<p>或者可以点击头像 → Settings → Developer settings → Personal access tokens → Generate new Token</p>
</blockquote>
</li>
<li>
<p>输入一个备注，选择您需要授权 Token 访问的内容，之后点击页面底部的 &quot;Generate Token&quot;</p>
</li>
<li>
<p>妥善保存该 Token (因为您无法再次查看它)</p>
</li>
</ol>
<p>详见 <a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener noreferrer">创建个人访问令牌</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="GitHub"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">JSON 教程</title>
    <id>https://list-jiang.github.io/code/language/json/</id>
    <link href="https://list-jiang.github.io/code/language/json/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>
<ul>
<li>
<p>JSON 是存储和交换文本信息的语法。类似 XML。</p>
</li>
<li>
<p>JSON 比 XML 更小、更快，更易解析。</p>
</li>
<li>
<p>JSON 是轻量级的文本数据交换格式</p>
</li>
<li>
<p>JSON 独立于语言: JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。目前非常多的动态(PHP，JSP，.NET)编程语言都支持 JSON。</p>
</li>
<li>
<p>JSON 具有自我描述性，更易理解</p>
</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>
<ul>
<li>
<p>JSON 是存储和交换文本信息的语法。类似 XML。</p>
</li>
<li>
<p>JSON 比 XML 更小、更快，更易解析。</p>
</li>
<li>
<p>JSON 是轻量级的文本数据交换格式</p>
</li>
<li>
<p>JSON 独立于语言: JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。目前非常多的动态(PHP，JSP，.NET)编程语言都支持 JSON。</p>
</li>
<li>
<p>JSON 具有自我描述性，更易理解</p>
</li>
</ul>

<h2 id="json-值"> JSON 值</h2>
<p>JSON 值可以是:</p>
<ul>
<li>数字(整数或浮点数)</li>
<li>字符串(在双引号中)</li>
<li>逻辑值(<code>true</code> 或 <code>false</code>)</li>
<li>数组(在中括号中)</li>
<li>对象(在大括号中)</li>
<li>null</li>
</ul>
<h2 id="json-数字"> JSON 数字</h2>
<p>JSON 数字可以是整型或者浮点型:</p>
<p><strong>例:</strong></p>
<ul>
<li><code>5201314</code></li>
<li><code>-1</code></li>
<li><code>3.141592654</code></li>
</ul>
<h2 id="json-布尔值"> JSON 布尔值</h2>
<p>JSON 布尔值可以是 <code>true</code> 或者 <code>false</code></p>
<h2 id="json-字符串"> JSON 字符串</h2>
<p>JSON 字符串需要用双括号 <code>&quot;</code> 包含，如果内部含有英文引号 <code>&quot;</code>，需要使用 <code>\</code> 转义。</p>
<p><strong>例:</strong></p>
<ul>
<li><code>&quot;Mr.Hope is handsome&quot;</code></li>
<li><code>&quot;春眠不觉晓，处处闻啼鸟&quot;</code></li>
<li><code>&quot;A saying goes: \&quot;Great hopes make great man.\&quot;&quot;</code></li>
</ul>
<h2 id="json-对象"> JSON 对象</h2>
<p>JSON 对象在大括号 <code>{}</code> 中书写以 <code>键: 值</code> 对的方式书写，不同键值对之间用 <code>,</code> 分隔。</p>
<p><strong>例:</strong></p>
<div><pre><code><span>{</span>
  <span>"tag"</span><span>:</span> <span>"text"</span><span>,</span>
  <span>"heading"</span><span>:</span> <span>"校园卡说明"</span><span>,</span>
  <span>"text"</span><span>:</span> <span>"校园卡是东师的金融消费卡"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="json-数组"> JSON 数组</h2>
<p>JSON 数组在中括号 <code>[]</code> 中书写，不同元素间用 <code>,</code> 隔开。</p>
<h2 id="json-null"> JSON null</h2>
<p>JSON 可以设置 <code>null</code> 值</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="JSON"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-07-25T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">如何学习一门计算机语言</title>
    <id>https://list-jiang.github.io/code/language/learning/</id>
    <link href="https://list-jiang.github.io/code/language/learning/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何学习一门计算机语言"> 如何学习一门计算机语言</h1>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
<p>本部分将以 JS 作为示例，展示什么是一门计算机语言，应该如何学习它们。</p>
</div>
<h2 id="基础"> 基础</h2>
<p>首先，任何语言都是由一些基本结构组成的，下面介绍几乎所有语言共有的一些概念:</p>
<h3 id="语句"> 语句</h3>
<p>语句可以简单理解为一个操作，它可以是赋值，也可以是执行，还可以是介于或者是可以归类到两者上的判断、声明、标记等。</p>
<p>请注意一条语句通常是一个计算机语言描述的最小操作。</p>
<p>比如:</p>
<div><pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span> <span>// 赋值</span>
<span>alert</span><span>(</span><span>"Hello word"</span><span>)</span><span>;</span> <span>// 调用函数 执行操作</span>
<span>if</span> <span>(</span>a <span>></span> <span>2</span><span>)</span> <span>{</span>
  <span>// 判断</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="代码块"> 代码块</h3>
<p>通常情况下，在有了语句概念后，我们就要使用不同的语句顺序，完成不同的操作，但是某些操作总是固定的。</p>
<p>比如回家，总是 “掏出钥匙”-“插入钥匙”-“转动钥匙”-“开启房门”-“拔出钥匙”-“进入”-“关闭房门” 。</p>
<p>这些步骤每一步都可以理解为一个语句，但是由于其顺序基本是固定的，我们就可以设计一个代码块，来约束它们。</p>
<div><pre><code>{
  “掏出钥匙”;
  “插入钥匙”;
  “转动钥匙”;
  “开启房门”;
  “拔出钥匙”;
  “进入”;
  “关闭房门”;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>大多数语言会使用 <code>{ }</code> 的形式，少数语言会使用统一的缩进进行表达。</p>
<h2 id="数据结构"> 数据结构</h2>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。</p>
<p>任何语言都是操作、计算(处理)、生成数据的。数据结构是一门语言存放数据的方式。不同的数据，需要定义不同的数据类型。了解了数据结构就了解了一门语言可以存储或处理何种数据。</p>
<p>大多数语言都包含了以下的一种或多种内容:</p>
<ul>
<li>
<p>数字:</p>
<p>不同语言对数字有不同的处理方式，少数语言可能只有数字这一种类型，一些语言可能会拆分成整数与浮点数。一些底层语言(涉及到内存)可能会魔鬼的将数字拆分为: 整型、浮点数、无符号整型、长整型、无符号长整形、长浮点数。(说的就是您，C 语言)</p>
</li>
<li>
<p>字符串:</p>
<p>一些语言只有字符串这个概念，一些语言分为字符和字符串这个概念。</p>
</li>
<li>
<p>布尔值:</p>
<p>几乎所有语言都有布尔值，布尔值只有真和假两种类型。大多数会表示为 <code>true</code> 和 <code>false</code>，少数会表示为 <code>True</code> 和 <code>False</code>。</p>
</li>
<li>
<p>数组:</p>
<p>大部分语言都有数组 (Array) 这个概念，它是一个有序的元素集合。很多底层语言就是靠数组实现的字符串 (因为字符串长度不固定)。在数组中，每个元素具有标号，从 0 开始依次递增。</p>
<p>一些语言还有 Set 这个概念，Set 表示的是无序元素集合，所有元素没有先后与标号的概念，自然 Set 也无法存入相同的元素。</p>
</li>
<li>
<p>对象:</p>
<p>大部分语言的对象 (Object) 都是由键值对组成的，它是一个由键标记的元素集合，可以使用特定的键名写入或读取其对应的值。</p>
<p>一些产生较晚的语言，将对象改为 Map，Map 表达一个映射，将对应的键映射到对应的值上。</p>
</li>
<li>
<p>类:</p>
<p>类 (Class) 是一个内容集合，它包含了自己的构造器、变量与方法。类在声明后，可以很轻松的使用构造器创建一个新的实例。每个实例可以用其内部的变量维护或表达一个状态，并可以使用它自身的方法来读取或是改变自己的状态。不同的类之间还可以进行继承。</p>
</li>
</ul>
<h2 id="变量"> 变量</h2>
<p>一个<strong>变量</strong>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>
<p>下面的语句创建(换句话说，<strong>声明</strong>或者<strong>定义</strong>)了一个名称为“message”的变量:</p>
<div><pre><code><span>let</span> message<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在有了变量之后，我们就可以将刚了解的数据结构赋值给变量，以变量来代替这些数据。</p>
<div><pre><code><span>let</span> user <span>=</span> <span>"John"</span><span>;</span>
<span>let</span> age <span>=</span> <span>25</span><span>;</span>
<span>let</span> message <span>=</span> <span>"Hello"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="条件"> 条件</h2>
<p>条件运算符用于判断，通过判断一个条件的真假，来执行不同的逻辑。这是每一门语言逻辑结构的基础。</p>
<div><pre><code><span>let</span> year <span>=</span> <span>2015</span><span>;</span>
<span>if</span> <span>(</span>year <span>&lt;</span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too early..."</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>year <span>></span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too late"</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Exactly!"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="循环"> 循环</h2>
<p>循环运算符的作用，是在条件控制下，零次或多次执行特定代码块。它使得重复执行成为了可能。</p>
<div><pre><code><span>let</span> result <span>=</span> <span>0</span><span>;</span>
<span>let</span> i <span>=</span> <span>1</span><span>;</span>

<span>while</span> <span>(</span>i <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>
  <span>// 计算1+2+3+...+100的结果</span>
  i <span>=</span> i <span>+</span> <span>1</span><span>;</span>
  result <span>=</span> result <span>+</span> i<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>// 结果为 0、1、2</span>
  <span>alert</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="函数"> 函数</h2>
<p>函数是程序的主要“构建模块”，</p>
<p>创建函数时，需要声明函数内容，函数内容由一系列语句(代码块) 构成。在声明函数后，使用函数即可多次调用一段代码。</p>
<p>例如:</p>
<div><pre><code><span>function</span> <span>showMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello everyone!"</span><span>)</span><span>;</span>
<span>}</span> <span>// 声明一个函数</span>

<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 调用它</span>
<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 可以在任意时刻调用它</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>同时函数可以通过接受参数的形式来根据情况返回不同的结果，比如这是一个简单的求和函数。</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>sum1<span>,</span> sum2</span><span>)</span> <span>{</span>
  <span>return</span> sum1 <span>+</span> sum2<span>;</span>
<span>}</span>

<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// return 3</span>
<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span> <span>// return 11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="教程"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">clang-format</title>
    <id>https://list-jiang.github.io/code/language/linter/clang-format/</id>
    <link href="https://list-jiang.github.io/code/language/linter/clang-format/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>clang-format 是一种代码格式化工具，可用于格式化(排版) C / C++ / Java / JavaScript / Objective-C / Protobuf / C# 的代码。它支持多种预设代码风格与自定义风格 (通过编写 <code>.clang-format</code> 文件)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>clang-format 是一种代码格式化工具，可用于格式化(排版) C / C++ / Java / JavaScript / Objective-C / Protobuf / C# 的代码。它支持多种预设代码风格与自定义风格 (通过编写 <code>.clang-format</code> 文件)。</p>

<h2 id="自定义格式化"> 自定义格式化</h2>
<div><pre><code>clang-format -style<span>=</span>格式名 -dump-config <span>></span> .clang-format`
</code></pre>
<div><span>1</span><br></div></div><p>其中，格式名的取值可以为 <code>LLVM</code>, <code>Google</code>, <code>Chromium</code>, <code>Mozilla</code>, <code>Webkit</code> 中的任一种，这会将对应格式预设写入 <code>.clang-format</code> 文件。</p>
<h2 id="使用命令行"> 使用命令行</h2>
<h3 id="格式"> 格式</h3>
<div><pre><code>clang-format <span>[</span>options<span>]</span> <span>[</span><span>&lt;</span>file<span>></span> <span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="可用选项"> 可用选项</h3>
<ul>
<li>
<p><code>--Werror</code>: 将格式化警告变为错误</p>
</li>
<li>
<p><code>--Wno-error=unknown</code>: 未知的格式化选项仅产生警告。</p>
<p>这可以保持格式化启用，即使配置包含未知 (较新) 选项。</p>
</li>
<li>
<p><code>--assume-filename=&lt;string&gt;</code>: 覆盖用于确定语言的文件名。</p>
<p>通常在从 stdin 读取时，帮助 clang-fomat 获取文件名</p>
</li>
<li>
<p><code>--dry-run</code> 或 <code>-n</code>: 如果设置，实际上不进行格式更改</p>
</li>
<li>
<p><code>--dump-config</code>: 将配置选项转储到标准输出并退出, 可以与 <code>--style</code> 选项一起使用。</p>
</li>
<li>
<p><code>--fallback-style=&lt;string&gt;</code>: 设置回退的默认格式，通常在 clang-format 找不到配置文件时使用。</p>
<p>设置 <code>--fallback-style=none</code> 可以在这种情况下跳过格式化</p>
</li>
<li>
<p><code>--ferror-limit=&lt;uint&gt;</code>: 设置 clang-format 输出的最大错误数，超过将停止输出。</p>
<p>请仅与 <code>--dry-run</code> 或 <code>-n</code> 配合使用，<code>0</code> 意味着无限制</p>
</li>
<li>
<p><code>-i</code>: 替换输入文件</p>
</li>
<li>
<p><code>--length=&lt;uint&gt;</code>: 格式化指定长度范围</p>
<p>可以通过指定多个偏移和长度对来格式化几个范围。</p>
<p>当仅指定一个偏移量而没有 <code>--length</code>，clang-format 会一直格式化到文件的最后。</p>
<p>只能与一个输入文件一起使用。</p>
</li>
<li>
<p><code>--lines=&lt;string&gt;</code>: 格式为 <code>&lt;start line&gt;:&lt;end line&gt;</code></p>
<p>设置格式化行的范围(起始为第一行)，可以通过指定多个范围来格式化多行。</p>
<p>不能与 <code>--offset</code> 和 <code>--length</code> 一起使用。</p>
<p>只能与一个输入文件一起使用。</p>
</li>
<li>
<p><code>--offset=&lt;uint&gt;</code>: 格式化从此字节偏移量开始的范围。</p>
<p>可以通过指定多个范围来格式化几个偏移量和长度对。</p>
<p>只能与一个输入文件一起使用。</p>
</li>
<li>
<p><code>--output-replacements-xml</code>: 输出 XML</p>
</li>
<li>
<p><code>--sort-includes</code>: 如果设置，将覆盖包含排序行为。由 SortIncludes 样式标志确定</p>
</li>
<li>
<p><code>--style=&lt;string&gt;</code> 编码样式</p>
<p>当前支持: <code>LLVM</code>, <code>Google</code>, <code>Chromium</code>, <code>Mozilla</code>, <code>Webkit</code></p>
<p>使用 <code>--style=file</code> 从中文件加载样式配置</p>
<p>使用 <code>--style=&quot;{key:value,...}&quot;</code> 来设置特定的参数，
例如: <code>&quot;{BasedOnStyle: llvm, IndentWidth: 8}&quot;</code></p>
</li>
<li>
<p><code>--verbose</code>: 输出处理的文件列表</p>
</li>
</ul>
<h2 id="vs-code"> VS Code</h2>
<p>在 VS Code 中安装 C/C++ 插件以启用两者支持时会自动安装 clang-format，因此无需进行任何操作，即可在 C/C++ 文件中对代码进行格式化。</p>
<h2 id="推荐样式"> 推荐样式</h2>
<p>Mr.Hope 推荐使用 Google 预设，所以在个人与工作室的每个项目中，都会使用 Google 编码风格。</p>
<p>建议在 VS Code 中配置默认格式风格:</p>
<div><pre><code><span>{</span>
  <span>"C_Cpp.clang_format_fallbackStyle"</span><span>:</span> <span>"Google"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="http://clang.llvm.org/docs/ClangFormat.html" target="_blank" rel="noopener noreferrer">地址</a> (需 VPN)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-10-21T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">linter 介绍</title>
    <id>https://list-jiang.github.io/code/language/linter/</id>
    <link href="https://list-jiang.github.io/code/language/linter/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>linter 用来检查程序的语法错误，并即时标注和指出来 (例如，把声明了但没使用的多余变量指出来，向错误语句添加红色波浪线)，是程序开发的辅助工具。同时，linter 也有统一规范代码书写方式的功能。</p>
<p>在大型项目中，编码需要统一的风格，比如在 JavaScript 中使用单引号还是双引号包裹字符串，在何时进行折行等。目前各种语言基本都有自己的出色 linter，能够确保相同的使用不同换行方式、缩进、标记代码会最终格式化为相同的输出。</p>
]]></summary>
    <content type="html"><![CDATA[<p>linter 用来检查程序的语法错误，并即时标注和指出来 (例如，把声明了但没使用的多余变量指出来，向错误语句添加红色波浪线)，是程序开发的辅助工具。同时，linter 也有统一规范代码书写方式的功能。</p>
<p>在大型项目中，编码需要统一的风格，比如在 JavaScript 中使用单引号还是双引号包裹字符串，在何时进行折行等。目前各种语言基本都有自己的出色 linter，能够确保相同的使用不同换行方式、缩进、标记代码会最终格式化为相同的输出。</p>

<h2 id="prettier"> Prettier</h2>
<p>Prettier 是一个前端知名的 linter，它可以代码规范根据设置为唯一的排列格式。它支持 markdown, html, css, js, ts, jsx, tsx, json, vue 等多种文件格式。</p>
<h2 id="eslint"> ESlint</h2>
<p>ESlint 是一个知名的 JavaScript linter，借助插件它也可以提供其他扩展语言的支持，如 jsx, ts, tsx, vue 等。</p>
<h2 id="clang-format"> clang-format</h2>
<p>clang-format 是 C/ C++ / Object-C 最流行的代码格式化工具，提供多种预设的代码风格。</p>
<ul>
<li><a href="./clang-format.html">查看详情</a></li>
</ul>
<h2 id="checkstyle"> checkStyle</h2>
<p>checkStyle 是比较流行的 Java linter</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-10-21T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Markdown 块元素</title>
    <id>https://list-jiang.github.io/code/language/markdown/block/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/block/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="段落和换行"> 段落和换行</h2>
<p>一个段落由一个及以上相连接的行句组成。</p>
<p>一个即以上的空行则会切分出不同的段落，一般的段落不需要用空白或断行缩进。</p>
<div><p>空行</p>
<p>空行的定义是显示上看起来像是空行，便会被视为空行。</p>
<p>也就是若某一行只包含空白和 tab，则该行也会被视为空行。</p>
</div>
<p>「一个及以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，其它的格式会把每个断行都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果您<strong>真的想要</strong>插入 <code>&lt;br /&gt;</code> 标签的话，在行尾加上两个以上的空白，然后按下回车:</p>
<div><pre><code>这是一句话，它可以在这里  
强制换行
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="标题"> 标题</h2>
<p>标题能显示出文章的结构。</p>
<p>Atx (<strong>推荐</strong>)形式是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如:</p>
<ul>
<li>H1: <code># Header 1</code></li>
<li>H2: <code>## Header 2</code></li>
<li>H3: <code>### Header 3</code></li>
<li>H4: <code>#### Header 4</code></li>
<li>H5: <code>##### Header 5</code></li>
<li>H6: <code>###### Header 6</code></li>
</ul>
<div><p>最佳实践</p>
<p>为了使内容可读性更强，Markdown 最佳实践要求标题应使用 Atx 写法，并且每个标题应被空行隔开。 (第一行的大标题不需要向上空行)</p>
</div>
<p>Setext<sup></sup> 格式不推荐使用。</p>
<h2 id="blockquotes"> Blockquotes</h2>
<p>Markdown 使用 email 形式的块引言。</p>
<p>如果您很熟悉如何在 email 信件中引言，您就知道如何在 Markdown 文件中建立一个块引言:在每行的最前面加上 <code>&gt;</code> 接一个空格:</p>
<div><pre><code><span>></span> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
<span>></span> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
<span>></span> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
<span>></span>
<span>></span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
<span>></span> id sem consectetuer libero luctus adipiscing.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><details><summary>渲染结果</summary>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
</details>
<div><p>易写性</p>
<p>处于易写性的考虑，Markdown 允许您只在整个段落的第一行最前面加上 <code>&gt;</code> :</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
  consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
  Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

<span>></span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
  id sem consectetuer libero luctus adipiscing.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>输出</strong>:</p>

<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>

</details>
<p>但是请注意，我们<strong>不推荐</strong>使用这种做法，这并不是符合 Markdown 最佳实践。</p>
<p>同时，<code>&gt;</code> 后面的空格也是可选的，我们也推荐您加上它。</p>
</div>
<details><summary>块引言可以有阶层 (例如: 引言内的引言) ，只要根据层数加上不同数量的 ></summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> This is the first level of quoting.
<span>></span>
<span>> ></span> This is nested blockquote.
<span>></span>
<span>></span> Back to the first level.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>输出</strong>:</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
</details>
<details><summary>引言的块内也可以使用其他的 Markdown 语法，包括标题、列表、代码块等</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> <span>1.</span> This is the first list item.
<span>></span> <span>1.</span> This is the second list item.
<span>></span>
<span>></span> Here’s some example code:
<span>></span> 
<span>></span> ```js
<span>></span> const a = 1;
<span>></span> ```
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>输出</strong>:</p>
<blockquote>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here’s some example code:</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
</details>
<h2 id="列表"> 列表</h2>
<p>Markdown 支持有序列表和无序列表。</p>
<h3 id="无序列表"> 无序列表</h3>
<p>无序列表在规范中使用减号作为列表标记:</p>
<div><pre><code><span>-</span> Red
<span>-</span> Green
<span>-</span> Blue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><details><summary>渲染结果</summary>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
</details>
<div><p>其他支持的符号</p>
<p>Markdown 最初的规范也支持使用星号、加号:</p>
<div><pre><code><span>+</span> Red
<span>+</span> Green
<span>+</span> Blue

<span>*</span> Red
<span>*</span> Green
<span>*</span> Blue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>我们<strong>极其不建议</strong>使用以上写法，它们并不符合 Markdown 最佳实践。(加号看上去并不像一个列表，而且星号并不是可以直接按键输入的符号)</p>
</div>
<h3 id="有序列表"> 有序列表</h3>
<p>有序列表使用数字接著一个英文句点:</p>
<div><pre><code><span>1.</span> Bird
<span>2.</span> McHale
<span>3.</span> Parish
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><details><summary>渲染结果</summary>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<p>很重要的一点是，您在列表标记上使用的数字并不会影响输出的 HTML 结果，因为上面的列表所产生的 HTML 标记为:</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Bird<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>McHale<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Parish<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><details><summary>这意味着您无需刻意对列表进行标号</summary>
<p>如果您使用:</p>
<div><pre><code><span>1.</span> Bird
<span>1.</span> McHale
<span>1.</span> Parish
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>列表项也会正确的渲染:</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<div><p>将标号交给 Markdown</p>
<p>人工为列表进行正确的标号与全部使用 <code>1.</code> 都符合 Markdown 最佳实践。</p>
<p>但是请不要错误的进行标号，如:</p>
<div><pre><code><span>2.</span> Bird
<span>3.</span> McHale
<span>5.</span> Parish
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了更加便捷的添加、删除或排序有序列表项，我们<strong>推荐都设置为标号 <code>1</code></strong>。</p>
</div>
<h3 id="列表格式的转义"> 列表格式的转义</h3>
<p>有些时候项目列表很可能会不小心被产生，比如:</p>
<div><pre><code>XXX finally died in
<span>1986.</span> What a great man.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，您可以在句点前面加上反斜线。</p>
<div><pre><code>XXX finally died in
1986\. What a great man.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="缩进与段落"> 缩进与段落</h3>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多三个空白，项目标记后面则一定要接著至少一个空白或 tab。</p>
<p>要让列表看起来更漂亮，您可以把内容用固定的缩进整理好:</p>
<div><pre><code><span>-</span> Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
  Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
  viverra nec, fringilla in, laoreet vitae, risus.
<span>-</span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><details><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<div><p>易写性</p>
<p>处于易写性的考虑，列表缩进不是强制的，也就是以下的内容渲染结果与上面相同。</p>
<div><pre><code><span>-</span> Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
<span>-</span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><details><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<p>但是我们<strong>不推荐</strong>这种写法，这种写法会导致 Markdown 源文件可读性变差，不符合 Markdown 最佳实践。</p>
</div>
<p>如果列表项目间用空行分开， Markdown 会把项目的内容在输出时用 <code>&lt;p&gt;</code> 标签包起来，举例来说:</p>
<details><summary>普通的无序列表</summary>
<p>输入:</p>
<div><pre><code><span>-</span> Bird
<span>-</span> Magic
<span>-</span> Wood
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>转换结果:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Bird<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Magic<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Wood<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>渲染:</p>
<ul>
<li>Bird</li>
<li>Magic</li>
<li>Wood</li>
</ul>
</details>
<p>但是这个:</p>
<div><pre><code><span>-</span> Bird

<span>-</span> Magic

<span>-</span> Wood
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>会被转换为:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Bird<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Magic<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Wood<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><details><summary>渲染结果</summary>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>这会在列表项之间创建更大的空间。</p>
<div><p>最佳实践</p>
<p>对于一个列表项来说，只要有一项使用了空行，所有项目都会转换为段落，也就是以下格式也会渲染为段落列表。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> Bird
<span>-</span> Magic

<span>-</span> Wood
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>Markdown 最佳实践要求您在每一个列表间始终(或始终不)添加空行。</p>
</div>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 2 - 4 个空白或是一个 tab。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> This is a list item with two paragraphs.

  This is the second paragraph in the list item. You’re
  only required to indent the first line. Lorem ipsum dolor
  sit amet, consectetuer adipiscing elit.

<span>-</span> Another item in the same list.

<span>1.</span> This is a list item with two paragraphs. Lorem ipsum dolor
   sit amet, consectetuer adipiscing elit. Aliquam hendrerit
   mi posuere lectus.

   Vestibulum enim wisi, viverra nec, fringilla in, laoreet
   vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
   sit amet velit.

<span>2.</span> Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>This is a list item with two paragraphs.</p>
<p>This is the second paragraph in the list item. You’re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.</p>
</li>
<li>
<p>Another item in the same list.</p>
</li>
</ul>
<ol>
<li>
<p>This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.</p>
</li>
<li>
<p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</li>
</ol>
</details>
<p>如果要在列表项目内放入其他内容，也需要缩进。</p>
<p>比如放进引言，那 <code>&gt;</code> 就需要缩进:</p>
<div><pre><code><span>-</span> A list item with a blockquote:

  > This is a blockquote
  > inside a list item.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>Markdown 最佳实践</p>
<p>为了更高的可读性，段落缩进应当等同于列表第一行，也就是无序列表缩进 2 个空格，有序列表根据缩进三或四个空格。</p>
</div>
<h2 id="代码块"> 代码块</h2>
<p>和代码相关的写作或是标签语言原始码通常会有已经排版好的代码块，通常这些块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码块包起来。</p>
<p>Markdown 最初标准只规定了一种缩进格式的代码块<sup></sup>。</p>
<p>由于缩进式的代码块格式不够鲜明，且无法在此模式下设置代码块的语言并对代码块进行高亮，围栏式的代码扩展几乎被所有 Markdown 实现所支持。</p>
<p>Markdown 最佳实践也同样推荐使用围栏式的代码块，尽管它并不在最初的标准中。</p>
<p>您可以很简单的使用 <code>```代码名称</code> 与 <code>```</code> 创建围栏式代码块。比如:</p>
<div><pre><code><span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>会渲染为</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在代码块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让您非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制粘贴，再加上缩进就可以了，剩下的 Markdown 都会帮您处理。</p>
<details><summary>Markdown 处理例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>```</span><span>html</span>
<span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>footer<span>"</span></span><span>></span></span>
  <span title="&copy;">&amp;copy;</span> 2004 Foo Corporation
<span><span><span>&lt;/</span>div</span><span>></span></span></span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>转换结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>pre</span><span>></span></span>
  <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>div<span title="&gt;">&amp;gt;</span>
  <span title="&amp;">&amp;amp;</span>copy; 2004 Foo Corporation
<span title="&lt;">&amp;lt;</span>/div<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span>
<span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>输出</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>footer<span>"</span></span><span>></span></span>
  <span title="&copy;">&amp;copy;</span> 2004 Foo Corporation
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<p>代码块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示您可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="转义与嵌套"> 转义与嵌套</h3>
<p>如果您希望在一个代码块中放置另一个 Markdown 代码块格式，您可以增加 <code>`</code> 的数量来进行嵌套</p>
<div><div><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br></div><pre><code><span><span>```</span><span>`md</span>
<span>```js
const a = 1;</span>
<span>```</span></span>
````
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>会渲染为</p>
<div><pre><code><span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您希望输入 <code>```</code>，您可以使用 <code>\</code> 转义:</p>
<p><code>\`\`\`</code> 会被渲染为: ```</p>
<h3 id="分隔线"> 分隔线</h3>
<p>您可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。您也可以在星号中间插入空白。下面每种写法都可以建立分隔线:</p>
<div><div><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br></div><pre><code>---(建议)

<span>* * *</span>

<span>***</span>

<span>*****</span>

<span>- - -</span>

<span>---------------------------------------</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>Setext 格式</p>
<p>Setext 形式是用底线的形式，利用 <code>=</code> (最高阶标题) 和 <code>-</code> (第二阶标题) ，例如:</p>
<div><pre><code><span>This is an H1
<span>=============</span></span>

<span>This is an H2
<span>-------------</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>请注意我们<strong>极其不推荐</strong>使用该格式! 因为它不仅麻烦，还仅支持两级目录。 </p>
</li>
<li id="footnote2"><p>缩进格式的代码块</p>
<p>在 Markdown 中，可以通过简单地缩进 4 个空白或是 1 个 tab 来建立代码块。比如:</p>
<div><pre><code>This is a normal paragraph:

<span>    This is a code block.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Markdown 会转换成:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>This is a normal paragraph:<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>pre</span><span>></span></span>
  <span><span><span>&lt;</span>code</span><span>></span></span>This is a code block.<span><span><span>&lt;/</span>code</span><span>></span></span>
<span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里的缩进 (4 个空白或是 1 个 tab) ，都会被移除，例如:</p>
<div><pre><code>Here is an example of AppleScript:

<span>    tell application "Foo"
    beep
    end tell</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>会被转换为:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Here is an example of AppleScript:<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>pre</span><span>></span></span><span><span><span>&lt;</span>code</span><span>></span></span>tell application "Foo"
beep
end tell
<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>一个代码块会一直持续到没有缩进的那一行 (或是文件结尾)。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">自然</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/nature/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/nature/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>☀️ <code>:sunny:</code></li>
<li>☔️ <code>:umbrella:</code></li>
<li>☁️ <code>:cloud:</code></li>
<li>❄️ <code>:snowflake:</code></li>
<li>⛄️ <code>:snowman:</code></li>
<li>⚡️ <code>:zap:</code></li>
<li>🌀 <code>:cyclone:</code></li>
<li>🌁 <code>:foggy:</code></li>
<li>🌊 <code>:ocean:</code></li>
<li>🐱 <code>:cat:</code></li>
<li>🐶 <code>:dog:</code></li>
<li>🐭 <code>:mouse:</code></li>
<li>🐹 <code>:hamster:</code></li>
<li>🐰 <code>:rabbit:</code></li>
<li>🐺 <code>:wolf:</code></li>
<li>🐸 <code>:frog:</code></li>
<li>🐯 <code>:tiger:</code></li>
<li>🐨 <code>:koala:</code></li>
<li>🐻 <code>:bear:</code></li>
<li>🐷 <code>:pig:</code></li>
<li>🐽 <code>:pig_nose:</code></li>
<li>🐮 <code>:cow:</code></li>
<li>🐗 <code>:boar:</code></li>
<li>🐵 <code>:monkey_face:</code></li>
<li>🐒 <code>:monkey:</code></li>
<li>🐴 <code>:horse:</code></li>
<li>🐎 <code>:racehorse:</code></li>
<li>🐫 <code>:camel:</code></li>
<li>🐑 <code>:sheep:</code></li>
<li>🐘 <code>:elephant:</code></li>
<li>🐼 <code>:panda_face:</code></li>
<li>🐍 <code>:snake:</code></li>
<li>🐦 <code>:bird:</code></li>
<li>🐤 <code>:baby_chick:</code></li>
<li>🐥 <code>:hatched_chick:</code></li>
<li>🐣 <code>:hatching_chick:</code></li>
<li>🐔 <code>:chicken:</code></li>
<li>🐧 <code>:penguin:</code></li>
<li>🐢 <code>:turtle:</code></li>
<li>🐛 <code>:bug:</code></li>
<li>🐝 <code>:honeybee:</code></li>
<li>🐜 <code>:ant:</code></li>
<li>🐞 <code>:beetle:</code></li>
<li>🐌 <code>:snail:</code></li>
<li>🐙 <code>:octopus:</code></li>
<li>🐠 <code>:tropical_fish:</code></li>
<li>🐟 <code>:fish:</code></li>
<li>🐳 <code>:whale:</code></li>
<li>🐋 <code>:whale2:</code></li>
<li>🐬 <code>:dolphin:</code></li>
<li>🐄 <code>:cow2:</code></li>
<li>🐏 <code>:ram:</code></li>
<li>🐀 <code>:rat:</code></li>
<li>🐃 <code>:water_buffalo:</code></li>
<li>🐅 <code>:tiger2:</code></li>
<li>🐇 <code>:rabbit2:</code></li>
<li>🐉 <code>:dragon:</code></li>
<li>🐐 <code>:goat:</code></li>
<li>🐓 <code>:rooster:</code></li>
<li>🐕 <code>:dog2:</code></li>
<li>🐖 <code>:pig2:</code></li>
<li>🐁 <code>:mouse2:</code></li>
<li>🐂 <code>:ox:</code></li>
<li>🐲 <code>:dragon_face:</code></li>
<li>🐡 <code>:blowfish:</code></li>
<li>🐊 <code>:crocodile:</code></li>
<li>🐪 <code>:dromedary_camel:</code></li>
<li>🐆 <code>:leopard:</code></li>
<li>🐈 <code>:cat2:</code></li>
<li>🐩 <code>:poodle:</code></li>
<li>🐾 <code>:paw_prints:</code></li>
<li>💐 <code>:bouquet:</code></li>
<li>🌸 <code>:cherry_blossom:</code></li>
<li>🌷 <code>:tulip:</code></li>
<li>🍀 <code>:four_leaf_clover:</code></li>
<li>🌹 <code>:rose:</code></li>
<li>🌻 <code>:sunflower:</code></li>
<li>🌺 <code>:hibiscus:</code></li>
<li>🍁 <code>:maple_leaf:</code></li>
<li>🍃 <code>:leaves:</code></li>
<li>🍂 <code>:fallen_leaf:</code></li>
<li>🌿 <code>:herb:</code></li>
<li>🍄 <code>:mushroom:</code></li>
<li>🌵 <code>:cactus:</code></li>
<li>🌴 <code>:palm_tree:</code></li>
<li>🌲 <code>:evergreen_tree:</code></li>
<li>🌳 <code>:deciduous_tree:</code></li>
<li>🌰 <code>:chestnut:</code></li>
<li>🌱 <code>:seedling:</code></li>
<li>🌼 <code>:blossom:</code></li>
<li>🌾 <code>:ear_of_rice:</code></li>
<li>🐚 <code>:shell:</code></li>
<li>🌐 <code>:globe_with_meridians:</code></li>
<li>🌞 <code>:sun_with_face:</code></li>
<li>🌝 <code>:full_moon_with_face:</code></li>
<li>🌚 <code>:new_moon_with_face:</code></li>
<li>🌑 <code>:new_moon:</code></li>
<li>🌒 <code>:waxing_crescent_moon:</code></li>
<li>🌓 <code>:first_quarter_moon:</code></li>
<li>🌔 <code>:waxing_gibbous_moon:</code></li>
<li>🌕 <code>:full_moon:</code></li>
<li>🌖 <code>:waning_gibbous_moon:</code></li>
<li>🌗 <code>:last_quarter_moon:</code></li>
<li>🌘 <code>:waning_crescent_moon:</code></li>
<li>🌜 <code>:last_quarter_moon_with_face:</code></li>
<li>🌛 <code>:first_quarter_moon_with_face:</code></li>
<li>🌙 <code>:crescent_moon:</code></li>
<li>🌍 <code>:earth_africa:</code></li>
<li>🌎 <code>:earth_americas:</code></li>
<li>🌏 <code>:earth_asia:</code></li>
<li>🌋 <code>:volcano:</code></li>
<li>🌌 <code>:milky_way:</code></li>
<li>⛅️ <code>:partly_sunny:</code></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Markdown示例</title>
    <id>https://list-jiang.github.io/code/language/markdown/demo/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/demo/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[
<h1 id="一级标题"> 一级标题</h1>

<div><pre><code><span><span>#</span> 一级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="二级标题"> 二级标题</h2>
<div><pre><code><span><span>##</span> 二级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="三级标题"> 三级标题</h3>
<div><pre><code><span><span>###</span> 三级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="四级标题"> 四级标题</h4>
<div><pre><code><span><span>####</span> 四级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h5 id="五级标题"> 五级标题</h5>
<div><pre><code><span><span>#####</span> 五级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h6 id="六级标题"> 六级标题</h6>
<div><pre><code><span><span>######</span> 六级标题</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="text"> Text</h2>
<p>这句话里拥有<strong>加粗</strong>、<em>倾斜</em>和<s>删除</s></p>
<div><pre><code>这句话里拥有<span><span>**</span><span>加粗</span><span>**</span></span>、<span><span>*</span><span>倾斜</span><span>*</span></span>和<span><span>~~</span><span>删除</span><span>~~</span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="段落"> 段落</h2>
<p>这是一个段落。</p>
<p>这是另一个段落。</p>
<div><pre><code>这是一个段落

这是另一个段落。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="换行"> 换行</h2>
<p>这是一句话不过我要在这里<br>
换行</p>
<div><pre><code>这是一句话不过我要在这里  
换行
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>提示</p>
<p>上方的代码中 <code>这里</code> 后面有两个空格</p>
</div>
<h2 id="引用"> 引用</h2>
<blockquote>
<p>引用也可以连用</p>
<blockquote>
<p>可以添加额外的大于号制造更深的引用</p>
</blockquote>
</blockquote>
<div><pre><code><span>></span> 引用也可以连用
<span>></span>
<span>> ></span> 可以添加额外的大于号制造更深的引用
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="列表"> 列表</h2>
<h3 id="无序列表"> 无序列表</h3>
<ul>
<li>
<p>无序列表项</p>
</li>
<li>
<p>无序列表项</p>
<ul>
<li>
<p>列表中的列表项</p>
<ul>
<li>更多的列表项</li>
<li>更多的列表项</li>
<li>更多的列表项</li>
</ul>
</li>
<li>
<p>列表中的长列表项，这个列表项很长。</p>
<p>而且由很多个段落构成。</p>
<p>甚至最后一个段落还包含了。</p>
</li>
</ul>
</li>
<li>
<p>无序列表项</p>
</li>
</ul>
<div><pre><code><span>-</span> 无序列表项
<span>-</span> 无序列表项

  <span>-</span> 列表中的列表项
    <span>-</span> 更多的列表项
    <span>-</span> 更多的列表项
    <span>-</span> 更多的列表项
  <span>-</span> 列表中的长列表项，这个列表项很长。

<span>    而且由很多个段落构成。</span>

<span>    甚至最后一个段落还包含了[链接](#链接)。</span>

<span>-</span> 无序列表项
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="有序列表"> 有序列表</h3>
<ol>
<li>有序列表第一项</li>
<li>有序列表第二项<br>
第二项的需要换行<br>
再次换行</li>
<li>有序列表第三项</li>
</ol>
<div><pre><code><span>1.</span> 有序列表第一项
<span>1.</span> 有序列表第二项  
   第二项的需要换行  
   再次换行
<span>1.</span> 有序列表第三项
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>
<p>上方的代码中<code>换行</code>后面有也两个空格</p>
</div>
<h2 id="分割线"> 分割线</h2>
<hr>
<div><pre><code><span>---</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="链接"> 链接</h2>
<p><a href="/">根目录访问主页</a></p>
<p><a href="./../../">相对路径主页</a></p>
<p><a href="/about">根目录访问关于</a></p>
<p><a href="./../../about.html">相对路径关于</a></p>
<div><pre><code><span>[<span>根目录访问主页</span>](<span>/</span>)</span>

<span>[<span>相对路径主页</span>](<span>../../readme.md</span>)</span>

<span>[<span>根目录访问关于</span>](<span>/about</span>)</span>

<span>[<span>相对路径关于</span>](<span>../../about.md</span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>提示</p>
<p>VuePress 还兼容如下跳转到主页的写法:</p>
<ul>
<li>
<p><a href="./../">相对路径访问，兼容 Markdown 编写时相互跳转</a></p>
</li>
<li>
<p><a href="/">根目录访问主页 2</a></p>
</li>
<li>
<p><a href="./../index.html">HTML 形式</a></p>
</li>
</ul>
<p>如果希望在使用编辑器编辑 Markdown 时也能够进行相互跳转的话，则需要全部使用<strong>相对路径</strong>，并且<code>readme.md</code><strong>不能省略</strong>。</p>
<p>代码:</p>
<div><pre><code><span>[<span>根目录访问主页 2</span>](<span>/readme.md</span>)</span>

<span>[<span>相对路径访问，兼容 markdown 编写时相互跳转</span>](<span>../readme.md</span>)</span>

<span>[<span>HTML 形式</span>](<span>../index.html</span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<h2 id="图片"> 图片</h2>
<p><img src="/logo.png" alt="Logo" loading="lazy"></p>
<div><pre><code><span><span>!</span>[<span>Logo</span>](<span>/logo.png</span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="emoji"> Emoji</h2>
<p>经典方式:</p>
<p>😉 😢 😆 😋</p>
<div><pre><code>:wink: :cry: :laughing: :yum:
</code></pre>
<div><span>1</span><br></div></div><p>简写:</p>
<p>😎 😃 😗 😦 😃 😦 😉</p>
<div><pre><code>8-) :) :\* :( :-) :-( ;)
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>更多详见<a href="./emoji.html">emoji 列表</a></p>
</div>
<h2 id="表格"> 表格</h2>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">aaaaaaaaa</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
<div><pre><code><span><span><span>|</span><span>     居中      </span><span>|</span><span>         右对齐 </span><span>|</span><span> 左对齐         </span><span>|</span>
</span><span><span>|</span> <span>:-----------:</span> <span>|</span> <span>-------------:</span> <span>|</span> <span>:-------------</span> <span>|</span>
</span><span><span>|</span><span> 居中使用<span>`:-:`</span> </span><span>|</span><span> 右对齐使用<span>`-:`</span> </span><span>|</span><span> 左对齐使用<span>`:-`</span> </span><span>|</span>
<span>|</span><span>       b       </span><span>|</span><span>      aaaaaaaaa </span><span>|</span><span> aaaa           </span><span>|</span>
<span>|</span><span>       c       </span><span>|</span><span>           aaaa </span><span>|</span><span> a              </span><span>|</span>
</span></span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="代码"> 代码</h2>
<p>行内代码效果: <code>code</code></p>
<div><pre><code>行内代码效果: <span>`code`</span>
</code></pre>
<div><span>1</span><br></div></div><p>缩进代码:</p>
<div><pre><code>// Some comments
line 1 of code
line 2 of code
line 3 of code
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>实际代码:</p>
<div><pre><code>    // Some comments
    line 1 of code
    line 2 of code
    line 3 of code
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>块级代码</p>
<div><pre><code>Sample text here...
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>块级代码

<span><span>```</span>
<span>Sample text here...</span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>高亮格式:</p>
<div><pre><code><span>var</span> <span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>bar</span><span>)</span> <span>{</span>
  <span>return</span> bar<span>++</span><span>;</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>高亮格式:

<span><span>```</span><span>js</span>
<span><span>var</span> <span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>bar</span><span>)</span> <span>{</span>
  <span>return</span> bar<span>++</span><span>;</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span></span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">对象</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/object/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/object/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>🎍 <code>:bamboo:</code></li>
<li>💝 <code>:gift_heart:</code></li>
<li>🎎 <code>:dolls:</code></li>
<li>🎒 <code>:school_satchel:</code></li>
<li>🎓 <code>:mortar_board:</code></li>
<li>🎏 <code>:flags:</code></li>
<li>🎆 <code>:fireworks:</code></li>
<li>🎇 <code>:sparkler:</code></li>
<li>🎐 <code>:wind_chime:</code></li>
<li>🎑 <code>:rice_scene:</code></li>
<li>🎃 <code>:jack_o_lantern:</code></li>
<li>👻 <code>:ghost:</code></li>
<li>🎅 <code>:santa:</code></li>
<li>🎄 <code>:christmas_tree:</code></li>
<li>🎁 <code>:gift:</code></li>
<li>🔔 <code>:bell:</code></li>
<li>🔕 <code>:no_bell:</code></li>
<li>🎋 <code>:tanabata_tree:</code></li>
<li>🎉 <code>:tada:</code></li>
<li>🎊 <code>:confetti_ball:</code></li>
<li>🎈 <code>:balloon:</code></li>
<li>🔮 <code>:crystal_ball:</code></li>
<li>💿 <code>:cd:</code></li>
<li>📀 <code>:dvd:</code></li>
<li>💾 <code>:floppy_disk:</code></li>
<li>📷 <code>:camera:</code></li>
<li>📹 <code>:video_camera:</code></li>
<li>🎥 <code>:movie_camera:</code></li>
<li>💻 <code>:computer:</code></li>
<li>📺 <code>:tv:</code></li>
<li>📱 <code>:iphone:</code></li>
<li>☎️ <code>:phone:</code></li>
<li>☎️ <code>:telephone:</code></li>
<li>📞 <code>:telephone_receiver:</code></li>
<li>📟 <code>:pager:</code></li>
<li>📠 <code>:fax:</code></li>
<li>💽 <code>:minidisc:</code></li>
<li>📼 <code>:vhs:</code></li>
<li>🔉 <code>:sound:</code></li>
<li>🔈 <code>:speaker:</code></li>
<li>🔇 <code>:mute:</code></li>
<li>📢 <code>:loudspeaker:</code></li>
<li>📣 <code>:mega:</code></li>
<li>⌛️ <code>:hourglass:</code></li>
<li>⏳ <code>:hourglass_flowing_sand:</code></li>
<li>⏰ <code>:alarm_clock:</code></li>
<li>⌚️ <code>:watch:</code></li>
<li>📻 <code>:radio:</code></li>
<li>📡 <code>:satellite:</code></li>
<li>➿ <code>:loop:</code></li>
<li>🔍 <code>:mag:</code></li>
<li>🔎 <code>:mag_right:</code></li>
<li>🔓 <code>:unlock:</code></li>
<li>🔒 <code>:lock:</code></li>
<li>🔏 <code>:lock_with_ink_pen:</code></li>
<li>🔐 <code>:closed_lock_with_key:</code></li>
<li>🔑 <code>:key:</code></li>
<li>💡 <code>:bulb:</code></li>
<li>🔦 <code>:flashlight:</code></li>
<li>🔆 <code>:high_brightness:</code></li>
<li>🔅 <code>:low_brightness:</code></li>
<li>🔌 <code>:electric_plug:</code></li>
<li>🔋 <code>:battery:</code></li>
<li>📲 <code>:calling:</code></li>
<li>✉️ <code>:email:</code></li>
<li>📫 <code>:mailbox:</code></li>
<li>📮 <code>:postbox:</code></li>
<li>🛀 <code>:bath:</code></li>
<li>🛁 <code>:bathtub:</code></li>
<li>🚿 <code>:shower:</code></li>
<li>🚽 <code>:toilet:</code></li>
<li>🔧 <code>:wrench:</code></li>
<li>🔩 <code>:nut_and_bolt:</code></li>
<li>🔨 <code>:hammer:</code></li>
<li>💺 <code>:seat:</code></li>
<li>💰 <code>:moneybag:</code></li>
<li>💴 <code>:yen:</code></li>
<li>💵 <code>:dollar:</code></li>
<li>💷 <code>:pound:</code></li>
<li>💶 <code>:euro:</code></li>
<li>💳 <code>:credit_card:</code></li>
<li>💸 <code>:money_with_wings:</code></li>
<li>📧 <code>:e-mail:</code></li>
<li>📥 <code>:inbox_tray:</code></li>
<li>📤 <code>:outbox_tray:</code></li>
<li>✉️ <code>:envelope:</code></li>
<li>📨 <code>:incoming_envelope:</code></li>
<li>📯 <code>:postal_horn:</code></li>
<li>📪 <code>:mailbox_closed:</code></li>
<li>📬 <code>:mailbox_with_mail:</code></li>
<li>📭 <code>:mailbox_with_no_mail:</code></li>
<li>📦 <code>:package:</code></li>
<li>🚪 <code>:door:</code></li>
<li>🚬 <code>:smoking:</code></li>
<li>💣 <code>:bomb:</code></li>
<li>🔫 <code>:gun:</code></li>
<li>🔪 <code>:hocho:</code></li>
<li>💊 <code>:pill:</code></li>
<li>💉 <code>:syringe:</code></li>
<li>📄 <code>:page_facing_up:</code></li>
<li>📃 <code>:page_with_curl:</code></li>
<li>📑 <code>:bookmark_tabs:</code></li>
<li>📊 <code>:bar_chart:</code></li>
<li>📈 <code>:chart_with_upwards_trend:</code></li>
<li>📉 <code>:chart_with_downwards_trend:</code></li>
<li>📜 <code>:scroll:</code></li>
<li>📋 <code>:clipboard:</code></li>
<li>📆 <code>:calendar:</code></li>
<li>📅 <code>:date:</code></li>
<li>📇 <code>:card_index:</code></li>
<li>📁 <code>:file_folder:</code></li>
<li>📂 <code>:open_file_folder:</code></li>
<li>✂️ <code>:scissors:</code></li>
<li>📌 <code>:pushpin:</code></li>
<li>📎 <code>:paperclip:</code></li>
<li>✒️ <code>:black_nib:</code></li>
<li>✏️ <code>:pencil2:</code></li>
<li>📏 <code>:straight_ruler:</code></li>
<li>📐 <code>:triangular_ruler:</code></li>
<li>📕 <code>:closed_book:</code></li>
<li>📗 <code>:green_book:</code></li>
<li>📘 <code>:blue_book:</code></li>
<li>📙 <code>:orange_book:</code></li>
<li>📓 <code>:notebook:</code></li>
<li>📔 <code>:notebook_with_decorative_cover:</code></li>
<li>📒 <code>:ledger:</code></li>
<li>📚 <code>:books:</code></li>
<li>🔖 <code>:bookmark:</code></li>
<li>📛 <code>:name_badge:</code></li>
<li>🔬 <code>:microscope:</code></li>
<li>🔭 <code>:telescope:</code></li>
<li>📰 <code>:newspaper:</code></li>
<li>🏈 <code>:football:</code></li>
<li>🏀 <code>:basketball:</code></li>
<li>⚽️ <code>:soccer:</code></li>
<li>⚾️ <code>:baseball:</code></li>
<li>🎾 <code>:tennis:</code></li>
<li>🎱 <code>:8ball:</code></li>
<li>🏉 <code>:rugby_football:</code></li>
<li>🎳 <code>:bowling:</code></li>
<li>⛳️ <code>:golf:</code></li>
<li>🚵 <code>:mountain_bicyclist:</code></li>
<li>🚴 <code>:bicyclist:</code></li>
<li>🏇 <code>:horse_racing:</code></li>
<li>🏂 <code>:snowboarder:</code></li>
<li>🏊 <code>:swimmer:</code></li>
<li>🏄 <code>:surfer:</code></li>
<li>🎿 <code>:ski:</code></li>
<li>♠️ <code>:spades:</code></li>
<li>♥️ <code>:hearts:</code></li>
<li>♣️ <code>:clubs:</code></li>
<li>♦️ <code>:diamonds:</code></li>
<li>💎 <code>:gem:</code></li>
<li>💍 <code>:ring:</code></li>
<li>🏆 <code>:trophy:</code></li>
<li>🎼 <code>:musical_score:</code></li>
<li>🎹 <code>:musical_keyboard:</code></li>
<li>🎻 <code>:violin:</code></li>
<li>👾 <code>:space_invader:</code></li>
<li>🎮 <code>:video_game:</code></li>
<li>🃏 <code>:black_joker:</code></li>
<li>🎴 <code>:flower_playing_cards:</code></li>
<li>🎲 <code>:game_die:</code></li>
<li>🎯 <code>:dart:</code></li>
<li>🀄️ <code>:mahjong:</code></li>
<li>🎬 <code>:clapper:</code></li>
<li>📝 <code>:memo:</code></li>
<li>📝 <code>:pencil:</code></li>
<li>📖 <code>:book:</code></li>
<li>🎨 <code>:art:</code></li>
<li>🎤 <code>:microphone:</code></li>
<li>🎧 <code>:headphones:</code></li>
<li>🎺 <code>:trumpet:</code></li>
<li>🎷 <code>:saxophone:</code></li>
<li>🎸 <code>:guitar:</code></li>
<li>👞 <code>:shoe:</code></li>
<li>👡 <code>:sandal:</code></li>
<li>👠 <code>:high_heel:</code></li>
<li>💄 <code>:lipstick:</code></li>
<li>👢 <code>:boot:</code></li>
<li>👕 <code>:shirt:</code></li>
<li>👕 <code>:tshirt:</code></li>
<li>👔 <code>:necktie:</code></li>
<li>👚 <code>:womans_clothes:</code></li>
<li>👗 <code>:dress:</code></li>
<li>🎽 <code>:running_shirt_with_sash:</code></li>
<li>👖 <code>:jeans:</code></li>
<li>👘 <code>:kimono:</code></li>
<li>👙 <code>:bikini:</code></li>
<li>🎀 <code>:ribbon:</code></li>
<li>🎩 <code>:tophat:</code></li>
<li>👑 <code>:crown:</code></li>
<li>👒 <code>:womans_hat:</code></li>
<li>👞 <code>:mans_shoe:</code></li>
<li>🌂 <code>:closed_umbrella:</code></li>
<li>💼 <code>:briefcase:</code></li>
<li>👜 <code>:handbag:</code></li>
<li>👝 <code>:pouch:</code></li>
<li>👛 <code>:purse:</code></li>
<li>👓 <code>:eyeglasses:</code></li>
<li>🎣 <code>:fishing_pole_and_fish:</code></li>
<li>☕️ <code>:coffee:</code></li>
<li>🍵 <code>:tea:</code></li>
<li>🍶 <code>:sake:</code></li>
<li>🍼 <code>:baby_bottle:</code></li>
<li>🍺 <code>:beer:</code></li>
<li>🍻 <code>:beers:</code></li>
<li>🍸 <code>:cocktail:</code></li>
<li>🍹 <code>:tropical_drink:</code></li>
<li>🍷 <code>:wine_glass:</code></li>
<li>🍴 <code>:fork_and_knife:</code></li>
<li>🍕 <code>:pizza:</code></li>
<li>🍔 <code>:hamburger:</code></li>
<li>🍟 <code>:fries:</code></li>
<li>🍗 <code>:poultry_leg:</code></li>
<li>🍖 <code>:meat_on_bone:</code></li>
<li>🍝 <code>:spaghetti:</code></li>
<li>🍛 <code>:curry:</code></li>
<li>🍤 <code>:fried_shrimp:</code></li>
<li>🍱 <code>:bento:</code></li>
<li>🍣 <code>:sushi:</code></li>
<li>🍥 <code>:fish_cake:</code></li>
<li>🍙 <code>:rice_ball:</code></li>
<li>🍘 <code>:rice_cracker:</code></li>
<li>🍚 <code>:rice:</code></li>
<li>🍜 <code>:ramen:</code></li>
<li>🍲 <code>:stew:</code></li>
<li>🍢 <code>:oden:</code></li>
<li>🍡 <code>:dango:</code></li>
<li>🥚 <code>:egg:</code></li>
<li>🍞 <code>:bread:</code></li>
<li>🍩 <code>:doughnut:</code></li>
<li>🍮 <code>:custard:</code></li>
<li>🍦 <code>:icecream:</code></li>
<li>🍨 <code>:ice_cream:</code></li>
<li>🍧 <code>:shaved_ice:</code></li>
<li>🎂 <code>:birthday:</code></li>
<li>🍰 <code>:cake:</code></li>
<li>🍪 <code>:cookie:</code></li>
<li>🍫 <code>:chocolate_bar:</code></li>
<li>🍬 <code>:candy:</code></li>
<li>🍭 <code>:lollipop:</code></li>
<li>🍯 <code>:honey_pot:</code></li>
<li>🍎 <code>:apple:</code></li>
<li>🍏 <code>:green_apple:</code></li>
<li>🍊 <code>:tangerine:</code></li>
<li>🍋 <code>:lemon:</code></li>
<li>🍒 <code>:cherries:</code></li>
<li>🍇 <code>:grapes:</code></li>
<li>🍉 <code>:watermelon:</code></li>
<li>🍓 <code>:strawberry:</code></li>
<li>🍑 <code>:peach:</code></li>
<li>🍈 <code>:melon:</code></li>
<li>🍌 <code>:banana:</code></li>
<li>🍐 <code>:pear:</code></li>
<li>🍍 <code>:pineapple:</code></li>
<li>🍠 <code>:sweet_potato:</code></li>
<li>🍆 <code>:eggplant:</code></li>
<li>🍅 <code>:tomato:</code></li>
<li>🌽 <code>:corn:</code></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">人物</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/people/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/people/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>😄 <code>:smile:</code></li>
<li>😆 <code>:laughing:</code></li>
<li>😊 <code>:blush:</code></li>
<li>😃 <code>:smiley:</code></li>
<li>😏 <code>:smirk:</code></li>
<li>😍 <code>:heart_eyes:</code></li>
<li>😘 <code>:kissing_heart:</code></li>
<li>😚 <code>:kissing_closed_eyes:</code></li>
<li>😳 <code>:flushed:</code></li>
<li>😌 <code>:relieved:</code></li>
<li>😆 <code>:satisfied:</code></li>
<li>😁 <code>:grin:</code></li>
<li>😉 <code>:wink:</code></li>
<li>😜 <code>:stuck_out_tongue_winking_eye:</code></li>
<li>😝 <code>:stuck_out_tongue_closed_eyes:</code></li>
<li>😀 <code>:grinning:</code></li>
<li>😗 <code>:kissing:</code></li>
<li>😙 <code>:kissing_smiling_eyes:</code></li>
<li>😛 <code>:stuck_out_tongue:</code></li>
<li>😴 <code>:sleeping:</code></li>
<li>😟 <code>:worried:</code></li>
<li>😦 <code>:frowning:</code></li>
<li>😧 <code>:anguished:</code></li>
<li>😮 <code>:open_mouth:</code></li>
<li>😬 <code>:grimacing:</code></li>
<li>😕 <code>:confused:</code></li>
<li>😯 <code>:hushed:</code></li>
<li>😑 <code>:expressionless:</code></li>
<li>😒 <code>:unamused:</code></li>
<li>😅 <code>:sweat_smile:</code></li>
<li>😓 <code>:sweat:</code></li>
<li>😥 <code>:disappointed_relieved:</code></li>
<li>😩 <code>:weary:</code></li>
<li>😔 <code>:pensive:</code></li>
<li>😞 <code>:disappointed:</code></li>
<li>😖 <code>:confounded:</code></li>
<li>😨 <code>:fearful:</code></li>
<li>😰 <code>:cold_sweat:</code></li>
<li>😣 <code>:persevere:</code></li>
<li>😢 <code>:cry:</code></li>
<li>😭 <code>:sob:</code></li>
<li>😂 <code>:joy:</code></li>
<li>😲 <code>:astonished:</code></li>
<li>😱 <code>:scream:</code></li>
<li>😫 <code>:tired_face:</code></li>
<li>😠 <code>:angry:</code></li>
<li>😡 <code>:rage:</code></li>
<li>😤 <code>:triumph:</code></li>
<li>😪 <code>:sleepy:</code></li>
<li>😋 <code>:yum:</code></li>
<li>😷 <code>:mask:</code></li>
<li>😎 <code>:sunglasses:</code></li>
<li>😵 <code>:dizzy_face:</code></li>
<li>👿 <code>:imp:</code></li>
<li>😈 <code>:smiling_imp:</code></li>
<li>😐 <code>:neutral_face:</code></li>
<li>😶 <code>:no_mouth:</code></li>
<li>😇 <code>:innocent:</code></li>
<li>👽 <code>:alien:</code></li>
<li>💛 <code>:yellow_heart:</code></li>
<li>💙 <code>:blue_heart:</code></li>
<li>💜 <code>:purple_heart:</code></li>
<li>❤️ <code>:heart:</code></li>
<li>💚 <code>:green_heart:</code></li>
<li>💔 <code>:broken_heart:</code></li>
<li>💓 <code>:heartbeat:</code></li>
<li>💗 <code>:heartpulse:</code></li>
<li>💕 <code>:two_hearts:</code></li>
<li>💞 <code>:revolving_hearts:</code></li>
<li>💘 <code>:cupid:</code></li>
<li>💖 <code>:sparkling_heart:</code></li>
<li>✨ <code>:sparkles:</code></li>
<li>⭐️ <code>:star:</code></li>
<li>🌟 <code>:star2:</code></li>
<li>💫 <code>:dizzy:</code></li>
<li>💥 <code>:boom:</code></li>
<li>💥 <code>:collision:</code></li>
<li>💢 <code>:anger:</code></li>
<li>❗️ <code>:exclamation:</code></li>
<li>❓ <code>:question:</code></li>
<li>❕ <code>:grey_exclamation:</code></li>
<li>❔ <code>:grey_question:</code></li>
<li>💤 <code>:zzz:</code></li>
<li>💨 <code>:dash:</code></li>
<li>💦 <code>:sweat_drops:</code></li>
<li>🎶 <code>:notes:</code></li>
<li>🎵 <code>:musical_note:</code></li>
<li>🔥 <code>:fire:</code></li>
<li>💩 <code>:hankey:</code></li>
<li>💩 <code>:poop:</code></li>
<li>💩 <code>:shit:</code></li>
<li>👍 <code>:+1:</code></li>
<li>👍 <code>:thumbsup:</code></li>
<li>👎 <code>:-1:</code></li>
<li>👎 <code>:thumbsdown:</code></li>
<li>👌 <code>:ok_hand:</code></li>
<li>👊 <code>:punch:</code></li>
<li>👊 <code>:facepunch:</code></li>
<li>✊ <code>:fist:</code></li>
<li>✌️ <code>:v:</code></li>
<li>👋 <code>:wave:</code></li>
<li>✋ <code>:hand:</code></li>
<li>✋ <code>:raised_hand:</code></li>
<li>👐 <code>:open_hands:</code></li>
<li>☝️ <code>:point_up:</code></li>
<li>👇 <code>:point_down:</code></li>
<li>👈 <code>:point_left:</code></li>
<li>👉 <code>:point_right:</code></li>
<li>🙌 <code>:raised_hands:</code></li>
<li>🙏 <code>:pray:</code></li>
<li>👆 <code>:point_up_2:</code></li>
<li>👏 <code>:clap:</code></li>
<li>💪 <code>:muscle:</code></li>
<li>🤘 <code>:metal:</code></li>
<li>🖕 <code>:fu:</code></li>
<li>🏃 <code>:runner:</code></li>
<li>🏃 <code>:running:</code></li>
<li>👫 <code>:couple:</code></li>
<li>👪 <code>:family:</code></li>
<li>👬 <code>:two_men_holding_hands:</code></li>
<li>👭 <code>:two_women_holding_hands:</code></li>
<li>💃 <code>:dancer:</code></li>
<li>👯 <code>:dancers:</code></li>
<li>🙆 <code>:ok_woman:</code></li>
<li>🙅 <code>:no_good:</code></li>
<li>💁 <code>:information_desk_person:</code></li>
<li>🙋 <code>:raising_hand:</code></li>
<li>👰 <code>:bride_with_veil:</code></li>
<li>🙎 <code>:person_with_pouting_face:</code></li>
<li>🙍 <code>:person_frowning:</code></li>
<li>🙇 <code>:bow:</code></li>
<li>💑 <code>:couple_with_heart:</code></li>
<li>💆 <code>:massage:</code></li>
<li>💇 <code>:haircut:</code></li>
<li>💅 <code>:nail_care:</code></li>
<li>👦 <code>:boy:</code></li>
<li>👧 <code>:girl:</code></li>
<li>👩 <code>:woman:</code></li>
<li>👨 <code>:man:</code></li>
<li>👶 <code>:baby:</code></li>
<li>👵 <code>:older_woman:</code></li>
<li>👴 <code>:older_man:</code></li>
<li>👱 <code>:person_with_blond_hair:</code></li>
<li>👲 <code>:man_with_gua_pi_mao:</code></li>
<li>👳 <code>:man_with_turban:</code></li>
<li>👷 <code>:construction_worker:</code></li>
<li>👮 <code>:cop:</code></li>
<li>👼 <code>:angel:</code></li>
<li>👸 <code>:princess:</code></li>
<li>😺 <code>:smiley_cat:</code></li>
<li>😸 <code>:smile_cat:</code></li>
<li>😻 <code>:heart_eyes_cat:</code></li>
<li>😽 <code>:kissing_cat:</code></li>
<li>😼 <code>:smirk_cat:</code></li>
<li>🙀 <code>:scream_cat:</code></li>
<li>😿 <code>:crying_cat_face:</code></li>
<li>😹 <code>:joy_cat:</code></li>
<li>😾 <code>:pouting_cat:</code></li>
<li>👹 <code>:japanese_ogre:</code></li>
<li>👺 <code>:japanese_goblin:</code></li>
<li>🙈 <code>:see_no_evil:</code></li>
<li>🙉 <code>:hear_no_evil:</code></li>
<li>🙊 <code>:speak_no_evil:</code></li>
<li>💂 <code>:guardsman:</code></li>
<li>💀 <code>:skull:</code></li>
<li>🐾 <code>:feet:</code></li>
<li>👄 <code>:lips:</code></li>
<li>💋 <code>:kiss:</code></li>
<li>💧 <code>:droplet:</code></li>
<li>👂 <code>:ear:</code></li>
<li>👀 <code>:eyes:</code></li>
<li>👃 <code>:nose:</code></li>
<li>👅 <code>:tongue:</code></li>
<li>💌 <code>:love_letter:</code></li>
<li>👤 <code>:bust_in_silhouette:</code></li>
<li>👥 <code>:busts_in_silhouette:</code></li>
<li>💬 <code>:speech_balloon:</code></li>
<li>💭 <code>:thought_balloon:</code></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">地点</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/place/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/place/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>🏠 <code>:house:</code></li>
<li>🏡 <code>:house_with_garden:</code></li>
<li>🏫 <code>:school:</code></li>
<li>🏢 <code>:office:</code></li>
<li>🏣 <code>:post_office:</code></li>
<li>🏥 <code>:hospital:</code></li>
<li>🏦 <code>:bank:</code></li>
<li>🏪 <code>:convenience_store:</code></li>
<li>🏩 <code>:love_hotel:</code></li>
<li>🏨 <code>:hotel:</code></li>
<li>💒 <code>:wedding:</code></li>
<li>⛪️ <code>:church:</code></li>
<li>🏬 <code>:department_store:</code></li>
<li>🏤 <code>:european_post_office:</code></li>
<li>🌇 <code>:city_sunrise:</code></li>
<li>🌆 <code>:city_sunset:</code></li>
<li>🏯 <code>:japanese_castle:</code></li>
<li>🏰 <code>:european_castle:</code></li>
<li>⛺️ <code>:tent:</code></li>
<li>🏭 <code>:factory:</code></li>
<li>🗼 <code>:tokyo_tower:</code></li>
<li>🗾 <code>:japan:</code></li>
<li>🗻 <code>:mount_fuji:</code></li>
<li>🌄 <code>:sunrise_over_mountains:</code></li>
<li>🌅 <code>:sunrise:</code></li>
<li>🌠 <code>:stars:</code></li>
<li>🗽 <code>:statue_of_liberty:</code></li>
<li>🌉 <code>:bridge_at_night:</code></li>
<li>🎠 <code>:carousel_horse:</code></li>
<li>🌈 <code>:rainbow:</code></li>
<li>🎡 <code>:ferris_wheel:</code></li>
<li>⛲️ <code>:fountain:</code></li>
<li>🎢 <code>:roller_coaster:</code></li>
<li>🚢 <code>:ship:</code></li>
<li>🚤 <code>:speedboat:</code></li>
<li>⛵️ <code>:boat:</code></li>
<li>⛵️ <code>:sailboat:</code></li>
<li>🚣 <code>:rowboat:</code></li>
<li>⚓️ <code>:anchor:</code></li>
<li>🚀 <code>:rocket:</code></li>
<li>✈️ <code>:airplane:</code></li>
<li>🚁 <code>:helicopter:</code></li>
<li>🚂 <code>:steam_locomotive:</code></li>
<li>🚊 <code>:tram:</code></li>
<li>🚞 <code>:mountain_railway:</code></li>
<li>🚲 <code>:bike:</code></li>
<li>🚡 <code>:aerial_tramway:</code></li>
<li>🚟 <code>:suspension_railway:</code></li>
<li>🚠 <code>:mountain_cableway:</code></li>
<li>🚜 <code>:tractor:</code></li>
<li>🚙 <code>:blue_car:</code></li>
<li>🚘 <code>:oncoming_automobile:</code></li>
<li>🚗 <code>:car:</code></li>
<li>🚗 <code>:red_car:</code></li>
<li>🚕 <code>:taxi:</code></li>
<li>🚖 <code>:oncoming_taxi:</code></li>
<li>🚛 <code>:articulated_lorry:</code></li>
<li>🚌 <code>:bus:</code></li>
<li>🚍 <code>:oncoming_bus:</code></li>
<li>🚨 <code>:rotating_light:</code></li>
<li>🚓 <code>:police_car:</code></li>
<li>🚔 <code>:oncoming_police_car:</code></li>
<li>🚒 <code>:fire_engine:</code></li>
<li>🚑 <code>:ambulance:</code></li>
<li>🚐 <code>:minibus:</code></li>
<li>🚚 <code>:truck:</code></li>
<li>🚋 <code>:train:</code></li>
<li>🚉 <code>:station:</code></li>
<li>🚆 <code>:train2:</code></li>
<li>🚅 <code>:bullettrain_front:</code></li>
<li>🚄 <code>:bullettrain_side:</code></li>
<li>🚈 <code>:light_rail:</code></li>
<li>🚝 <code>:monorail:</code></li>
<li>🚃 <code>:railway_car:</code></li>
<li>🚎 <code>:trolleybus:</code></li>
<li>🎫 <code>:ticket:</code></li>
<li>⛽️ <code>:fuelpump:</code></li>
<li>🚦 <code>:vertical_traffic_light:</code></li>
<li>🚥 <code>:traffic_light:</code></li>
<li>⚠️ <code>:warning:</code></li>
<li>🚧 <code>:construction:</code></li>
<li>🔰 <code>:beginner:</code></li>
<li>🏧 <code>:atm:</code></li>
<li>🎰 <code>:slot_machine:</code></li>
<li>🚏 <code>:busstop:</code></li>
<li>💈 <code>:barber:</code></li>
<li>♨️ <code>:hotsprings:</code></li>
<li>🏁 <code>:checkered_flag:</code></li>
<li>🎌 <code>:crossed_flags:</code></li>
<li>🏮 <code>:izakaya_lantern:</code></li>
<li>🗿 <code>:moyai:</code></li>
<li>🎪 <code>:circus_tent:</code></li>
<li>🎭 <code>:performing_arts:</code></li>
<li>📍 <code>:round_pushpin:</code></li>
<li>🚩 <code>:triangular_flag_on_post:</code></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Emoji 列表</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="人物"> 人物</h2>
<ul>
<li><a href="./people.html">点击前往</a></li>
</ul>
<h2 id="自然"> 自然</h2>
<ul>
<li><a href="./nature.html">点击前往</a></li>
</ul>
<h2 id="对象"> 对象</h2>
<ul>
<li><a href="./object.html">点击前往</a></li>
</ul>
<h2 id="地点"> 地点</h2>
<ul>
<li><a href="./place.html">点击前往</a></li>
</ul>
<h2 id="符号"> 符号</h2>
<ul>
<li><a href="./symbol.html">点击前往</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">符号</title>
    <id>https://list-jiang.github.io/code/language/markdown/emoji/symbol/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/emoji/symbol/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>1️⃣ <code>:one:</code></li>
<li>2️⃣ <code>:two:</code></li>
<li>3️⃣ <code>:three:</code></li>
<li>4️⃣ <code>:four:</code></li>
<li>5️⃣ <code>:five:</code></li>
<li>6️⃣ <code>:six:</code></li>
<li>7️⃣ <code>:seven:</code></li>
<li>8️⃣ <code>:eight:</code></li>
<li>9️⃣ <code>:nine:</code></li>
<li>🔟 <code>:keycap_ten:</code></li>
<li>🔢 <code>:1234:</code></li>
<li>0️⃣ <code>:zero:</code></li>
<li>#️⃣ <code>:hash:</code></li>
<li>🔣 <code>:symbols:</code></li>
<li>◀️ <code>:arrow_backward:</code></li>
<li>⬇️ <code>:arrow_down:</code></li>
<li>▶️ <code>:arrow_forward:</code></li>
<li>⬅️ <code>:arrow_left:</code></li>
<li>🔠 <code>:capital_abcd:</code></li>
<li>🔡 <code>:abcd:</code></li>
<li>🔤 <code>:abc:</code></li>
<li>↙️ <code>:arrow_lower_left:</code></li>
<li>↘️ <code>:arrow_lower_right:</code></li>
<li>➡️ <code>:arrow_right:</code></li>
<li>⬆️ <code>:arrow_up:</code></li>
<li>↖️ <code>:arrow_upper_left:</code></li>
<li>↗️ <code>:arrow_upper_right:</code></li>
<li>⏬ <code>:arrow_double_down:</code></li>
<li>⏫ <code>:arrow_double_up:</code></li>
<li>🔽 <code>:arrow_down_small:</code></li>
<li>⤵️ <code>:arrow_heading_down:</code></li>
<li>⤴️ <code>:arrow_heading_up:</code></li>
<li>↩️ <code>:leftwards_arrow_with_hook:</code></li>
<li>↪️ <code>:arrow_right_hook:</code></li>
<li>↔️ <code>:left_right_arrow:</code></li>
<li>↕️ <code>:arrow_up_down:</code></li>
<li>🔼 <code>:arrow_up_small:</code></li>
<li>🔃 <code>:arrows_clockwise:</code></li>
<li>🔄 <code>:arrows_counterclockwise:</code></li>
<li>⏪ <code>:rewind:</code></li>
<li>⏩ <code>:fast_forward:</code></li>
<li>ℹ️ <code>:information_source:</code></li>
<li>🆗 <code>:ok:</code></li>
<li>🔀 <code>:twisted_rightwards_arrows:</code></li>
<li>🔁 <code>:repeat:</code></li>
<li>🔂 <code>:repeat_one:</code></li>
<li>🆕 <code>:new:</code></li>
<li>🔝 <code>:top:</code></li>
<li>🆙 <code>:up:</code></li>
<li>🆒 <code>:cool:</code></li>
<li>🆓 <code>:free:</code></li>
<li>🆖 <code>:ng:</code></li>
<li>🎦 <code>:cinema:</code></li>
<li>🈁 <code>:koko:</code></li>
<li>📶 <code>:signal_strength:</code></li>
<li>🈂️ <code>:sa:</code></li>
<li>🚻 <code>:restroom:</code></li>
<li>🚹 <code>:mens:</code></li>
<li>🚺 <code>:womens:</code></li>
<li>🚼 <code>:baby_symbol:</code></li>
<li>🚭 <code>:no_smoking:</code></li>
<li>🅿️ <code>:parking:</code></li>
<li>♿️ <code>:wheelchair:</code></li>
<li>🚇 <code>:metro:</code></li>
<li>🛄 <code>:baggage_claim:</code></li>
<li>🉑 <code>:accept:</code></li>
<li>🚾 <code>:wc:</code></li>
<li>🚰 <code>:potable_water:</code></li>
<li>🚮 <code>:put_litter_in_its_place:</code></li>
<li>㊙️ <code>:secret:</code></li>
<li>㊗️ <code>:congratulations:</code></li>
<li>Ⓜ️ <code>:m:</code></li>
<li>🛂 <code>:passport_control:</code></li>
<li>🛅 <code>:left_luggage:</code></li>
<li>🛃 <code>:customs:</code></li>
<li>🉐 <code>:ideograph_advantage:</code></li>
<li>🆑 <code>:cl:</code></li>
<li>🆘 <code>:sos:</code></li>
<li>🆔 <code>:id:</code></li>
<li>🚫 <code>:no_entry_sign:</code></li>
<li>🔞 <code>:underage:</code></li>
<li>📵 <code>:no_mobile_phones:</code></li>
<li>🚯 <code>:do_not_litter:</code></li>
<li>🚱 <code>:non-potable_water:</code></li>
<li>🚳 <code>:no_bicycles:</code></li>
<li>🚷 <code>:no_pedestrians:</code></li>
<li>🚸 <code>:children_crossing:</code></li>
<li>⛔️ <code>:no_entry:</code></li>
<li>✳️ <code>:eight_spoked_asterisk:</code></li>
<li>❇️ <code>:sparkle:</code></li>
<li>✴️ <code>:eight_pointed_black_star:</code></li>
<li>💟 <code>:heart_decoration:</code></li>
<li>🆚 <code>:vs:</code></li>
<li>📳 <code>:vibration_mode:</code></li>
<li>📴 <code>:mobile_phone_off:</code></li>
<li>💹 <code>:chart:</code></li>
<li>💱 <code>:currency_exchange:</code></li>
<li>♈️ <code>:aries:</code></li>
<li>♉️ <code>:taurus:</code></li>
<li>♊️ <code>:gemini:</code></li>
<li>♋️ <code>:cancer:</code></li>
<li>♌️ <code>:leo:</code></li>
<li>♍️ <code>:virgo:</code></li>
<li>♎️ <code>:libra:</code></li>
<li>♏️ <code>:scorpius:</code></li>
<li>♐️ <code>:sagittarius:</code></li>
<li>♑️ <code>:capricorn:</code></li>
<li>♒️ <code>:aquarius:</code></li>
<li>♓️ <code>:pisces:</code></li>
<li>⛎ <code>:ophiuchus:</code></li>
<li>🔯 <code>:six_pointed_star:</code></li>
<li>❎ <code>:negative_squared_cross_mark:</code></li>
<li>🅰️ <code>:a:</code></li>
<li>🅱️ <code>:b:</code></li>
<li>🆎 <code>:ab:</code></li>
<li>🅾️ <code>:o2:</code></li>
<li>💠 <code>:diamond_shape_with_a_dot_inside:</code></li>
<li>♻️ <code>:recycle:</code></li>
<li>🔚 <code>:end:</code></li>
<li>🔙 <code>:back:</code></li>
<li>🔛 <code>:on:</code></li>
<li>🔜 <code>:soon:</code></li>
<li>🕐 <code>:clock1:</code></li>
<li>🕜 <code>:clock130:</code></li>
<li>🕙 <code>:clock10:</code></li>
<li>🕥 <code>:clock1030:</code></li>
<li>🕚 <code>:clock11:</code></li>
<li>🕦 <code>:clock1130:</code></li>
<li>🕛 <code>:clock12:</code></li>
<li>🕧 <code>:clock1230:</code></li>
<li>🕑 <code>:clock2:</code></li>
<li>🕝 <code>:clock230:</code></li>
<li>🕒 <code>:clock3:</code></li>
<li>🕞 <code>:clock330:</code></li>
<li>🕓 <code>:clock4:</code></li>
<li>🕟 <code>:clock430:</code></li>
<li>🕔 <code>:clock5:</code></li>
<li>🕠 <code>:clock530:</code></li>
<li>🕕 <code>:clock6:</code></li>
<li>🕡 <code>:clock630:</code></li>
<li>🕖 <code>:clock7:</code></li>
<li>🕢 <code>:clock730:</code></li>
<li>🕗 <code>:clock8:</code></li>
<li>🕣 <code>:clock830:</code></li>
<li>🕘 <code>:clock9:</code></li>
<li>🕤 <code>:clock930:</code></li>
<li>💲 <code>:heavy_dollar_sign:</code></li>
<li>©️ <code>:copyright:</code></li>
<li>®️ <code>:registered:</code></li>
<li>™️ <code>:tm:</code></li>
<li>❌ <code>:x:</code></li>
<li>❗️ <code>:heavy_exclamation_mark:</code></li>
<li>‼️ <code>:bangbang:</code></li>
<li>⁉️ <code>:interrobang:</code></li>
<li>⭕️ <code>:o:</code></li>
<li>✖️ <code>:heavy_multiplication_x:</code></li>
<li>➕ <code>:heavy_plus_sign:</code></li>
<li>➖ <code>:heavy_minus_sign:</code></li>
<li>➗ <code>:heavy_division_sign:</code></li>
<li>💮 <code>:white_flower:</code></li>
<li>💯 <code>:100:</code></li>
<li>✔️ <code>:heavy_check_mark:</code></li>
<li>☑️ <code>:ballot_box_with_check:</code></li>
<li>🔘 <code>:radio_button:</code></li>
<li>🔗 <code>:link:</code></li>
<li>➰ <code>:curly_loop:</code></li>
<li>〰️ <code>:wavy_dash:</code></li>
<li>〽️ <code>:part_alternation_mark:</code></li>
<li>🔱 <code>:trident:</code></li>
<li>▪️ <code>:black_small_square:</code></li>
<li>▫️ <code>:white_small_square:</code></li>
<li>◾️ <code>:black_medium_small_square:</code></li>
<li>◽️ <code>:white_medium_small_square:</code></li>
<li>◼️ <code>:black_medium_square:</code></li>
<li>◻️ <code>:white_medium_square:</code></li>
<li>⬛️ <code>:black_large_square:</code></li>
<li>⬜️ <code>:white_large_square:</code></li>
<li>✅ <code>:white_check_mark:</code></li>
<li>🔲 <code>:black_square_button:</code></li>
<li>🔳 <code>:white_square_button:</code></li>
<li>⚫️ <code>:black_circle:</code></li>
<li>⚪️ <code>:white_circle:</code></li>
<li>🔴 <code>:red_circle:</code></li>
<li>🔵 <code>:large_blue_circle:</code></li>
<li>🔷 <code>:large_blue_diamond:</code></li>
<li>🔶 <code>:large_orange_diamond:</code></li>
<li>🔹 <code>:small_blue_diamond:</code></li>
<li>🔸 <code>:small_orange_diamond:</code></li>
<li>🔺 <code>:small_red_triangle:</code></li>
<li>🔻 <code>:small_red_triangle_down:</code></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Markdown 扩展</title>
    <id>https://list-jiang.github.io/code/language/markdown/extend/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/extend/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="其他特性"> 其他特性</h2>
<h3 id="自动链接"> 自动链接</h3>
<p>Markdown 支持比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如:</p>
<div><pre><code>&lt;http://example.com/>
</code></pre>
<div><span>1</span><br></div></div><p>Markdown 会转为:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.com/<span>"</span></span><span>></span></span>http://example.com/<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>自动的邮件链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以混淆一些不好的信箱地址收集机器人，例如:</p>
<div><pre><code><span><span><span>&lt;</span>address@example.com</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>Markdown 会转成:</p>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span><span title="&#x6D;">&amp;#x6D;</span><span title="&#x61;">&amp;#x61;</span>i<span title="&#x6C;">&amp;#x6C;</span><span title="&#x74;">&amp;#x74;</span><span title="&#x6F;">&amp;#x6F;</span>:<span title="&#x61;">&amp;#x61;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x72;">&amp;#x72;</span><span title="&#x65;">&amp;#x65;</span><span title="&#115;">&amp;#115;</span><span title="&#115;">&amp;#115;</span><span title="&#64;">&amp;#64;</span><span title="&#101;">&amp;#101;</span><span title="&#120;">&amp;#120;</span><span title="&#x61;">&amp;#x61;</span><span title="&#109;">&amp;#109;</span><span title="&#x70;">&amp;#x70;</span><span title="&#x6C;">&amp;#x6C;</span>e<span title="&#x2E;">&amp;#x2E;</span><span title="&#99;">&amp;#99;</span><span title="&#111;">&amp;#111;</span><span title="&#109;">&amp;#109;</span><span>"</span></span>
  <span>></span></span><span title="&#x61;">&amp;#x61;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x72;">&amp;#x72;</span><span title="&#x65;">&amp;#x65;</span><span title="&#115;">&amp;#115;</span><span title="&#115;">&amp;#115;</span><span title="&#64;">&amp;#64;</span><span title="&#101;">&amp;#101;</span><span title="&#120;">&amp;#120;</span><span title="&#x61;">&amp;#x61;</span><span title="&#109;">&amp;#109;</span><span title="&#x70;">&amp;#x70;</span><span title="&#x6C;">&amp;#x6C;</span>e<span title="&#x2E;">&amp;#x2E;</span><span title="&#99;">&amp;#99;</span><span title="&#111;">&amp;#111;</span><span title="&#109;">&amp;#109;</span><span><span><span>&lt;/</span>a</span>
<span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在浏览器里面，这段字串会变成一个可以点击的「address@example.com」链接。</p>
<p>(这种作法虽然可以混淆不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开您的信箱终究会引来广告信件的。)</p>
<h3 id="转义字符"> 转义字符</h3>
<p>Markdown 可以利用反斜线来插入一些在语法中有其它意义的符号，例如: 如果您想要用星号加在文字旁边的方式来做出强调效果 (但不用 <code>&lt;em&gt;</code> 标签) ，您可以在星号的前面加上反斜线:</p>
<div><pre><code>\*literal asterisks\*
</code></pre>
<div><span>1</span><br></div></div><p>Markdown 支持在下面这些符号前面加上反斜线来帮助插入普通的符号:</p>
<ul>
<li><code>\</code> 反斜线</li>
<li><code>`</code> 反引号</li>
<li><code>*</code> 星号</li>
<li><code>_</code> 底线</li>
<li><code>{}</code> 大括号</li>
<li><code>[]</code> 方括号</li>
<li><code>()</code> 括号</li>
<li><code>#</code> 井字号</li>
<li><code>+</code> 加号</li>
<li><code>-</code> 减号</li>
<li><code>.</code> 英文句点</li>
<li><code>!</code> 惊叹号</li>
</ul>
<h2 id="大部分编辑器通用快捷键"> 大部分编辑器通用快捷键</h2>
<table>
<thead>
<tr>
<th>输出后的效果</th>
<th>Markdown</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bold</strong></td>
<td><code>**text**</code></td>
<td>Ctrl/⌘ + B</td>
</tr>
<tr>
<td><em>Emphasize</em></td>
<td><code>*text*</code></td>
<td>Ctrl/⌘ + I</td>
</tr>
<tr>
<td><code>Inline Code</code></td>
<td>`code`</td>
<td>选中后 <code>`</code></td>
</tr>
</tbody>
</table>
<h2 id="常见扩展"> 常见扩展</h2>
<p>有几种轻量级标记语言是 Markdown 的超集。它们包含 Gruber 的基本语法，并通过添加其他元素 (例如表，代码块，语法突出显示，URL 自动链接和脚注) 在此基础上构建。许多最受欢迎的 Markdown 应用程序使用以下轻量级标记语言之一:</p>
<ul>
<li><a href="https://commonmark.org/" target="_blank" rel="noopener noreferrer">CommonMark</a></li>
<li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener noreferrer">GitHub Flavored Markdown (GFM)</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" target="_blank" rel="noopener noreferrer">Markdown Extra</a></li>
<li><a href="https://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener noreferrer">MultiMarkdown</a></li>
<li><a href="https://rmarkdown.rstudio.com/" target="_blank" rel="noopener noreferrer">R Markdown</a></li>
</ul>
<h3 id="表格"> 表格</h3>
<p>表格是 GFM 标准支持的格式。</p>
<p>您需要创建表头，并使用 <code>---</code> 来分割表头和表身。</p>
<p>您需要使用 <code>|</code> 来分割每一个表格项目，如果您需要输入 <code>|</code> 请使用 <code>\</code> 转义它。</p>
<p>您可以在表头分割行处使用 <code>:</code> 来自定义该列的对其</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span><span>|</span><span>     居中      </span><span>|</span><span>                   右对齐 </span><span>|</span><span> 左对齐         </span><span>|</span>
</span><span><span>|</span> <span>:-----------:</span> <span>|</span> <span>-----------------------:</span> <span>|</span> <span>:-------------</span> <span>|</span>
</span><span><span>|</span><span> 居中使用<span>`:-:`</span> </span><span>|</span><span>           右对齐使用<span>`-:`</span> </span><span>|</span><span> 左对齐使用<span>`:-`</span> </span><span>|</span>
<span>|</span><span>       b       </span><span>|</span><span> 表格中包含的 \| 需要转义 </span><span>|</span><span> aaaa           </span><span>|</span>
<span>|</span><span>       c       </span><span>|</span><span>                     aaaa </span><span>|</span><span> a              </span><span>|</span>
</span></span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>输出</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">表格中包含的 | 需要转义</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
</details>
<h3 id="emoji"> Emoji</h3>
<p>Emoji 是 GFM 标准支持的格式，需要通过 <code>:emoji名称:</code> 来使用 emoji。</p>
<p>例子: <code>:smile:</code> 😄</p>
<p>您可以在 <a href="./emoji/">Emoji 列表</a> 找到所有可用的 Emoji。</p>
<h3 id="删除线"> 删除线</h3>
<p>您可以使用 <code>~~delete~~</code> 来创建类似 <s>delete</s> 的删除线</p>
<h3 id="脚注"> 脚注</h3>
<p>在 Markdown 中使用 <code>[^锚点文字]</code> 来定义脚注。</p>
<p>在之后的任何位置使用 <code>[^锚点文字]: ...</code> 来描述脚注内容。</p>
<p>如果脚注包含多个段落，其后的段落应当保持双层缩进。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>脚注 1 链接[^first].

脚注 2 链接[^second].

行内的脚注^[Text of inline footnote] 定义.

重复的页脚引用[^second].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 脚注</span> <span><span>**</span><span>可以包含特殊标记</span><span>**</span></span>

<span>    也可以由多个段落组成</span>

<span><span>[</span><span>^second</span><span>]</span><span>:</span> 脚注文字。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>输出</strong>:</p>
<p>脚注 1 链接<sup></sup>.</p>
<p>脚注 2 链接<sup></sup>.</p>
<p>行内的脚注<sup></sup> 定义.</p>
<p>重复的页脚引用<sup></sup>.</p>
</details>
<h3 id="自定义标题"> 自定义标题</h3>
<p>许多 Markdown 处理器支持标题的自定义 ID。</p>
<p>添加自定义 ID 允许您直接链接到标题并使用 CSS 对其进行修改。要添加自定义标题 ID，请在与标题相同的行上用大括号括起该自定义 ID。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>###</span> My Great Heading {#custom-id}</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>id</span><span><span>=</span><span>"</span>custom-id<span>"</span></span><span>></span></span>My Great Heading<span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></details>
<h3 id="定义列表"> 定义列表</h3>
<p>一些 Markdown 处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>First Term
: This is the definition of the first term.

Second Term
: This is one definition of the second term.
: This is another definition of the second term.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>dl</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>First Term<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is the definition of the first term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>Second Term<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is one definition of the second term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is another definition of the second term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
<span><span><span>&lt;/</span>dl</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>输出</strong>:</p>

<dl>
  <dt>First Term</dt>
  <dd>This is the definition of the first term.</dd>
  <dt>Second Term</dt>
  <dd>This is one definition of the second term.</dd>
  <dd>This is another definition of the second term.</dd>
</dl>
</details>
<h3 id="任务列表"> 任务列表</h3>
<p>任务列表使您可以创建带有复选框的项目列表。</p>
<p>要创建任务列表，请创建一个列表，并以方括号 <code>[ ]</code> 开头。通过添加空格 <code>x</code> 来改变复选框的勾选情况。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> [x] Write the press release
<span>-</span> [ ] Update the website
<span>-</span> [ ] Contact the media
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>输出</strong>:</p>
<ul>
  <li><input type="checkbox" checked disabled />Write the press release</li>
  <li><input type="checkbox" disabled />Update the website</li>
  <li><input type="checkbox" disabled />Contact the media</li>
</ul>
</details>
<hr>
<section>
<ol>
<li id="footnote1"><p>脚注 <strong>可以包含特殊标记</strong></p>
<p>也可以由多个段落组成 </p>
</li>
<li id="footnote2"><p>脚注文字。  </p>
</li>
<li id="footnote3"><p>Text of inline footnote </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Markdown 行内元素</title>
    <id>https://list-jiang.github.io/code/language/markdown/inline/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/inline/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链接"> 链接</h2>
<p>Markdown 支持两种形式的链接语法: <em>行内</em>和<em>参考</em>。</p>
<p>不管是哪一种，链接的文字都是用 <code>[方括号]</code> 来标记。</p>
<h3 id="行内链接"> 行内链接</h3>
<p>要建立一个行内形式的链接，只要在方块括号后输入圆括号并插入网址链接即可，如果您还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>This is <span>[<span>an example</span>](<span>http://example.com/</span> <span>"Title"</span>)</span> inline link.

<span>[<span>This link</span>](<span>http://example.net/</span>)</span> has no title attribute.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  This is <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Title<span>"</span></span><span>></span></span> an example<span><span><span>&lt;/</span>a</span><span>></span></span> inline
  link.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.net/<span>"</span></span><span>></span></span>This link<span><span><span>&lt;/</span>a</span><span>></span></span> has no title attribute.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>输出</strong>:</p>
<p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener noreferrer">an example</a> inline link.</p>
<p><a href="http://example.net/" target="_blank" rel="noopener noreferrer">This link</a> has no title attribute.</p>
</details>
<p>如果您是要链接到同样主机的资源，您可以使用绝对路径或相对路径:</p>
<div><pre><code>See my <span>[<span>About</span>](<span>/about/</span>)</span> page for details.
</code></pre>
<div><span>1</span><br></div></div><h3 id="参考链接"> 参考链接</h3>
<p>参考形式的链接使用另外一个方括号接在链接文字的括号后面，而在第二个方括号里面要填入标识链接的标签:</p>
<div><pre><code>This is <span>[<span>an example</span>][<span>id</span>]</span> reference-style link.
</code></pre>
<div><span>1</span><br></div></div><p>之后在文件的任意地方，您都可以把这个标签的链接内容定义出来:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>链接定义的形式为:</p>
<ul>
<li>方括号，输入链接的标识 ID</li>
<li>冒号</li>
<li>一个以上的空白或 tab</li>
<li>链接的网址</li>
<li>选择性地添加 title 内容，可以用单引号、双引号或是括号包括</li>
</ul>
<p>下面这三种链接的定义相同:</p>
<div><pre><code><span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
<span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
<span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>链接网址也可以用方括号包起来:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> [http://example.com/] <span>"Optional Title Here"</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以把 title 属性放到下一行，也可以加一些缩进，网址太长的话，这样会比较好看:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> http://example.com/longish/path/to/resource/here</span>
    "Optional Title Here"
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨识标签可以有字母、数字、空白和标点符号，但是并<strong>不</strong>区分大小写，因此下面两个链接是一样的:</p>
<div><pre><code><span>[<span>link text</span>][<span>a</span>]</span>
<span>[<span>link text</span>][<span>A</span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>最佳实践</p>
<p>由于不区分大小写的原因，Markdown 最佳实践推荐标识标签均使用小写。</p>
</div>
<h4 id="简写"> 简写</h4>
<p>您可以通过简写写法省略指定链接标签，这种情形下，链接标签和链接文字会视为相同，要用预设链接标签只要在链接文字后面加上一个空的方括号，如果您要让 &quot;Google&quot; 链接到 google.com，您可以简化成:</p>
<div><pre><code>[Google][]
</code></pre>
<div><span>1</span><br></div></div><p>然后定义链接内容:</p>
<div><pre><code><span><span>[</span><span>google</span><span>]</span><span>:</span> http://google.com/</span>
</code></pre>
<div><span>1</span><br></div></div><p>由于链接文字可能包含空白，所以这种简化的标签内也可以包含多个文字:</p>
<div><pre><code>Visit [Daring Fireball][] for more information.
</code></pre>
<div><span>1</span><br></div></div><p>然后定义链接:</p>
<div><pre><code><span><span>[</span><span>daring fireball</span><span>]</span><span>:</span> http://daringfireball.net/</span>
</code></pre>
<div><span>1</span><br></div></div><p>链接的定义可以放在文件中的任何一个地方，建议放在链接出现段落的后面或文件最后面，就像是注解一样。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>I get 10 times more traffic from <span>[<span>Google</span>][<span>1</span>]</span> than from
<span>[<span>Yahoo</span>][<span>2</span>]</span> or <span>[<span>MSN</span>][<span>3</span>]</span>.

<span><span>[</span><span>1</span><span>]</span><span>:</span> http://google.com/ <span>"Google"</span></span>
<span><span>[</span><span>2</span><span>]</span><span>:</span> http://search.yahoo.com/ <span>"Yahoo Search"</span></span>
<span><span>[</span><span>3</span><span>]</span><span>:</span> http://search.msn.com/ <span>"MSN Search"</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>等同于</strong>:</p>
<div><pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

<span><span>[</span><span>google</span><span>]</span><span>:</span> http://google.com/ <span>"Google"</span></span>
<span><span>[</span><span>yahoo</span><span>]</span><span>:</span> http://search.yahoo.com/ <span>"Yahoo Search"</span></span>
<span><span>[</span><span>msn</span><span>]</span><span>:</span> http://search.msn.com/ <span>"MSN Search"</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  I get 10 times more traffic from
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://google.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Google<span>"</span></span><span>></span></span>Google<span><span><span>&lt;/</span>a</span><span>></span></span> than from
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://search.yahoo.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Yahoo Search<span>"</span></span><span>></span></span>Yahoo<span><span><span>&lt;/</span>a</span><span>></span></span>
  or <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://search.msn.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>MSN Search<span>"</span></span><span>></span></span>MSN<span><span><span>&lt;/</span>a</span><span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>输出</strong>:</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener noreferrer">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener noreferrer">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener noreferrer">MSN</a>.</p>
<p><strong>同样的行内模式写法</strong>:</p>
<div><pre><code>I get 10 times more traffic from <span>[<span>Google</span>](<span>http://google.com/</span> <span>"Google"</span>)</span>
than from <span>[<span>Yahoo</span>](<span>http://search.yahoo.com/</span> <span>"Yahoo Search"</span>)</span> or
<span>[<span>MSN</span>](<span>http://search.msn.com/</span> <span>"MSN Search"</span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<div><p>优势</p>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的链接却会增加到 176 个字符，如果是用纯 HTML 格式来写，会有 234 个字符，在 HTML 格式中，标签比文字还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让您可以把一些标记相关的资讯移到段落文字之外，您就可以增加链接而不让文章的阅读感觉被打断。</p>
</div>
<h2 id="强调"> 强调</h2>
<p>Markdown 使用星号 (<code>*</code>) 和底线 (<code>_</code>) 作为标记强调字词的符号。</p>
<p>被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>**</span><span>double asterisks</span><span>**</span></span> (建议)

<span><span>_</span><span>single underscores</span><span>_</span></span> (建议)

<span><span>__</span><span>double underscores</span><span>__</span></span>

<span><span>*</span><span>single asterisks</span><span>*</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>strong</span><span>></span></span>double asterisks<span><span><span>&lt;/</span>strong</span><span>></span></span>

<span><span><span>&lt;</span>em</span><span>></span></span>single underscores<span><span><span>&lt;/</span>em</span><span>></span></span>

<span><span><span>&lt;</span>strong</span><span>></span></span>double underscores<span><span><span>&lt;/</span>strong</span><span>></span></span>

<span><span><span>&lt;</span>em</span><span>></span></span>single asterisks<span><span><span>&lt;/</span>em</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>
<p>但是如果您的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>These two <span><span>_</span><span>, </span><span>_</span></span> and <span><span>*</span><span>, </span><span>*</span></span> will be treated as normal characters.
</code></pre>
<div><span>1</span><br></div></div><p><strong>输出</strong>:</p>
<p>These two _, _ and *, * will be treated as normal characters.</p>
</details>
<div><p>最佳实践</p>
<p>为了将两者进行区分，Markdown 最佳实践要求在所有地方尽可能使用 <code>**</code> 和 <code>_</code>。但是这里有一个例外:</p>
<p>由于使用代码或者是其他情况，人们很容易创造出带有下划线的单词 (如 <code>last_updated_time</code>)，在这种情况下，updated 就不会识别为斜体。只有在这种情况下，使用 <code>*</code> 而不是 <code>_</code>。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>A varibale like last_updated_time won’t be <span><span>_</span><span>transformed</span><span>_</span></span> like last<span><span>*</span><span>updated</span><span>*</span></span>time.
</code></pre>
<div><span>1</span><br></div></div><p><strong>输出</strong>:</p>
<p>A varibale like last_updated_time won’t be <em>transformed</em> like last<em>updated</em>time.</p>
</details>
</div>
<p>强调也可以直接插在文字中间:</p>
<div><pre><code>un<span><span>*</span><span>frigging</span><span>*</span></span>believable
</code></pre>
<div><span>1</span><br></div></div><h3 id="转义"> 转义</h3>
<details><summary>如果要在文字前后直接插入普通的星号或底线，您可以用 \</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>\*this text is surrounded by literal asterisks\*

\_this text is surrounded by literal underscores\_
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>输出</strong>:</p>
<p>*this text is surrounded by literal asterisks*</p>
<p>_this text is surrounded by literal underscores_</p>
</details>
<h2 id="代码"> 代码</h2>
<p>如果要标记一小段行内代码，您可以用反引号 (<code>`</code>) 把它包起来。</p>
<div><p>反引号</p>
<p>反引号在键盘的左上角，ESC 键的下方</p>
</div>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>Use the <span>`printf()`</span> function.
</code></pre>
<div><span>1</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Use the <span><span><span>&lt;</span>code</span><span>></span></span>printf()<span><span><span>&lt;/</span>code</span><span>></span></span> function.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>输出</strong>:</p>
<p>Use the <code>printf()</code> function.</p>
</details>
<h3 id="转义-2"> 转义</h3>
<p>如果要在代码内插入反引号，您可以用多个反引号来开启和结束行内代码</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>`` There is a literal backtick (`) here. ``</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>code</span><span>></span></span>There is a literal backtick (`) here.<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>输出</strong>:</p>
<p><code>There is a literal backtick (`) here.</code></p>
</details>
<p>代码码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样您就可以在区段的一开始就插入反引号。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>A single backtick in a code span: <span>`` ` ``</span>

A backtick-delimited string in a code span: <span>`` `foo` ``</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>A single backtick in a code span: <span><span><span>&lt;</span>code</span><span>></span></span>`<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>A backtick-delimited string in a code span: <span><span><span>&lt;</span>code</span><span>></span></span>`foo`<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>输出</strong>:</p>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
</details>
<p>在代码码区段内，<code>&amp;</code> 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码.</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>Please don’t use any <span>`&lt;blink>`</span> tags.
</code></pre>
<div><span>1</span><br></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Please don’t use any <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>blink<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span> tags.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>输出</strong>:</p>
<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>
</details>
<h2 id="图片"> 图片</h2>
<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式: <em>行内</em> 和 <em>参考</em>。</p>
<ul>
<li>
<p>行内图片的语法如下:</p>
<div><pre><code><span><span>!</span>[<span>Alt text</span>](<span>/path/to/img.jpg</span>)</span>

<span><span>!</span>[<span>Alt text</span>](<span>/path/to/img.jpg</span> <span>"Optional title"</span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>详细叙述如下:</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>一个方括号，里面放上图片的替代文字</li>
<li>一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 title 文字。</li>
</ul>
</li>
<li>
<p>参考式的图片语法如下:</p>
<div><pre><code><span><span>!</span>[<span>Alt text</span>][<span>id</span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>id</code> 是图片参考的名称，图片参考的定义方式则和链接参考一样:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> url/to/image <span>"Optional title attribute"</span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<p>它们的优劣与链接相同。</p>
<div><p>提示</p>
<p>Markdown 无法指定图片的宽高，如果您需要的话，您可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Markdown 介绍</title>
    <id>https://list-jiang.github.io/code/language/markdown/intro/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。它的扩展名为 <code>.md</code>。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。它的扩展名为 <code>.md</code>。</p>

<h2 id="设计理念"> 设计理念</h2>
<p>Markdown 最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字发布，并且看起来不会像是由许多标签或是格式指令所构成。</p>
<p>其语法在设计时受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener noreferrer">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener noreferrer">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener noreferrer">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener noreferrer">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener noreferrer">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener noreferrer">EtText</a>，然而最大灵感来源其实是纯文字的电子邮件格式。因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。假如您有使用过电子邮件，引言写法看起来就真的像是引用一段文字。</p>
<p>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能 (如表格、脚注、内嵌 HTML 等等) ，这些功能并不在最初的设计中，但它们能让 Markdown 转换成更多的格式，例如 LaTeX，Docbook。Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、 Maruku 等。这些衍生版本要么基于工具，如 Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
<h2 id="用途"> 用途</h2>
<p>Markdown 的语法有个主要的目的: 用来作为一种网络内容的<strong>写作用语言</strong>。Markdown 的重点在于，它能让文件<strong>更容易阅读、编写</strong>。因此，Markdown 的格式语法只涵盖纯文字可以涵盖的范围。</p>
<p>Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台 WordPress 能很好的支持 Markdown。</p>
<p>用于编写说明文档，并且以 “README.md” 的文件名保存在软件的目录下面。</p>
<p>除此之外，我们还可以快速将 Markdown 转化为演讲 PPT、Word 产品文档、LaTex 论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown 已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p>
<h2 id="特点"> 特点</h2>
<h3 id="行内-html"> 行内 HTML</h3>
<p>不在 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>只有块元素 ── 比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以利与内容区隔。而且这些 (元素) 的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 的解析器有智慧型判断，可以避免在块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>举例来说，在 Markdown 文件里加上一段 HTML 表格:</p>
<div><pre><code>This is a regular paragraph.

<span><span><span>&lt;</span>table</span><span>></span></span>
    <span><span><span>&lt;</span>tr</span><span>></span></span>
        <span><span><span>&lt;</span>td</span><span>></span></span>Foo<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>

This is another regular paragraph.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>注意</p>
<p>Markdown 语法在 HTML 块标签中将不会被进行处理。</p>
<p>例如，您无法在 HTML 块内使用 Markdown 形式的 <code>*强调*</code>。</p>
</div>
<h3 id="特殊字符自动转换"> 特殊字符自动转换</h3>
<p>简单来说，在 Markdown 中，您无需考虑 HTML 本应考虑的特殊字符转义的问题。</p>
<p>比如对于 <code>AT&amp;T</code>，Markdown 就会将它转为 <code>AT&amp;amp;T</code>。</p>
<div><p>HTML 中的特殊字符</p>
<p>在 HTML 文件中，有两个字符需要特殊处理: <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果您只是想要使用这些符号，您必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p>使用 HTML 时，<code>&amp;</code> 符号其实很容易让写作网络文件的人感到困扰。</p>
<p>如果您要打 「AT&amp;T」 ，您必须要写成 <code>「AT&amp;amp;T」</code>。</p>
<p>同时您还得转换网址内的 <code>&amp;</code> 符号，如果您要链接到 <code>http://images.google.com/images?num=30&amp;q=larry+bird</code>，您必须要把网址转成 <code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code>，才能放到链接标签的 <code>href</code> 属性里。</p>
<p>不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
</div>
<p>Markdown 即允许您直接使用这些符号。也允许您使用转义符号。</p>
<p>比如您如果要在文件中插入一个著作权的符号，但是您又不想费力地输入这个不常见的特殊符号，您可以直接在 Markdown 中输入 <code>&amp;copy;</code>，Markdown 会推测出它是转移符号，并把它输出为 ©。</p>
<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持  ，如果您是使用 <code>&lt;</code> 符号作为 HTML 标签使用，那 Markdown 也不会对它做任何转换，但是如果您是写:</p>
<div><pre><code>4 &lt; 5
</code></pre>
<div><span>1</span><br></div></div><p>Markdown 将会把它转换为:</p>
<div><pre><code>4 <span title="&lt;">&amp;lt;</span> 5
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>需要注意的是，code 范围内，不论是行内还是块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让您可以很容易地用 Markdown 写 HTML code (和 HTML 相对而言， HTML 语法中，您要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。)</p>
</div>
<h2 id="编写"> 编写</h2>
<p>Markdown 就是一个扩展名为 <code>.md</code> 的文本文件。</p>
<p>理论上您可以使用任何编辑器 (如 <a href="./../../../software/vscode/">VS Code</a>)编辑 Markdown，也可以使用专门的 Markdown 编辑器 (如 <a href="https://typora.io" target="_blank" rel="noopener noreferrer">Typora</a>) 进行编写。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">生成器</title>
    <id>https://list-jiang.github.io/code/language/python/advance/generator/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/generator/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器: generator。</p>
]]></summary>
    <content type="html"><![CDATA[<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器: generator。</p>

<p>要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span>x <span>*</span> x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>]</span>
<span>>></span><span>></span> L
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>,</span> <span>25</span><span>,</span> <span>36</span><span>,</span> <span>49</span><span>,</span> <span>64</span><span>,</span> <span>81</span><span>]</span>
<span>>></span><span>></span> g <span>=</span> <span>(</span>x <span>*</span> x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
<span>>></span><span>></span> g
<span>&lt;</span>generator <span>object</span> <span>&lt;</span>genexpr<span>></span> at <span>0x1022ef630</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>创建 <code>L</code> 和 <code>g</code> 的区别仅在于最外层的 <code>[]</code> 和 <code>()</code>，L 是一个 list，而 g 是一个 generator。</p>
<p>我们可以直接打印出 list 的每一个元素，但我们怎么打印出 generator 的每一个元素呢?</p>
<p>如果要一个一个打印出来，可以通过 <code>next()</code> 函数获得 generator 的下一个返回值:</p>
<div><pre><code><span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>0</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>1</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>4</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>9</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>16</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>25</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>36</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>49</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>64</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
<span>81</span>
<span>>></span><span>></span> <span>next</span><span>(</span>g<span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
StopIteration
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>我们讲过，generator 保存的是算法，每次调用 <code>next(g)</code>，就计算出 <code>g</code> 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 <code>StopIteration</code> 的错误。</p>
<p>当然，上面这种不断调用 <code>next(g)</code> 实在是太变态了，正确的方法是使用 for 循环，因为 generator 也是可迭代对象:</p>
<div><pre><code><span>>></span><span>></span> g <span>=</span> <span>(</span>x <span>*</span> x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
<span>>></span><span>></span> <span>for</span> n <span>in</span> g<span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>0</span>
<span>1</span>
<span>4</span>
<span>9</span>
<span>16</span>
<span>25</span>
<span>36</span>
<span>49</span>
<span>64</span>
<span>81</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>所以，我们创建了一个 generator 后，基本上永远不会调用 <code>next()</code>，而是通过 for 循环来迭代它，并且不需要关心 <code>StopIteration</code> 的错误。</p>
<p>Generator 非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。</p>
<p>比如，著名的斐波拉契数列(Fibonacci)，除第一个和第二个数外，任意一个数都可由前两个数相加得到:</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易:</p>
<div><pre><code><span>def</span> <span>fib</span><span>(</span><span>max</span><span>)</span><span>:</span>
    n<span>,</span> a<span>,</span> b <span>=</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span>
    <span>while</span> n <span>&lt;</span> <span>max</span><span>:</span>
        <span>print</span><span>(</span>b<span>)</span>
        a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
        n <span>=</span> n <span>+</span> <span>1</span>
    <span>return</span> <span>'done'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意，赋值语句:</p>
<div><pre><code>a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
</code></pre>
<div><span>1</span><br></div></div><p>相当于:</p>
<div><pre><code>t <span>=</span> <span>(</span>b<span>,</span> a <span>+</span> b<span>)</span> <span># t是一个tuple</span>
a <span>=</span> t<span>[</span><span>0</span><span>]</span>
b <span>=</span> t<span>[</span><span>1</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但不必显式写出临时变量 <code>t</code> 就可以赋值。</p>
<p>上面的函数可以输出斐波那契数列的前 N 个数:</p>
<div><pre><code><span>>></span><span>></span> fib<span>(</span><span>6</span><span>)</span>
<span>1</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>5</span>
<span>8</span>
<span>'done'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>仔细观察，可以看出，<code>fib</code> 函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似 generator。</p>
<p>也就是说，上面的函数和 generator 仅一步之遥。要把 fib 函数变成 generator，只需要把 <code>print(b)</code> 改为 <code>yield b</code> 就可以了:</p>
<div><pre><code><span>def</span> <span>fib</span><span>(</span><span>max</span><span>)</span><span>:</span>
    n<span>,</span> a<span>,</span> b <span>=</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span>
    <span>while</span> n <span>&lt;</span> <span>max</span><span>:</span>
        <span>yield</span> b
        a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
        n <span>=</span> n <span>+</span> <span>1</span>
    <span>return</span> <span>'done'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这就是定义 generator 的另一种方法。如果一个函数定义中包含 <code>yield</code> 关键字，那么这个函数就不再是一个普通函数，而是一个 generator:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> fib<span>(</span><span>6</span><span>)</span>
<span>>></span><span>></span> f
<span>&lt;</span>generator <span>object</span> fib at <span>0x104feaaa0</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，遇到 <code>return</code> 语句或者最后一行函数语句就返回。而变成 generator 的函数，在每次调用 <code>next()</code> 的时候执行，遇到 <code>yield</code> 语句返回，再次执行时从上次返回的 <code>yield</code> 语句处继续执行。</p>
<p>举个简单的例子，定义一个 generator，依次返回数字 1，3，5:</p>
<div><pre><code><span>def</span> <span>odd</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'step 1'</span><span>)</span>
    <span>yield</span> <span>1</span>
    <span>print</span><span>(</span><span>'step 2'</span><span>)</span>
    <span>yield</span><span>(</span><span>3</span><span>)</span>
    <span>print</span><span>(</span><span>'step 3'</span><span>)</span>
    <span>yield</span><span>(</span><span>5</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>调用该 generator 时，首先要生成一个 generator 对象，然后用 <code>next()</code> 函数不断获得下一个返回值:</p>
<div><pre><code><span>>></span><span>></span> o <span>=</span> odd<span>(</span><span>)</span>
<span>>></span><span>></span> <span>next</span><span>(</span>o<span>)</span>
step <span>1</span>
<span>1</span>
<span>>></span><span>></span> <span>next</span><span>(</span>o<span>)</span>
step <span>2</span>
<span>3</span>
<span>>></span><span>></span> <span>next</span><span>(</span>o<span>)</span>
step <span>3</span>
<span>5</span>
<span>>></span><span>></span> <span>next</span><span>(</span>o<span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
StopIteration
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>可以看到，<code>odd</code> 不是普通函数，而是 generator，在执行过程中，遇到 <code>yield</code> 就中断，下次又继续执行。执行 3 次 <code>yield</code> 后，已经没有 <code>yield</code> 可以执行了，所以，第 4 次调用 <code>next(o)</code> 就报错。</p>
<p>回到 fib 的例子，我们在循环过程中不断调用 <code>yield</code>，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p>
<p>同样的，把函数改成 generator 后，我们基本上从来不会用 <code>next()</code> 来获取下一个返回值，而是直接使用 for 循环来迭代:</p>
<div><pre><code><span>>></span><span>></span> <span>for</span> n <span>in</span> fib<span>(</span><span>6</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>1</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>5</span>
<span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>但是用 for 循环调用 generator 时，发现拿不到 generator 的 <code>return</code> 语句的返回值。如果想要拿到返回值，必须捕获 <code>StopIteration</code> 错误，返回值包含在 <code>StopIteration</code> 的 value 中:</p>
<div><pre><code><span>>></span><span>></span> g <span>=</span> fib<span>(</span><span>6</span><span>)</span>
<span>>></span><span>></span> <span>while</span> <span>True</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>try</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         x <span>=</span> <span>next</span><span>(</span>g<span>)</span>
<span>.</span><span>.</span><span>.</span>         <span>print</span><span>(</span><span>'g:'</span><span>,</span> x<span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>except</span> StopIteration <span>as</span> e<span>:</span>
<span>.</span><span>.</span><span>.</span>         <span>print</span><span>(</span><span>'Generator return value:'</span><span>,</span> e<span>.</span>value<span>)</span>
<span>.</span><span>.</span><span>.</span>         <span>break</span>
<span>.</span><span>.</span><span>.</span>
g<span>:</span> <span>1</span>
g<span>:</span> <span>1</span>
g<span>:</span> <span>2</span>
g<span>:</span> <span>3</span>
g<span>:</span> <span>5</span>
g<span>:</span> <span>8</span>
Generator <span>return</span> value<span>:</span> done
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>关于如何捕获错误，后面的错误处理还会详细讲解。</p>
<h2 id="小结"> 小结</h2>
<p>Generator 是非常强大的工具，在 Python 中，可以简单地把列表生成式改成 generator，也可以通过函数实现复杂逻辑的 generator。</p>
<p>要理解 generator 的工作原理，它是在 for 循环的过程中不断计算出下一个元素，并在适当的条件结束 for 循环。对于函数改成的 generator 来说，遇到 <code>return</code> 语句或者执行到函数体最后一行语句，就是结束 generator 的指令，for 循环随之结束。</p>
<p>请注意区分普通函数和 generator 函数，普通函数调用直接返回结果:</p>
<div><pre><code><span>>></span><span>></span> r <span>=</span> <span>abs</span><span>(</span><span>6</span><span>)</span>
<span>>></span><span>></span> r
<span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Generator 函数的“调用”实际返回一个 generator 对象:</p>
<div><pre><code><span>>></span><span>></span> g <span>=</span> fib<span>(</span><span>6</span><span>)</span>
<span>>></span><span>></span> g
<span>&lt;</span>generator <span>object</span> fib at <span>0x1022ef948</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-29T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">Markdown</title>
    <id>https://list-jiang.github.io/code/language/markdown/</id>
    <link href="https://list-jiang.github.io/code/language/markdown/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。</p>
<p>Markdown 的主要目的是用来作为一种网络内容的<strong>写作用语言</strong>。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。</p>
<p>Markdown 的主要目的是用来作为一种网络内容的<strong>写作用语言</strong>。</p>

<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./intro.html">简介</a></li>
<li><a href="./block.html">块元素</a></li>
<li><a href="./inline.html">行内元素</a></li>
<li><a href="./extend.html">扩展与其他内容</a></li>
</ul>
<h2 id="markdown-效果演示"> Markdown 效果演示</h2>
<ul>
<li><a href="./demo.html">查看详情</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Markdown"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">迭代</title>
    <id>https://list-jiang.github.io/code/language/python/advance/iteration/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/iteration/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple，这种遍历我们称为迭代(Iteration)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple，这种遍历我们称为迭代(Iteration)。</p>

<p>在 Python 中，迭代是通过 <code>for ... in</code> 来完成的，而很多语言比如 C 语言，迭代 list 是通过下标完成的，比如 Java 代码:</p>
<div><pre><code><span>for</span> <span>(</span>i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>list<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    n <span>=</span> list<span>[</span>i<span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看出，Python 的 for 循环抽象程度要高于 C 的 for 循环，因为 Python 的 for 循环不仅可以用在 list 或 tuple 上，还可以作用在其他可迭代对象上。</p>
<p>list 这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如 dict 就可以迭代:</p>
<div><pre><code><span>>></span><span>></span> d <span>=</span> <span>{</span><span>'a'</span><span>:</span> <span>1</span><span>,</span> <span>'b'</span><span>:</span> <span>2</span><span>,</span> <span>'c'</span><span>:</span> <span>3</span><span>}</span>
<span>>></span><span>></span> <span>for</span> key <span>in</span> d<span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>key<span>)</span>
<span>.</span><span>.</span><span>.</span>
a
c
b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>因为 dict 的存储不是按照 list 的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</p>
<p>默认情况下，dict 迭代的是 key。如果要迭代 value，可以用 <code>for value in d.values()</code>，如果要同时迭代 key 和 value，可以用 for k, v in d.items()。</p>
<p>由于字符串也是可迭代对象，因此，也可以作用于 for 循环:</p>
<div><pre><code><span>>></span><span>></span> <span>for</span> ch <span>in</span> <span>'ABC'</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>ch<span>)</span>
<span>.</span><span>.</span><span>.</span>
A
B
C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，当我们使用 for 循环时，只要作用于一个可迭代对象，for 循环就可以正常运行，而我们不太关心该对象究竟是 list 还是其他数据类型。</p>
<p>那么，如何判断一个对象是可迭代对象呢? 方法是通过 collections 模块的 Iterable 类型判断:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> collections <span>import</span> Iterable
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>'abc'</span><span>,</span> Iterable<span>)</span> <span># str是否可迭代</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>,</span> Iterable<span>)</span> <span># list是否可迭代</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>123</span><span>,</span> Iterable<span>)</span> <span># 整数是否可迭代</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>最后一个小问题，如果要对 list 实现类似 Java 那样的下标循环怎么办? Python 内置的 <code>enumerate</code> 函数可以把一个 list 变成索引-元素对，这样就可以在 for 循环中同时迭代索引和元素本身:</p>
<div><pre><code><span>>></span><span>></span> <span>for</span> i<span>,</span> value <span>in</span> <span>enumerate</span><span>(</span><span>[</span><span>'A'</span><span>,</span> <span>'B'</span><span>,</span> <span>'C'</span><span>]</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>i<span>,</span> value<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>0</span> A
<span>1</span> B
<span>2</span> C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的 for 循环里，同时引用了两个变量，在 Python 里是很常见的，比如下面的代码:</p>
<div><pre><code><span>>></span><span>></span> <span>for</span> x<span>,</span> y <span>in</span> <span>[</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>,</span> <span>(</span><span>2</span><span>,</span> <span>4</span><span>)</span><span>,</span> <span>(</span><span>3</span><span>,</span> <span>9</span><span>)</span><span>]</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>x<span>,</span> y<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>1</span> <span>1</span>
<span>2</span> <span>4</span>
<span>3</span> <span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="小结"> 小结</h2>
<p>任何可迭代对象都可以作用于 for 循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用 for 循环。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">迭代器</title>
    <id>https://list-jiang.github.io/code/language/python/advance/iterator/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/iterator/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们已经知道，可以直接作用于 for 循环的数据类型有以下几种:</p>
<p>一类是集合数据类型，如 list、tuple、dict、set、str 等；</p>
<p>一类是 generator，包括生成器和带 yield 的 generator function。</p>
<p>这些可以直接作用于 for 循环的对象统称为可迭代对象: Iterable。</p>
<p>可以使用 isinstance()判断一个对象是否是 Iterable 对象:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> collections<span>.</span>abc <span>import</span> Iterable
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>[</span><span>]</span><span>,</span> Iterable<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>{</span><span>}</span><span>,</span> Iterable<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>'abc'</span><span>,</span> Iterable<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>(</span>x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>,</span> Iterable<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>100</span><span>,</span> Iterable<span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>而生成器不但可以作用于 for 循环，还可以被 <code>next()</code> 函数不断调用并返回下一个值，直到最后抛出 <code>StopIteration</code> 错误表示无法继续返回下一个值了。</p>
<p>可以被 <code>next()</code> 函数调用并不断返回下一个值的对象称为迭代器: <code>Iterator</code>。</p>
<p>可以使用 <code>isinstance()</code> 判断一个对象是否是 <code>Iterator</code> 对象:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> collections<span>.</span>abc <span>import</span> Iterator
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>(</span>x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>,</span> Iterator<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>[</span><span>]</span><span>,</span> Iterator<span>)</span>
<span>False</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>{</span><span>}</span><span>,</span> Iterator<span>)</span>
<span>False</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>'abc'</span><span>,</span> Iterator<span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>生成器都是 <code>Iterator</code> 对象，但 list、dict、str 虽然是 <code>Iterable</code>，却不是 <code>Iterator</code>。</p>
<p>把 list、dict、str 等 <code>Iterable</code> 变成 <code>Iterator</code> 可以使用 <code>iter()</code> 函数:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span><span>iter</span><span>(</span><span>[</span><span>]</span><span>)</span><span>,</span> Iterator<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>iter</span><span>(</span><span>'abc'</span><span>)</span><span>,</span> Iterator<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>您可能会问，为什么 list、dict、str 等数据类型不是 <code>Iterator</code>?</p>
<p>这是因为 Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 <code>next()</code> 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next()函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator 甚至可以表示一个无限大的数据流，例如全体自然数。而使用 list 是永远不可能存储全体自然数的。</p>
<h2 id="小结"> 小结</h2>
<p>凡是可作用于 for 循环的对象都是 <code>Iterable</code> 类型；</p>
<p>凡是可作用于 <code>next()</code> 函数的对象都是 <code>Iterator</code> 类型，它们表示一个惰性计算的序列；</p>
<p>集合数据类型如 list、dict、str 等是 <code>Iterable</code> 但不是 <code>Iterator</code>，不过可以通过 <code>iter()</code> 函数获得一个 <code>Iterator</code> 对象。</p>
<p>Python 的 for 循环本质上就是通过不断调用 <code>next()</code> 函数实现的，例如:</p>
<div><pre><code><span>for</span> x <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>实际上完全等价于:</p>
<div><pre><code><span># 首先获得Iterator对象</span>

it <span>=</span> <span>iter</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>)</span>

<span># 循环</span>

<span>while</span> <span>True</span><span>:</span>
    <span>try</span><span>:</span>
        <span># 获得下一个值:</span>
        x <span>=</span> <span>next</span><span>(</span>it<span>)</span>
    <span>except</span> StopIteration<span>:</span>
        <span># 遇到StopIteration就退出循环</span>
        <span>break</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-29T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">列表生成式</title>
    <id>https://list-jiang.github.io/code/language/python/advance/list-comprehensions/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/list-comprehensions/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式。</p>
]]></summary>
    <content type="html"><![CDATA[<p>列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式。</p>

<p>举个例子，要生成 list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> 可以用 <code>list(range(1, 11))</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>list</span><span>(</span><span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但如果要生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code> 怎么做? 方法一是循环:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>    L<span>.</span>append<span>(</span>x <span>*</span> x<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> L
<span>[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>,</span> <span>25</span><span>,</span> <span>36</span><span>,</span> <span>49</span><span>,</span> <span>64</span><span>,</span> <span>81</span><span>,</span> <span>100</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的 list:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>*</span> x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>,</span> <span>25</span><span>,</span> <span>36</span><span>,</span> <span>49</span><span>,</span> <span>64</span><span>,</span> <span>81</span><span>,</span> <span>100</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>写列表生成式时，把要生成的元素 <code>x * x</code> 放到前面，后面跟 for 循环，就可以把 list 创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for 循环后面还可以加上 if 判断，这样我们就可以筛选出仅偶数的平方:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>*</span> x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span> <span>if</span> x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>]</span>
<span>[</span><span>4</span><span>,</span> <span>16</span><span>,</span> <span>36</span><span>,</span> <span>64</span><span>,</span> <span>100</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>还可以使用两层循环，可以生成全排列:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>m <span>+</span> n <span>for</span> m <span>in</span> <span>'ABC'</span> <span>for</span> n <span>in</span> <span>'XYZ'</span><span>]</span>
<span>[</span><span>'AX'</span><span>,</span> <span>'AY'</span><span>,</span> <span>'AZ'</span><span>,</span> <span>'BX'</span><span>,</span> <span>'BY'</span><span>,</span> <span>'BZ'</span><span>,</span> <span>'CX'</span><span>,</span> <span>'CY'</span><span>,</span> <span>'CZ'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>三层和三层以上的循环就很少用到了。</p>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> os <span># 导入os模块，模块的概念后面讲到</span>
<span>>></span><span>></span> <span>[</span>d <span>for</span> d <span>in</span> os<span>.</span>listdir<span>(</span><span>'.'</span><span>)</span><span>]</span> <span># os.listdir可以列出文件和目录</span>
<span>[</span><span>'.emacs.d'</span><span>,</span> <span>'.ssh'</span><span>,</span> <span>'.Trash'</span><span>,</span> <span>'Adlm'</span><span>,</span> <span>'Applications'</span><span>,</span> <span>'Desktop'</span><span>,</span> <span>'Documents'</span><span>,</span> <span>'Downloads'</span><span>,</span> <span>'Library'</span><span>,</span> <span>'Movies'</span><span>,</span> <span>'Music'</span><span>,</span> <span>'Pictures'</span><span>,</span> <span>'Public'</span><span>,</span> <span>'VirtualBox VMs'</span><span>,</span> <span>'Workspace'</span><span>,</span> <span>'XCode'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 <code>items()</code> 可以同时迭代 key 和 value:</p>
<div><pre><code><span>>></span><span>></span> d <span>=</span> <span>{</span><span>'x'</span><span>:</span> <span>'A'</span><span>,</span> <span>'y'</span><span>:</span> <span>'B'</span><span>,</span> <span>'z'</span><span>:</span> <span>'C'</span> <span>}</span>
<span>>></span><span>></span> <span>for</span> k<span>,</span> v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>k<span>,</span> <span>'='</span><span>,</span> v<span>)</span>
<span>.</span><span>.</span><span>.</span>
y <span>=</span> B
x <span>=</span> A
z <span>=</span> C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>因此，列表生成式也可以使用两个变量来生成 list:</p>
<div><pre><code><span>>></span><span>></span> d <span>=</span> <span>{</span><span>'x'</span><span>:</span> <span>'A'</span><span>,</span> <span>'y'</span><span>:</span> <span>'B'</span><span>,</span> <span>'z'</span><span>:</span> <span>'C'</span> <span>}</span>
<span>>></span><span>></span> <span>[</span>k <span>+</span> <span>'='</span> <span>+</span> v <span>for</span> k<span>,</span> v <span>in</span> d<span>.</span>items<span>(</span><span>)</span><span>]</span>
<span>[</span><span>'y=B'</span><span>,</span> <span>'x=A'</span><span>,</span> <span>'z=C'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最后把一个 list 中所有的字符串变成小写:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span><span>'Hello'</span><span>,</span> <span>'World'</span><span>,</span> <span>'IBM'</span><span>,</span> <span>'Apple'</span><span>]</span>
<span>>></span><span>></span> <span>[</span>s<span>.</span>lower<span>(</span><span>)</span> <span>for</span> s <span>in</span> L<span>]</span>
<span>[</span><span>'hello'</span><span>,</span> <span>'world'</span><span>,</span> <span>'ibm'</span><span>,</span> <span>'apple'</span><span>]</span>
<span>if</span> <span>.</span><span>.</span><span>.</span> <span>else</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用列表生成式的时候，有些童鞋经常搞不清楚 if...else 的用法。</p>
<p>例如，以下代码正常输出偶数:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span> <span>if</span> x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>]</span>
<span>[</span><span>2</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>,</span> <span>10</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是，我们不能在最后的 if 加上 else:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>for</span> <span>x</span> <span>in</span> range<span>(</span><span>1</span>, <span>11</span><span>)</span> <span>if</span> x % <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>0</span><span>]</span>
  File <span>"&lt;stdin>"</span>, line <span>1</span>
    <span>[</span>x <span>for</span> <span>x</span> <span>in</span> range<span>(</span><span>1</span>, <span>11</span><span>)</span> <span>if</span> x % <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>0</span><span>]</span>
                                              ^
SyntaxError: invalid syntax
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这是因为跟在 for 后面的 if 是一个筛选条件，不能带 else，否则如何筛选?</p>
<p>另一些童鞋发现把 if 写在 for 前面必须加 else，否则报错:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>if</span> x % <span>2</span> <span>==</span> <span>0</span> <span>for</span> <span>x</span> <span>in</span> range<span>(</span><span>1</span>, <span>11</span><span>)</span><span>]</span>
  File <span>"&lt;stdin>"</span>, line <span>1</span>
    <span>[</span>x <span>if</span> x % <span>2</span> <span>==</span> <span>0</span> <span>for</span> <span>x</span> <span>in</span> range<span>(</span><span>1</span>, <span>11</span><span>)</span><span>]</span>
                       ^
SyntaxError: invalid syntax
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这是因为 for 前面的部分是一个表达式，它必须根据 x 计算出一个结果。因此，考察表达式: <code>x if x % 2 == 0</code>，它无法根据 x 计算出结果，因为缺少 else，必须加上 else:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>x <span>if</span> x <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>-</span>x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>11</span><span>)</span><span>]</span>
<span>[</span><span>-</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>-</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>-</span><span>9</span><span>,</span> <span>10</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上述 for 前面的表达式 <code>x if x % 2 == 0 else -x</code> 才能根据 x 计算出确定的结果。</p>
<p>可见，在一个列表生成式中，for 前面的 <code>if ... else</code> 是表达式，而 for 后面的 if 是过滤条件，不能带 else。</p>
<h2 id="小结"> 小结</h2>
<p>运用列表生成式，可以快速生成 list，可以通过一个 list 推导出另一个 list，而代码却十分简洁。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-05-29T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Python 高级语法</title>
    <id>https://list-jiang.github.io/code/language/python/advance/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./slice.html">切片</a></p>
</li>
<li>
<p><a href="./iteration.html">迭代</a></p>
</li>
<li>
<p><a href="./list-comprehensions.html">列表生成式</a></p>
</li>
<li>
<p><a href="./generator.html">生成器</a></p>
</li>
<li>
<p><a href="./iterator.html">迭代器</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">切片</title>
    <id>https://list-jiang.github.io/code/language/python/advance/slice/</id>
    <link href="https://list-jiang.github.io/code/language/python/advance/slice/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>取一个 list 或 tuple 的部分元素是非常常见的操作。比如，一个 list 如下:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Jack'</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>取前 3 个元素，应该怎么做?</p>
<p>笨办法:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span>L<span>[</span><span>0</span><span>]</span><span>,</span> L<span>[</span><span>1</span><span>]</span><span>,</span> L<span>[</span><span>2</span><span>]</span><span>]</span>
<span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>之所以是笨办法是因为扩展一下，取前 N 个元素就没辙了。</p>
<p>取前 N 个元素，也就是索引为 0-(N-1)的元素，可以用循环:</p>
<div><pre><code><span>>></span><span>></span> r <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> n <span>=</span> <span>3</span>
<span>>></span><span>></span> <span>for</span> i <span>in</span> <span>range</span><span>(</span>n<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     r<span>.</span>append<span>(</span>L<span>[</span>i<span>]</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> r
<span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python 提供了切片(Slice)操作符，能大大简化这种操作。</p>
<p>对应上面的问题，取前 3 个元素，用一行代码就可以完成切片:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>0</span><span>:</span><span>3</span><span>]</span>
<span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>L[0:3]</code> 表示，从索引 0 开始取，直到索引 3 为止，但不包括索引 3。即索引 0，1，2，正好是 3 个元素。</p>
<p>如果第一个索引是 0，还可以省略:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>:</span><span>3</span><span>]</span>
<span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
也可以从索引<span>1</span>开始，取出<span>2</span>个元素出来<span>:</span>
<span>>></span><span>></span> L<span>[</span><span>1</span><span>:</span><span>3</span><span>]</span>
<span>[</span><span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
类似的，既然Python支持L<span>[</span><span>-</span><span>1</span><span>]</span>取倒数第一个元素，那么它同样支持倒数切片，试试<span>:</span>
<span>>></span><span>></span> L<span>[</span><span>-</span><span>2</span><span>:</span><span>]</span>
<span>[</span><span>'Bob'</span><span>,</span> <span>'Jack'</span><span>]</span>
<span>>></span><span>></span> L<span>[</span><span>-</span><span>2</span><span>:</span><span>-</span><span>1</span><span>]</span>
<span>[</span><span>'Bob'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>记住倒数第一个元素的索引是 <code>-1</code>。</p>
<p>切片操作十分有用。我们先创建一个 0-99 的数列:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>100</span><span>)</span><span>)</span>
<span>>></span><span>></span> L
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> <span>99</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以通过切片轻松取出某一段数列。比如前 10 个数:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>:</span><span>10</span><span>]</span>
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>后 10 个数:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>-</span><span>10</span><span>:</span><span>]</span>
<span>[</span><span>90</span><span>,</span> <span>91</span><span>,</span> <span>92</span><span>,</span> <span>93</span><span>,</span> <span>94</span><span>,</span> <span>95</span><span>,</span> <span>96</span><span>,</span> <span>97</span><span>,</span> <span>98</span><span>,</span> <span>99</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>前 11-20 个数:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>10</span><span>:</span><span>20</span><span>]</span>
<span>[</span><span>10</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>14</span><span>,</span> <span>15</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>19</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>前 10 个数，每两个取一个:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>:</span><span>10</span><span>:</span><span>2</span><span>]</span>
<span>[</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>8</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>所有数，每 5 个取一个:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>:</span><span>:</span><span>5</span><span>]</span>
<span>[</span><span>0</span><span>,</span> <span>5</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>,</span> <span>20</span><span>,</span> <span>25</span><span>,</span> <span>30</span><span>,</span> <span>35</span><span>,</span> <span>40</span><span>,</span> <span>45</span><span>,</span> <span>50</span><span>,</span> <span>55</span><span>,</span> <span>60</span><span>,</span> <span>65</span><span>,</span> <span>70</span><span>,</span> <span>75</span><span>,</span> <span>80</span><span>,</span> <span>85</span><span>,</span> <span>90</span><span>,</span> <span>95</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>甚至什么都不写，只写 <code>[:]</code> 就可以原样复制一个 list:</p>
<div><pre><code><span>>></span><span>></span> L<span>[</span><span>:</span><span>]</span>
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>,</span> <span>99</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>tuple 也是一种 list，唯一区别是 tuple 不可变。因此，tuple 也可以用切片操作，只是操作的结果仍是 tuple:</p>
<div><pre><code><span>>></span><span>></span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>(</span><span>:</span><span>3</span><span>)</span>
<span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>字符串 <code>'xxx'</code> 也可以看成是一种 list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串:</p>
<div><pre><code><span>>></span><span>></span> <span>'ABCDEFG'</span><span>[</span><span>:</span><span>3</span><span>]</span>
<span>'ABC'</span>
<span>>></span><span>></span> <span>'ABCDEFG'</span><span>[</span><span>:</span><span>:</span><span>2</span><span>]</span>
<span>'ACEG'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在很多编程语言中，针对字符串提供了很多各种截取函数(例如，substring)，其实目的就是对字符串切片。Python 没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<h2 id="小结"> 小结</h2>
<p>有了切片操作，很多地方循环就不再需要了。Python 的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">函数的参数</title>
    <id>https://list-jiang.github.io/code/language/python/function/argument/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/argument/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python 的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
]]></summary>
    <content type="html"><![CDATA[<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p>
<p>Python 的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>

<h2 id="位置参数"> 位置参数</h2>
<p>我们先写一个计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> 的函数:</p>
<div><pre><code><span>def</span> <span>power</span><span>(</span>x<span>)</span><span>:</span>
    <span>return</span> x <span>*</span> x
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于 <code>power(x)</code> 函数，参数 <code>x</code> 就是一个位置参数。</p>
<p>当我们调用 <code>power</code> 函数时，必须传入有且仅有的一个参数 x:</p>
<div><pre><code><span>>></span><span>></span> power<span>(</span><span>5</span><span>)</span>
<span>25</span>
<span>>></span><span>></span> power<span>(</span><span>15</span><span>)</span>
<span>225</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，如果我们要计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>3</span></span></span></span></span></span></span></span></span></span></span> 怎么办? 可以再定义一个 <code>power3</code> 函数，但是如果要计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span>、<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span>……怎么办? 我们不可能定义无限多个函数。</p>
<p>您也许想到了，可以把 <code>power(x)</code> 修改为 <code>power(x, n)</code>，用来计算 x<sup>n</sup>，说干就干:</p>
<div><pre><code><span>def</span> <span>power</span><span>(</span>x<span>,</span> n<span>)</span><span>:</span>
    s <span>=</span> <span>1</span>
    <span>while</span> n <span>></span> <span>0</span><span>:</span>
        n <span>=</span> n <span>-</span> <span>1</span>
        s <span>=</span> s <span>*</span> x
    <span>return</span> s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对于这个修改后的 <code>power(x, n)</code> 函数，可以计算任意 n 次方:</p>
<div><pre><code><span>>></span><span>></span> power<span>(</span><span>5</span><span>,</span> <span>2</span><span>)</span>
<span>25</span>
<span>>></span><span>></span> power<span>(</span><span>5</span><span>,</span> <span>3</span><span>)</span>
<span>125</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修改后的 <code>power(x, n)</code> 函数有两个参数: x 和 n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数 x 和 n。</p>
<h2 id="默认参数"> 默认参数</h2>
<p>新的 <code>power(x, n)</code> 函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用:</p>
<div><pre><code><span>>></span><span>></span> power<span>(</span><span>5</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: power<span>(</span><span>)</span> missing <span>1</span> required positional argument: <span>'n'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Python 的错误信息很明确: 调用函数 <code>power()</code> 缺少了一个位置参数 <code>n</code>。</p>
<p>这个时候，默认参数就排上用场了。由于我们经常计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span>，所以，完全可以把第二个参数 n 的默认值设定为 2:</p>
<div><pre><code><span>def</span> <span>power</span><span>(</span>x<span>,</span> n<span>=</span><span>2</span><span>)</span><span>:</span>
    s <span>=</span> <span>1</span>
    <span>while</span> n <span>></span> <span>0</span><span>:</span>
        n <span>=</span> n <span>-</span> <span>1</span>
        s <span>=</span> s <span>*</span> x
    <span>return</span> s
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这样，当我们调用 <code>power(5)</code> 时，相当于调用 <code>power(5, 2)</code>:</p>
<div><pre><code><span>>></span><span>></span> power<span>(</span><span>5</span><span>)</span>
<span>25</span>
<span>>></span><span>></span> power<span>(</span><span>5</span><span>,</span> <span>2</span><span>)</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>而对于 <code>n &gt; 2</code> 的其他情况，就必须明确地传入 n，比如 <code>power(5, 3)</code>。</p>
<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意:</p>
<ol>
<li>
<p>必选参数在前，默认参数在后，否则 Python 的解释器会报错(思考一下为什么默认参数不能放在必选参数前面)；</p>
</li>
<li>
<p>设置默认参数: 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ol>
<h3 id="优点"> 优点</h3>
<p>最大的好处是能降低调用函数的难度。</p>
<p>举个例子，我们写个一年级小学生注册的函数，需要传入 <code>name</code> 和 <code>gender</code> 两个参数:</p>
<div><pre><code><span>def</span> <span>enroll</span><span>(</span>name<span>,</span> gender<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'name:'</span><span>,</span> name<span>)</span>
    <span>print</span><span>(</span><span>'gender:'</span><span>,</span> gender<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这样，调用 <code>enroll()</code> 函数只需要传入两个参数:</p>
<div><pre><code><span>>></span><span>></span> enroll<span>(</span><span>'Sarah'</span><span>,</span> <span>'F'</span><span>)</span>
name<span>:</span> Sarah
gender<span>:</span> F
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果要继续传入年龄、城市等信息怎么办? 这样会使得调用函数的复杂度大大增加。</p>
<p>我们可以把年龄和城市设为默认参数:</p>
<div><pre><code><span>def</span> <span>enroll</span><span>(</span>name<span>,</span> gender<span>,</span> age<span>=</span><span>6</span><span>,</span> city<span>=</span><span>'Beijing'</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'name:'</span><span>,</span> name<span>)</span>
    <span>print</span><span>(</span><span>'gender:'</span><span>,</span> gender<span>)</span>
    <span>print</span><span>(</span><span>'age:'</span><span>,</span> age<span>)</span>
    <span>print</span><span>(</span><span>'city:'</span><span>,</span> city<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数:</p>
<div><pre><code><span>>></span><span>></span> enroll<span>(</span><span>'Sarah'</span><span>,</span> <span>'F'</span><span>)</span>
name<span>:</span> Sarah
gender<span>:</span> F
age<span>:</span> <span>6</span>
city<span>:</span> Beijing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>只有与默认参数不符的学生才需要提供额外的信息:</p>
<div><pre><code>enroll<span>(</span><span>'Bob'</span><span>,</span> <span>'M'</span><span>,</span> <span>7</span><span>)</span>
enroll<span>(</span><span>'Adam'</span><span>,</span> <span>'M'</span><span>,</span> city<span>=</span><span>'Tianjin'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用 <code>enroll('Bob', 'M', 7)</code>，意思是，除了 <code>name</code>，<code>gender</code> 这两个参数外，最后 1 个参数应用在参数 <code>age</code> 上，<code>city</code> 参数由于没有提供，仍然使用默认值。</p>
<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用 <code>enroll('Adam', 'M', city='Tianjin')</code>，意思是，<code>city</code> 参数用传进去的值，其他默认参数继续使用默认值。</p>
<h3 id="缺点"> 缺点</h3>
<p>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下:</p>
<p>先定义一个函数，传入一个 list，添加一个 <code>END</code> 再返回:</p>
<div><pre><code><span>def</span> <span>add_end</span><span>(</span>L<span>=</span><span>[</span><span>]</span><span>)</span><span>:</span>
    L<span>.</span>append<span>(</span><span>'END'</span><span>)</span>
    <span>return</span> L
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当您正常调用时，结果似乎不错:</p>
<div><pre><code><span>>></span><span>></span> add_end<span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>'END'</span><span>]</span>
<span>>></span><span>></span> add_end<span>(</span><span>[</span><span>'x'</span><span>,</span> <span>'y'</span><span>,</span> <span>'z'</span><span>]</span><span>)</span>
<span>[</span><span>'x'</span><span>,</span> <span>'y'</span><span>,</span> <span>'z'</span><span>,</span> <span>'END'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当您使用默认参数调用时，一开始结果也是对的:</p>
<div><pre><code><span>>></span><span>></span> add_end<span>(</span><span>)</span>
<span>[</span><span>'END'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是，再次调用 <code>add_end()</code> 时，结果就不对了:</p>
<div><pre><code><span>>></span><span>></span> add_end<span>(</span><span>)</span>
<span>[</span><span>'END'</span><span>,</span> <span>'END'</span><span>]</span>
<span>>></span><span>></span> add_end<span>(</span><span>)</span>
<span>[</span><span>'END'</span><span>,</span> <span>'END'</span><span>,</span> <span>'END'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>很多初学者很疑惑，默认参数是 <code>[]</code>，但是函数似乎每次都“记住了”上次添加了 <code>'END'</code> 后的 list。</p>
<p>原因解释如下:</p>
<p>Python 函数在定义的时候，默认参数 <code>L</code> 的值就被计算出来了，即 <code>[]</code> ，因为默认参数 L 也是一个变量，它指向对象 <code>[]</code>，每次调用该函数，如果改变了 <code>L</code> 的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的 <code>[]</code> 了。</p>
<div><p>注意</p>
<p>定义默认参数要牢记一点: 默认参数必须指向不变对象!</p>
</div>
<p>要修改上面的例子，我们可以用 None 这个不变对象来实现:</p>
<div><pre><code><span>def</span> <span>add_end</span><span>(</span>L<span>=</span><span>None</span><span>)</span><span>:</span>
    <span>if</span> L <span>is</span> <span>None</span><span>:</span>
        L <span>=</span> <span>[</span><span>]</span>
    L<span>.</span>append<span>(</span><span>'END'</span><span>)</span>
    <span>return</span> L
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在，无论调用多少次，都不会有问题:</p>
<div><pre><code><span>>></span><span>></span> add_end<span>(</span><span>)</span>
<span>[</span><span>'END'</span><span>]</span>
<span>>></span><span>></span> add_end<span>(</span><span>)</span>
<span>[</span><span>'END'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>尽可能使用不变对象</p>
<p>为什么要设计 <code>str</code>、<code>None</code> 这样的不变对象呢? 因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
</div>
<h2 id="可变参数"> 可变参数</h2>
<p>在 Python 函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是 1 个、2 个到任意个，还可以是 0 个。</p>
<p>我们以数学题为例子，给定一组数字 a，b，c……，请计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>a</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>b</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>c</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.313em;"></span><span>⋯</span></span></span></span>。</p>
<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把 a，b，c……作为一个 list 或 tuple 传进来，这样，函数可以定义如下:</p>
<div><pre><code><span>def</span> <span>calc</span><span>(</span>numbers<span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>0</span>
    <span>for</span> n <span>in</span> numbers<span>:</span>
        <span>sum</span> <span>=</span> <span>sum</span> <span>+</span> n <span>*</span> n
    <span>return</span> <span>sum</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是调用的时候，需要先组装出一个 list 或 tuple:</p>
<div><pre><code><span>>></span><span>></span> calc<span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>14</span>
<span>>></span><span>></span> calc<span>(</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>)</span><span>)</span>
<span>84</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果利用可变参数，调用函数的方式可以简化成这样:</p>
<div><pre><code><span>>></span><span>></span> calc<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
<span>14</span>
<span>>></span><span>></span> calc<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>)</span>
<span>84</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>所以，我们把函数的参数改为可变参数:</p>
<div><pre><code><span>def</span> <span>calc</span><span>(</span><span>*</span>numbers<span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>0</span>
    <span>for</span> n <span>in</span> numbers<span>:</span>
<span>sum</span> <span>=</span> <span>sum</span> <span>+</span> n<span>*</span> n
    <span>return</span> <span>sum</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>定义可变参数和定义一个 list 或 tuple 参数相比，仅仅在参数前面加了一个 <code>*</code> 号。在函数内部，参数 <code>numbers</code> 接收到的是一个 tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括 0 个参数:</p>
<div><pre><code><span>>></span><span>></span> calc<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>5</span>
<span>>></span><span>></span> calc<span>(</span><span>)</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果已经有一个 list 或者 tuple，要调用一个可变参数怎么办? 可以这样做:</p>
<div><pre><code><span>>></span><span>></span> nums <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>>></span><span>></span> calc<span>(</span>nums<span>[</span><span>0</span><span>]</span><span>,</span> nums<span>[</span><span>1</span><span>]</span><span>,</span> nums<span>[</span><span>2</span><span>]</span><span>)</span>
<span>14</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这种写法当然是可行的，问题是太繁琐，所以 Python 允许您在 list 或 tuple 前面加一个 <code>*</code> 号，把 list 或 tuple 的元素变成可变参数传进去:</p>
<div><pre><code><span>>></span><span>></span> nums <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>>></span><span>></span> calc<span>(</span><span>*</span>nums<span>)</span>
<span>14</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>*nums</code> 表示把 <code>nums</code> 这个 list 的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h2 id="关键字参数"> 关键字参数</h2>
<p>可变参数允许您传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。而关键字参数允许您传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。请看示例:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'name:'</span><span>,</span> name<span>,</span> <span>'age:'</span><span>,</span> age<span>,</span> <span>'other:'</span><span>,</span> kw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>函数 <code>person</code> 除了必选参数 <code>name</code> 和 <code>age</code> 外，还接受关键字参数 <code>kw</code>。在调用该函数时，可以只传入必选参数:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Michael'</span><span>,</span> <span>30</span><span>)</span>
name<span>:</span> Michael age<span>:</span> <span>30</span> other<span>:</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以传入任意个数的关键字参数:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Bob'</span><span>,</span> <span>35</span><span>,</span> city<span>=</span><span>'Beijing'</span><span>)</span>
name<span>:</span> Bob age<span>:</span> <span>35</span> other<span>:</span> <span>{</span><span>'city'</span><span>:</span> <span>'Beijing'</span><span>}</span>
<span>>></span><span>></span> person<span>(</span><span>'Adam'</span><span>,</span> <span>45</span><span>,</span> gender<span>=</span><span>'M'</span><span>,</span> job<span>=</span><span>'Engineer'</span><span>)</span>
name<span>:</span> Adam age<span>:</span> <span>45</span> other<span>:</span> <span>{</span><span>'gender'</span><span>:</span> <span>'M'</span><span>,</span> <span>'job'</span><span>:</span> <span>'Engineer'</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>关键字参数有什么用? 它可以扩展函数的功能。比如，在 <code>person</code> 函数里，我们保证能接收到 <code>name</code> 和 <code>age</code> 这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想您正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<p>和可变参数类似，也可以先组装出一个 dict，然后，把该 dict 转换为关键字参数传进去:</p>
<div><pre><code><span>>></span><span>></span> extra <span>=</span> <span>{</span><span>'city'</span><span>:</span> <span>'Beijing'</span><span>,</span> <span>'job'</span><span>:</span> <span>'Engineer'</span><span>}</span>
<span>>></span><span>></span> person<span>(</span><span>'Jack'</span><span>,</span> <span>24</span><span>,</span> city<span>=</span>extra<span>[</span><span>'city'</span><span>]</span><span>,</span> job<span>=</span>extra<span>[</span><span>'job'</span><span>]</span><span>)</span>
name<span>:</span> Jack age<span>:</span> <span>24</span> other<span>:</span> <span>{</span><span>'city'</span><span>:</span> <span>'Beijing'</span><span>,</span> <span>'job'</span><span>:</span> <span>'Engineer'</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当然，上面复杂的调用可以用简化的写法:</p>
<div><pre><code><span>>></span><span>></span> extra <span>=</span> <span>{</span><span>'city'</span><span>:</span> <span>'Beijing'</span><span>,</span> <span>'job'</span><span>:</span> <span>'Engineer'</span><span>}</span>
<span>>></span><span>></span> person<span>(</span><span>'Jack'</span><span>,</span> <span>24</span><span>,</span> <span>**</span>extra<span>)</span>
name<span>:</span> Jack age<span>:</span> <span>24</span> other<span>:</span> <span>{</span><span>'city'</span><span>:</span> <span>'Beijing'</span><span>,</span> <span>'job'</span><span>:</span> <span>'Engineer'</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>**extra</code> 表示把 <code>extra</code> 这个 dict 的所有 key-value 用关键字参数传入到函数的 <code>**kw</code> 参数，<code>kw</code> 将获得一个 dict，注意 <code>kw</code> 获得的 dict 是 <code>extra</code> 的一份拷贝，对 <code>kw</code> 的改动不会影响到函数外的 <code>extra</code>。</p>
<h2 id="命名关键字参数"> 命名关键字参数</h2>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过 kw 检查。</p>
<p>仍以 <code>person()</code> 函数为例，我们希望检查是否有 <code>city</code> 和 <code>job</code> 参数:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
    <span>if</span> <span>'city'</span> <span>in</span> kw<span>:</span>
        <span># 有 city 参数</span>
        <span>pass</span>
    <span>if</span> <span>'job'</span> <span>in</span> kw<span>:</span>
        <span># 有 job 参数</span>
        <span>pass</span>
    <span>print</span><span>(</span><span>'name:'</span><span>,</span> name<span>,</span> <span>'age:'</span><span>,</span> age<span>,</span> <span>'other:'</span><span>,</span> kw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是调用者仍可以传入不受限制的关键字参数:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Jack'</span><span>,</span> <span>24</span><span>,</span> city<span>=</span><span>'Beijing'</span><span>,</span> addr<span>=</span><span>'Chaoyang'</span><span>,</span> zipcode<span>=</span><span>123456</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收 city 和 job 作为关键字参数。这种方式定义的函数如下:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> <span>*</span><span>,</span> city<span>,</span> job<span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>,</span> age<span>,</span> city<span>,</span> job<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>和关键字参数 <code>**kw</code> 不同，命名关键字参数需要一个特殊分隔符 <code>*</code>，<code>*</code> 后面的参数被视为命名关键字参数。</p>
<p>调用方式如下:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Jack'</span><span>,</span> <span>24</span><span>,</span> city<span>=</span><span>'Beijing'</span><span>,</span> job<span>=</span><span>'Engineer'</span><span>)</span>
Jack <span>24</span> Beijing Engineer
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 <code>*</code> 了:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> <span>*</span>args<span>,</span> city<span>,</span> job<span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>,</span> age<span>,</span> args<span>,</span> city<span>,</span> job<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Jack'</span>, <span>24</span>, <span>'Beijing'</span>, <span>'Engineer'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: person<span>(</span><span>)</span> takes <span>2</span> positional arguments but <span>4</span> were given
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>由于调用时缺少参数名 <code>city</code> 和 <code>job</code>，Python 解释器把这 4 个参数均视为位置参数，但 <code>person()</code> 函数仅接受 2 个位置参数。</p>
<p>命名关键字参数可以有缺省值，从而简化调用:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> <span>*</span><span>,</span> city<span>=</span><span>'Beijing'</span><span>,</span> job<span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>,</span> age<span>,</span> city<span>,</span> job<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于命名关键字参数 <code>city</code> 具有默认值，调用时，可不传入 <code>city</code> 参数:</p>
<div><pre><code><span>>></span><span>></span> person<span>(</span><span>'Jack'</span><span>,</span> <span>24</span><span>,</span> job<span>=</span><span>'Engineer'</span><span>)</span>
Jack <span>24</span> Beijing Engineer
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个 <code>*</code> 作为特殊分隔符。如果缺少 <code>*</code>，Python 解释器将无法识别位置参数和命名关键字参数:</p>
<div><pre><code><span>def</span> <span>person</span><span>(</span>name<span>,</span> age<span>,</span> city<span>,</span> job<span>)</span><span>:</span>
    <span># 缺少 *，city 和 job 被视为位置参数</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="参数组合"> 参数组合</h2>
<p>在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。但是请注意，参数定义的顺序必须是: 必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>比如定义一个函数，包含上述若干种参数:</p>
<div><pre><code><span>def</span> <span>f1</span><span>(</span>a<span>,</span> b<span>,</span> c<span>=</span><span>0</span><span>,</span> <span>*</span>args<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'a ='</span><span>,</span> a<span>,</span> <span>'b ='</span><span>,</span> b<span>,</span> <span>'c ='</span><span>,</span> c<span>,</span> <span>'args ='</span><span>,</span> args<span>,</span> <span>'kw ='</span><span>,</span> kw<span>)</span>

<span>def</span> <span>f2</span><span>(</span>a<span>,</span> b<span>,</span> c<span>=</span><span>0</span><span>,</span> <span>*</span><span>,</span> d<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'a ='</span><span>,</span> a<span>,</span> <span>'b ='</span><span>,</span> b<span>,</span> <span>'c ='</span><span>,</span> c<span>,</span> <span>'d ='</span><span>,</span> d<span>,</span> <span>'kw ='</span><span>,</span> kw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在函数调用的时候，Python 解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<div><pre><code><span>>></span><span>></span> f1<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>0</span> args <span>=</span> <span>(</span><span>)</span> kw <span>=</span> <span>{</span><span>}</span>
<span>>></span><span>></span> f1<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> c<span>=</span><span>3</span><span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>3</span> args <span>=</span> <span>(</span><span>)</span> kw <span>=</span> <span>{</span><span>}</span>
<span>>></span><span>></span> f1<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>3</span> args <span>=</span> <span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span> kw <span>=</span> <span>{</span><span>}</span>
<span>>></span><span>></span> f1<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>,</span> x<span>=</span><span>99</span><span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>3</span> args <span>=</span> <span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span> kw <span>=</span> <span>{</span><span>'x'</span><span>:</span> <span>99</span><span>}</span>
<span>>></span><span>></span> f2<span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> d<span>=</span><span>99</span><span>,</span> ext<span>=</span><span>None</span><span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>0</span> d <span>=</span> <span>99</span> kw <span>=</span> <span>{</span><span>'ext'</span><span>:</span> <span>None</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>最神奇的是通过一个 tuple 和 dict，您也可以调用上述函数:</p>
<div><pre><code><span>>></span><span>></span> args <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>)</span>
<span>>></span><span>></span> kw <span>=</span> <span>{</span><span>'d'</span><span>:</span> <span>99</span><span>,</span> <span>'x'</span><span>:</span> <span>'#'</span><span>}</span>
<span>>></span><span>></span> f1<span>(</span><span>*</span>args<span>,</span> <span>**</span>kw<span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>3</span> args <span>=</span> <span>(</span><span>4</span><span>,</span><span>)</span> kw <span>=</span> <span>{</span><span>'d'</span><span>:</span> <span>99</span><span>,</span> <span>'x'</span><span>:</span> <span>'#'</span><span>}</span>
<span>>></span><span>></span> args <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span>
<span>>></span><span>></span> kw <span>=</span> <span>{</span><span>'d'</span><span>:</span> <span>88</span><span>,</span> <span>'x'</span><span>:</span> <span>'#'</span><span>}</span>
<span>>></span><span>></span> f2<span>(</span><span>*</span>args<span>,</span><span>**</span>kw<span>)</span>
a <span>=</span> <span>1</span> b <span>=</span> <span>2</span> c <span>=</span> <span>3</span> d <span>=</span> <span>88</span> kw <span>=</span> <span>{</span><span>'x'</span><span>:</span> <span>'#'</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>所以，对于任意函数，都可以通过类似 <code>func(*args, **kw)</code> 的形式调用它，无论它的参数是如何定义的。</p>
<div><p>提示</p>
<p>虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
</div>
<h2 id="小结"> 小结</h2>
<p>Python 的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误!</p>
<p>要注意定义可变参数和关键字参数的语法:</p>
<p><code>*args</code> 是可变参数，args 接收的是一个 tuple；</p>
<p><code>**kw</code> 是关键字参数，kw 接收的是一个 dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法:</p>
<p>可变参数既可以直接传入: <code>func(1, 2, 3)</code>，又可以先组装 list 或 tuple，再通过 <code>*args</code> 传入: <code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入: <code>func(a=1, b=2)</code>，又可以先组装 dict，再通过 <code>**kw</code> 传入: <code>func(**{'a': 1, 'b': 2})</code>。</p>
<p>使用 <code>*args</code> 和 <code>**kw</code> 是 Python 的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符 <code>*</code>，否则定义的将是位置参数。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">调用函数</title>
    <id>https://list-jiang.github.io/code/language/python/function/call/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/call/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Python 内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 <code>abs</code>，只有一个参数。可以直接从 Python 的官方网站 <a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener noreferrer">查看文档</a>:</p>
]]></summary>
    <content type="html"><![CDATA[<p>Python 内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 <code>abs</code>，只有一个参数。可以直接从 Python 的官方网站 <a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener noreferrer">查看文档</a>:</p>

<p>也可以在交互式命令行通过 <code>help(abs)</code> 查看 <code>abs</code> 函数的帮助信息。</p>
<p>调用 <code>abs</code> 函数:</p>
<div><pre><code><span>>></span><span>></span> <span>abs</span><span>(</span><span>100</span><span>)</span>
<span>100</span>
<span>>></span><span>></span> <span>abs</span><span>(</span><span>-</span><span>20</span><span>)</span>
<span>20</span>
<span>>></span><span>></span> <span>abs</span><span>(</span><span>12.34</span><span>)</span>
<span>12.34</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>调用函数的时候，如果传入的参数数量不对，会报 <code>TypeError</code> 的错误，并且 Python 会明确地告诉您: <code>abs()</code> 有且仅有 1 个参数，但给出了两个:</p>
<div><pre><code><span>>></span><span>></span> abs<span>(</span><span>1</span>, <span>2</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: abs<span>(</span><span>)</span> takes exactly one argument <span>(</span><span>2</span> given<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报 <code>TypeError</code> 的错误，并且给出错误信息: str 是错误的参数类型:</p>
<div><pre><code><span>>></span><span>></span> abs<span>(</span><span>'a'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: bad operand <span>type</span> <span>for</span> abs<span>(</span><span>)</span>: <span>'str'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>而 max 函数 <code>max()</code> 可以接收任意多个参数，并返回最大的那个:</p>
<div><pre><code><span>>></span><span>></span> <span>max</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>2</span>
<span>>></span><span>></span> <span>max</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>-</span><span>5</span><span>)</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="数据类型转换"> 数据类型转换</h2>
<p>Python 内置的常用函数还包括数据类型转换函数，比如 <code>int()</code> 函数可以把其他数据类型转换为整数:</p>
<div><pre><code><span>>></span><span>></span> <span>int</span><span>(</span><span>'123'</span><span>)</span>
<span>123</span>
<span>>></span><span>></span> <span>int</span><span>(</span><span>12.34</span><span>)</span>
<span>12</span>
<span>>></span><span>></span> <span>float</span><span>(</span><span>'12.34'</span><span>)</span>
<span>12.34</span>
<span>>></span><span>></span> <span>str</span><span>(</span><span>1.23</span><span>)</span>
<span>'1.23'</span>
<span>>></span><span>></span> <span>str</span><span>(</span><span>100</span><span>)</span>
<span>'100'</span>
<span>>></span><span>></span> <span>bool</span><span>(</span><span>1</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>bool</span><span>(</span><span>''</span><span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”:</p>
<div><pre><code><span>>></span><span>></span> a <span>=</span> <span>abs</span> <span># 变量a指向abs函数</span>
<span>>></span><span>></span> a<span>(</span><span>-</span><span>1</span><span>)</span> <span># 所以也可以通过a调用abs函数</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="小结"> 小结</h2>
<p>调用 Python 的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要!</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-26T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">定义函数</title>
    <id>https://list-jiang.github.io/code/language/python/function/define/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/define/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在 Python 中，定义一个函数要使用 <code>def</code> 语句，依次写出函数名、括号、括号中的参数和冒号 <code>:</code>，然后，在缩进块中编写函数体，函数的返回值用 <code>return</code> 语句返回。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在 Python 中，定义一个函数要使用 <code>def</code> 语句，依次写出函数名、括号、括号中的参数和冒号 <code>:</code>，然后，在缩进块中编写函数体，函数的返回值用 <code>return</code> 语句返回。</p>

<p>我们以自定义一个求绝对值的 <code>my_abs</code> 函数为例:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>

<span>def</span> <span>my_abs</span><span>(</span>x<span>)</span><span>:</span>
    <span>if</span> x <span>>=</span> <span>0</span><span>:</span>
        <span>return</span> x
    <span>else</span><span>:</span>
        <span>return</span> <span>-</span>x

<span>print</span><span>(</span>my_abs<span>(</span><span>-</span><span>99</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>请自行测试并调用 <code>my_abs</code> 看看返回结果是否正确。</p>
<p>请注意，函数体内部的语句在执行时，一旦执行到 <code>return</code> 时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有 <code>return</code> 语句，函数执行完毕后也会返回结果，只是结果为 <code>None</code>。<code>return None</code> 可以简写为 <code>return</code>。</p>
<p>在 Python 交互环境中定义函数时，注意 Python 会出现 <code>...</code> 的提示。函数定义结束后需要按两次回车重新回到<code>&gt;&gt;&gt;</code> 提示符下:</p>
<div><pre><code>┌────────────────────────────────────────────────────────┐
│Command Prompt - python                           - □ x │
├────────────────────────────────────────────────────────┤
│&gt;&gt;&gt; def my_abs(x):                                      │
│...     if x &gt;= 0:                                      │
│...         return x                                    │
│...     else:                                           │
│...         return -x                                   │
│...                                                     │
│&gt;&gt;&gt; my_abs(-9)                                          │
│9                                                       │
│&gt;&gt;&gt; _                                                   │
│                                                        │
│                                                        │
└────────────────────────────────────────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果您已经把 <code>my_abs()</code> 的函数定义保存为 <code>abstest.py</code> 文件了，那么，可以在该文件的当前目录下启动 Python 解释器，用 <code>from abstest import my_abs</code> 来导入 <code>my_abs()</code> 函数，注意 <code>abstest</code> 是文件名(不含 .py 扩展名):</p>
<div><pre><code>┌────────────────────────────────────────────────────────┐
│Command Prompt - python                           - □ x │
├────────────────────────────────────────────────────────┤
│&gt;&gt;&gt; from abstest import my_abs                          │
│&gt;&gt;&gt; my_abs(-9)                                          │
│9                                                       │
│&gt;&gt;&gt; _                                                   │
│                                                        │
│                                                        │
│                                                        │
│                                                        │
│                                                        │
│                                                        │
│                                                        │
└────────────────────────────────────────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>import</code> 的用法在后续 <a href="./../module/">模块</a> 一节中会详细介绍。</p>
<h2 id="空函数"> 空函数</h2>
<p>如果想定义一个什么事也不做的空函数，可以用 pass 语句:</p>
<div><pre><code><span>def</span> <span>nop</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>pass 语句什么都不做，那有什么用? 实际上 pass 可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个 pass，让代码能运行起来。</p>
<p>pass 还可以用在其他语句里，比如:</p>
<div><pre><code><span>if</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>缺少了 pass，代码运行就会有语法错误。</p>
<h2 id="参数检查"> 参数检查</h2>
<p>调用函数时，如果参数个数不对，Python 解释器会自动检查出来，并抛出 <code>TypeError</code>:</p>
<div><pre><code><span>>></span><span>></span> my_abs<span>(</span><span>1</span>, <span>2</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: my_abs<span>(</span><span>)</span> takes <span>1</span> positional argument but <span>2</span> were given
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但是如果参数类型不对，Python 解释器就无法帮我们检查。试试 <code>my_abs</code> 和内置函数 abs 的差别:</p>
<div><pre><code><span>>></span><span>></span> my_abs<span>(</span><span>'A'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
  File <span>"&lt;stdin>"</span>, line <span>2</span>, <span>in</span> my_abs
TypeError: unorderable types: str<span>(</span><span>)</span> <span>>=</span> int<span>(</span><span>)</span>
<span>>></span><span>></span> abs<span>(</span><span>'A'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: bad operand <span>type</span> <span>for</span> abs<span>(</span><span>)</span>: <span>'str'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当传入了不恰当的参数时，内置函数 <code>abs</code> 会检查出参数错误，而我们定义的 <code>my_abs</code> 没有参数检查，会导致 <code>if</code> 语句出错，出错信息和 <code>abs</code> 不一样。所以，这个函数定义不够完善。</p>
<p>让我们修改一下 <code>my_abs</code> 的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数 <code>isinstance()</code> 实现:</p>
<div><pre><code><span>def</span> <span>my_abs</span><span>(</span>x<span>)</span><span>:</span>
    <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>x<span>,</span> <span>(</span><span>int</span><span>,</span> <span>float</span><span>)</span><span>)</span><span>:</span>
        <span>raise</span> TypeError<span>(</span><span>'bad operand type'</span><span>)</span>
    <span>if</span> x <span>>=</span> <span>0</span><span>:</span>
        <span>return</span> x
    <span>else</span><span>:</span>
        <span>return</span> <span>-</span>x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误:</p>
<div><pre><code><span>>></span><span>></span> my_abs<span>(</span><span>'A'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
  File <span>"&lt;stdin>"</span>, line <span>3</span>, <span>in</span> my_abs
TypeError: bad operand <span>type</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>错误和异常处理将在后续讲到。</p>
<h2 id="返回多个值"> 返回多个值</h2>
<p>函数可以返回多个值吗? 答案是肯定的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标:</p>
<div><pre><code><span>import</span> math

<span>def</span> <span>move</span><span>(</span>x<span>,</span> y<span>,</span> step<span>,</span> angle<span>=</span><span>0</span><span>)</span><span>:</span>
    nx <span>=</span> x <span>+</span> step <span>*</span>math<span>.</span>cos<span>(</span>angle<span>)</span>
ny <span>=</span> y <span>-</span> step<span>*</span> math<span>.</span>sin<span>(</span>angle<span>)</span>
    <span>return</span> nx<span>,</span> ny
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>import math</code> 语句表示导入 <code>math</code> 包，并允许后续代码引用 <code>math</code> 包里的 <code>sin</code>、<code>cos</code> 等函数。</p>
<p>然后，我们就可以同时获得返回值:</p>
<div><pre><code><span>>></span><span>></span> x<span>,</span> y <span>=</span> move<span>(</span><span>100</span><span>,</span> <span>100</span><span>,</span> <span>60</span><span>,</span> math<span>.</span>pi <span>/</span> <span>6</span><span>)</span>
<span>>></span><span>></span> <span>print</span><span>(</span>x<span>,</span> y<span>)</span>
<span>151.96152422706632</span> <span>70.0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但其实这只是一种假象，Python 函数返回的仍然是单一值:</p>
<div><pre><code><span>>></span><span>></span> r <span>=</span> move<span>(</span><span>100</span><span>,</span> <span>100</span><span>,</span> <span>60</span><span>,</span> math<span>.</span>pi <span>/</span> <span>6</span><span>)</span>
<span>>></span><span>></span> <span>print</span><span>(</span>r<span>)</span>
<span>(</span><span>151.96152422706632</span><span>,</span> <span>70.0</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>原来返回值是一个 tuple! 但是，在语法上，返回一个 tuple 可以省略括号，而多个变量可以同时接收一个 tuple，按位置赋给对应的值，所以，Python 的函数返回多值其实就是返回一个 tuple，但写起来更方便。</p>
<h2 id="小结"> 小结</h2>
<p>定义函数时，需要确定函数名和参数个数；</p>
<p>如果有必要，可以先对参数的数据类型做检查；</p>
<p>函数体内部可以用 <code>return</code> 随时返回函数结果；</p>
<p>函数执行完毕也没有 <code>return</code> 语句时，自动 <code>return None</code>。</p>
<p>函数可以同时返回多个值，但其实就是一个 tuple。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-26T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">函数介绍</title>
    <id>https://list-jiang.github.io/code/language/python/function/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们知道圆的面积计算公式为: <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.05764em;">S</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span style="margin-right:0.03588em;">π</span><span><span style="margin-right:0.02778em;">r</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>当我们知道半径 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span style="margin-right:0.02778em;">r</span></span></span></span> 的值时，就可以根据公式计算出面积。假设我们需要计算 3 个不同大小的圆的面积:</p>
<div><pre><code><span>const</span> r1 <span>=</span> <span>12.34</span><span>;</span>
<span>const</span> r2 <span>=</span> <span>9.08</span><span>;</span>
<span>const</span> r3 <span>=</span> <span>73.1</span><span>;</span>
<span>const</span> s1 <span>=</span> <span>3.14</span> <span>*</span> r1 <span>*</span> r1<span>;</span>
<span>const</span> s2 <span>=</span> <span>3.14</span> <span>*</span> r2 <span>*</span> r2<span>;</span>
<span>const</span> s3 <span>=</span> <span>3.14</span> <span>*</span> r3 <span>*</span> r3<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当代码出现有规律的重复的时候，您就需要当心了，每次写 <code>3.14 *x* x</code> 不仅很麻烦，而且，如果要把 <code>3.14</code> 改成 <code>3.14159265359</code> 的时候，得全部替换。</p>
<h2 id="函数是什么"> 函数是什么</h2>
<p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<p>有了函数，我们就不再每次写 <code>s = 3.14 *x* x</code>，而是写成更有意义的函数调用 <code>s = area_of_circle(x)</code>，而函数 <code>area_of_circle</code> 本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，Python 也不例外。Python 不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<h2 id="抽象"> 抽象</h2>
<p>抽象是数学中非常常见的概念。举个例子:</p>
<p>计算数列的和，比如: <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>⋯</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>100</span></span></span></span>，写起来十分不方便，于是数学家发明了求和符号 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="position:relative;top:0em;">∑</span></span></span></span>，可以把 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>⋯</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>100</span></span></span></span> 记作 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.4682em;vertical-align:-0.9671em;"></span><span><span><span><span style="height:1.5011em;"><span style="top:-2.1329em;margin-left:0em;"><span style="height:3em;"></span><span><span><span>n</span><span>=</span><span>1</span></span></span></span><span style="top:-3em;"><span style="height:3em;"></span><span><span>∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span style="height:3em;"></span><span><span><span>100</span></span></span></span></span><span>​</span></span><span><span style="height:0.9671em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>n</span></span></span></span> 。</p>
<p>这种抽象记法非常强大，因为我们看到 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="position:relative;top:0em;">∑</span></span></span></span> 就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如: <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.4682em;vertical-align:-0.9671em;"></span><span><span><span><span style="height:1.5011em;"><span style="top:-2.1329em;margin-left:0em;"><span style="height:3em;"></span><span><span><span>n</span><span>=</span><span>1</span></span></span></span><span style="top:-3em;"><span style="height:3em;"></span><span><span>∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span style="height:3em;"></span><span><span><span>100</span></span></span></span></span><span>​</span></span><span><span style="height:0.9671em;"><span></span></span></span></span></span><span>(</span><span><span>n</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span></span></span></span></p>
<p>还原成加法运算就变成了:</p>
<p><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>1</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>2</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>⋯</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>100</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>100</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span></span></span></span></p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-25T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">函数</title>
    <id>https://list-jiang.github.io/code/language/python/function/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">函数介绍</a></p>
</li>
<li>
<p><a href="./define.html">函数定义</a></p>
</li>
<li>
<p><a href="./call.html">函数调用</a></p>
</li>
<li>
<p><a href="./argument.html">函数参数</a></p>
</li>
<li>
<p><a href="./recursive.html">递归调用</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-25T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">递归函数</title>
    <id>https://list-jiang.github.io/code/language/python/function/recursive/</id>
    <link href="https://list-jiang.github.io/code/language/python/function/recursive/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>

<p>举个例子，我们来计算阶乘 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>n</span><span>!</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>⋯</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span></span></span></span> ，用函数 <code>fact(n)</code> 表示，可以看出:</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>a</span><span>c</span><span>t</span><span>(</span><span>n</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6944em;"></span><span>n</span><span>!</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>⋯</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span></span><span></span><span><span style="height:0.3669em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)!</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>a</span><span>c</span><span>t</span><span>(</span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>n</span></span></span></span></span></p>
<p>所以，<code>fact(n)</code> 可以表示为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>a</span><span>c</span><span>t</span><span>(</span><span>n</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span></span></span></span>，只有 n=1 时需要特殊处理。</p>
<p>于是，<code>fact(n)</code> 用递归的方式写出来就是:</p>
<div><pre><code><span>def</span> <span>fact</span><span>(</span>n<span>)</span><span>:</span>
    <span>if</span> n<span>==</span><span>1</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>return</span> n <span>*</span> fact<span>(</span>n <span>-</span> <span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面就是一个递归函数。可以试试:</p>
<div><pre><code><span>>></span><span>></span> fact<span>(</span><span>1</span><span>)</span>
<span>1</span>
<span>>></span><span>></span> fact<span>(</span><span>5</span><span>)</span>
<span>120</span>
<span>>></span><span>></span> fact<span>(</span><span>100</span><span>)</span>
<span>93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果我们计算 <code>fact(5)</code>，可以根据函数定义看到计算过程如下:</p>
<div><pre><code>===&gt; fact(5)
===&gt; 5 *fact(4)
===&gt; 5* (4 *fact(3))
===&gt; 5* (4 *(3* fact(2)))
===&gt; 5 *(4* (3 *(2* fact(1))))
===&gt; 5 *(4* (3 *(2* 1)))
===&gt; 5 *(4* (3 *2))
===&gt; 5* (4 *6)
===&gt; 5* 24
===&gt; 120
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试 <code>fact(1000)</code>:</p>
<div><pre><code><span>>></span><span>></span> fact<span>(</span><span>1000</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
  File <span>"&lt;stdin>"</span>, line <span>4</span>, <span>in</span> fact
  <span>..</span>.
  File <span>"&lt;stdin>"</span>, line <span>4</span>, <span>in</span> fact
RuntimeError: maximum recursion depth exceeded <span>in</span> comparison
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的 <code>fact(n)</code> 函数由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中:</p>
<div><pre><code><span>def</span> <span>fact</span><span>(</span>n<span>)</span><span>:</span>
    <span>return</span> fact_iter<span>(</span>n<span>,</span> <span>1</span><span>)</span>

<span>def</span> <span>fact_iter</span><span>(</span>num<span>,</span> product<span>)</span><span>:</span>
    <span>if</span> num <span>==</span> <span>1</span><span>:</span>
        <span>return</span> product
    <span>return</span> fact_iter<span>(</span>num <span>-</span> <span>1</span><span>,</span> num <span>*</span>product<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，<code>return fact_iter(num - 1, num* product)</code> 仅返回递归函数本身，<code>num - 1</code> 和 <code>num * product</code> 在函数调用前就会被计算，不影响函数调用。</p>
<p><code>fact(5)</code> 对应的 <code>fact_iter(5, 1)</code> 的调用如下:</p>
<div><pre><code>===&gt; fact_iter(5, 1)
===&gt; fact_iter(4, 5)
===&gt; fact_iter(3, 20)
===&gt; fact_iter(2, 60)
===&gt; fact_iter(1, 120)
===&gt; 120
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python 解释器也没有做优化，所以，即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p>
<h2 id="小结"> 小结</h2>
<p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
<p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<p>Python 标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">匿名函数</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/anonymous-function/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/anonymous-function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在 Python 中，对匿名函数提供了有限支持。还是以 <code>map()</code> 函数为例，计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> 时，除了定义一个 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span></span></span></span> 的函数外，还可以直接传入匿名函数:</p>
<div><pre><code><span>>></span><span>></span> <span>list</span><span>(</span><span>map</span><span>(</span><span>lambda</span> x<span>:</span> x <span>*</span>x<span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>)</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>,</span> <span>25</span><span>,</span> <span>36</span><span>,</span> <span>49</span><span>,</span> <span>64</span><span>,</span> <span>81</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过对比可以看出，匿名函数 <code>lambda x: x* x</code> 实际上就是:</p>
<div><pre><code><span>def</span> <span>f</span><span>(</span>x<span>)</span><span>:</span>
    <span>return</span> x <span>*</span> x
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>关键字 <code>lambda</code> 表示匿名函数，冒号前面的 <code>x</code> 表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写 <code>return</code>，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> <span>lambda</span> x<span>:</span> x <span>*</span> x
<span>>></span><span>></span> f
<span>&lt;</span>function <span>&lt;</span><span>lambda</span><span>></span> at <span>0x101c6ef28</span><span>></span>
<span>>></span><span>></span> f<span>(</span><span>5</span><span>)</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>同样，也可以把匿名函数作为返回值返回，比如:</p>
<div><pre><code><span>def</span> <span>build</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
    <span>return</span> <span>lambda</span><span>:</span> x <span>*</span>x <span>+</span> y<span>*</span> y
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="小结"> 小结</h2>
<p>Python 对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-15T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">装饰器</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/decorator/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/decorator/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>now</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'2021-3-15'</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> f <span>=</span> now
<span>>></span><span>></span> f<span>(</span><span>)</span>
<span>2021</span><span>-</span><span>3</span><span>-</span><span>15</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>函数对象有一个 <code>__name__</code> 属性，可以拿到函数的名字:</p>
<div><pre><code><span>>></span><span>></span> now<span>.</span>__name__
<span>'now'</span>
<span>>></span><span>></span> f<span>.</span>__name__
<span>'now'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，假设我们要增强 <code>now()</code> 函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改 <code>now()</code> 函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器” (Decorator) 。</p>
<p>本质上，decorator 就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的 decorator，可以定义如下:</p>
<div><pre><code><span>def</span> <span>log</span><span>(</span>func<span>)</span><span>:</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'call %s():'</span> <span>%</span> func<span>.</span>__name__<span>)</span>
<span>return</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kw<span>)</span>
    <span>return</span> wrapper
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>观察上面的 <code>log</code>，因为它是一个 decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助 Python 的 <code>@</code> 语法，把 decorator 置于函数的定义处:</p>
<div><pre><code><span>@log</span>
<span>def</span> <span>now</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'2021-3-15'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>调用 <code>now()</code> 函数，不仅会运行 <code>now()</code> 函数本身，还会在运行 <code>now()</code> 函数前打印一行日志:</p>
<div><pre><code><span>>></span><span>></span> now<span>(</span><span>)</span>
call now<span>(</span><span>)</span><span>:</span>
<span>2021</span><span>-</span><span>3</span><span>-</span><span>15</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>把 <code>@log</code> 放到 <code>now()</code> 函数的定义处，相当于执行了语句:</p>
<div><pre><code>now <span>=</span> log<span>(</span>now<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>由于 <code>log()</code> 是一个 decorator，返回一个函数，所以，原来的 <code>now()</code> 函数仍然存在，只是现在同名的 <code>now</code> 变量指向了新的函数，于是调用 <code>now()</code> 将执行新函数，即在 <code>log()</code> 函数中返回的 <code>wrapper()</code> 函数。</p>
<p><code>wrapper()</code> 函数的参数定义是 <code>(*args, **kw)</code>，因此，<code>wrapper()</code> 函数可以接受任意参数的调用。在 <code>wrapper()</code> 函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数，写出来会更复杂。比如，要自定义 <code>log</code> 的文本:</p>
<div><pre><code><span>def</span> <span>log</span><span>(</span>text<span>)</span><span>:</span>
    <span>def</span> <span>decorator</span><span>(</span>func<span>)</span><span>:</span>
        <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
            <span>print</span><span>(</span><span>'%s %s():'</span> <span>%</span> <span>(</span>text<span>,</span> func<span>.</span>__name__<span>)</span><span>)</span>
<span>return</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kw<span>)</span>
        <span>return</span> wrapper
    <span>return</span> decorator
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个 3 层嵌套的 decorator 用法如下:</p>
<div><pre><code><span>@log</span><span>(</span><span>'execute'</span><span>)</span>
<span>def</span> <span>now</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'2021-3-15'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行结果如下:</p>
<div><pre><code><span>>></span><span>></span> now<span>(</span><span>)</span>
execute now<span>(</span><span>)</span><span>:</span>
<span>2021</span><span>-</span><span>3</span><span>-</span><span>15</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>和两层嵌套的 decorator 相比，3 层嵌套的效果是这样的:</p>
<div><pre><code><span>>></span><span>></span> now <span>=</span> log<span>(</span><span>'execute'</span><span>)</span><span>(</span>now<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们来剖析上面的语句，首先执行 <code>log('execute')</code>，返回的是 decorator 函数，再调用返回的函数，参数是 <code>now</code> 函数，返回值最终是 <code>wrapper</code> 函数。</p>
<p>以上两种 decorator 的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有 <code>__name__</code>等属性，但您去看经过 decorator 装饰之后的函数，它们的 <code>__name__</code> 已经从原来的 <code>'now'</code> 变成了 <code>'wrapper'</code>:</p>
<div><pre><code><span>>></span><span>></span> now<span>.</span>__name__
<span>'wrapper'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为返回的那个 <code>wrapper()</code> 函数名字就是 <code>'wrapper'</code>，所以，需要把原始函数的 <code>__name__</code> 等属性复制到 <code>wrapper()</code> 函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写 <code>wrapper.__name__ = func.__name__</code> 这样的代码，Python 内置的 <code>functools.wraps</code> 就是干这个事的，所以，一个完整的 decorator 的写法如下:</p>
<div><pre><code><span>import</span> functools

<span>def</span> <span>log</span><span>(</span>func<span>)</span><span>:</span>
    <span>@functools<span>.</span>wraps</span><span>(</span>func<span>)</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'call %s():'</span> <span>%</span> func<span>.</span>__name__<span>)</span>
<span>return</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kw<span>)</span>
    <span>return</span> wrapper
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>或者针对带参数的 decorator:</p>
<div><pre><code><span>import</span> functools

<span>def</span> <span>log</span><span>(</span>text<span>)</span><span>:</span>
    <span>def</span> <span>decorator</span><span>(</span>func<span>)</span><span>:</span>
        <span>@functools<span>.</span>wraps</span><span>(</span>func<span>)</span>
        <span>def</span> <span>wrapper</span><span>(</span><span>*</span>args<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
            <span>print</span><span>(</span><span>'%s %s():'</span> <span>%</span> <span>(</span>text<span>,</span> func<span>.</span>__name__<span>)</span><span>)</span>
<span>return</span> func<span>(</span><span>*</span>args<span>,</span><span>**</span>kw<span>)</span>
        <span>return</span> wrapper
    <span>return</span> decorator
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>import functools</code> 是导入 <code>functools</code> 模块。模块的概念稍候讲解。现在，只需记住在定义 <code>wrapper()</code> 的前面加上 <code>@functools.wraps(func)</code> 即可。</p>
<h2 id="小结"> 小结</h2>
<p>在面向对象 (OOP) 的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。Python 的 decorator 可以用函数实现，也可以用类实现。</p>
<p>decorator 可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<p>请编写一个 decorator，能在函数调用的前后打印出 <code>'begin call'</code> 和 <code>'end call'</code> 的日志。</p>
<p>再思考一下能否写出一个 <code>@log</code> 的 decorator，使它既支持:</p>
<div><pre><code><span>@log</span>
<span>def</span> <span>f</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>又支持:</p>
<div><pre><code><span>@log</span><span>(</span><span>'execute'</span><span>)</span>
<span>def</span> <span>f</span><span>(</span><span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-15T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">filter</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/filter/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/filter/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>Python 内建的 <code>filter()</code> 函数用于过滤序列。</p>
<p>和 <code>map()</code> 类似，<code>filter()</code> 也接收一个函数和一个序列。和 <code>map()</code> 不同的是，<code>filter()</code> 把传入的函数依次作用于每个元素，然后根据返回值是 <code>True</code> 还是 <code>False</code> 决定保留还是丢弃该元素。</p>
<p>例如，在一个 list 中，删掉偶数，只保留奇数，可以这么写:</p>
<div><pre><code><span>def</span> <span>is_odd</span><span>(</span>n<span>)</span><span>:</span>
    <span>return</span> n <span>%</span> <span>2</span> <span>==</span> <span>1</span>

<span>list</span><span>(</span><span>filter</span><span>(</span>is_odd<span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>]</span><span>)</span><span>)</span>
<span># 结果: [1, 5, 9, 15]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>把一个序列中的空字符串删掉，可以这么写:</p>
<div><pre><code><span>def</span> <span>not_empty</span><span>(</span>s<span>)</span><span>:</span>
    <span>return</span> s <span>and</span> s<span>.</span>strip<span>(</span><span>)</span>

<span>list</span><span>(</span><span>filter</span><span>(</span>not_empty<span>,</span> <span>[</span><span>'A'</span><span>,</span> <span>''</span><span>,</span> <span>'B'</span><span>,</span> <span>None</span><span>,</span> <span>'C'</span><span>,</span> <span>'  '</span><span>]</span><span>)</span><span>)</span>
<span># 结果: ['A', 'B', 'C']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可见用 <code>filter()</code> 这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<p>注意到 <code>filter()</code> 函数返回的是一个 Iterator，也就是一个惰性序列，所以要强迫 <code>filter()</code> 完成计算结果，需要用 <code>list()</code> 函数获得所有结果并返回 list。</p>
<h2 id="用-filter-求素数"> 用 filter 求素数</h2>
<p>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单:</p>
<p>首先，列出从 2 开始的所有自然数，构造一个序列:</p>
<p>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</p>
<p>取序列的第一个数 2，它一定是素数，然后用 2 把序列的 2 的倍数筛掉:</p>
<p>3, <s>4</s>, 5, <s>6</s>, 7, <s>8</s>, 9, <s>10</s>, 11, <s>12</s>, 13, <s>14</s>, 15, <s>16</s>, 17, <s>18</s>, 19, <s>20</s>, ...</p>
<p>取新序列的第一个数 3，它一定是素数，然后用 3 把序列的 3 的倍数筛掉:</p>
<p>5, <s>6</s>, 7, <s>8</s>, <s>9</s>, <s>10</s>, 11, <s>12</s>, 13, <s>14</s>, <s>15</s>, <s>16</s>, 17, <s>18</s>, 19, <s>20</s>, ...</p>
<p>取新序列的第一个数 5，然后用 5 把序列的 5 的倍数筛掉:</p>
<p>7, <s>8</s>, <s>9</s>, <s>10</s>, 11, <s>12</s>, 13, <s>14</s>, <s>15</s>, <s>16</s>, 17, <s>18</s>, 19, <s>20</s>, ...</p>
<p>不断筛下去，就可以得到所有的素数。</p>
<p>用 Python 来实现这个算法，可以先构造一个从 3 开始的奇数序列:</p>
<div><pre><code><span>def</span> <span>_odd_iter</span><span>(</span><span>)</span><span>:</span>
    n <span>=</span> <span>1</span>
    <span>while</span> <span>True</span><span>:</span>
        n <span>=</span> n <span>+</span> <span>2</span>
        <span>yield</span> n
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意这是一个生成器，并且是一个无限序列。</p>
<p>然后定义一个筛选函数:</p>
<div><pre><code><span>def</span> <span>_not_divisible</span><span>(</span>n<span>)</span><span>:</span>
    <span>return</span> <span>lambda</span> x<span>:</span> x <span>%</span> n <span>></span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后，定义一个生成器，不断返回下一个素数:</p>
<div><pre><code><span>def</span> <span>primes</span><span>(</span><span>)</span><span>:</span>
    <span>yield</span> <span>2</span>
    it <span>=</span> _odd_iter<span>(</span><span>)</span> <span># 初始序列</span>
    <span>while</span> <span>True</span><span>:</span>
        n <span>=</span> <span>next</span><span>(</span>it<span>)</span> <span># 返回序列的第一个数</span>
        <span>yield</span> n
        it <span>=</span> <span>filter</span><span>(</span>_not_divisible<span>(</span>n<span>)</span><span>,</span> it<span>)</span> <span># 构造新序列</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个生成器先返回第一个素数 2，然后，利用 <code>filter()</code> 不断产生筛选后的新的序列。</p>
<p>由于 <code>primes()</code> 也是一个无限序列，所以调用时需要设置一个退出循环的条件:</p>
<div><pre><code><span># 打印1000以内的素数</span>

<span>for</span> n <span>in</span> primes<span>(</span><span>)</span><span>:</span>
    <span>if</span> n <span>&lt;</span> <span>1000</span><span>:</span>
        <span>print</span><span>(</span>n<span>)</span>
    <span>else</span><span>:</span>
        <span>break</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意到 Iterator 是惰性计算的序列，所以我们可以用 Python 表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。</p>
<h2 id="小结"> 小结</h2>
<p><code>filter()</code> 的作用是从一个序列中筛出符合条件的元素。由于 <code>filter()</code> 使用了惰性计算，所以只有在取 <code>filter()</code> 结果的时候，才会真正筛选并每次返回下一个筛出的元素。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>高阶函数英文叫 Higher-order function。什么是高阶函数? 把函数作为参数传入，这样的函数称为高阶函数。</p>
]]></summary>
    <content type="html"><![CDATA[<p>高阶函数英文叫 Higher-order function。什么是高阶函数? 把函数作为参数传入，这样的函数称为高阶函数。</p>

<p>我们以实际代码为例子，一步一步深入概念。</p>
<h2 id="变量可以指向函数"> 变量可以指向函数</h2>
<p>以 Python 内置的求绝对值的函数 <code>abs()</code> 为例，调用该函数用以下代码:</p>
<div><pre><code><span>>></span><span>></span> <span>abs</span><span>(</span><span>-</span><span>10</span><span>)</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是，如果只写 <code>abs</code> 呢?</p>
<div><pre><code><span>>></span><span>></span> <span>abs</span>
<span>&lt;</span>built<span>-</span><span>in</span> function <span>abs</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可见，<code>abs(-10)</code> 是函数调用，而 <code>abs</code> 是函数本身。</p>
<p>要获得函数调用结果，我们可以把结果赋值给变量:</p>
<div><pre><code><span>>></span><span>></span> x <span>=</span> <span>abs</span><span>(</span><span>-</span><span>10</span><span>)</span>
<span>>></span><span>></span> x
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是，如果把函数本身赋值给变量呢?</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> <span>abs</span>
<span>>></span><span>></span> f
<span>&lt;</span>built<span>-</span><span>in</span> function <span>abs</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>结论: 函数本身也可以赋值给变量，即: 变量可以指向函数。</p>
<p>如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数? 用代码验证一下:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> <span>abs</span>
<span>>></span><span>></span> f<span>(</span><span>-</span><span>10</span><span>)</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>成功! 说明变量 f 现在已经指向了 <code>abs</code> 函数本身。直接调用 <code>abs()</code> 函数和调用变量 <code>f()</code> 完全相同。</p>
<h2 id="函数名也是变量"> 函数名也是变量</h2>
<p>那么函数名是什么呢? 函数名其实就是指向函数的变量! 对于 <code>abs()</code> 这个函数，完全可以把函数名 <code>abs</code> 看成变量，它指向一个可以计算绝对值的函数!</p>
<p>如果把 <code>abs</code> 指向其他对象，会有什么情况发生?</p>
<div><pre><code><span>>></span><span>></span> abs <span>=</span> <span>10</span>
<span>>></span><span>></span> abs<span>(</span>-10<span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: <span>'int'</span> object is not callable
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>把 <code>abs</code> 指向 <code>10</code> 后，就无法通过 <code>abs(-10)</code> 调用该函数了! 因为 <code>abs</code> 这个变量已经不指向求绝对值函数而是指向一个整数 10!</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复 <code>abs</code> 函数，请重启 Python 交互环境。</p>
<div><p>提示</p>
<p>由于 abs 函数实际上是定义在 <code>import builtins</code> 模块中的，所以要让修改 <code>abs</code> 变量的指向在其它模块也生效，要用 <code>import builtins; builtins.abs = 10</code>。</p>
</div>
<h2 id="传入函数"> 传入函数</h2>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数:</p>
<div><pre><code><span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>,</span> f<span>)</span><span>:</span>
    <span>return</span> f<span>(</span>x<span>)</span> <span>+</span> f<span>(</span>y<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当我们调用 <code>add(-5, 6, abs)</code> 时，参数 <code>x</code>，<code>y</code> 和 <code>f</code> 分别接收 <code>-5</code>，<code>6</code> 和 <code>abs</code>，根据函数定义，我们可以推导计算过程为:</p>
<div><pre><code>x <span>=</span> <span>-</span><span>5</span>
y <span>=</span> <span>6</span>
f <span>=</span> <span>abs</span>
f<span>(</span>x<span>)</span> <span>+</span> f<span>(</span>y<span>)</span> <span>==</span><span>></span> <span>abs</span><span>(</span><span>-</span><span>5</span><span>)</span> <span>+</span> <span>abs</span><span>(</span><span>6</span><span>)</span> <span>==</span><span>></span> <span>11</span>
<span>return</span> <span>11</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>编写高阶函数，就是让函数的参数能够接收别的函数。</p>
<h2 id="小结"> 小结</h2>
<p>把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">map / reduce</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/map-and-reduce/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/map-and-reduce/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Python 内建了 <code>map()</code> 和 <code>reduce()</code> 函数。</p>
<p>如果您读过 Google 的那篇大名鼎鼎的论文 <a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener noreferrer">“MapReduce: Simplified Data Processing on Large Clusters”</a>，您就能大概明白 map / reduce 的概念。</p>
<blockquote>
<p>访问需要科学上网。</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>Python 内建了 <code>map()</code> 和 <code>reduce()</code> 函数。</p>
<p>如果您读过 Google 的那篇大名鼎鼎的论文 <a href="http://research.google.com/archive/mapreduce.html" target="_blank" rel="noopener noreferrer">“MapReduce: Simplified Data Processing on Large Clusters”</a>，您就能大概明白 map / reduce 的概念。</p>
<blockquote>
<p>访问需要科学上网。</p>
</blockquote>

<p>我们先看 map。<code>map()</code> 函数接收两个参数，一个是函数，一个是 <code>Iterable</code>，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 <code>Iterator</code> 返回。</p>
<p>举例说明，比如我们有一个函数 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> ，要把这个函数作用在一个 list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code> 上，就可以用 <code>map()</code> 实现如下:</p>
<div><pre><code>            f(x) = x * x

                  │
                  │
  ┌───┬───┬───┬───┼───┬───┬───┬───┐
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   2   3   4   5   6   7   8   9 ]

  │   │   │   │   │   │   │   │   │
  │   │   │   │   │   │   │   │   │
  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼

[ 1   4   9  16  25  36  49  64  81 ]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>现在，我们用 Python 代码实现:</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>f</span><span>(</span>x<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x <span>*</span> x
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> r <span>=</span> <span>map</span><span>(</span>f<span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>)</span>
<span>>></span><span>></span> <span>list</span><span>(</span>r<span>)</span>
<span>[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>,</span> <span>25</span><span>,</span> <span>36</span><span>,</span> <span>49</span><span>,</span> <span>64</span><span>,</span> <span>81</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>map()</code> 传入的第一个参数是 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span style="margin-right:0.10764em;">f</span></span></span></span> ，即函数对象本身。由于结果 <code>r</code> 是一个 Iterator，Iterator 是惰性序列，因此通过 <code>list()</code> 函数让它把整个序列都计算出来并返回一个 list。</p>
<p>您可能会想，不需要 <code>map()</code> 函数，写一个循环，也可以计算出结果:</p>
<div><pre><code>L <span>=</span> <span>[</span><span>]</span>
<span>for</span> n <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>:</span>
    L<span>.</span>append<span>(</span>f<span>(</span>n<span>)</span><span>)</span>
<span>print</span><span>(</span>L<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>的确可以，但是，从上面的循环代码，能一眼看明白“把 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span></span></span></span> 作用在 list 的每一个元素并把结果生成一个新的 list”吗?</p>
<p>所以，<code>map()</code> 作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10764em;">f</span><span>(</span><span>x</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8141em;"></span><span><span>x</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span> ，还可以计算任意复杂的函数，比如，把这个 list 所有数字转为字符串:</p>
<div><pre><code><span>>></span><span>></span> <span>list</span><span>(</span><span>map</span><span>(</span><span>str</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>)</span><span>)</span>
<span>[</span><span>'1'</span><span>,</span> <span>'2'</span><span>,</span> <span>'3'</span><span>,</span> <span>'4'</span><span>,</span> <span>'5'</span><span>,</span> <span>'6'</span><span>,</span> <span>'7'</span><span>,</span> <span>'8'</span><span>,</span> <span>'9'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>只需要一行代码。</p>
<p>再看 <code>reduce</code> 的用法。<code>reduce</code> 把一个函数作用在一个序列 <code>[x1, x2, x3, ...]</code> 上，这个函数必须接收两个参数，<code>reduce</code> 把结果继续和序列的下一个元素做累积计算，其效果就是:</p>
<div><pre><code><span>reduce</span><span>(</span>f<span>,</span> <span>[</span>x1<span>,</span> x2<span>,</span> x3<span>,</span> x4<span>]</span><span>)</span> <span>=</span> f<span>(</span>f<span>(</span>f<span>(</span>x1<span>,</span> x2<span>)</span><span>,</span> x3<span>)</span><span>,</span> x4<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>比方说对一个序列求和，就可以用 reduce 实现:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> functools <span>import</span> <span>reduce</span>
<span>>></span><span>></span> <span>def</span> <span>add</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x <span>+</span> y
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>reduce</span><span>(</span>add<span>,</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>]</span><span>)</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当然求和运算可以直接用 Python 内建函数 <code>sum()</code>，没必要动用 <code>reduce</code>。</p>
<p>但是如果要把序列 <code>[1, 3, 5, 7, 9]</code> 变换成整数 13579，<code>reduce</code> 就可以派上用场:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> functools <span>import</span> <span>reduce</span>
<span>>></span><span>></span> <span>def</span> <span>fn</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x <span>*</span><span>10</span> <span>+</span> y
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>reduce</span><span>(</span>fn<span>,</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>]</span><span>)</span>
<span>13579</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个例子本身没多大用处，但是，如果考虑到字符串 <code>str</code> 也是一个序列，对上面的例子稍加改动，配合 <code>map()</code>，我们就可以写出把 <code>str</code> 转换为 <code>int</code> 的函数:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> functools <span>import</span> <span>reduce</span>
<span>>></span><span>></span> <span>def</span> <span>fn</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x<span>*</span> <span>10</span> <span>+</span> y
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>def</span> <span>char2num</span><span>(</span>s<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     digits <span>=</span> <span>{</span><span>'0'</span><span>:</span> <span>0</span><span>,</span> <span>'1'</span><span>:</span> <span>1</span><span>,</span> <span>'2'</span><span>:</span> <span>2</span><span>,</span> <span>'3'</span><span>:</span> <span>3</span><span>,</span> <span>'4'</span><span>:</span> <span>4</span><span>,</span> <span>'5'</span><span>:</span> <span>5</span><span>,</span> <span>'6'</span><span>:</span> <span>6</span><span>,</span> <span>'7'</span><span>:</span> <span>7</span><span>,</span> <span>'8'</span><span>:</span> <span>8</span><span>,</span> <span>'9'</span><span>:</span> <span>9</span><span>}</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> digits<span>[</span>s<span>]</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>reduce</span><span>(</span>fn<span>,</span> <span>map</span><span>(</span>char2num<span>,</span> <span>'13579'</span><span>)</span><span>)</span>
<span>13579</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>整理成一个 <code>str2int</code> 的函数就是:</p>
<div><pre><code><span>from</span> functools <span>import</span> <span>reduce</span>

DIGITS <span>=</span> <span>{</span><span>'0'</span><span>:</span> <span>0</span><span>,</span> <span>'1'</span><span>:</span> <span>1</span><span>,</span> <span>'2'</span><span>:</span> <span>2</span><span>,</span> <span>'3'</span><span>:</span> <span>3</span><span>,</span> <span>'4'</span><span>:</span> <span>4</span><span>,</span> <span>'5'</span><span>:</span> <span>5</span><span>,</span> <span>'6'</span><span>:</span> <span>6</span><span>,</span> <span>'7'</span><span>:</span> <span>7</span><span>,</span> <span>'8'</span><span>:</span> <span>8</span><span>,</span> <span>'9'</span><span>:</span> <span>9</span><span>}</span>

<span>def</span> <span>str2int</span><span>(</span>s<span>)</span><span>:</span>
    <span>def</span> <span>fn</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
        <span>return</span> x <span>*</span> <span>10</span> <span>+</span> y
    <span>def</span> <span>char2num</span><span>(</span>s<span>)</span><span>:</span>
        <span>return</span> DIGITS<span>[</span>s<span>]</span>
    <span>return</span> <span>reduce</span><span>(</span>fn<span>,</span> <span>map</span><span>(</span>char2num<span>,</span> s<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>还可以用 lambda 函数进一步简化成:</p>
<div><pre><code><span>from</span> functools <span>import</span> <span>reduce</span>

DIGITS <span>=</span> <span>{</span><span>'0'</span><span>:</span> <span>0</span><span>,</span> <span>'1'</span><span>:</span> <span>1</span><span>,</span> <span>'2'</span><span>:</span> <span>2</span><span>,</span> <span>'3'</span><span>:</span> <span>3</span><span>,</span> <span>'4'</span><span>:</span> <span>4</span><span>,</span> <span>'5'</span><span>:</span> <span>5</span><span>,</span> <span>'6'</span><span>:</span> <span>6</span><span>,</span> <span>'7'</span><span>:</span> <span>7</span><span>,</span> <span>'8'</span><span>:</span> <span>8</span><span>,</span> <span>'9'</span><span>:</span> <span>9</span><span>}</span>

<span>def</span> <span>char2num</span><span>(</span>s<span>)</span><span>:</span>
    <span>return</span> DIGITS<span>[</span>s<span>]</span>

<span>def</span> <span>str2int</span><span>(</span>s<span>)</span><span>:</span>
    <span>return</span> <span>reduce</span><span>(</span><span>lambda</span> x<span>,</span> y<span>:</span> x <span>*</span> <span>10</span> <span>+</span> y<span>,</span> <span>map</span><span>(</span>char2num<span>,</span> s<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>也就是说，假设 Python 没有提供 <code>int()</code> 函数，您完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码!</p>
<p>lambda 函数的用法在后面介绍。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">高阶函数</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">高阶函数介绍</a></p>
</li>
<li>
<p><a href="./map-and-reduce.html">map / reduce</a></p>
</li>
<li>
<p><a href="./filter.html">filter</a></p>
</li>
<li>
<p><a href="./sorted.html">sorted</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">sorted</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/sorted/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/high-order-function/sorted/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="排序算法"> 排序算法</h2>
<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个 dict 呢? 直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p>
<p>Python 内置的 <code>sorted()</code> 函数就可以对 list 进行排序:</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>36</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>12</span><span>,</span> <span>9</span><span>,</span> <span>-</span><span>21</span><span>]</span><span>)</span>
<span>[</span><span>-</span><span>21</span><span>,</span> <span>-</span><span>12</span><span>,</span> <span>5</span><span>,</span> <span>9</span><span>,</span> <span>36</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>此外，<code>sorted()</code> 函数也是一个高阶函数，它还可以接收一个 <code>key</code> 函数来实现自定义的排序，例如按绝对值大小排序:</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>36</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>12</span><span>,</span> <span>9</span><span>,</span> <span>-</span><span>21</span><span>]</span><span>,</span> key<span>=</span><span>abs</span><span>)</span>
<span>[</span><span>5</span><span>,</span> <span>9</span><span>,</span> <span>-</span><span>12</span><span>,</span> <span>-</span><span>21</span><span>,</span> <span>36</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>key 指定的函数将作用于 list 的每一个元素上，并根据 <code>key</code> 函数返回的结果进行排序。对比原始的 list 和经过 <code>key=abs</code> 处理过的 list:</p>
<div><pre><code><span>list</span> <span>=</span> <span>[</span><span>36</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>12</span><span>,</span> <span>9</span><span>,</span> <span>-</span><span>21</span><span>]</span>

keys <span>=</span> <span>[</span><span>36</span><span>,</span> <span>5</span><span>,</span>  <span>12</span><span>,</span> <span>9</span><span>,</span>  <span>21</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后 <code>sorted()</code> 函数按照 keys 进行排序，并按照对应关系返回 list 相应的元素:</p>
<div><pre><code>keys排序结果 =&gt; [5, 9,  12,  21, 36]
                |  |    |    |   |
最终结果     =&gt; [5, 9, -12, -21, 36]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们再看一个字符串排序的例子:</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>'bob'</span><span>,</span> <span>'about'</span><span>,</span> <span>'Zoo'</span><span>,</span> <span>'Credit'</span><span>]</span><span>)</span>
<span>[</span><span>'Credit'</span><span>,</span> <span>'Zoo'</span><span>,</span> <span>'about'</span><span>,</span> <span>'bob'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>默认情况下，对字符串排序，是按照 ASCII 的大小比较的，由于 <code>'Z' &lt; 'a'</code>，结果，大写字母 Z 会排在小写字母 a 的前面。</p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个 key 函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写(或者都变成小写)，再比较。</p>
<p>这样，我们给 <code>sorted</code> 传入 key 函数，即可实现忽略大小写的排序:</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>'bob'</span><span>,</span> <span>'about'</span><span>,</span> <span>'Zoo'</span><span>,</span> <span>'Credit'</span><span>]</span><span>,</span> key<span>=</span><span>str</span><span>.</span>lower<span>)</span>
<span>[</span><span>'about'</span><span>,</span> <span>'bob'</span><span>,</span> <span>'Credit'</span><span>,</span> <span>'Zoo'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>要进行反向排序，不必改动 key 函数，可以传入第三个参数 <code>reverse=True</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>'bob'</span><span>,</span> <span>'about'</span><span>,</span> <span>'Zoo'</span><span>,</span> <span>'Credit'</span><span>]</span><span>,</span> key<span>=</span><span>str</span><span>.</span>lower<span>,</span> reverse<span>=</span><span>True</span><span>)</span>
<span>[</span><span>'Zoo'</span><span>,</span> <span>'Credit'</span><span>,</span> <span>'bob'</span><span>,</span> <span>'about'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<h2 id="小结"> 小结</h2>
<p><code>sorted()</code> 也是一个高阶函数。用 <code>sorted()</code> 排序的关键在于实现一个映射函数。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">偏函数</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/parital-function/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/parital-function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>Python 的 <code>functools</code> 模块提供了很多有用的功能，其中一个就是偏函数 (Partial function) 。</p>
<div><p>提示</p>
<p>要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
</div>
<p>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下:</p>
<p><code>int()</code> 函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code> 函数默认按十进制转换:</p>
<div><pre><code><span>>></span><span>></span> <span>int</span><span>(</span><span>'12345'</span><span>)</span>
<span>12345</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但 <code>int()</code> 函数还提供额外的 <code>base</code> 参数，默认值为 <code>10</code>。如果传入 <code>base</code> 参数，就可以做 N 进制的转换:</p>
<div><pre><code><span>>></span><span>></span> <span>int</span><span>(</span><span>'12345'</span><span>,</span> base<span>=</span><span>8</span><span>)</span>
<span>5349</span>
<span>>></span><span>></span> <span>int</span><span>(</span><span>'12345'</span><span>,</span> <span>16</span><span>)</span>
<span>74565</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>假设要转换大量的二进制字符串，每次都传入 <code>int(x, base=2)</code> 非常麻烦，于是，我们想到，可以定义一个 <code>int2()</code> 的函数，默认把 <code>base=2</code> 传进去:</p>
<div><pre><code><span>def</span> <span>int2</span><span>(</span>x<span>,</span> base<span>=</span><span>2</span><span>)</span><span>:</span>
    <span>return</span> <span>int</span><span>(</span>x<span>,</span> base<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样，我们转换二进制就非常方便了:</p>
<div><pre><code><span>>></span><span>></span> int2<span>(</span><span>'1000000'</span><span>)</span>
<span>64</span>
<span>>></span><span>></span> int2<span>(</span><span>'1010101'</span><span>)</span>
<span>85</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>functools.partial</code> 就是帮助我们创建一个偏函数的，不需要我们自己定义 <code>int2()</code>，可以直接使用下面的代码创建一个新的函数 <code>int2</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> functools
<span>>></span><span>></span> int2 <span>=</span> functools<span>.</span>partial<span>(</span><span>int</span><span>,</span> base<span>=</span><span>2</span><span>)</span>
<span>>></span><span>></span> int2<span>(</span><span>'1000000'</span><span>)</span>
<span>64</span>
<span>>></span><span>></span> int2<span>(</span><span>'1010101'</span><span>)</span>
<span>85</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，简单总结 <code>functools.partial</code> 的作用就是，把一个函数的某些参数给固定住 (也就是设置默认值) ，返回一个新的函数，调用这个新函数会更简单。</p>
<p>注意到上面的新的 <code>int2</code> 函数，仅仅是把 <code>base</code> 参数重新设定默认值为 <code>2</code>，但也可以在函数调用时传入其他值:</p>
<div><pre><code><span>>></span><span>></span> int2<span>(</span><span>'1000000'</span><span>,</span> base<span>=</span><span>10</span><span>)</span>
<span>1000000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code> 和 <code>**kw</code> 这 3 个参数，当传入:</p>
<div><pre><code>int2 <span>=</span> functools<span>.</span>partial<span>(</span><span>int</span><span>,</span> base<span>=</span><span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>实际上固定了 <code>int()</code> 函数的关键字参数 <code>base</code>，也就是:</p>
<div><pre><code>int2<span>(</span><span>'10010'</span><span>)</span>
相当于<span>:</span>

kw <span>=</span> <span>{</span> <span>'base'</span><span>:</span> <span>2</span> <span>}</span>
<span>int</span><span>(</span><span>'10010'</span><span>,</span> <span>**</span>kw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当传入:</p>
<div><pre><code>max2 <span>=</span> functools<span>.</span>partial<span>(</span><span>max</span><span>,</span> <span>10</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>实际上会把 10 作为 <code>*args</code> 的一部分自动加到左边，也就是:</p>
<div><pre><code>max2<span>(</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>相当于:</p>
<div><pre><code>args <span>=</span> <span>(</span><span>10</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>)</span>
<span>max</span><span>(</span><span>*</span>args<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>结果为 <code>10</code>。</p>
<h2 id="小结"> 小结</h2>
<p>当函数的参数个数太多，需要简化时，使用 <code>functools.partial</code> 可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-15T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">函数式编程</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>函数是 Python 内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程(请注意多了一个“式”字)——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机(Computer)和计算(Compute)的概念。</p>
<p>在计算机的层次上，CPU 执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如 C 语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如 Lisp 语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数!</p>
<p>Python 对函数式编程提供部分支持。由于 Python 允许使用变量，因此，Python 不是纯函数式编程语言。</p>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./high-order-function/intro.html">高阶函数介绍</a></p>
</li>
<li>
<p><a href="./high-order-function/map-and-reduce.html">map / reduce</a></p>
</li>
<li>
<p><a href="./high-order-function/filter.html">filter</a></p>
</li>
<li>
<p><a href="./high-order-function/sorted.html">sorted</a></p>
</li>
<li>
<p><a href="./return-function.html">返回函数</a></p>
</li>
<li>
<p><a href="./anonymous-function.html">匿名函数</a></p>
</li>
<li>
<p><a href="./decorator.html">装饰器</a></p>
</li>
<li>
<p><a href="./parital-function.html">偏函数</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-31T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">返回函数</title>
    <id>https://list-jiang.github.io/code/language/python/functional-programming/return-function/</id>
    <link href="https://list-jiang.github.io/code/language/python/functional-programming/return-function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="函数作为返回值"> 函数作为返回值</h2>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的:</p>
<div><pre><code><span>def</span> <span>calc_sum</span><span>(</span><span>*</span>args<span>)</span><span>:</span>
    ax <span>=</span> <span>0</span>
    <span>for</span> n <span>in</span> args<span>:</span>
        ax <span>=</span> ax <span>+</span> n
    <span>return</span> ax
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办? 可以不返回求和的结果，而是返回求和的函数:</p>
<div><pre><code><span>def</span> <span>lazy_sum</span><span>(</span><span>*</span>args<span>)</span><span>:</span>
    <span>def</span> <span>sum</span><span>(</span><span>)</span><span>:</span>
        ax <span>=</span> <span>0</span>
        <span>for</span> n <span>in</span> args<span>:</span>
            ax <span>=</span> ax <span>+</span> n
        <span>return</span> ax
    <span>return</span> <span>sum</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当我们调用 <code>lazy_sum()</code> 时，返回的并不是求和结果，而是求和函数:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> lazy_sum<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>)</span>
<span>>></span><span>></span> f
<span>&lt;</span>function lazy_sum<span>.</span><span>&lt;</span><span>locals</span><span>></span><span>.</span><span>sum</span> at <span>0x101c6ed90</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>调用函数 <code>f</code> 时，才真正计算求和的结果:</p>
<div><pre><code><span>>></span><span>></span> f<span>(</span><span>)</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在这个例子中，我们在函数 <code>lazy_sum</code> 中又定义了函数 <code>sum</code>，并且，内部函数 <code>sum</code> 可以引用外部函数 <code>lazy_sum</code> 的参数和局部变量，当 <code>lazy_sum</code> 返回函数 sum 时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p>
<p>请再注意一点，当我们调用 <code>lazy_sum()</code> 时，每次调用都会返回一个新的函数，即使传入相同的参数:</p>
<div><pre><code><span>>></span><span>></span> f1 <span>=</span> lazy_sum<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>)</span>
<span>>></span><span>></span> f2 <span>=</span> lazy_sum<span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>)</span>
<span>>></span><span>></span> f1<span>==</span>f2
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>f1()</code> 和 <code>f2()</code> 的调用结果互不影响。</p>
<h2 id="闭包"> 闭包</h2>
<p>注意到返回的函数在其定义内部引用了局部变量 <code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 <code>f()</code> 才执行。我们来看一个例子:</p>
<div><pre><code><span>def</span> <span>count</span><span>(</span><span>)</span><span>:</span>
    fs <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>4</span><span>)</span><span>:</span>
        <span>def</span> <span>f</span><span>(</span><span>)</span><span>:</span>
             <span>return</span> i<span>*</span>i
        fs<span>.</span>append<span>(</span>f<span>)</span>
    <span>return</span> fs

f1<span>,</span> f2<span>,</span> f3 <span>=</span> count<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的 3 个函数都返回了。</p>
<p>您可能认为调用 <code>f1()</code>，<code>f2()</code> 和 <code>f3()</code> 结果应该是 <code>1</code>，<code>4</code>，<code>9</code>，但实际结果是:</p>
<div><pre><code><span>>></span><span>></span> f1<span>(</span><span>)</span>
<span>9</span>
<span>>></span><span>></span> f2<span>(</span><span>)</span>
<span>9</span>
<span>>></span><span>></span> f3<span>(</span><span>)</span>
<span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>全部都是 <code>9</code>! 原因就在于返回的函数引用了变量 <code>i</code>，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 <code>i</code> 已经变成了 <code>3</code>，因此最终结果为 <code>9</code>。</p>
<div><p>注意</p>
<p>返回闭包时牢记一点:返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</div>
<p>如果一定要引用循环变量怎么办? 方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:</p>
<div><pre><code><span>def</span> <span>count</span><span>(</span><span>)</span><span>:</span>
    <span>def</span> <span>f</span><span>(</span>j<span>)</span><span>:</span>
        <span>def</span> <span>g</span><span>(</span><span>)</span><span>:</span>
            <span>return</span> j<span>*</span>j
        <span>return</span> g
    fs <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>4</span><span>)</span><span>:</span>
        fs<span>.</span>append<span>(</span>f<span>(</span>i<span>)</span><span>)</span> <span># f(i)立刻被执行，因此i的当前值被传入f()</span>
    <span>return</span> fs
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再看看结果:</p>
<div><pre><code><span>>></span><span>></span> f1<span>,</span> f2<span>,</span> f3 <span>=</span> count<span>(</span><span>)</span>
<span>>></span><span>></span> f1<span>(</span><span>)</span>
<span>1</span>
<span>>></span><span>></span> f2<span>(</span><span>)</span>
<span>4</span>
<span>>></span><span>></span> f3<span>(</span><span>)</span>
<span>9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>缺点是代码较长，可利用 lambda 函数缩短代码。</p>
<h2 id="小结"> 小结</h2>
<p>一个函数可以返回一个计算结果，也可以返回一个函数。</p>
<p>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-06-02T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">Python 基础</title>
    <id>https://list-jiang.github.io/code/language/python/guide/basic/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/basic/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Python 是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成 CPU 能够执行的机器码，然后执行。Python 也不例外。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Python 是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成 CPU 能够执行的机器码，然后执行。Python 也不例外。</p>

<p>Python 的语法比较简单，采用缩进方式，写出来的代码就像下面的样子:</p>
<div><pre><code><span># print absolute value of an integer:</span>
a <span>=</span> <span>100</span>
<span>if</span> a <span>>=</span> <span>0</span><span>:</span>
    <span>print</span><span>(</span>a<span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>-</span>a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>以 <code>#</code> 开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号 <code>:</code> 结尾时，缩进的语句视为代码块。</p>
<div><p>Python 中的缩进</p>
<p>缩进有利有弊。好处是强迫您写出格式化的代码，但没有规定缩进是几个空格还是 Tab。按照约定俗成的惯例，应该始终坚持使用 4 个空格的缩进。</p>
<p>缩进的另一个好处是强迫您写出缩进较少的代码，您会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。</p>
<p>缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当您重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE 很难像格式化 Java 代码那样格式化 Python 代码。</p>
</div>
<div><p>注意</p>
<p>Python 程序是大小写敏感的，如果写错了大小写，程序会报错。</p>
</div>
<h2 id="数据类型"> 数据类型</h2>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在 Python 中，能够直接处理的数据类型有以下几种:</p>
<h3 id="整数"> 整数</h3>
<p>Python 可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如: <code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用 <code>0x</code> 前缀和 <code>0-9</code>，<code>a-f</code> 表示，例如: <code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p>
<h3 id="浮点数"> 浮点数</h3>
<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10<sup>9</sup> 和 <code>12.3x108</code> 是完全相等的。浮点数可以用数学写法，如 <code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把 <code>10</code> 用 <code>e</code> 替代，1.23x10<sup>9</sup> 就是 <code>1.23e9</code>，或者 <code>12.3e8</code>，<code>0.000012</code> 可以写成 <code>1.2e-5</code>，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的(除法难道也是精确的? 是的! )，而浮点数运算则可能会有四舍五入的误差。</p>
<h3 id="字符串"> 字符串</h3>
<h4 id="简介"> 简介</h4>
<p>字符串是以单引号 <code>'</code> 或双引号 <code>&quot;</code> 括起来的任意文本，比如 <code>'abc'</code>，<code>&quot;xyz&quot;</code> 等等。请注意，<code>''</code> 或 <code>&quot;&quot;</code> 本身只是一种表示方式，不是字符串的一部分，因此，字符串 <code>'abc'</code> 只有 <code>a</code>，<code>b</code>，<code>c</code> 这 3 个字符。如果 <code>'</code> 本身也是一个字符，那就可以用 <code>&quot;&quot;</code> 括起来，比如 <code>&quot;I'm OK&quot;</code> 包含的字符是 <code>I</code>，<code>'</code>，<code>m</code>，空格，<code>O</code>，<code>K</code> 这 6 个字符。</p>
<h4 id="转义"> 转义</h4>
<p>如果字符串内部既包含 <code>'</code> 又包含 <code>&quot;</code> 怎么办? 可以用转义字符 <code>\</code> 来标识，比如:</p>
<div><pre><code><span>'I\'m \"OK\"!'</span>
</code></pre>
<div><span>1</span><br></div></div><p>表示的字符串内容是:</p>
<div><pre><code>I&#39;m &quot;OK&quot;!
</code></pre>
<div><span>1</span><br></div></div><p>转义字符 <code>\</code> 可以转义很多字符，比如 <code>\n</code> 表示换行，<code>\t</code> 表示制表符，字符 <code>\</code> 本身也要转义，所以 <code>\\</code> 表示的字符就是 <code>\</code>，可以在 Python 的交互式命令行用 <code>print()</code> 打印字符串看看:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'I\'m ok.'</span><span>)</span>
I'm ok<span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>'I\'m learning\nPython.'</span><span>)</span>
I'm learning
Python<span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>'\\\n\\'</span><span>)</span>
\
\
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="非转义字符串"> 非转义字符串</h3>
<p>如果字符串里面有很多字符都需要转义，就需要加很多 <code>\</code>，为了简化，Python 还允许用 <code>r''</code> 表示 <code>''</code> 内部的字符串默认不转义，可以自己试试:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'\\\t\\'</span><span>)</span>
\       \
<span>>></span><span>></span> <span>print</span><span>(</span><span>r'\\\t\\'</span><span>)</span>
\\\t\\
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="多行字符串"> 多行字符串</h3>
<p>如果字符串内部有很多换行，用 <code>\n</code> 写在一行里不好阅读，为了简化，Python 允许用 <code>'''...'''</code> 的格式表示多行内容，可以自己试试:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'''line1
... line2
... line3'''</span><span>)</span>
line1
line2
line3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由 <code>&gt;&gt;&gt;</code> 变为 <code>...</code>，提示您可以接着上一行输入，注意 <code>...</code> 是提示符，不是代码的一部分:</p>
<div><pre><code>┌────────────────────────────────────────────────────────┐
│Command Prompt - python                           _ □ x │
├────────────────────────────────────────────────────────┤
│&gt;&gt;&gt; print(&#39;&#39;&#39;line1                                      │
│... line2                                               │
│... line3&#39;&#39;&#39;)                                           │
│line1                                                   │
│line2                                                   │
│line3                                                   │
│                                                        │
│&gt;&gt;&gt;_                                                    │
│                                                        │
└────────────────────────────────────────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>当输入完结束符 <code>```</code> 和括号 <code>)</code> 后，执行该语句并打印结果。</p>
<p>如果写成程序并存为 <code>.py</code> 文件，就是:</p>
<div><pre><code><span>print</span><span>(</span><span>'''line1
line2
line3'''</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>多行字符串 <code>'''...'''</code> 还可以在前面加上 <code>r</code> 使用，请自行测试:</p>
<h3 id="布尔值"> 布尔值</h3>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有 <code>True</code>、<code>False</code> 两种值，在 Python 中，可以直接用 <code>True</code>、<code>False</code> 表示布尔值(请注意大小写)，也可以通过布尔运算计算出来:</p>
<div><pre><code><span>>></span><span>></span> <span>True</span>
<span>True</span>
<span>>></span><span>></span> <span>False</span>
<span>False</span>
<span>>></span><span>></span> <span>3</span> <span>></span> <span>2</span>
<span>True</span>
<span>>></span><span>></span> <span>3</span> <span>></span> <span>5</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>布尔值可以用 <code>and</code>、<code>or</code> 和 <code>not</code> 运算。</p>
<p><code>and</code> 运算是与运算，只有所有都为 <code>True</code>，<code>and</code> 运算结果才是 <code>True</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>True</span> <span>and</span> <span>True</span>
<span>True</span>
<span>>></span><span>></span> <span>True</span> <span>and</span> <span>False</span>
<span>False</span>
<span>>></span><span>></span> <span>False</span> <span>and</span> <span>False</span>
<span>False</span>
<span>>></span><span>></span> <span>5</span> <span>></span> <span>3</span> <span>and</span> <span>3</span> <span>></span> <span>1</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>or</code> 运算是或运算，只要其中有一个为 <code>True</code>，<code>or</code> 运算结果就是 <code>True</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>True</span> <span>or</span> <span>True</span>
<span>True</span>
<span>>></span><span>></span> <span>True</span> <span>or</span> <span>False</span>
<span>True</span>
<span>>></span><span>></span> <span>False</span> <span>or</span> <span>False</span>
<span>False</span>
<span>>></span><span>></span> <span>5</span> <span>></span> <span>3</span> <span>or</span> <span>1</span> <span>></span> <span>3</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>not</code> 运算是非运算，它是一个单目运算符，把 <code>True</code> 变成 <code>False</code>，<code>False</code> 变成 <code>True</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>not</span> <span>True</span>
<span>False</span>
<span>>></span><span>></span> <span>not</span> <span>False</span>
<span>True</span>
<span>>></span><span>></span> <span>not</span> <span>1</span> <span>></span> <span>2</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>布尔值经常用在条件判断中，比如:</p>
<div><pre><code><span>if</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>print</span><span>(</span><span>'adult'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'teenager'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="空值"> 空值</h3>
<p>空值是 Python 里一个特殊的值，用 <code>None</code> 表示。<code>None</code> 不能理解为 <code>0</code>，因为 <code>0</code> 是有意义的，而 <code>None</code> 是一个特殊的空值。</p>
<p>此外，Python 还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p>
<h2 id="变量"> 变量</h2>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和 <code>_</code> 的组合，且不能用数字开头，比如:</p>
<div><pre><code>a <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>变量 <code>a</code> 是一个整数。</p>
<div><pre><code>t_007 <span>=</span> <span>'T007'</span>
</code></pre>
<div><span>1</span><br></div></div><p>变量 <code>t_007</code> 是一个字符串。</p>
<div><pre><code>Answer <span>=</span> <span>True</span>
</code></pre>
<div><span>1</span><br></div></div><p>变量 <code>Answer</code> 是一个布尔值 <code>True</code>。</p>
<p>在 Python 中，等号 <code>=</code> 是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>

a <span>=</span> <span>123</span> <span># a是整数</span>
<span>print</span><span>(</span>a<span>)</span>
a <span>=</span> <span>'ABC'</span> <span># a变为字符串</span>
<span>print</span><span>(</span>a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如 Java 是静态语言，赋值语句如下(<code>//</code> 表示注释):</p>
<div><pre><code><span>int</span> a <span>=</span> <span>123</span><span>;</span> <span>// a是整数类型变量</span>
a <span>=</span> <span>"ABC"</span><span>;</span> <span>// 错误:不能把字符串赋给整型变量</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码:</p>
<div><pre><code>x <span>=</span> <span>10</span>
x <span>=</span> x <span>+</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果从数学上理解 <code>x = x + 2</code> 那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式 <code>x + 2</code>，得到结果 <code>12</code>，再赋给变量 <code>x</code>。由于 <code>x</code> 之前的值是 <code>10</code>，重新赋值后，<code>x</code> 的值变成 <code>12</code>。</p>
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写:</p>
<div><pre><code>a <span>=</span> <span>'ABC'</span>
</code></pre>
<div><span>1</span><br></div></div><p>时，Python 解释器干了两件事情:</p>
<ol>
<li>
<p>在内存中创建了一个 <code>'ABC'</code> 的字符串；</p>
</li>
<li>
<p>在内存中创建了一个名为 a 的变量，并把它指向 <code>'ABC'</code>。</p>
</li>
</ol>
<p>也可以把一个变量 a 赋值给另一个变量 b，这个操作实际上是把变量 b 指向变量 a 所指向的数据，例如下面的代码:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>

a <span>=</span> <span>'ABC'</span>
b <span>=</span> a
a <span>=</span> <span>'XYZ'</span>
<span>print</span><span>(</span>b<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>最后一行打印出变量 b 的内容到底是 <code>'ABC'</code> 呢还是 <code>'XYZ'</code>? 如果从数学意义上理解，就会错误地得出 b 和 a 相同，也应该是 <code>'XYZ'</code>，但实际上 b 的值是 <code>'ABC'</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事:</p>
<ol>
<li>
<p>执行 <code>a = 'ABC</code>'，解释器创建了字符串 <code>'ABC'</code> 和变量 a，并把 a 指向 <code>'ABC'</code></p>
</li>
<li>
<p>执行 <code>b = a</code>，解释器创建了变量 b，并把 b 指向 a 指向的字符串 <code>'ABC'</code></p>
</li>
<li>
<p>执行 <code>a = 'XYZ'</code>，解释器创建了字符串 <code>'XYZ'</code>，并把 a 的指向改为 <code>'XYZ'</code>，但 b 并没有更改</p>
</li>
<li>
<p>所以，最后打印变量 b 的结果自然是 <code>'ABC'</code> 了。</p>
</li>
</ol>
<h3 id="常量"> 常量</h3>
<p>所谓常量就是不能变的变量，比如常用的数学常数 π 就是一个常量。在 Python 中，通常用全部大写的变量名表示常量:</p>
<div><pre><code>PI <span>=</span> <span>3.14159265359</span>
</code></pre>
<div><span>1</span><br></div></div><p>但事实上 PI 仍然是一个变量，Python 根本没有任何机制保证 PI 不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果您一定要改变变量 PI 的值，也没人能拦住您。</p>
<p>最后解释一下整数的除法为什么也是精确的。在 Python 中，有两种除法，一种除法是 <code>/</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>10</span> <span>/</span> <span>3</span>
<span>3.3333333333333335</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>/</code> 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数:</p>
<div><pre><code><span>>></span><span>></span> <span>9</span> <span>/</span> <span>3</span>
<span>3.0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>还有一种除法是 <code>//</code>，称为地板除，两个整数的除法仍然是整数:</p>
<div><pre><code><span>>></span><span>></span> <span>10</span> <span>//</span> <span>3</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>您没有看错，整数的地板除 <code>//</code> 永远是整数，即使除不尽。要做精确的除法，使用 <code>/</code> 就可以。</p>
<p>因为 <code>//</code> 除法只取结果的整数部分，所以 Python 还提供一个余数运算 <code>%</code>，可以得到两个整数相除的余数:</p>
<div><pre><code><span>>></span><span>></span> <span>10</span> <span>%</span> <span>3</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>无论整数做 <code>//</code> 除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p>
<h2 id="小结"> 小结</h2>
<p>Python 支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>
<p>对变量赋值 <code>x = y</code> 是把变量 x 指向真正的对象，该对象是变量 y 所指向的。随后对变量 y 的赋值不影响变量 x 的指向。</p>
<p>Python 的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>−</span><span>2147483648</span></span></span></span> ~ <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>2147483647</span></span></span></span>。</p>
<p>Python 的浮点数也没有大小限制，但是超出一定范围就直接表示为 <code>inf</code>(无限大)。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-21T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">条件判断</title>
    <id>https://list-jiang.github.io/code/language/python/guide/condition/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/condition/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在 Python 程序中，用 <code>if</code> 语句实现:</p>
]]></summary>
    <content type="html"><![CDATA[<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在 Python 程序中，用 <code>if</code> 语句实现:</p>

<div><pre><code>age <span>=</span> <span>20</span>
<span>if</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>print</span><span>(</span><span>'your age is'</span><span>,</span> age<span>)</span>
    <span>print</span><span>(</span><span>'adult'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>根据 Python 的缩进规则，如果 <code>if</code> 语句判断是 <code>True</code>，就把缩进的两行 <code>print</code> 语句执行了，否则，什么也不做。</p>
<p>也可以给 <code>if</code> 添加一个 <code>else</code> 语句，意思是，如果 <code>if</code> 判断是 <code>False</code>，不要执行 <code>if</code> 的内容，去把 <code>else</code> 执行了:</p>
<div><pre><code>age <span>=</span> <span>3</span>
<span>if</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>print</span><span>(</span><span>'your age is'</span><span>,</span> age<span>)</span>
    <span>print</span><span>(</span><span>'adult'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'your age is'</span><span>,</span> age<span>)</span>
    <span>print</span><span>(</span><span>'teenager'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意不要少写了冒号 <code>:</code>。</p>
<p>当然上面的判断是很粗略的，完全可以用 <code>elif</code> 做更细致的判断:</p>
<div><pre><code>age <span>=</span> <span>3</span>
<span>if</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>print</span><span>(</span><span>'adult'</span><span>)</span>
<span>elif</span> age <span>>=</span> <span>6</span><span>:</span>
    <span>print</span><span>(</span><span>'teenager'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'kid'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>elif</code> 是 <code>else if</code> 的缩写，完全可以有多个 <code>elif</code>，所以 <code>if</code> 语句的完整形式就是:</p>
<div><pre><code><span>if</span> <span>&lt;</span>条件判断<span>1</span><span>></span><span>:</span>
    <span>&lt;</span>执行<span>1</span><span>></span>
<span>elif</span> <span>&lt;</span>条件判断<span>2</span><span>></span><span>:</span>
    <span>&lt;</span>执行<span>2</span><span>></span>
<span>elif</span> <span>&lt;</span>条件判断<span>3</span><span>></span><span>:</span>
    <span>&lt;</span>执行<span>3</span><span>></span>
<span>else</span><span>:</span>
    <span>&lt;</span>执行<span>4</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>if</code> 语句执行有个特点，它是从上往下判断，如果在某个判断上是 <code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的 <code>elif</code> 和 <code>else</code>，所以，请测试并解释为什么下面的程序打印的是 <code>teenager</code>:</p>
<div><pre><code>age <span>=</span> <span>20</span>
<span>if</span> age <span>>=</span> <span>6</span><span>:</span>
    <span>print</span><span>(</span><span>'teenager'</span><span>)</span>
<span>elif</span> age <span>>=</span> <span>18</span><span>:</span>
    <span>print</span><span>(</span><span>'adult'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'kid'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>if</code> 判断条件还可以简写，比如写:</p>
<div><pre><code><span>if</span> x<span>:</span>
    <span>print</span><span>(</span><span>'True'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>只要 <code>x</code> 是非零数值、非空字符串、非空 list 等，就判断为 <code>True</code>，否则为 <code>False</code>。</p>
<h2 id="再议-input"> 再议 input</h2>
<p>最后看一个有问题的条件判断。很多同学会用 <code>input()</code> 读取用户的输入，这样可以自己输入，程序运行得更有意思:</p>
<div><pre><code>birth <span>=</span> <span>input</span><span>(</span><span>'birth: '</span><span>)</span>
<span>if</span> birth <span>&lt;</span> <span>2000</span><span>:</span>
    <span>print</span><span>(</span><span>'00前'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'00后'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>输入 1982，结果报错:</p>
<div><pre><code>Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
TypeError: unorderable types: str<span>(</span><span>)</span> <span>></span> int<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是因为 <code>input()</code> 返回的数据类型是 <code>str</code>，<code>str</code> 不能直接和整数比较，必须先把 <code>str</code> 转换成整数。Python 提供了 <code>int()</code> 函数来完成这件事情:</p>
<div><pre><code>s <span>=</span> <span>input</span><span>(</span><span>'birth: '</span><span>)</span>
birth <span>=</span> <span>int</span><span>(</span>s<span>)</span>
<span>if</span> birth <span>&lt;</span> <span>2000</span><span>:</span>
    <span>print</span><span>(</span><span>'00前'</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>'00后'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>再次运行，就可以得到正确地结果。但是，如果输入 <code>abc</code> 呢? 又会得到一个错误信息:</p>
<div><pre><code>Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
ValueError: invalid literal <span>for</span> int<span>(</span><span>)</span> with base <span>10</span>: <span>'abc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>原来 <code>int()</code> 函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</p>
<p>如何检查并捕获程序运行期的错误呢? 后面的错误和调试会讲到。</p>
<h2 id="小结"> 小结</h2>
<p>条件判断可以让计算机自己做选择，Python 的 <code>if...elif...else</code> 很灵活。</p>
<p>条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的 <code>elif</code> 和 <code>else</code> 都不再执行。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-24T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">dict 和 set</title>
    <id>https://list-jiang.github.io/code/language/python/guide/dict-and-set/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/dict-and-set/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p><code>dict</code> 和 <code>set</code> 是 Python 中常用的数据结构。</p>
]]></summary>
    <content type="html"><![CDATA[<p><code>dict</code> 和 <code>set</code> 是 Python 中常用的数据结构。</p>

<h2 id="dict"> dict</h2>
<p>Python 内置了字典 dict 的支持，dict 全称 dictionary，在其他语言中也称为 map，使用 <code>键-值</code> (key-value)存储，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用 list 实现，需要两个 list:</p>
<div><pre><code>names <span>=</span> <span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
scores <span>=</span> <span>[</span><span>95</span><span>,</span> <span>75</span><span>,</span> <span>85</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，list 越长，耗时越长。</p>
<p>如果用 dict 实现，只需要一个 <code>名字-成绩</code> 的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 Python 写一个 dict 如下:</p>
<div><pre><code><span>>></span><span>></span> d <span>=</span> <span>{</span><span>'Michael'</span><span>:</span> <span>95</span><span>,</span> <span>'Bob'</span><span>:</span> <span>75</span><span>,</span> <span>'Tracy'</span><span>:</span> <span>85</span><span>}</span>
<span>>></span><span>></span> d<span>[</span><span>'Michael'</span><span>]</span>
<span>95</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>dict 的速度优势</p>
<p>为什么 dict 查找速度这么快? 因为 dict 的实现原理和查字典是一样的。</p>
<p>假设字典包含了 1 万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在 list 中查找元素的方法，list 越大，查找越慢。</p>
<p>第二种方法是先在字典的索引表里(比如部首表)查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>
<p>dict 就是第二种实现方式，给定一个名字，比如 <code>'Michael'</code>，dict 在内部就可以直接计算出 <code>Michael</code> 对应的存放成绩的“页码”，也就是 <code>95</code> 这个数字存放的内存地址，直接取出来，所以速度非常快。</p>
</div>
<p>您可以猜到，这种 <code>key - value</code> 存储方式，在放进去的时候，必须根据 key 算出 value 的存放位置，这样，取的时候才能根据 key 直接拿到 value。</p>
<p>把数据放入 dict 的方法，除了初始化时指定外，还可以通过 key 放入:</p>
<div><pre><code><span>>></span><span>></span> d<span>[</span><span>'Adam'</span><span>]</span> <span>=</span> <span>67</span>
<span>>></span><span>></span> d<span>[</span><span>'Adam'</span><span>]</span>
<span>67</span>
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉<span>:</span>
<span>>></span><span>></span> d<span>[</span><span>'Jack'</span><span>]</span> <span>=</span> <span>90</span>
<span>>></span><span>></span> d<span>[</span><span>'Jack'</span><span>]</span>
<span>90</span>
<span>>></span><span>></span> d<span>[</span><span>'Jack'</span><span>]</span> <span>=</span> <span>88</span>
<span>>></span><span>></span> d<span>[</span><span>'Jack'</span><span>]</span>
<span>88</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果 key 不存在，dict 就会报错:</p>
<div><pre><code><span>>></span><span>></span> d<span>[</span><span>'Thomas'</span><span>]</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
KeyError<span>:</span> <span>'Thomas'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>要避免 key 不存在的错误，有两种办法，一是通过 <code>in</code> 判断 key 是否存在:</p>
<div><pre><code><span>>></span><span>></span> <span>'Thomas'</span> <span>in</span> d
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>二是通过 dict 提供的 <code>get()</code> 方法，如果 key 不存在，可以返回 <code>None</code>，或者自己指定的 value:</p>
<div><pre><code><span>>></span><span>></span> d<span>.</span>get<span>(</span><span>'Thomas'</span><span>)</span>
<span>>></span><span>></span> d<span>.</span>get<span>(</span><span>'Thomas'</span><span>,</span> <span>-</span><span>1</span><span>)</span>
<span>-</span><span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>返回 <code>None</code> 的时候 Python 的交互环境不显示结果。</p>
</div>
<p>要删除一个 key，用 <code>pop(key)</code> 方法，对应的 value 也会从 dict 中删除:</p>
<div><pre><code><span>>></span><span>></span> d<span>.</span>pop<span>(</span><span>'Bob'</span><span>)</span>
<span>75</span>
<span>>></span><span>></span> d
<span>{</span><span>'Michael'</span><span>:</span> <span>95</span><span>,</span> <span>'Tracy'</span><span>:</span> <span>85</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>请务必注意，dict 内部存放的顺序和 key 放入的顺序是没有关系的。</p>
<p>和 list 比较，dict 有以下几个特点:</p>
<ul>
<li>查找和插入的速度极快，不会随着 key 的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ul>
<p>而 list 相反:</p>
<ul>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ul>
<p>所以，dict 是用空间来换取时间的一种方法。</p>
<p>dict 可以用在需要高速查找的很多地方，在 Python 代码中几乎无处不在，正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是<strong>不可变对象</strong>。</p>
<p>这是因为 dict 根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法(Hash)。</p>
<p>要保证 hash 的正确性，作为 key 的对象就不能变。在 Python 中，字符串、整数等都是不可变的，因此，可以放心地作为 key。而 list 是可变的，就不能作为 key:</p>
<div><pre><code><span>>></span><span>></span> key <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
<span>>></span><span>></span> d<span>[</span>key<span>]</span> <span>=</span> <span>'a list'</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
TypeError<span>:</span> unhashable <span>type</span><span>:</span> <span>'list'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>关于 dict 的补充内容请看脚注<sup></sup>。</p>
<h2 id="set"> set</h2>
<p>set 和 dict 类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key。</p>
<p>要创建一个 set，需要提供一个 list 作为输入集合:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> <span>set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，传入的参数 <code>[1, 2, 3]</code> 是一个 list，而显示的 <code>{1, 2, 3}</code> 只是告诉您这个 set 内部有 1，2，3 这 3 个元素，显示的顺序也不表示 set 是有序的。。</p>
<p>重复元素在 set 中自动被过滤:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> <span>set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通过 <code>add(key)</code> 方法可以添加元素到 set 中，可以重复添加，但不会有效果:</p>
<div><pre><code><span>>></span><span>></span> s<span>.</span>add<span>(</span><span>4</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>}</span>
<span>>></span><span>></span> s<span>.</span>add<span>(</span><span>4</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>通过 <code>remove(key)</code> 方法可以删除元素:</p>
<div><pre><code><span>>></span><span>></span> s<span>.</span>remove<span>(</span><span>4</span><span>)</span>
<span>>></span><span>></span> s
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>set 可以看成数学意义上的无序和无重复元素的集合，因此，两个 set 可以做数学意义上的交集、并集等操作:</p>
<div><pre><code><span>>></span><span>></span> s1 <span>=</span> <span>set</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>>></span><span>></span> s2 <span>=</span> <span>set</span><span>(</span><span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>)</span>
<span>>></span><span>></span> s1 <span>&amp;</span> s2
<span>{</span><span>2</span><span>,</span> <span>3</span><span>}</span>
<span>>></span><span>></span> s1 <span>|</span> s2
<span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>set 和 dict 的唯一区别仅在于没有存储对应的 value，但是，set 的原理和 dict 一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证 set 内部“不会有重复元素”。试试把 list 放入 set，看看是否会报错。</p>
<h2 id="不可变对象"> 不可变对象</h2>
<p>上面我们讲了，str 是不变对象，而 list 是可变对象。</p>
<p>对于可变对象，比如 list，对 list 进行操作，list 内部的内容是会变化的，比如:</p>
<div><pre><code><span>>></span><span>></span> a <span>=</span> <span>[</span><span>'c'</span><span>,</span> <span>'b'</span><span>,</span> <span>'a'</span><span>]</span>
<span>>></span><span>></span> a<span>.</span>sort<span>(</span><span>)</span>
<span>>></span><span>></span> a
<span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>而对于不可变对象，比如 str，对 str 进行操作呢:</p>
<div><pre><code><span>>></span><span>></span> a <span>=</span> <span>'abc'</span>
<span>>></span><span>></span> a<span>.</span>replace<span>(</span><span>'a'</span><span>,</span> <span>'A'</span><span>)</span>
<span>'Abc'</span>
<span>>></span><span>></span> a
<span>'abc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>虽然字符串有个 <code>replace()</code> 方法，也确实变出了 <code>'Abc'</code>，但变量 a 最后仍是 <code>'abc'</code>，应该怎么理解呢?</p>
<p>我们先把代码改成下面这样:</p>
<div><pre><code><span>>></span><span>></span> a <span>=</span> <span>'abc'</span>
<span>>></span><span>></span> b <span>=</span> a<span>.</span>replace<span>(</span><span>'a'</span><span>,</span> <span>'A'</span><span>)</span>
<span>>></span><span>></span> b
<span>'Abc'</span>
<span>>></span><span>></span> a
<span>'abc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>要始终牢记的是，a 是变量，而 <code>'abc'</code> 才是字符串对象! 有些时候，我们经常说，对象 a 的内容是 <code>'abc'</code>，但其实是指，a 本身是一个变量，它指向的对象的内容才是 <code>'abc'</code>:</p>
<div><pre><code>┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ &#39;abc&#39; │
└───┘                  └───────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们调用 <code>a.replace('a', 'A')</code> 时，实际上调用方法 <code>replace</code> 是作用在字符串对象 <code>'abc'</code> 上的，而这个方法虽然名字叫 replace，但却没有改变字符串 <code>'abc'</code> 的内容。相反，<code>replace</code> 方法创建了一个新字符串 <code>'Abc'</code> 并返回，如果我们用变量 b 指向该新字符串，就容易理解了，变量 a 仍指向原有的字符串 <code>'abc'</code>，但变量 b 却指向新字符串 <code>'Abc'</code> 了:</p>
<div><pre><code>┌───┐                  ┌───────┐
│ a │─────────────────&gt;│ &#39;abc&#39; │
└───┘                  └───────┘
┌───┐                  ┌───────┐
│ b │─────────────────&gt;│ &#39;Abc&#39; │
└───┘                  └───────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<h2 id="小结"> 小结</h2>
<p>使用 key-value 存储结构的 dict 在 Python 中非常有用，选择不可变对象作为 key 很重要，最常用的 key 是字符串。</p>
<p>tuple 虽然是不变对象，但试试把 <code>(1, 2, 3)</code> 和 <code>(1, [2, 3])</code> 放入 dict 或 set 中，并解释结果。</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>补充内容</p>
<p>要理解 dict 的有关内容需要您理解哈希表(map)的相关基础知识，这个其实是《算法与数据结构》里面的内容。</p>
<ol>
<li>
<p>list 和 tuple 其实是用链表顺序存储的，也就是前一个元素中存储了下一个元素的位置，这样只要找到第一个元素的位置就可以顺藤摸瓜找到所有元素的位置，所以 list 的名字其实就是个指针，指向 list 的第一个元素的位置。list 的插入和删除等可以直接用链表的方式进行，比如我要在第 1 个元素和第 2 个元素中间插入一个元素，那么直接在链表的最后面(我们假设这个 list 只有两个元素，那么也就是在第 3 个元素的位置上)插入这个元素，然后把第一个元素指针指向这个元素(第 3 个位置)，然后再把新插入的元素的指针指向原来的第 2 个元素，这样插入操作就完成了。读取这个 list 的时候，先用 list 的名字(就是个指针，指向第 1 个元素的位置)找到第一个元素，然后用第 1 一个元素的指针找到第 2 个元素(位置 3)，然后用第 2 个元素的指针找到第 3 个元素(位置 2)，以此类推。所以 list 的顺序和内存中的实际顺序其实不一定完全对应。这种存储方式不会浪费内存，但查找起来特别费时间，因为要按照链表一个一个找下去，如果您的 list 特别大的话，那么要等好久才会找到结果。</p>
</li>
<li>
<p>dict 则为了快速查找使用了一种特别的方法，哈希表。哈希表采用哈希函数从 key 计算得到一个数字(哈希函数有个特点: 对于不同的 key，有很大的概率得到的哈希值也不同)，然后直接把 value 存储到这个数字所对应的地址上，比如 <code>key='ABC'，value=10</code>，经过哈希函数得到 key 对应的哈希值为 <code>123</code>，那么就申请一个有 1000 个地址(从 0 到 999)的内存，然后把 <code>10</code> 存放在地址为 123 的地方。类似的，对于 <code>key='BCD'，value=20</code>，得到 key 的哈希值为 <code>234</code>，那么就把 <code>20</code> 存放在地址为 234 的地方。对于这样的表查找起来是非常方便的。只要给出 key，计算得到哈希值，然后直接到对应的地址去找 value 就可以了。无论有几个元素，都可以直接找到 value，无需遍历整个表。不过虽然 dict 查找速度快，但内存浪费严重，您看我们只存储了两个元素，都要申请一个长度为 1000 的内存。</p>
</li>
<li>
<p>现在您知道为啥 key 要用不可变对象了吧? 因为不可变对象是常量，每次的哈希值算出来都是固定的，这样就不会出错。比如 <code>key='ABC'，value=10</code>，存储地址为 123，假设我突发奇想，把 key 改成 <code>'BCD'</code>，那么当查找 <code>'BCD'</code> 的 value 的时候就会去 234 的地址找，但那里啥也没有，这就乱套了。</p>
</li>
</ol>
<p>对于不同的 key，有很大的概率得到的哈希值也不同。那么有很小的概率不同的 key 可以得到相同的哈希值了? 没错，比如对于我们的例子来说，哈希值只有 3 位，那么只要元素个数超过 1000，就一定会有至少两个 key 的哈希值相同(鸽笼原理)，这种情况叫“冲突”，设计哈希表的时候要采取办法减少冲突，实在冲突了也要想办法补救。不过这是编译器的事情，况且对于初学者的我们来说碰到的冲突的概率基本等于零，就不用操心了。 </p>
</li>
</ol>
</section>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-25T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">练习</title>
    <id>https://list-jiang.github.io/code/language/python/guide/exercise/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/exercise/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="bmi"> BMI</h2>
<p>小明的成绩从去年的 72 分提升到了今年的 85 分，请计算小明成绩提升的百分点，并用字符串格式化显示出 'xx.x%'，只保留小数点后 1 位:</p>
<p>答案<sup></sup></p>
<hr>
<section>
<ol>
<li id="footnote1"><div><pre><code>score1 <span>=</span> <span>72</span>

score2 <span>=</span> <span>85</span>

result <span>=</span> <span>(</span>score2 <span>-</span> score1<span>)</span> <span>/</span> score1 <span>*</span> <span>100</span>

<span>print</span><span>(</span><span>'小明成绩提升了%.1f%%'</span> <span>%</span> result<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div> </li>
</ol>
</section>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-06-02T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">输入和输出</title>
    <id>https://list-jiang.github.io/code/language/python/guide/io/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/io/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>一个脚本语言少不了与用户进行交互，就一定涉及到输入输出。</p>
]]></summary>
    <content type="html"><![CDATA[<p>一个脚本语言少不了与用户进行交互，就一定涉及到输入输出。</p>

<h2 id="输出"> 输出</h2>
<p>用 <code>print()</code> 在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出 <code>'hello, world'</code>，用代码实现如下:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'hello, world'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>print()</code> 函数也可以接受多个字符串，用逗号 “,” 隔开，就可以连成一串输出:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'The quick brown fox'</span><span>,</span> <span>'jumps over'</span><span>,</span> <span>'the lazy dog'</span><span>)</span>
The quick brown fox jumps over the lazy dog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>print()</code> 会依次打印每个字符串，遇到逗号“,”会输出一个空格。</p>
<p><code>print()</code> 也可以打印整数，或者计算结果:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>300</span><span>)</span>
<span>300</span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>100</span> <span>+</span> <span>200</span><span>)</span>
<span>300</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因此，我们可以把计算 <code>100 + 200</code> 的结果打印得更漂亮一点:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span><span>'100 + 200 ='</span><span>,</span> <span>100</span> <span>+</span> <span>200</span><span>)</span>
<span>100</span> <span>+</span> <span>200</span> <span>=</span> <span>300</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，对于 <code>100 + 200</code>，Python 解释器自动计算出结果 300，但是，<code>'100 + 200 ='</code> 是字符串而非数学公式，Python 把它视为字符串，请自行解释上述打印结果。</p>
<h2 id="输入"> 输入</h2>
<p>如果需要用户从电脑输入一些字符，Python 提供了一个 <code>input()</code>，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字:</p>
<div><pre><code><span>>></span><span>></span> name <span>=</span> <span>input</span><span>(</span><span>)</span>
Mr<span>.</span>Hope
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当您输入 <code>name = input()</code> 并按下回车后，Python 交互式命令行就在等待您的输入了。这时，您可以输入任意字符，然后按回车后完成输入。</p>
<p>输入完成后，不会有任何提示，Python 交互式命令行又回到 <code>&gt;&gt;&gt;</code> 状态了。那我们刚才输入的内容到哪去了? 答案是存放到 <code>name</code> 变量里了。可以直接输入 <code>name</code> 查看变量内容:</p>
<div><pre><code><span>>></span><span>></span> name
<span>'Mr.Hope'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>变量</p>
<p>请回忆初中数学所学的代数基础知识:</p>
<p>设正方形的边长为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>a</span></span></span></span> ，则正方形的面积为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>a</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>a</span></span></span></span> 。把边长 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>a</span></span></span></span> 看做一个变量，我们就可以根据 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>a</span></span></span></span> 的值计算正方形的面积，比如:</p>
<p>若 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>a</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span></span></span></span> ，则面积为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>a</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>a</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>2</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>4</span></span></span></span> ；</p>
<p>若 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>a</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>3.5</span></span></span></span>，则面积为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>a</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>a</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3.5</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>3.5</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>12.25</span></span></span></span> 。</p>
<p>在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，<code>name</code> 作为一个变量就是一个字符串。</p>
<p>要打印出 <code>name</code> 变量的内容，除了直接写 <code>name</code> 然后按回车外，还可以用 <code>print()</code> 函数:</p>
<div><pre><code><span>>></span><span>></span> <span>print</span><span>(</span>name<span>)</span>
Mr<span>.</span>Hope
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<p>有了输入和输出，我们就可以把上次打印 <code>'hello, world'</code> 的程序改成有点意义的程序了:</p>
<div><pre><code>name <span>=</span> <span>input</span><span>(</span><span>)</span>
<span>print</span><span>(</span><span>'hello,'</span><span>,</span> name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入 <code>name</code> 变量中；第二行代码会根据用户的名字向用户说 <code>hello</code>，比如输入 <code>Mr.Hope</code></p>
<div><pre><code>C:/Workspace<span>></span> python hello.py
Mr.Hope
hello, Mr.Hope
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是程序运行的时候，没有任何提示信息告诉用户:“嘿，赶紧输入您的名字”，这样显得很不友好。所以 <code>input()</code> 可以让您显示一个字符串来提示用户，于是我们把代码改成:</p>
<div><pre><code>name <span>=</span> <span>input</span><span>(</span><span>'please enter your name: '</span><span>)</span>
<span>print</span><span>(</span><span>'hello,'</span><span>,</span> name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再次运行这个程序，您会发现，程序一运行，会首先打印出 <code>please enter your name:</code>，这样，用户就可以根据提示，输入名字后，得到 <code>hello, xxx</code> 的输出:</p>
<div><pre><code>C:/Workspace<span>></span> python hello.py
please enter your name: Mr.Hope
hello, Mr.Hope
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>每次运行该程序，根据用户输入的不同，输出结果也会不同。</p>
<p>在命令行下，输入和输出就是这么简单。</p>
<h2 id="小结"> 小结</h2>
<p>任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。</p>
<p>输入是 Input，输出是 Output，因此，我们把输入输出统称为 Input/Output，或者简写为 IO。</p>
<p><code>input()</code> 和 <code>print()</code> 是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-20T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">list 和 tuple</title>
    <id>https://list-jiang.github.io/code/language/python/guide/list-and-tuple/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/list-and-tuple/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p><code>list</code> 和 <code>tuple</code> 是 Python 中常用的数据结构。</p>
]]></summary>
    <content type="html"><![CDATA[<p><code>list</code> 和 <code>tuple</code> 是 Python 中常用的数据结构。</p>

<h2 id="list"> list</h2>
<p>Python 内置的一种数据类型是列表: list。list 是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个 list 表示:</p>
<div><pre><code><span>>></span><span>></span> classmates <span>=</span> <span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>变量 <code>classmates</code> 就是一个 list。用 <code>len()</code> 函数可以获得 list 元素的个数:</p>
<div><pre><code><span>>></span><span>></span> <span>len</span><span>(</span>classmates<span>)</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>用索引来访问 list 中每一个位置的元素，记得索引是从 <code>0</code> 开始的:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>[</span><span>0</span><span>]</span>
<span>'Michael'</span>
<span>>></span><span>></span> classmates<span>[</span><span>1</span><span>]</span>
<span>'Bob'</span>
<span>>></span><span>></span> classmates<span>[</span><span>2</span><span>]</span>
<span>'Tracy'</span>
<span>>></span><span>></span> classmates<span>[</span><span>3</span><span>]</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
IndexError<span>:</span> <span>list</span> index out of <span>range</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当索引超出了范围时，Python 会报一个 <code>IndexError</code> 错误，所以，要确保索引不要越界，记得最后一个元素的索引是 <code>len(classmates) - 1</code>。</p>
<p>如果要取最后一个元素，除了计算索引位置外，还可以用 <code>-1</code> 做索引，直接获取最后一个元素:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>[</span><span>-</span><span>1</span><span>]</span>
<span>'Tracy'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>以此类推，可以获取倒数第 2 个、倒数第 3 个:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>[</span>-2<span>]</span>
<span>'Bob'</span>
<span>>></span><span>></span> classmates<span>[</span>-3<span>]</span>
<span>'Michael'</span>
<span>>></span><span>></span> classmates<span>[</span>-4<span>]</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
IndexError: list index out of range
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当然，倒数第 4 个就越界了。</p>
<p>list 是一个可变的有序表，所以，可以往 list 中追加元素到末尾:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>.</span>append<span>(</span><span>'Adam'</span><span>)</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>,</span> <span>'Adam'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也可以把元素插入到指定的位置，比如索引号为 <code>1</code> 的位置:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>.</span>insert<span>(</span><span>1</span><span>,</span> <span>'Jack'</span><span>)</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Jack'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>,</span> <span>'Adam'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要删除 list 末尾的元素，用 <code>pop()</code> 方法:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>.</span>pop<span>(</span><span>)</span>
<span>'Adam'</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Jack'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>要删除指定位置的元素，用 <code>pop(i)</code> 方法，其中 <code>i</code> 是索引位置:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>.</span>pop<span>(</span><span>1</span><span>)</span>
<span>'Jack'</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置:</p>
<div><pre><code><span>>></span><span>></span> classmates<span>[</span><span>1</span><span>]</span> <span>=</span> <span>'Sarah'</span>
<span>>></span><span>></span> classmates
<span>[</span><span>'Michael'</span><span>,</span> <span>'Sarah'</span><span>,</span> <span>'Tracy'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>list 里面的元素的数据类型也可以不同，比如:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span><span>'Apple'</span><span>,</span> <span>123</span><span>,</span> <span>True</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>list 元素也可以是另一个 list，比如:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> <span>[</span><span>'python'</span><span>,</span> <span>'java'</span><span>,</span> <span>[</span><span>'asp'</span><span>,</span> <span>'php'</span><span>]</span><span>,</span> <span>'scheme'</span><span>]</span>
<span>>></span><span>></span> <span>len</span><span>(</span>s<span>)</span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要注意 <code>s</code> 只有 4 个元素，其中 <code>s[2]</code> 又是一个 list，如果拆开写就更容易理解了:</p>
<div><pre><code><span>>></span><span>></span> p <span>=</span> <span>[</span><span>'asp'</span><span>,</span> <span>'php'</span><span>]</span>
<span>>></span><span>></span> s <span>=</span> <span>[</span><span>'python'</span><span>,</span> <span>'java'</span><span>,</span> p<span>,</span> <span>'scheme'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>要拿到 <code>'php'</code> 可以写 <code>p[1]</code> 或者 <code>s[2][1]</code>，因此 <code>s</code> 可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</p>
<p>如果一个 list 中一个元素也没有，就是一个空的 list，它的长度为 0:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> <span>len</span><span>(</span>L<span>)</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="tuple"> tuple</h2>
<p>另一种有序列表叫元组: tuple。tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改，比如同样是列出同学的名字:</p>
<div><pre><code><span>>></span><span>></span> classmates <span>=</span> <span>(</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>现在，classmates 这个 tuple 不能变了，它也没有 <code>append()</code>，<code>insert()</code> 这样的方法。其他获取元素的方法和 list 是一样的，您可以正常地使用 <code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p>
<p>不可变的 tuple 有什么意义? 因为 tuple 不可变，所以代码更安全。如果可能，能用 tuple 代替 list 就尽量用 tuple。</p>
<p>tuple 的陷阱: 当您定义一个 tuple 时，在定义的时候，tuple 的元素就必须被确定下来，比如:</p>
<div><pre><code><span>>></span><span>></span> t <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>>></span><span>></span> t
<span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果要定义一个空的 tuple，可以写成 <code>()</code>:</p>
<div><pre><code><span>>></span><span>></span> t <span>=</span> <span>(</span><span>)</span>
<span>>></span><span>></span> t
<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是，要定义一个只有 1 个元素的 tuple，如果您这么定义:</p>
<div><pre><code><span>>></span><span>></span> t <span>=</span> <span>(</span><span>1</span><span>)</span>
<span>>></span><span>></span> t
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>定义的不是 tuple，是 <code>1</code> 这个数! 这是因为括号 <code>()</code> 既可以表示 tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python 规定，这种情况下，按小括号进行计算，计算结果自然是 1。</p>
<p>所以，只有 1 个元素的 tuple 定义时必须加一个逗号 <code>,</code>，来消除歧义:</p>
<div><pre><code><span>>></span><span>></span> t <span>=</span> <span>(</span><span>1</span><span>,</span><span>)</span>
<span>>></span><span>></span> t
<span>(</span><span>1</span><span>,</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Python 在显示只有 1 个元素的 tuple 时，也会加一个逗号 <code>,</code>，以免您误解成数学计算意义上的括号。</p>
<p>最后来看一个“可变的”tuple:</p>
<div><pre><code><span>>></span><span>></span> t <span>=</span> <span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>[</span><span>'A'</span><span>,</span> <span>'B'</span><span>]</span><span>)</span>
<span>>></span><span>></span> t<span>[</span><span>2</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>'X'</span>
<span>>></span><span>></span> t<span>[</span><span>2</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>'Y'</span>
<span>>></span><span>></span> t
<span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>[</span><span>'X'</span><span>,</span> <span>'Y'</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个 tuple 定义的时候有 3 个元素，分别是 <code>'a'</code>，<code>'b'</code> 和一个 list。不是说 tuple 一旦定义后就不可变了吗? 怎么后来又变了?</p>
<p>别急，我们先看看定义的时候 tuple 包含的 3 个元素:</p>
<p><img src="./../assets/tuple0.png" alt="tuple 示意图" loading="lazy"></p>
<p>当我们把 list 的元素 <code>'A'</code> 和 <code>'B'</code> 修改为 <code>'X'</code> 和 <code>'Y'</code> 后，tuple 变为:</p>
<p><img src="./../assets/tuple1.png" alt="tuple 示意图" loading="lazy"></p>
<p>表面上看，tuple 的元素确实变了，但其实变的不是 tuple 的元素，而是 list 的元素。tuple 一开始指向的 list 并没有改成别的 list，所以，tuple 所谓的“不变”是说，tuple 的每个元素，指向永远不变。即指向 <code>'a'</code>，就不能改成指向 <code>'b'</code>，指向一个 list，就不能改成指向其他对象，但指向的这个 list 本身是可变的!</p>
<p>理解了 “指向不变” 后，要创建一个内容也不变的 tuple 怎么做? 那就必须保证 tuple 的每一个元素本身也不能变。</p>
<h2 id="小结"> 小结</h2>
<p>list 和 tuple 是 Python 内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-23T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">循环</title>
    <id>https://list-jiang.github.io/code/language/python/guide/loop/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/loop/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>要计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>3</span></span></span></span> ，我们可以直接写表达式:</p>
<div><pre><code><span>>></span><span>></span> <span>1</span> <span>+</span> <span>2</span> <span>+</span> <span>3</span>
<span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>要计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>...</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>10</span></span></span></span> ，勉强也能写出来。</p>
<p>但是，要计算 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>1</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>2</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>3</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>...</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>10000</span></span></span></span> ，直接写表达式就不可能了。</p>
<p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p>
<p>Python 的循环有两种，一种是 <code>for...in</code> 循环，依次把 list 或 tuple 中的每个元素迭代出来，看例子:</p>
<div><pre><code>names <span>=</span> <span>[</span><span>'Michael'</span><span>,</span> <span>'Bob'</span><span>,</span> <span>'Tracy'</span><span>]</span>
<span>for</span> name <span>in</span> names<span>:</span>
    <span>print</span><span>(</span>name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行这段代码，会依次打印 <code>names</code> 的每一个元素:</p>
<div><pre><code>Michael
Bob
Tracy
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>所以 <code>for x in ...</code> 循环就是把每个元素代入变量 <code>x</code>，然后执行缩进块的语句。</p>
<p>再比如我们想计算 1-10 的整数之和，可以用一个 <code>sum</code> 变量做累加:</p>
<div><pre><code><span>sum</span> <span>=</span> <span>0</span>
<span>for</span> x <span>in</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>]</span><span>:</span>
    <span>sum</span> <span>=</span> <span>sum</span> <span>+</span> x
<span>print</span><span>(</span><span>sum</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果要计算 1-100 的整数之和，从 1 写到 100 有点困难，幸好 Python 提供一个 <code>range()</code> 函数，可以生成一个整数序列，再通过 <code>list()</code> 函数可以转换为 list。比如 <code>range(5)</code> 生成的序列是从 0 开始小于 5 的整数:</p>
<div><pre><code><span>>></span><span>></span> <span>list</span><span>(</span><span>range</span><span>(</span><span>5</span><span>)</span><span>)</span>
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>range(101)</code> 就可以生成 0-100 的整数序列，计算如下:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>
<span>sum</span> <span>=</span> <span>0</span>
<span>for</span> x <span>in</span> <span>range</span><span>(</span><span>101</span><span>)</span><span>:</span>
    <span>sum</span> <span>=</span> <span>sum</span> <span>+</span> x
<span>print</span><span>(</span><span>sum</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>请自行运行上述代码，看看结果是不是当年高斯同学心算出的 5050。</p>
<p>第二种循环是 <code>while</code> 循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算 100 以内所有奇数之和，可以用 <code>while</code> 循环实现:</p>
<div><pre><code><span>sum</span> <span>=</span> <span>0</span>
n <span>=</span> <span>99</span>
<span>while</span> n <span>></span> <span>0</span><span>:</span>
    <span>sum</span> <span>=</span> <span>sum</span> <span>+</span> n
    n <span>=</span> n <span>-</span> <span>2</span>
<span>print</span><span>(</span><span>sum</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在循环内部变量 <code>n</code> 不断自减，直到变为 <code>-1</code> 时，不再满足 <code>while</code> 条件，循环退出。</p>
<h2 id="break"> break</h2>
<p>在循环中，<code>break</code> 语句可以提前退出循环。例如，本来要循环打印 1 ～ 100 的数字:</p>
<div><pre><code>n <span>=</span> <span>1</span>
<span>while</span> n <span>&lt;=</span> <span>100</span><span>:</span>
    <span>print</span><span>(</span>n<span>)</span>
    n <span>=</span> n <span>+</span> <span>1</span>
<span>print</span><span>(</span><span>'END'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的代码可以打印出 1~100。</p>
<p>如果要提前结束循环，可以用 <code>break</code> 语句:</p>
<div><pre><code>n <span>=</span> <span>1</span>
<span>while</span> n <span>&lt;=</span> <span>100</span><span>:</span>
    <span>if</span> n <span>></span> <span>10</span><span>:</span> <span># 当n = 11时，条件满足，执行break语句</span>
        <span>break</span> <span># break语句会结束当前循环</span>
    <span>print</span><span>(</span>n<span>)</span>
    n <span>=</span> n <span>+</span> <span>1</span>
<span>print</span><span>(</span><span>'END'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行上面的代码可以看到，打印出 1~10 后，紧接着打印 <code>END</code>，程序结束。</p>
<p>可见 <code>break</code> 的作用是提前结束循环。</p>
<h2 id="continue"> continue</h2>
<p>在循环过程中，也可以通过 <code>continue</code> 语句，跳过当前的这次循环，直接开始下一次循环。</p>
<div><pre><code>n <span>=</span> <span>0</span>
<span>while</span> n <span>&lt;</span> <span>10</span><span>:</span>
    n <span>=</span> n <span>+</span> <span>1</span>
    <span>print</span><span>(</span>n<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的程序可以打印出 1 ～ 10。但是，如果我们想只打印奇数，可以用 <code>continue</code> 语句跳过某些循环:</p>
<div><pre><code>n <span>=</span> <span>0</span>
<span>while</span> n <span>&lt;</span> <span>10</span><span>:</span>
    n <span>=</span> n <span>+</span> <span>1</span>
    <span>if</span> n <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>:</span> <span># 如果n是偶数，执行continue语句</span>
        <span>continue</span> <span># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span>
    <span>print</span><span>(</span>n<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行上面的代码可以看到，打印的不再是 1 ～ 10，而是 1，3，5，7，9。</p>
<p>可见 <code>continue</code> 的作用是提前结束本轮循环，并直接开始下一轮循环。</p>
<h2 id="小结"> 小结</h2>
<p>循环是让计算机做重复任务的有效的方法。</p>
<p><code>break</code> 语句可以在循环过程中直接退出循环，而 <code>continue</code> 语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合 <code>if</code> 语句使用。</p>
<p>要特别注意，不要滥用 <code>break</code> 和 <code>continue</code> 语句。<code>break</code> 和 <code>continue</code> 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 <code>break</code> 和 <code>continue</code> 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 <code>break</code> 和 <code>continue</code> 语句。</p>
<p>有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用 <code>Ctrl + C</code> 退出程序，或者强制结束 Python 进程。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-24T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">基础教程</title>
    <id>https://list-jiang.github.io/code/language/python/guide/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <summary type="html"><![CDATA[<p>本章节介绍 Python 的基础语法，帮助您尽快了解 Python 的基础内容</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章节介绍 Python 的基础语法，帮助您尽快了解 Python 的基础内容</p>

<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./write.html">第一个 Python 程序</a></p>
</li>
<li>
<p><a href="./io.html">输入与输出</a></p>
</li>
<li>
<p><a href="./basic.html">基础语法</a></p>
</li>
<li>
<p><a href="./string.html">字符串</a></p>
</li>
<li>
<p><a href="./list-and-tuple.html">List 和 Tuple</a></p>
</li>
<li>
<p><a href="./condition.html">条件判断</a></p>
</li>
<li>
<p><a href="./loop.html">循环</a></p>
</li>
<li>
<p><a href="./dict-and-set.html">Dictionary 和 Set</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-19T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">字符串</title>
    <id>https://list-jiang.github.io/code/language/python/guide/string/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/string/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在最新的 Python 3 版本中，字符串是以 Unicode 编码的，也就是说，Python 的字符串支持多语言，例如:</p>
<div><pre><code><span>>></span><span>></span> print<span>(</span><span>'包含中文的str'</span><span>)</span>
包含中文的str
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于单个字符的编码，Python 提供了 <code>ord()</code> 函数获取字符的整数表示，<code>chr()</code> 函数把编码转换为对应的字符:</p>
<div><pre><code><span>>></span><span>></span> <span>ord</span><span>(</span><span>'A'</span><span>)</span>
<span>65</span>
<span>>></span><span>></span> <span>ord</span><span>(</span><span>'中'</span><span>)</span>
<span>20013</span>
<span>>></span><span>></span> <span>chr</span><span>(</span><span>66</span><span>)</span>
<span>'B'</span>
<span>>></span><span>></span> <span>chr</span><span>(</span><span>25991</span><span>)</span>
<span>'文'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果知道字符的整数编码，还可以用十六进制这么写 <code>str</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>'\u4e2d\u6587'</span>
<span>'中文'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>两种写法完全是等价的。</p>
<p>由于 Python 的字符串类型是 <code>str</code>，在内存中以 Unicode 表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 <code>str</code> 变为以字节为单位的 <code>bytes</code>。</p>
<p>Python 对 <code>bytes</code> 类型的数据用带 <code>b</code> 前缀的单引号或双引号表示:</p>
<div><pre><code>x <span>=</span> <span>b'ABC'</span>
</code></pre>
<div><span>1</span><br></div></div><p>要注意区分 <code>'ABC'</code> 和 <code>b'ABC'</code>，前者是 <code>str</code>，后者虽然内容显示得和前者一样，但 <code>bytes</code> 的每个字符都只占用一个字节。</p>
<p>以 Unicode 表示的 <code>str</code> 通过 <code>encode()</code> 方法可以编码为指定的 <code>bytes</code>，例如:</p>
<div><pre><code><span>>></span><span>></span> <span>'ABC'</span>.encode<span>(</span><span>'ascii'</span><span>)</span>
b<span>'ABC'</span>
<span>>></span><span>></span> <span>'中文'</span>.encode<span>(</span><span>'utf-8'</span><span>)</span>
b<span>'\xe4\xb8\xad\xe6\x96\x87'</span>
<span>>></span><span>></span> <span>'中文'</span>.encode<span>(</span><span>'ascii'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
UnicodeEncodeError: <span>'ascii'</span> codec can't encode characters <span>in</span> position <span>0</span>-1: ordinal not <span>in</span> range<span>(</span><span>128</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>纯英文的 <code>str</code> 可以用 ASCII 编码为 <code>bytes</code>，内容是一样的，含有中文的 <code>str</code> 可以用 UTF-8 编码为 <code>bytes</code>。含有中文的 <code>str</code> 无法用 ASCII 编码，因为中文编码的范围超过了 ASCII 编码的范围，Python 会报错。</p>
<p>在 <code>bytes</code> 中，无法显示为 ASCII 字符的字节，用 <code>\x##</code> 显示。</p>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 <code>bytes</code>。要把 <code>bytes</code> 变为 <code>str</code>，就需要用 <code>decode()</code> 方法:</p>
<div><pre><code><span>>></span><span>></span> <span>b'ABC'</span><span>.</span>decode<span>(</span><span>'ascii'</span><span>)</span>
<span>'ABC'</span>
<span>>></span><span>></span> <span>b'\xe4\xb8\xad\xe6\x96\x87'</span><span>.</span>decode<span>(</span><span>'utf-8'</span><span>)</span>
<span>'中文'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果 <code>bytes</code> 中包含无法解码的字节，<code>decode()</code> 方法会报错:</p>
<div><pre><code><span>>></span><span>></span> b<span>'\xe4\xb8\xad\xff'</span>.decode<span>(</span><span>'utf-8'</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span>:
  <span>..</span>.
UnicodeDecodeError: <span>'utf-8'</span> codec can't decode byte 0xff <span>in</span> position <span>3</span>: invalid start byte
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果 <code>bytes</code> 中只有一小部分无效的字节，可以传入 <code>errors='ignore'</code> 忽略错误的字节:</p>
<div><pre><code><span>>></span><span>></span> <span>b'\xe4\xb8\xad\xff'</span><span>.</span>decode<span>(</span><span>'utf-8'</span><span>,</span> errors<span>=</span><span>'ignore'</span><span>)</span>
<span>'中'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>要计算 <code>str</code> 包含多少个字符，可以用 <code>len()</code> 函数:</p>
<div><pre><code><span>>></span><span>></span> <span>len</span><span>(</span><span>'ABC'</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> <span>len</span><span>(</span><span>'中文'</span><span>)</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>len()</code> 函数计算的是 <code>str</code> 的字符数，如果换成 <code>bytes</code>，<code>len()</code> 函数就计算字节数:</p>
<div><pre><code><span>>></span><span>></span> <span>len</span><span>(</span><span>b'ABC'</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> <span>len</span><span>(</span><span>b'\xe4\xb8\xad\xe6\x96\x87'</span><span>)</span>
<span>6</span>
<span>>></span><span>></span> <span>len</span><span>(</span><span>'中文'</span><span>.</span>encode<span>(</span><span>'utf-8'</span><span>)</span><span>)</span>
<span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可见，1 个中文字符经过 UTF-8 编码后通常会占用 3 个字节，而 1 个英文字符只占用 1 个字节。</p>
<p>在操作字符串时，我们经常遇到 <code>str</code> 和 <code>bytes</code> 的互相转换。为了避免乱码问题，应当始终坚持使用 UTF-8 编码对 <code>str</code> 和 <code>bytes</code> 进行转换。</p>
<p>由于 Python 源代码也是一个文本文件，所以，当您的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当 Python 解释器读取源代码时，为了让它按 UTF-8 编码读取，我们通常在文件开头写上这两行:</p>
<div><pre><code><span># !/usr/bin/env python3</span>

<span># -*- coding: utf-8 -*-</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第一行注释是为了告诉 Linux/macOS 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释；</p>
<p>第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，您在源代码中写的中文输出可能会有乱码。</p>
<p>申明了 UTF-8 编码并不意味着您的 <code>.py</code> 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 &quot;UTF-8 without BOM&quot; 编码。</p>
<div><p>相关信息</p>
<p>旧版 Windows 记事本的 UTF-8 是 UTF-8 with BOM。</p>
<ul>
<li>具体详情请见 <a href="./../../../windows/notepad.html">记事本的遗留问题</a></li>
</ul>
</div>
<p>如果 <code>.py</code> 文件本身使用 UTF-8 编码，并且也申明了 <code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文。</p>
<h2 id="格式化"> 格式化</h2>
<p>一个常见的问题是如何输出格式化的字符串。我们经常会输出类似 <code>'亲爱的xxx您好! 您xx月的话费是xx，余额是xx'</code> 之类的字符串，而 <code>xxx</code> 的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p>
<p>在 Python 中，采用的格式化方式和 C 语言是一致的，用 <code>%</code> 实现，举例如下:</p>
<div><pre><code><span>>></span><span>></span> <span>'Hello, %s'</span> <span>%</span> <span>'world'</span>
<span>'Hello, world'</span>
<span>>></span><span>></span> <span>'Hi, %s, you have $%d.'</span> <span>%</span> <span>(</span><span>'Michael'</span><span>,</span> <span>1000000</span><span>)</span>
<span>'Hi, Michael, you have $1000000.'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>没错，<code>%</code> 运算符就是用来格式化字符串的。在字符串内部，<code>%s</code> 表示用字符串替换，<code>%d</code> 表示用整数替换，有几个 <code>%?</code> 占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个 <code>%?</code>，括号可以省略。</p>
<div><p>常见的占位符有</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%d</code></td>
<td>整数</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点数</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>十六进制整数</td>
</tr>
</tbody>
</table>
</div>
<p>其中，格式化整数和浮点数还可以指定是否补 0 和整数与小数的位数:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>
<span>print</span><span>(</span><span>'%2d-%02d'</span> <span>%</span> <span>(</span><span>3</span><span>,</span> <span>1</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>'%.2f'</span> <span>%</span> <span>3.1415926</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您不太确定应该用什么，<code>%s</code> 永远起作用，它会把任何数据类型转换为字符串:</p>
<div><pre><code><span>>></span><span>></span> <span>'Age: %s. Gender: %s'</span> <span>%</span> <span>(</span><span>25</span><span>,</span> <span>True</span><span>)</span>
<span>'Age: 25. Gender: True'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有些时候，字符串里面的 <code>%</code> 是一个普通字符怎么办? 这个时候就需要转义，用 <code>%%</code> 来表示一个 <code>%</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>'growth rate: %d %%'</span> <span>%</span> <span>7</span>
<span>'growth rate: 7 %'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="format"> format()</h3>
<p>另一种格式化字符串的方法是使用字符串的 <code>format()</code> 方法，它会用传入的参数依次替换字符串内的占位符 <code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比 <code>%</code> 要麻烦得多:</p>
<div><pre><code><span>>></span><span>></span> <span>'Hello, {0}, 成绩提升了 {1:.1f}%'</span><span>.</span><span>format</span><span>(</span><span>'小明'</span><span>,</span> <span>17.125</span><span>)</span>
<span>'Hello, 小明, 成绩提升了 17.1%'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="小结"> 小结</h3>
<p>Python 3 的字符串使用 Unicode，直接支持多语言。</p>
<p>当 <code>str</code> 和 <code>bytes</code> 互相转换时，需要指定编码。最常用的编码是 <code>UTF-8</code>。Python 当然也支持其他编码方式，比如把 Unicode 编码成 <code>GB2312</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>'中文'</span><span>.</span>encode<span>(</span><span>'gb2312'</span><span>)</span>
<span>b'\xd6\xd0\xce\xc4'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用 UTF-8 编码。</p>
<p>格式化字符串的时候，可以用 Python 的交互式环境测试，方便快捷。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-22T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">第一个 Python 程序</title>
    <id>https://list-jiang.github.io/code/language/python/guide/write/</id>
    <link href="https://list-jiang.github.io/code/language/python/guide/write/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在正式编写第一个 Python 程序前，我们先复习一下什么是命令行模式和 Python 交互模式。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在正式编写第一个 Python 程序前，我们先复习一下什么是命令行模式和 Python 交互模式。</p>

<h2 id="命令行模式"> 命令行模式</h2>
<p>打开“命令提示符”，就进入到命令行模式，它的提示符类似 <code>C:\&gt;</code>:</p>
<div><p>相关信息</p>
<p>如何打开，请见 <a href="./../../../windows/cmd.html">打开命令行</a></p>
</div>
<h2 id="python-交互模式"> Python 交互模式</h2>
<p>在命令行模式下敲命令 <code>python</code>，就进入到 Python 交互模式，它的提示符是 <code>&gt;&gt;&gt;</code>。</p>
<p>在交互模式的提示符 <code>&gt;&gt;&gt;</code> 下，直接输入代码，按回车，就可以立刻得到代码执行结果。</p>
<blockquote>
<p>请敲入 <code>100 + 200</code> 然后按回车，您就会得到 <code>300</code>。</p>
</blockquote>
<p>如果要让 Python 打印出指定的文字，可以用 <code>print()</code> 函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号。</p>
<blockquote>
<p>输入 <code>print('hello, world')</code> 后回车。</p>
</blockquote>
<p>最后，用 <code>exit()</code> 退出 Python，我们的第一个 Python 程序完成! 唯一的缺憾是没有保存下来，下次运行时还要再输入一遍代码。</p>
<p>在 Python 的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。</p>
<p>所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。</p>
<p>现在，我们就把上次的 <code>'hello, world'</code> 程序用文本编辑器写出来，保存下来。</p>
<div><p>文本编辑器</p>
<p>关于文本编辑器，请使用 <a href="./../../../../software/vscode/">VS Code</a></p>
</div>
<p>安装好文本编辑器后，输入以下代码:</p>
<div><pre><code><span>print</span><span>(</span><span>'hello, world'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>注意 <code>print</code> 前面不要有任何空格。然后，选择一个目录，例如 <code>C:\work</code>，把文件保存为 hello.py，就可以打开命令行窗口，把当前目录切换到 hello.py 所在目录，就可以运行这个程序了:</p>
<div><pre><code>C:/work<span>></span> python hello.py
hello, world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以保存为别的名字，比如 first.py，但是必须要以 <code>.py</code> 结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 hello.py 这个文件，运行 <code>python hello.py</code> 就会报错:</p>
<div><pre><code>C:/Users/MrHope<span>></span> python hello.py
python: can<span>'t open file '</span>hello.py': <span>[</span>Errno <span>2</span><span>]</span> No such <span>file</span> or directory
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>报错的意思就是，无法打开 hello.py 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。如果 hello.py 存放在另外一个目录下，要首先用 <code>cd</code> 命令切换当前目录。</p>
<h2 id="直接运行-py-文件"> 直接运行 py 文件</h2>
<p>您可能有疑问，能不能像 <code>.exe</code> 文件那样直接运行 <code>.py</code> 文件呢? 在 Windows 上是不行的，但是，在 Mac 和 Linux 上是可以的，方法是在 <code>.py</code> 文件的第一行加上一个特殊的注释:</p>
<div><pre><code><span># !/usr/bin/env python3</span>

<span>print</span><span>(</span><span>'hello, world'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，通过命令给 hello.py 以执行权限:</p>
<div><pre><code><span>chmod</span> a+x hello.py
</code></pre>
<div><span>1</span><br></div></div><p>就可以直接运行 hello.py 了，比如在 Mac 下运行:</p>
<h2 id="小结"> 小结</h2>
<p>用文本编辑器写 Python 程序，然后保存为后缀为 <code>.py</code> 的文件，就可以用 Python 直接运行这个程序了。</p>
<p>Python 的交互模式和直接运行 <code>.py</code> 文件有什么区别呢?</p>
<p>直接输入 python 进入交互模式，相当于启动了 Python 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>.py</code> 文件相当于启动了 Python 解释器，然后一次性把 <code>.py</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>用 Python 开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27’ 的超大显示器!</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-20T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">安装 Python</title>
    <id>https://list-jiang.github.io/code/language/python/intro/install/</id>
    <link href="https://list-jiang.github.io/code/language/python/intro/install/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>要开始学习 Python 编程，首先就得把 Python 安装到您的电脑里。安装后，您会得到 Python 解释器(就是负责运行 Python 程序的)，一个命令行交互环境，还有一个简单的集成开发环境。本节将指导您如何安装 Python。</p>
<h2 id="在-mac-上安装-python"> 在 Mac 上安装 Python</h2>
<p>如果您正在使用 Mac，系统是 OS X&gt;=10.9，那么系统自带的 Python 版本是 2.7。要安装最新的 Python 3.9，有两个方法:</p>
<p>方法一:从 Python 官网下载 Python 3.9 的安装程序，下载后双击运行并安装；</p>
<p>方法二:如果安装了 Homebrew，直接通过命令 brew install python3 安装即可。</p>
<h2 id="在-linux-上安装-python"> 在 Linux 上安装 Python</h2>
<p>用 Linux 的人自行安装 Python 3 应该没有问题，否则，请换回 Windows 系统。</p>
<h2 id="在-windows-上安装-python"> 在 Windows 上安装 Python</h2>
<p>首先，从 Python 的官方网站下载 Python 3.9 对应的 64 位安装程序，然后，运行下载的 exe 安装包。</p>
<blockquote>
<p>这年头应该没人用 32 位的系统了吧 😏</p>
</blockquote>
<p>特别要注意勾上 <code>Add Python 3.9 to PATH</code>，然后点 “Install Now” 即可完成安装。</p>
<h2 id="运行-python"> 运行 Python</h2>
<p>安装成功后，打开命令提示符窗口，敲入 <code>python</code> 后，会出现两种情况:</p>
<p>情况一:</p>
<p><img src="./../assets/cmd.png" alt="示意图" loading="lazy"></p>
<p>看到上面的画面，就说明 Python 安装成功!</p>
<p>您看到提示符 <code>&gt;&gt;&gt;</code> 就表示我们已经在 Python 交互式环境中了，可以输入任何 Python 代码，回车后会立刻得到执行结果。现在，输入 <code>exit()</code> 并回车，就可以退出 Python 交互式环境(直接关掉命令行窗口也可以)。</p>
<p>情况二:</p>
<div><pre><code><span>'python'</span> is not recognized as an internal or external command, operable program or batch file.
</code></pre>
<div><span>1</span><br></div></div><p>这是因为 Windows 会根据一个 Path 的环境变量设定的路径去查找 python.exe，如果没找到，就会报错。如果在安装时漏掉了勾选 &quot;Add Python 3.9 to PATH&quot;，那就要手动把 python.exe 所在的路径添加到 Path 中。</p>
<p>如果您不知道怎么修改环境变量，建议把 Python 安装程序重新运行一遍，务必记得勾上 &quot;Add Python 3.9 to PATH&quot;。</p>
<div><p>注意</p>
<p>需要注意的是:</p>
<ul>
<li>
<p>在 Windows 上运行 Python 时，请先启动命令行，然后运行 <code>python</code>。</p>
</li>
<li>
<p>在 Mac 和 Linux 上运行 Python 时，请打开终端，然后运行 <code>python3</code>。</p>
</li>
</ul>
</div>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-18T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">Python 解释器</title>
    <id>https://list-jiang.github.io/code/language/python/intro/interpreter/</id>
    <link href="https://list-jiang.github.io/code/language/python/intro/interpreter/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 <code>.py</code> 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 <code>.py</code> 文件。</p>
]]></summary>
    <content type="html"><![CDATA[<p>当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 <code>.py</code> 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 <code>.py</code> 文件。</p>

<p>由于整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码(当然难度很大)。事实上，确实存在多种 Python 解释器。</p>
<h2 id="cpython"> CPython</h2>
<p>当我们从 Python 官方网站下载并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器:CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 python 就是启动 CPython 解释器。</p>
<p>CPython 是使用最广的 Python 解释器。教程的所有代码也都在 CPython 下执行。</p>
<h2 id="ipython"> IPython</h2>
<p>IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了辣鸡 IE。</p>
<p>CPython 用 <code>&gt;&gt;&gt;</code> 作为提示符，而 IPython 用 <code>In [序号]:</code> 作为提示符。</p>
<h2 id="pypy"> PyPy</h2>
<p>PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 <a href="https://zh.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener noreferrer">JIT</a> 技术，对 Python 代码进行动态编译(注意不是解释)，所以可以显著提高 Python 代码的执行速度。</p>
<p>绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果您的代码要放到 PyPy 下执行，就需要了解 <a href="https://doc.pypy.org/en/latest/cpython_differences.html" target="_blank" rel="noopener noreferrer">PyPy 和 CPython 的不同点</a>。</p>
<h2 id="jython"> Jython</h2>
<p>Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p>
<h2 id="ironpython"> IronPython</h2>
<p>IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。</p>
<h2 id="小结"> 小结</h2>
<p>Python 的解释器很多，但使用最广泛的还是 CPython。如果要和 Java 或.Net 平台交互，最好的办法不是用 Jython 或 IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p>
<p>本教程的所有代码只确保在 CPython 3.x 版本下运行。请务必在本地安装 CPython(也就是从 Python 官方网站下载的安装程序)。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-19T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">Python 简介</title>
    <id>https://list-jiang.github.io/code/language/python/intro/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/intro/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本节将简单介绍 Python 的历史。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本节将简单介绍 Python 的历史。</p>

<h2 id="特点"> 特点</h2>
<p>Python 是 Guido van Rossum(“龟叔”) 在 1989 年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p>
<p>龟叔给 Python 的定位是“优雅”、“明确”、“简单”，所以 Python 程序看上去总是简单易懂，初学者学 Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</p>
<div><p>Python 的优势 —— 内置电池</p>
<p>总的来说，编程语言各有千秋。</p>
<p>以最常见的 C 语言为例，它是可以用来编写操作系统的贴近硬件的语言，所以，C 语言适合开发那些追求运行速度、充分发挥硬件性能的程序。</p>
<p>而 Python 是用来编写应用程序的高级编程语言。当您用一种语言开始作真正的软件开发时，您除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助您加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让您能直接调用，比如，针对电子邮件协议的 SMTP 库，针对桌面环境的 GUI 库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。</p>
<p>Python 就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池(batteries included)”。用 Python 开发，许多功能不必从零编写，直接使用现成的即可。</p>
<p>除了内置的库外，Python 还有大量的第三方库，也就是别人开发的，供您直接使用的东西。当然，如果您开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p>
<p>许多大型网站就是用 Python 开发的，例如 YouTube、Instagram，还有国内的豆瓣。很多大公司，包括 Google、Yahoo 等，甚至 NASA(美国航空航天局)都大量地使用 Python。</p>
</div>
<p>总的来说，Python 的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向您炫耀他写的晦涩难懂、动不动就几万行的代码，您可以尽情地嘲笑他。</p>
<h2 id="应用领域"> 应用领域</h2>
<p>Python 适合开发哪些类型的应用:</p>
<ul>
<li>
<p>首选是网络应用，包括网站、后台服务等等；</p>
</li>
<li>
<p>其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p>
</li>
<li>
<p>另外就是把其他语言开发的程序再包装起来，方便使用。</p>
</li>
</ul>
<h2 id="缺点"> 缺点</h2>
<h3 id="运行速度慢"> 运行速度慢</h3>
<p>Python 和 C 程序相比非常慢，因为 Python 是解释型语言，您的代码在执行时会一行一行地翻译成 CPU 能理解的机器码，这个翻译过程非常耗时，所以很慢。而 C 程序是运行前直接编译成 CPU 能执行的机器码，所以非常快。</p>
<p>但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载 MP3 的网络应用程序，C 程序的运行时间需要 0.001 秒，而 Python 程序的运行时间需要 0.1 秒，慢了 100 倍，但由于网络更慢，需要等待 1 秒，您想，用户能感觉到 1.001 秒和 1.1 秒的区别吗? 这就好比 F1 赛车和普通的出租车在北京三环路上行驶的道理一样，虽然 F1 赛车理论时速高达 400 公里，但由于三环路堵车的时速只有 20 公里，因此，作为乘客，您感觉的时速永远是 20 公里。</p>
<h3 id="代码不能加密"> 代码不能加密</h3>
<p>Python 语言是个脚本语言，这点跟前端广泛使用的 JS 相同。如果要发布您的 Python 程序，实际上就是发布源代码。</p>
<div><p>解释器与编译器</p>
<ul>
<li>
<p>Python 运行时采用解释器，也就是使用解释器直接解释源码。</p>
</li>
<li>
<p>C 语言不同，C 语言不用发布源代码，只需要把通过编译器编译后的机器码(也就是您在 Windows 上常见的 xxx.exe 文件)发布出去。要从机器码反推出 C 代码是不可能的。</p>
</li>
</ul>
</div>
<p>所以任何编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</p>
<p>这个缺点仅限于您要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-18T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>https://list-jiang.github.io/code/language/python/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">Python 介绍</a></p>
</li>
<li>
<p><a href="./install.html">Python 安装</a></p>
</li>
<li>
<p><a href="./interpreter.html">解释器</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-25T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">安装第三方模块</title>
    <id>https://list-jiang.github.io/code/language/python/module/install/</id>
    <link href="https://list-jiang.github.io/code/language/python/module/install/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在 Python 中，安装第三方模块，是通过包管理工具 pip 完成的。</p>
<p>如果您正在使用 Mac 或 Linux，安装 pip 本身这个步骤就可以跳过了。</p>
<p>如果您正在使用 Windows，请参考 <a href="./../intro/install.html">安装 Python</a> 一节的内容，确保安装时勾选了 <code>pip</code> 和 <code>Add python.exe to Path</code>。</p>
<p>在命令提示符窗口下尝试运行 pip，如果 Windows 提示未找到命令，可以重新运行安装程序添加 pip。</p>
<div><p>注意</p>
<p>Mac 或 Linux 上有可能并存 Python 3.x 和 Python 2.x，因此对应的 pip 命令是 pip3。</p>
</div>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是 Python 下非常强大的处理图像的工具库。不过，PIL 目前只支持到 Python 2.7，并且有年头没有更新了，因此，基于 PIL 的 Pillow 项目开发非常活跃，并且支持最新的 Python 3。</p>
<p>一般来说，第三方库都会在 Python 官方的 &lt;pypi.python.org&gt; 网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者 pypi 上搜索，比如 Pillow 的名称叫 <a href="https://pypi.python.org/pypi/Pillow/" target="_blank" rel="noopener noreferrer">Pillow</a>，因此，安装 Pillow 的命令就是:</p>
<div><pre><code>pip <span>install</span> Pillow
</code></pre>
<div><span>1</span><br></div></div><p>耐心等待下载并安装后，就可以使用 Pillow 了。</p>
<h2 id="安装常用模块"> 安装常用模块</h2>
<p>在使用 Python 时，我们经常需要用到很多第三方库，例如，上面提到的 Pillow，以及 MySQL 驱动程序，Web 框架 Flask，科学计算 Numpy 等。用 pip 一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用 <a href="https://www.anaconda.com/" target="_blank" rel="noopener noreferrer">Anaconda</a>，这是一个基于 Python 的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上 Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从 <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener noreferrer">Anaconda 官网</a> 下载 GUI 安装包，安装包有 500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda 会把系统 Path 中的 python 指向自己自带的 Python，并且，Anaconda 安装的第三方模块会安装在 Anaconda 自己的路径下，不影响系统已安装的 Python 目录。</p>
<p>安装好 Anaconda 后，重新打开命令行窗口，输入 python，可以看到 Anaconda 的信息:</p>
<div><pre><code>┌────────────────────────────────────────────────────────┐
│Command Prompt - python                           - □ x │
├────────────────────────────────────────────────────────┤
│Microsoft Windows [Version 10.0.0]                      │
│(c) 2015 Microsoft Corporation. All rights reserved.    │
│                                                        │
│C:\&gt; python                                             │
│Python 3.9.2 |Anaconda, Inc.| ... on win32              │
│Type &quot;help&quot;, ... for more information.                  │
│&gt;&gt;&gt; import numpy                                        │
│&gt;&gt;&gt; _                                                   │
│                                                        │
│                                                        │
│                                                        │
└────────────────────────────────────────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>可以尝试直接 <code>import numpy</code> 等已安装的第三方模块。</p>
<h2 id="模块搜索路径"> 模块搜索路径</h2>
<p>当我们试图加载一个模块时，Python 会在指定的路径下搜索对应的.py 文件，如果找不到，就会报错:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> mymodule
Traceback <span>(</span>most recent call last<span>)</span>:
  File <span>"&lt;stdin>"</span>, line <span>1</span>, <span>in</span> <span>&lt;</span>module<span>></span>
ImportError: No module named mymodule
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>默认情况下，Python 解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在 sys 模块的 path 变量中:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> sys
<span>>></span><span>></span> sys.path
<span>[</span><span>''</span>, <span>'/Library/Frameworks/Python.framework/Versions/3.9/lib/python36.zip'</span>, <span>'/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9'</span>, <span>..</span>., <span>'/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们要添加自己的搜索目录，有两种方法:</p>
<p>一是直接修改 <code>sys.path</code>，添加要搜索的目录:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> sys
<span>>></span><span>></span> sys.path.append<span>(</span><span>'/Users/michael/my_py_scripts'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种方法是在运行时修改，运行结束后失效。</p>
<p>第二种方法是设置环境变量 <code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与 <a href="./../../../windows/add-path.html">设置 Path 环境变量</a> 类似。注意只需要添加您自己的搜索路径，Python 自己本身的搜索路径不受影响。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">模块</title>
    <id>https://list-jiang.github.io/code/language/python/module/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/module/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Python 中，一个 <code>.py</code> 文件就称之为一个模块 (Module) 。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Python 中，一个 <code>.py</code> 文件就称之为一个模块 (Module) 。</p>

<h2 id="优点"> 优点</h2>
<ol>
<li>
<p>使用模块大大提高了代码的可维护性。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Python 内置的模块和来自第三方的模块。</p>
</li>
<li>
<p>使用模块可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。</p>
</li>
</ol>
<div><p>相关信息</p>
<p><a href="http://docs.python.org/3/library/functions.html" target="_blank" rel="noopener noreferrer">Python 的所有内置函数</a></p>
</div>
<h2 id="包"> 包</h2>
<p>为了避免模块名冲突，Python 引入了按目录来组织模块的方法，称为包 (Package) 。</p>
<p>举个例子，一个 <code>abc.py</code> 的文件就是一个名字叫 abc 的模块，一个 <code>xyz.py</code> 的文件就是一个名字叫 xyz 的模块。</p>
<p>现在，假设我们的 abc 和 xyz 这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如 hopestudio，按照如下目录存放:</p>
<div><pre><code>hopestudio
├─ __init__.py
├─ abc.py
└─ xyz.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code> 模块的名字就变成了 <code>hopestudio.abc</code>，类似的，<code>xyz.py</code> 的模块名变成了 <code>hopestudio.xyz</code>。</p>
<p>请注意，每一个包目录下面都会有一个 <code>__init__.py</code> 的文件，这个文件是必须存在的，否则，Python 就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有 Python 代码，因为 <code>__init__.py</code> 本身就是一个模块，而它的模块名就是 hopestudio。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构:</p>
<div><pre><code>hopestudio
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ utils.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>文件 <code>www.py</code> 的模块名就是 <code>hopestudio.web.www</code>，两个文件 <code>utils.py</code> 的模块名分别是 <code>hopestudio.utils</code> 和 <code>hopestudio.web.utils</code>。</p>
<div><p>注意</p>
<p>自己创建模块时要注意命名，不能和 Python 自带的模块名称冲突。例如，系统自带了 sys 模块，自己的模块就不可命名为 <code>sys.py</code>，否则将无法导入系统自带的 sys 模块。</p>
</div>
<h2 id="总结"> 总结</h2>
<ul>
<li>
<p>模块是一组 Python 代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
</li>
<li>
<p>创建自己的模块时，要注意:</p>
<ol>
<li>模块名要遵循 Python 变量命名规范，不要使用中文、特殊字符；</li>
<li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在 Python 交互环境执行 <code>import abc</code>，若成功则说明系统存在此模块。</li>
</ol>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">模块</title>
    <id>https://list-jiang.github.io/code/language/python/module/</id>
    <link href="https://list-jiang.github.io/code/language/python/module/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">介绍</a></p>
</li>
<li>
<p><a href="./usage.html">使用模块</a></p>
</li>
<li>
<p><a href="./install.html">安装第三方模块</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">使用模块</title>
    <id>https://list-jiang.github.io/code/language/python/module/usage/</id>
    <link href="https://list-jiang.github.io/code/language/python/module/usage/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Python 本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Python 本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>

<p>我们以内建的 sys 模块为例，编写一个 hello 的模块:</p>
<div><pre><code><span>#!/usr/bin/env python3</span>
<span># -*- coding: utf-8 -*-</span>

<span>' a test module '</span>

__author__ <span>=</span> <span>'Mr.Hope'</span>

<span>import</span> sys

<span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    args <span>=</span> sys<span>.</span>argv
    <span>if</span> <span>len</span><span>(</span>args<span>)</span><span>==</span><span>1</span><span>:</span>
        <span>print</span><span>(</span><span>'Hello, world!'</span><span>)</span>
    <span>elif</span> <span>len</span><span>(</span>args<span>)</span><span>==</span><span>2</span><span>:</span>
        <span>print</span><span>(</span><span>'Hello, %s!'</span> <span>%</span> args<span>[</span><span>1</span><span>]</span><span>)</span>
    <span>else</span><span>:</span>
        <span>print</span><span>(</span><span>'Too many arguments!'</span><span>)</span>

<span>if</span> __name__<span>==</span><span>'__main__'</span><span>:</span>
    test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>第 1 行和第 2 行是标准注释，第 1 行注释可以让这个 <code>hello.py</code> 文件直接在 <code>Unix/Linux/Mac</code> 上运行，第 2 行注释表示 <code>.py</code> 文件本身使用标准 UTF-8 编码；</p>
<p>第 4 行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p>
<p>第 6 行使用 <code>__author__</code> 变量把作者写进去，这样当您公开源代码后别人就可以瞻仰您的大名；</p>
<p>以上就是 Python 模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p>
<p>后面开始就是真正的代码部分。</p>
<p>您可能注意到了，使用 <code>sys</code> 模块的第一步，就是导入该模块:</p>
<div><pre><code><span>import</span> sys
</code></pre>
<div><span>1</span><br></div></div><p>导入 sys 模块后，我们就有了变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。</p>
<p>sys 模块有一个 <code>argv</code> 变量，用 list 存储了命令行的所有参数。<code>argv</code> 至少有一个元素，因为第一个参数永远是该.py 文件的名称，例如:</p>
<p>运行 <code>python3 hello.py</code> 获得的 <code>sys.argv</code> 就是 <code>['hello.py']</code>；</p>
<p>运行 <code>python3 hello.py Mr.Hope</code> 获得的 <code>sys.argv</code> 就是 <code>['hello.py', 'Mr.Hope']</code>。</p>
<p>最后，注意到这两行代码:</p>
<div><pre><code><span>if</span> __name__<span>==</span><span>'__main__'</span><span>:</span>
    test<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当我们在命令行运行 hello 模块文件时，Python 解释器把一个特殊变量 <code>__name__</code> 置为 <code>__main__</code>，而如果在其他地方导入该 hello 模块时，if 判断将失败，因此，这种 if 测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>我们可以用命令行运行 hello.py 看看效果:</p>
<div><pre><code>$ python3 hello.py
Hello, world<span>!</span>
$ python hello.py Michael
Hello, Michael<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果启动 Python 交互环境，再导入 hello 模块:</p>
<div><pre><code>$ python3
Python <span>3.4</span>.3 <span>(</span>v3.4.3:9b73f1c3e601, Feb <span>23</span> <span>2015</span>, 02:52:03<span>)</span>
<span>[</span>GCC <span>4.2</span>.1 <span>(</span>Apple Inc. build <span>5666</span><span>)</span> <span>(</span>dot <span>3</span><span>)</span><span>]</span> on darwin
Type <span>"help"</span>, <span>"copyright"</span>, <span>"credits"</span> or <span>"license"</span> <span>for</span> <span>more</span> information.
<span>>></span><span>></span> <span>import</span> hello
<span>>></span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>导入时，没有打印 <code>Hello, word!</code>，因为没有执行 <code>test()</code> 函数。</p>
<p>调用 <code>hello.test()</code> 时，才能打印出 <code>Hello, word!</code> :</p>
<div><pre><code><span>>></span><span>></span> hello.test<span>(</span><span>)</span>
Hello, world<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="作用域"> 作用域</h2>
<p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在 Python 中，是通过_前缀来实现的。</p>
<p>正常的函数和变量名是公开的 (public) ，可以被直接引用，比如: <code>abc</code>，<code>x123</code>，<code>PI</code> 等；</p>
<p>类似 <code>__xxx__</code> 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 <code>__author__</code>，<code>__name__</code> 就是特殊变量，hello 模块定义的文档注释也可以用特殊变量 <code>__doc__</code> 访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似 <code>_xxx</code> 和 <code>__xxx</code> 这样的函数或变量就是非公开的 (private) ，不应该被直接引用，比如 <code>_abc</code>，<code>__abc</code> 等；</p>
<p>之所以我们说，private 函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为 Python 并没有一种方法可以完全限制访问 private 函数或变量，但是，从编程习惯上不应该引用 private 函数或变量。</p>
<p>private 函数或变量不应该被别人引用，那它们有什么用呢？请看例子:</p>
<div><pre><code><span>def</span> <span>_private_1</span><span>(</span>name<span>)</span><span>:</span>
    <span>return</span> <span>'Hello, %s'</span> <span>%</span> name

<span>def</span> <span>_private_2</span><span>(</span>name<span>)</span><span>:</span>
    <span>return</span> <span>'Hi, %s'</span> <span>%</span> name

<span>def</span> <span>greeting</span><span>(</span>name<span>)</span><span>:</span>
    <span>if</span> <span>len</span><span>(</span>name<span>)</span> <span>></span> <span>3</span><span>:</span>
        <span>return</span> _private_1<span>(</span>name<span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> _private_2<span>(</span>name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我们在模块里公开 <code>greeting()</code> 函数，而把内部逻辑用 private 函数隐藏起来了，这样，调用 <code>greeting()</code> 函数不用关心内部的 private 函数细节，这也是一种非常有用的代码封装和抽象的方法，即:</p>
<p>外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为 public。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-27T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">定制类</title>
    <id>https://list-jiang.github.io/code/language/python/oop/customize/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/customize/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>看到类似 <code>__slots__</code> 这种形如 <code>__xxx__</code> 的变量或者函数名就要注意，这些在 Python 中是有特殊用途的。</p>
<p><code>__slots__</code> 我们已经知道怎么用了，<code>__len__()</code> 方法我们也知道是为了能让 class 作用于 <code>len()</code> 函数。</p>
<p>除此之外，Python 的 class 中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h2 id="str"> <code>__str__</code></h2>
<p>我们先定义一个 Student 类，打印一个实例:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         self<span>.</span>name <span>=</span> name
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span>Student<span>(</span><span>'Michael'</span><span>)</span><span>)</span>
<span>&lt;</span>__main__<span>.</span>Student <span>object</span> at <span>0x109afb190</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>打印出一堆 <code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p>怎么才能打印得好看呢？只需要定义好 <code>__str__()</code> 方法，返回一个好看的字符串就可以了:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         self<span>.</span>name <span>=</span> name
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         <span>return</span> <span>'Student object (name: %s)'</span> <span>%</span> self<span>.</span>name
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span>Student<span>(</span><span>'Michael'</span><span>)</span><span>)</span>
Student <span>object</span> <span>(</span>name<span>:</span> Michael<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p>
<p>但是细心的朋友会发现直接敲变量不用 <code>print</code>，打印出来的实例还是不好看:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>'Michael'</span><span>)</span>
<span>>></span><span>></span> s
<span>&lt;</span>__main__<span>.</span>Student <span>object</span> at <span>0x109afb310</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是因为直接显示变量调用的不是 <code>__str__()</code>，而是 <code>__repr__()</code>，两者的区别是 <code>__str__()</code> 返回用户看到的字符串，而 <code>__repr__()</code> 返回程序开发者看到的字符串，也就是说，<code>__repr__()</code> 是为调试服务的。</p>
<p>解决办法是再定义一个 <code>__repr__()</code>。但是通常 <code>__str__()</code> 和 <code>__repr__()</code> 代码都是一样的，所以，有个偷懒的写法:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
    <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>'Student object (name=%s)'</span> <span>%</span> self<span>.</span>name
    __repr__ <span>=</span> __str__
__iter__
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果一个类想被用于 <code>for ... in</code> 循环，类似 list 或 tuple 那样，就必须实现一个 <code>__iter__()</code> 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 <code>__next__()</code> 方法拿到循环的下一个值，直到遇到 <code>StopIteration</code> 错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个 <code>Fib</code> 类，可以作用于 for 循环:</p>
<div><pre><code><span>class</span> <span>Fib</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>a<span>,</span> self<span>.</span>b <span>=</span> <span>0</span><span>,</span> <span>1</span> <span># 初始化两个计数器a，b</span>

    <span>def</span> <span>__iter__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self <span># 实例本身就是迭代对象，故返回自己</span>

    <span>def</span> <span>__next__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>a<span>,</span> self<span>.</span>b <span>=</span> self<span>.</span>b<span>,</span> self<span>.</span>a <span>+</span> self<span>.</span>b <span># 计算下一个值</span>
        <span>if</span> self<span>.</span>a <span>></span> <span>100000</span><span>:</span> <span># 退出循环的条件</span>
            <span>raise</span> StopIteration<span>(</span><span>)</span>
        <span>return</span> self<span>.</span>a <span># 返回下一个值</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>现在，试试把 <code>Fib</code> 实例作用于 for 循环:</p>
<div><pre><code><span>>></span><span>></span> <span>for</span> n <span>in</span> Fib<span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>1</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>5</span>
<span>.</span><span>.</span><span>.</span>
<span>46368</span>
<span>75025</span>
__getitem__
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>Fib</code> 实例虽然能作用于 for 循环，看起来和 <code>list</code> 有点像，但是，把它当成 <code>list</code> 来使用还是不行，比如，取第 5 个元素:</p>
<div><pre><code><span>>></span><span>></span> Fib<span>(</span><span>)</span><span>[</span><span>5</span><span>]</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
TypeError<span>:</span> <span>'Fib'</span> <span>object</span> does <span>not</span> support indexing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>要表现得像 list 那样按照下标取出元素，需要实现 <code>__getitem__()</code> 方法:</p>
<div><pre><code><span>class</span> <span>Fib</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__getitem__</span><span>(</span>self<span>,</span> n<span>)</span><span>:</span>
        a<span>,</span> b <span>=</span> <span>1</span><span>,</span> <span>1</span>
        <span>for</span> x <span>in</span> <span>range</span><span>(</span>n<span>)</span><span>:</span>
            a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
        <span>return</span> a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>现在，就可以按下标访问数列的任意一项了:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> Fib<span>(</span><span>)</span>
<span>>></span><span>></span> f<span>[</span><span>0</span><span>]</span>
<span>1</span>
<span>>></span><span>></span> f<span>[</span><span>1</span><span>]</span>
<span>1</span>
<span>>></span><span>></span> f<span>[</span><span>2</span><span>]</span>
<span>2</span>
<span>>></span><span>></span> f<span>[</span><span>3</span><span>]</span>
<span>3</span>
<span>>></span><span>></span> f<span>[</span><span>10</span><span>]</span>
<span>89</span>
<span>>></span><span>></span> f<span>[</span><span>100</span><span>]</span>
<span>573147844013817084101</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>但是 <code>list</code> 有个神奇的切片方法:</p>
<div><pre><code><span>>></span><span>></span> <span>list</span><span>(</span><span>range</span><span>(</span><span>100</span><span>)</span><span>)</span><span>[</span><span>5</span><span>:</span><span>10</span><span>]</span>
<span>[</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于 Fib 却报错。原因是 <code>__getitem__()</code> 传入的参数可能是一个 <code>int</code>，也可能是一个切片对象 <code>slice</code>，所以要做判断:</p>
<div><pre><code><span>class</span> <span>Fib</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__getitem__</span><span>(</span>self<span>,</span> n<span>)</span><span>:</span>
        <span>if</span> <span>isinstance</span><span>(</span>n<span>,</span> <span>int</span><span>)</span><span>:</span> <span># n是索引</span>
            a<span>,</span> b <span>=</span> <span>1</span><span>,</span> <span>1</span>
            <span>for</span> x <span>in</span> <span>range</span><span>(</span>n<span>)</span><span>:</span>
                a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
            <span>return</span> a
        <span>if</span> <span>isinstance</span><span>(</span>n<span>,</span> <span>slice</span><span>)</span><span>:</span> <span># n是切片</span>
            start <span>=</span> n<span>.</span>start
            stop <span>=</span> n<span>.</span>stop
            <span>if</span> start <span>is</span> <span>None</span><span>:</span>
                start <span>=</span> <span>0</span>
            a<span>,</span> b <span>=</span> <span>1</span><span>,</span> <span>1</span>
            L <span>=</span> <span>[</span><span>]</span>
            <span>for</span> x <span>in</span> <span>range</span><span>(</span>stop<span>)</span><span>:</span>
                <span>if</span> x <span>>=</span> start<span>:</span>
                    L<span>.</span>append<span>(</span>a<span>)</span>
                a<span>,</span> b <span>=</span> b<span>,</span> a <span>+</span> b
            <span>return</span> L
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>现在试试 <code>Fib</code> 的切片:</p>
<div><pre><code><span>>></span><span>></span> f <span>=</span> Fib<span>(</span><span>)</span>
<span>>></span><span>></span> f<span>[</span><span>0</span><span>:</span><span>5</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span>
<span>>></span><span>></span> f<span>[</span><span>:</span><span>10</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>,</span> <span>13</span><span>,</span> <span>21</span><span>,</span> <span>34</span><span>,</span> <span>55</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是没有对 step 参数作处理:</p>
<div><pre><code><span>>></span><span>></span> f<span>[</span><span>:</span><span>10</span><span>:</span><span>2</span><span>]</span>
<span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>,</span> <span>13</span><span>,</span> <span>21</span><span>,</span> <span>34</span><span>,</span> <span>55</span><span>,</span> <span>89</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也没有对负数作处理，所以，要正确实现一个 <code>__getitem__()</code> 还是有很多工作要做的。</p>
<p>此外，如果把对象看成 dict，<code>__getitem__()</code> 的参数也可能是一个可以作 <code>key</code> 的 <code>object</code>，例如 <code>str</code>。</p>
<p>与之对应的是 <code>__setitem__()</code> 方法，把对象视作 <code>list</code> 或 <code>dict</code> 来对集合赋值。最后，还有一个 <code>__delitem__()</code> 方法，用于删除某个元素。</p>
<p>总之，通过上面的方法，我们自己定义的类表现得和 Python 自带的 <code>list</code>、<code>tuple</code>、<code>dict</code> 没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h2 id="getattr"> <code>__getattr__</code></h2>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义 <code>Student</code> 类:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> <span>'Michael'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>调用 <code>name</code> 属性，没问题，但是，调用不存在的 <code>score</code> 属性，就有问题了:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>name<span>)</span>
Michael
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>score<span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  <span>.</span><span>.</span><span>.</span>
AttributeError<span>:</span> <span>'Student'</span> <span>object</span> has no attribute <span>'score'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>错误信息很清楚地告诉我们，没有找到 <code>score</code> 这个 <code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个 <code>score</code> 属性外，Python 还有另一个机制，那就是写一个 <code>__getattr__()</code> 方法，动态返回一个属性。修改如下:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> <span>'Michael'</span>

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> attr<span>)</span><span>:</span>
        <span>if</span> attr<span>==</span><span>'score'</span><span>:</span>
            <span>return</span> <span>99</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当调用不存在的属性时，比如 <code>score</code>，Python 解释器会试图调用 <code>__getattr__(self, 'score')</code> 来尝试获得属性，这样，我们就有机会返回 <code>score</code> 的值:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> s<span>.</span>name
<span>'Michael'</span>
<span>>></span><span>></span> s<span>.</span>score
<span>99</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>返回函数也是完全可以的:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> attr<span>)</span><span>:</span>
        <span>if</span> attr<span>==</span><span>'age'</span><span>:</span>
            <span>return</span> <span>lambda</span><span>:</span> <span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>只是调用方式要变为:</p>
<div><pre><code><span>>></span><span>></span> s<span>.</span>age<span>(</span><span>)</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，只有在没有找到属性的情况下，才调用 <code>__getattr__</code>，已有的属性，比如 <code>name</code>，不会在 <code>__getattr__</code> 中查找。</p>
<p>此外，注意到任意调用如 <code>s.abc</code> 都会返回 <code>None</code>，这是因为我们定义的 <code>__getattr__</code> 默认返回就是 <code>None</code>。要让 class 只响应特定的几个属性，我们就要按照约定，抛出 <code>AttributeError</code> 的错误:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> attr<span>)</span><span>:</span>
        <span>if</span> attr<span>==</span><span>'age'</span><span>:</span>
            <span>return</span> <span>lambda</span><span>:</span> <span>25</span>
        <span>raise</span> AttributeError<span>(</span><span>'\'Student\' object has no attribute \'%s\''</span> <span>%</span> attr<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<p>举个例子:</p>
<p>现在很多网站都搞 REST API，比如新浪微博、豆瓣啥的，调用 API 的 URL 类似:</p>
<ul>
<li><code>http://api.server/user/friends</code></li>
<li><code>http://api.server/user/timeline/list</code></li>
</ul>
<p>如果要写 SDK，给每个 URL 对应的 API 都写一个方法，那得累死，而且，API 一旦改动，SDK 也要改。</p>
<p>利用完全动态的 <code>__getattr__</code>，我们可以写出一个链式调用:</p>
<div><pre><code><span>class</span> <span>Chain</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> path<span>=</span><span>''</span><span>)</span><span>:</span>
        self<span>.</span>_path <span>=</span> path

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> path<span>)</span><span>:</span>
        <span>return</span> Chain<span>(</span><span>'%s/%s'</span> <span>%</span> <span>(</span>self<span>.</span>_path<span>,</span> path<span>)</span><span>)</span>

    <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_path

    __repr__ <span>=</span> __str__
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>试试:</p>
<div><pre><code><span>>></span><span>></span> Chain<span>(</span><span>)</span><span>.</span>status<span>.</span>user<span>.</span>timeline<span>.</span><span>list</span>
<span>'/status/user/timeline/list'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样，无论 API 怎么变，SDK 都可以根据 URL 实现完全动态的调用，而且，不随 API 的增加而改变!</p>
<p>还有些 REST API 会把参数放到 URL 中，比如 GitHub 的 API:</p>
<div><pre><code>GET <span>/</span>users<span>/</span><span>:</span>user<span>/</span>repos
</code></pre>
<div><span>1</span><br></div></div><p>调用时，需要把 <code>:user</code> 替换为实际用户名。如果我们能写出这样的链式调用:</p>
<div><pre><code>Chain<span>(</span><span>)</span><span>.</span>users<span>(</span><span>'michael'</span><span>)</span><span>.</span>repos
</code></pre>
<div><span>1</span><br></div></div><p>就可以非常方便地调用 API 了。有兴趣的童鞋可以试试写出来。</p>
<h2 id="call"> <code>__call__</code></h2>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用 <code>instance.method()</code> 来调用。能不能直接在实例本身上调用呢？在 Python 中，答案是肯定的。</p>
<p>任何类，只需要定义一个 <code>__call__()</code> 方法，就可以直接对实例进行调用。请看示例:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

    <span>def</span> <span>__call__</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'My name is %s.'</span> <span>%</span> self<span>.</span>name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>调用方式如下:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>'Michael'</span><span>)</span>
<span>>></span><span>></span> s<span>(</span><span>)</span> <span># self参数不要传入</span>
My name <span>is</span> Michael<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>__call__()</code> 还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以您完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果您把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个 Callable 对象，比如函数和我们上面定义的带有 <code>__call__()</code> 的类实例:</p>
<div><pre><code><span>>></span><span>></span> <span>callable</span><span>(</span>Student<span>(</span><span>)</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>callable</span><span>(</span><span>max</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>callable</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span>
<span>False</span>
<span>>></span><span>></span> <span>callable</span><span>(</span><span>None</span><span>)</span>
<span>False</span>
<span>>></span><span>></span> <span>callable</span><span>(</span><span>'str'</span><span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>通过 <code>callable()</code> 函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<div><p>相关信息</p>
<p>更多可定制的方法，请参考 <a href="http://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener noreferrer">Python 的官方文档</a>。</p>
</div>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">继承和多态</title>
    <id>https://list-jiang.github.io/code/language/python/oop/extend/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/extend/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在 OOP 程序设计中，当我们定义一个 class 的时候，可以从某个现有的 class 继承，新的 class 称为子类 (Subclass) ，而被继承的 class 称为基类、父类或超类 (Base class、Super class) 。</p>
<p>比如，我们已经编写了一个名为 Animal 的 class，有一个 <code>run()</code> 方法可以直接打印:</p>
<div><pre><code><span>class</span> <span>Animal</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Animal is running...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们需要编写 Dog 和 Cat 类时，就可以直接从 Animal 类继承:</p>
<div><pre><code><span>class</span> <span>Dog</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>对于 Dog 来说，Animal 就是它的父类，对于 Animal 来说，Dog 就是它的子类。Cat 和 Dog 类似。</p>
<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于 Animial 实现了 <code>run()</code> 方法，因此，Dog 和 Cat 作为它的子类，什么事也没干，就自动拥有了 <code>run()</code> 方法:</p>
<div><pre><code>dog <span>=</span> Dog<span>(</span><span>)</span>
dog<span>.</span>run<span>(</span><span>)</span>

cat <span>=</span> Cat<span>(</span><span>)</span>
cat<span>.</span>run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行结果如下:</p>
<div><pre><code>Animal is running...
Animal is running...
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当然，也可以对子类增加一些方法，比如 Dog 类:</p>
<div><pre><code><span>class</span> <span>Dog</span><span>(</span>Animal<span>)</span><span>:</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Dog is running...'</span><span>)</span>

    <span>def</span> <span>eat</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Eating meat...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>继承的第二个好处需要我们对代码做一点改进。您看到了，无论是 Dog 还是 Cat，它们 <code>run()</code> 的时候，显示的都是 <code>Animal is running...</code>，符合逻辑的做法是分别显示 <code>Dog is running...</code> 和 <code>Cat is running...</code>，因此，对 Dog 和 Cat 类改进如下:</p>
<div><pre><code><span>class</span> <span>Dog</span><span>(</span>Animal<span>)</span><span>:</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Dog is running...'</span><span>)</span>

<span>class</span> <span>Cat</span><span>(</span>Animal<span>)</span><span>:</span>

    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Cat is running...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再次运行，结果如下:</p>
<div><pre><code>Dog is running...
Cat is running...
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当子类和父类都存在相同的 <code>run()</code> 方法时，我们说，子类的 <code>run()</code> 覆盖了父类的 <code>run()</code>，在代码运行的时候，总是会调用子类的 <code>run()</code>。这样，我们就获得了继承的另一个好处: 多态。</p>
<p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和 Python 自带的数据类型，比如 <code>str</code>、<code>list</code>、<code>dict</code> 没什么两样:</p>
<div><pre><code>a <span>=</span> <span>list</span><span>(</span><span>)</span> <span># a是list类型</span>
b <span>=</span> Animal<span>(</span><span>)</span> <span># b是Animal类型</span>
c <span>=</span> Dog<span>(</span><span>)</span> <span># c是Dog类型</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>判断一个变量是否是某个类型可以用 <code>isinstance()</code> 判断:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>a<span>,</span> <span>list</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span>b<span>,</span> Animal<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span>c<span>,</span> Dog<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>看来 a、b、c 确实对应着 <code>list</code>、<code>Animal</code>、<code>Dog</code> 这 3 种类型。</p>
<p>但是等等，试试:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>c<span>,</span> Animal<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>看来 c 不仅仅是 <code>Dog</code>，c 还是 <code>Animal</code>!</p>
<p>不过仔细想想，这是有道理的，因为 Dog 是从 Animal 继承下来的，当我们创建了一个 Dog 的实例 c 时，我们认为 c 的数据类型是 Dog 没错，但 c 同时也是 Animal 也没错，Dog 本来就是 Animal 的一种!</p>
<p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行:</p>
<div><pre><code><span>>></span><span>></span> b <span>=</span> Animal<span>(</span><span>)</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span>b<span>,</span> Dog<span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Dog 可以看成 Animal，但 Animal 不可以看成 Dog。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个 Animal 类型的变量:</p>
<div><pre><code><span>def</span> <span>run_twice</span><span>(</span>animal<span>)</span><span>:</span>
    animal<span>.</span>run<span>(</span><span>)</span>
    animal<span>.</span>run<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们传入 Animal 的实例时，<code>run_twice()</code> 就打印出:</p>
<div><pre><code><span>>></span><span>></span> run_twice<span>(</span>Animal<span>(</span><span>))</span>
Animal is running<span>..</span>.
Animal is running<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们传入 Dog 的实例时，<code>run_twice()</code> 就打印出:</p>
<div><pre><code><span>>></span><span>></span> run_twice<span>(</span>Dog<span>(</span><span>))</span>
Dog is running<span>..</span>.
Dog is running<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们传入 Cat 的实例时，<code>run_twice()</code> 就打印出:</p>
<div><pre><code><span>>></span><span>></span> run_twice<span>(</span>Cat<span>(</span><span>))</span>
Cat is running<span>..</span>.
Cat is running<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个 <code>Tortoise</code> 类型，也从 <code>Animal</code> 派生:</p>
<div><pre><code><span>class</span> <span>Tortoise</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Tortoise is running slowly...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当我们调用 <code>run_twice()</code> 时，传入 <code>Tortoise</code> 的实例:</p>
<div><pre><code><span>>></span><span>></span> run_twice<span>(</span>Tortoise<span>(</span><span>))</span>
Tortoise is running slowly<span>..</span>.
Tortoise is running slowly<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>您会发现，新增一个 Animal 的子类，不必对 <code>run_twice()</code> 做任何修改，实际上，任何依赖 Animal 作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入 Dog、Cat、Tortoise……时，我们只需要接收 Animal 类型就可以了，因为 Dog、Cat、Tortoise……都是 Animal 类型，然后，按照 Animal 类型进行操作即可。由于 Animal 类型有 <code>run()</code> 方法，因此，传入的任意类型，只要是 Animal 类或者子类，就会自动调用实际类型的 <code>run()</code> 方法，这就是多态的意思:</p>
<p>对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 <code>run()</code> 方法，而具体调用的 <code>run()</code> 方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力: 调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 <code>run()</code> 方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则:</p>
<p>对扩展开放: 允许新增 Animal 子类；</p>
<p>对修改封闭: 不需要修改依赖 Animal 类型的 <code>run_twice()</code> 等函数。</p>
<p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类 object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树:</p>
<div><pre><code>                ┌───────────────┐
                │    object     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Animal    │           │    Plant    │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="静态语言-vs-动态语言"> 静态语言 vs 动态语言</h2>
<p>对于静态语言 (例如 Java) 来说，如果需要传入 Animal 类型，则传入的对象必须是 Animal 类型或者它的子类，否则，将无法调用 <code>run()</code> 方法。</p>
<p>对于 Python 这样的动态语言来说，则不一定需要传入 Animal 类型。我们只需要保证传入的对象有一个 <code>run()</code> 方法就可以了:</p>
<div><pre><code><span>class</span> <span>Timer</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Start...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python 的 “file-like object“ 就是一种鸭子类型。对真正的文件对象，它有一个 <code>read()</code> 方法，返回其内容。但是，许多对象，只要有 <code>read()</code> 方法，都被视为 “file-like object“。许多函数接收的参数就是 “file-like object“，您不一定要传入真正的文件对象，完全可以传入任何实现了 <code>read()</code> 方法的对象。</p>
<h2 id="多重继承"> 多重继承</h2>
<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>
<p>回忆一下 <code>Animal</code> 类层次的设计，假设我们要实现以下 4 种动物:</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。</li>
</ul>
<p>如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次:</p>
<div><pre><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次:</p>
<div><pre><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次:</p>
<ul>
<li>哺乳类: 能跑的哺乳类，能飞的哺乳类；</li>
<li>鸟类: 能跑的鸟类，能飞的鸟类。</li>
</ul>
<p>这么一来，类的层次就复杂了:</p>
<div><pre><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</p>
<p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计:</p>
<div><pre><code><span>class</span> <span>Animal</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>pass</span>

<span># 大类:</span>
<span>class</span> <span>Mammal</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>Bird</span><span>(</span>Animal<span>)</span><span>:</span>
    <span>pass</span>

<span># 各种动物:</span>
<span>class</span> <span>Dog</span><span>(</span>Mammal<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>Bat</span><span>(</span>Mammal<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>Parrot</span><span>(</span>Bird<span>)</span><span>:</span>
    <span>pass</span>

<span>class</span> <span>Ostrich</span><span>(</span>Bird<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>现在，我们要给动物再加上 <code>Runnable</code> 和 <code>Flyable</code> 的功能，只需要先定义好 <code>Runnable</code> 和 <code>Flyable</code> 的类:</p>
<div><pre><code><span>class</span> <span>Runnable</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>run</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Running...'</span><span>)</span>

<span>class</span> <span>Flyable</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>fly</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Flying...'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对于需要 <code>Runnable</code> 功能的动物，就多继承一个 <code>Runnable</code>，例如 <code>Dog</code>:</p>
<div><pre><code><span>class</span> <span>Dog</span><span>(</span>Mammal<span>,</span> Runnable<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于需要 <code>Flyable</code> 功能的动物，就多继承一个 <code>Flyable</code>，例如 <code>Bat</code>:</p>
<div><pre><code><span>class</span> <span>Bat</span><span>(</span>Mammal<span>,</span> Flyable<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<h2 id="mixin"> MixIn</h2>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code> 继承自 <code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让 <code>Ostrich</code> 除了继承自 <code>Bird</code> 外，再同时继承 <code>Runnable</code>。这种设计通常称之为 MixIn。</p>
<p>为了更好地看出继承关系，我们把 <code>Runnable</code> 和 <code>Flyable</code> 改为 <code>RunnableMixIn</code> 和 <code>FlyableMixIn</code>。类似的，您还可以定义出肉食动物<code>CarnivorousMixIn</code> 和植食动物 <code>HerbivoresMixIn</code>，让某个动物同时拥有好几个 MixIn:</p>
<div><pre><code><span>class</span> <span>Dog</span><span>(</span>Mammal<span>,</span> RunnableMixIn<span>,</span> CarnivorousMixIn<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>MixIn 的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个 MixIn 的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python 自带的很多库也使用了 MixIn。举个例子，Python 自带了 TCPServer 和 UDPServer 这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由 ForkingMixIn 和 ThreadingMixIn 提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的 TCP 服务，定义如下:</p>
<div><pre><code><span>class</span> <span>MyTCPServer</span><span>(</span>TCPServer<span>,</span> ForkingMixIn<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>编写一个多线程模式的 UDP 服务，定义如下:</p>
<div><pre><code><span>class</span> <span>MyUDPServer</span><span>(</span>UDPServer<span>,</span> ThreadingMixIn<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果您打算搞一个更先进的协程模型，可以编写一个 CoroutineMixIn:</p>
<div><pre><code><span>class</span> <span>MyTCPServer</span><span>(</span>TCPServer<span>,</span> CoroutineMixIn<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>
<h2 id="小结"> 小结</h2>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<p>由于 Python 允许使用多重继承，因此，MixIn 就是一种常见的设计。</p>
<p>只允许单一继承的语言 (如 Java) 不能使用 MixIn 的设计。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">获取对象信息</title>
    <id>https://list-jiang.github.io/code/language/python/oop/info/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/info/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h2 id="使用-type"> 使用 <code>type()</code></h2>
<p>首先，我们来判断对象类型，使用 <code>type()</code> 函数:</p>
<p>基本类型都可以用 <code>type()</code> 判断:</p>
<div><pre><code><span>>></span><span>></span> <span>type</span><span>(</span><span>123</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'int'</span><span>></span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>'str'</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'str'</span><span>></span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>None</span><span>)</span>
<span>&lt;</span><span>type</span><span>(</span><span>None</span><span>)</span> <span>'NoneType'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果一个变量指向函数或者类，也可以用 <code>type()</code> 判断:</p>
<div><pre><code><span>>></span><span>></span> <span>type</span><span>(</span><span>abs</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'builtin_function_or_method'</span><span>></span>
<span>>></span><span>></span> <span>type</span><span>(</span>a<span>)</span>
<span>&lt;</span><span>class</span> <span>'__main__.Animal'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但是 <code>type()</code> 函数返回的是什么类型呢？它返回对应的 Class 类型。如果我们要在 if 语句中判断，就需要比较两个变量的 type 类型是否相同:</p>
<div><pre><code><span>>></span><span>></span> <span>type</span><span>(</span><span>123</span><span>)</span><span>==</span><span>type</span><span>(</span><span>456</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>123</span><span>)</span><span>==</span><span>int</span>
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>'abc'</span><span>)</span><span>==</span><span>type</span><span>(</span><span>'123'</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>'abc'</span><span>)</span><span>==</span><span>str</span>
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>'abc'</span><span>)</span><span>==</span><span>type</span><span>(</span><span>123</span><span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>判断基本数据类型可以直接写 <code>int</code>，<code>str</code> 等，但如果要判断一个对象是否是函数怎么办？可以使用 <code>types</code> 模块中定义的常量:</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> types
<span>>></span><span>></span> <span>def</span> <span>fn</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>pass</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>type</span><span>(</span>fn<span>)</span><span>==</span>types<span>.</span>FunctionType
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>abs</span><span>)</span><span>==</span>types<span>.</span>BuiltinFunctionType
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>lambda</span> x<span>:</span> x<span>)</span><span>==</span>types<span>.</span>LambdaType
<span>True</span>
<span>>></span><span>></span> <span>type</span><span>(</span><span>(</span>x <span>for</span> x <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>==</span>types<span>.</span>GeneratorType
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="使用-isinstance"> 使用 <code>isinstance()</code></h2>
<p>对于 class 的继承关系来说，使用 <code>type()</code> 就很不方便。我们要判断 class 的类型，可以使用 <code>isinstance()</code> 函数。</p>
<p>我们回顾上次的例子，如果继承关系是:</p>
<div><pre><code>object -&gt; Animal -&gt; Dog -&gt; Husky
</code></pre>
<div><span>1</span><br></div></div><p>那么，<code>isinstance()</code> 就可以告诉我们，一个对象是否是某种类型。先创建 3 种类型的对象:</p>
<div><pre><code><span>>></span><span>></span> a <span>=</span> Animal<span>(</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Dog<span>(</span><span>)</span>
<span>>></span><span>></span> h <span>=</span> Husky<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，判断:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>h<span>,</span> Husky<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>没有问题，因为 <code>h</code> 变量指向的就是 <code>Husky</code> 对象。</p>
<p>再判断:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>h<span>,</span> Dog<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>h</code> 虽然自身是 <code>Husky</code> 类型，但由于 <code>Husky</code> 是从 <code>Dog</code> 继承下来的，所以，<code>h</code> 也还是 <code>Dog</code> 类型。换句话说，<code>isinstance()</code> 判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<p>因此，我们可以确信，<code>h</code> 还是 <code>Animal</code> 类型:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>h<span>,</span> Animal<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>同理，实际类型是 <code>Dog</code> 的 <code>d</code> 也是 <code>Animal</code> 类型:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>d<span>,</span> Dog<span>)</span> <span>and</span> <span>isinstance</span><span>(</span>d<span>,</span> Animal<span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是，<code>d</code> 不是 <code>Husky</code> 类型:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span>d<span>,</span> Husky<span>)</span>
<span>False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>能用 <code>type()</code> 判断的基本类型也可以用 <code>isinstance()</code> 判断:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span><span>'a'</span><span>,</span> <span>str</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>123</span><span>,</span> <span>int</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>b'a'</span><span>,</span> <span>bytes</span><span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是 <code>list</code> 或者 <code>tuple</code>:</p>
<div><pre><code><span>>></span><span>></span> <span>isinstance</span><span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>(</span><span>list</span><span>,</span> <span>tuple</span><span>)</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>isinstance</span><span>(</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>,</span> <span>(</span><span>list</span><span>,</span> <span>tuple</span><span>)</span><span>)</span>
<span>True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>提示</p>
<p>总是优先使用 <code>isinstance()</code> 判断类型，可以将指定类型及其子类“一网打尽”。</p>
</div>
<h2 id="使用-dir"> 使用 <code>dir()</code></h2>
<p>如果要获得一个对象的所有属性和方法，可以使用 <code>dir()</code> 函数，它返回一个包含字符串的 <code>list</code>，比如，获得一个 <code>str</code> 对象的所有属性和方法:</p>
<div><pre><code><span>>></span><span>></span> <span>dir</span><span>(</span><span>'ABC'</span><span>)</span>
<span>[</span><span>'__add__'</span><span>,</span> <span>'__class__'</span><span>,</span><span>.</span><span>.</span><span>.</span><span>,</span> <span>'__subclasshook__'</span><span>,</span> <span>'capitalize'</span><span>,</span> <span>'casefold'</span><span>,</span><span>.</span><span>.</span><span>.</span><span>,</span> <span>'zfill'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>类似 <code>__xxx__</code> 的属性和方法在 Python 中都是有特殊用途的，比如 <code>__len__</code> 方法返回长度。在 Python 中，如果您调用 <code>len()</code> 函数试图获取一个对象的长度，实际上，在 len()函数内部，它自动去调用该对象的 <code>__len__()</code> 方法，所以，下面的代码是等价的:</p>
<div><pre><code><span>>></span><span>></span> <span>len</span><span>(</span><span>'ABC'</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> <span>'ABC'</span><span>.</span>__len__<span>(</span><span>)</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>我们自己写的类，如果也想用 <code>len(myObj)</code> 的话，就自己写一个 <code>__len__()</code> 方法:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>MyDog</span><span>(</span><span>object</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__len__</span><span>(</span>self<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         <span>return</span> <span>100</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> dog <span>=</span> MyDog<span>(</span><span>)</span>
<span>>></span><span>></span> <span>len</span><span>(</span>dog<span>)</span>
<span>100</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>剩下的都是普通属性或方法，比如 <code>lower()</code> 返回小写的字符串:</p>
<div><pre><code><span>>></span><span>></span> <span>'ABC'</span><span>.</span>lower<span>(</span><span>)</span>
<span>'abc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>仅仅把属性和方法列出来是不够的，配合 <code>getattr()</code>、<code>setattr()</code> 以及 <code>hasattr()</code>，我们可以直接操作一个对象的状态:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>MyObject</span><span>(</span><span>object</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         self<span>.</span>x <span>=</span> <span>9</span>
<span>.</span><span>.</span><span>.</span>     <span>def</span> <span>power</span><span>(</span>self<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>         <span>return</span> self<span>.</span>x <span>*</span> self<span>.</span>x
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> obj <span>=</span> MyObject<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>紧接着，可以测试该对象的属性:</p>
<div><pre><code><span>>></span><span>></span> <span>hasattr</span><span>(</span>obj<span>,</span> <span>'x'</span><span>)</span> <span># 有属性'x'吗？</span>
<span>True</span>
<span>>></span><span>></span> obj<span>.</span>x
<span>9</span>
<span>>></span><span>></span> <span>hasattr</span><span>(</span>obj<span>,</span> <span>'y'</span><span>)</span> <span># 有属性'y'吗？</span>
<span>False</span>
<span>>></span><span>></span> <span>setattr</span><span>(</span>obj<span>,</span> <span>'y'</span><span>,</span> <span>19</span><span>)</span> <span># 设置一个属性'y'</span>
<span>>></span><span>></span> <span>hasattr</span><span>(</span>obj<span>,</span> <span>'y'</span><span>)</span> <span># 有属性'y'吗？</span>
<span>True</span>
<span>>></span><span>></span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'y'</span><span>)</span> <span># 获取属性'y'</span>
<span>19</span>
<span>>></span><span>></span> obj<span>.</span>y <span># 获取属性'y'</span>
<span>19</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如果试图获取不存在的属性，会抛出 <code>AttributeError</code> 的错误:</p>
<div><pre><code><span>>></span><span>></span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'z'</span><span>)</span> <span># 获取属性'z'</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'MyObject'</span> <span>object</span> has no attribute <span>'z'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以传入一个 <code>default</code> 参数，如果属性不存在，就返回默认值:</p>
<div><pre><code><span>>></span><span>></span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'z'</span><span>,</span> <span>404</span><span>)</span> <span># 获取属性'z'，如果不存在，返回默认值404</span>
<span>404</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以获得对象的方法:</p>
<div><pre><code><span>>></span><span>></span> <span>hasattr</span><span>(</span>obj<span>,</span> <span>'power'</span><span>)</span> <span># 有属性'power'吗？</span>
<span>True</span>
<span>>></span><span>></span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'power'</span><span>)</span> <span># 获取属性'power'</span>
<span>&lt;</span>bound method MyObject<span>.</span>power of <span>&lt;</span>__main__<span>.</span>MyObject <span>object</span> at <span>0x10077a6a0</span><span>>></span>
<span>>></span><span>></span> fn <span>=</span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'power'</span><span>)</span> <span># 获取属性'power'并赋值到变量fn</span>
<span>>></span><span>></span> fn <span># fn指向obj.power</span>
<span>&lt;</span>bound method MyObject<span>.</span>power of <span>&lt;</span>__main__<span>.</span>MyObject <span>object</span> at <span>0x10077a6a0</span><span>>></span>
<span>>></span><span>></span> fn<span>(</span><span>)</span> <span># 调用fn()与调用obj.power()是一样的</span>
<span>81</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="小结"> 小结</h2>
<p>通过内置的一系列函数，我们可以对任意一个 Python 对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写:</p>
<div><pre><code><span>sum</span> <span>=</span> obj<span>.</span>x <span>+</span> obj<span>.</span>y
</code></pre>
<div><span>1</span><br></div></div><p>就不要写:</p>
<div><pre><code><span>sum</span> <span>=</span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'x'</span><span>)</span> <span>+</span> <span>getattr</span><span>(</span>obj<span>,</span> <span>'y'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>一个正确的用法的例子如下:</p>
<div><pre><code><span>def</span> <span>readImage</span><span>(</span>fp<span>)</span><span>:</span>
    <span>if</span> <span>hasattr</span><span>(</span>fp<span>,</span> <span>'read'</span><span>)</span><span>:</span>
        <span>return</span> readData<span>(</span>fp<span>)</span>
    <span>return</span> <span>None</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>假设我们希望从文件流 <code>fp</code> 中读取图像，我们首先要判断该 <code>fp</code> 对象是否存在 <code>read</code> 方法，如果存在，则该对象是一个流，如果不存在，则无法读取。<code>hasattr()</code> 就派上了用场。</p>
<p>请注意，在 Python 这类动态语言中，根据鸭子类型，有 <code>read()</code> 方法，不代表该 fp 对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要 <code>read()</code> 方法返回的是有效的图像数据，就不影响读取图像的功能。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">类和实例</title>
    <id>https://list-jiang.github.io/code/language/python/oop/instance/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/instance/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>面向对象最重要的概念就是类 (Class) 和实例 (Instance) ，必须牢记类是抽象的模板，比如 <code>Student</code> 类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
]]></summary>
    <content type="html"><![CDATA[<p>面向对象最重要的概念就是类 (Class) 和实例 (Instance) ，必须牢记类是抽象的模板，比如 <code>Student</code> 类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>

<p>仍以 <code>Student</code> 类为例，在 Python 中，定义类是通过 class 关键字:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>class 后面紧接着是类名，即 <code>Student</code>，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用 object 类，这是所有类最终都会继承的类。</p>
<p>定义好了 <code>Student</code> 类，就可以根据 <code>Student</code> 类创建出 <code>Student</code> 的实例，创建实例是通过 <code>className()</code> 实现的:</p>
<div><pre><code><span>>></span><span>></span> bart <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> bart
<span>&lt;</span>__main__<span>.</span>Student <span>object</span> at <span>0x10a67a590</span><span>></span>
<span>>></span><span>></span> Student
<span>&lt;</span><span>class</span> <span>'__main__.Student'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>可以看到，变量 <code>bart</code> 指向的就是一个 Student 的实例，后面的 <code>0x10a67a590</code> 是内存地址，每个 object 的地址都不一样，而 <code>Student</code> 本身则是一个类。</p>
<p>可以自由地给一个实例变量绑定属性，比如，给实例 <code>bart</code> 绑定一个 <code>name</code> 属性:</p>
<div><pre><code><span>>></span><span>></span> bart<span>.</span>name <span>=</span> <span>'Bart Simpson'</span>
<span>>></span><span>></span> bart<span>.</span>name
<span>'Bart Simpson'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的 <strong>init</strong> 方法，在创建实例的时候，就把 <code>name</code>，<code>score</code> 等属性绑上去:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>
<p>特殊方法 <code>__init__</code> 前后分别有两个下划线!!!</p>
</div>
<p>由于 <strong>init</strong> 方法的第一个参数永远是 <code>self</code>，表示创建的实例本身，因此，在 <strong>init</strong> 方法内部，就可以把各种属性绑定到 <code>self</code>，因为 <code>self</code> 就指向创建的实例本身。</p>
<p>有了 <strong>init</strong> 方法，在创建实例的时候，就不能传入空的参数了，必须传入与 <strong>init</strong> 方法匹配的参数，但 self 不需要传，Python 解释器自己会把实例变量传进去:</p>
<div><pre><code>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
&gt;&gt;&gt; bart.name
&#39;Bart Simpson&#39;
&gt;&gt;&gt; bart.score
59
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量 self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，您仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h2 id="数据封装"> 数据封装</h2>
<p>面向对象编程的一个重要特点就是数据封装。在上面的 Student 类中，每个实例就拥有各自的 name 和 score 这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩:</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>print_score</span><span>(</span>std<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>std<span>.</span>name<span>,</span> std<span>.</span>score<span>)</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> print_score<span>(</span>bart<span>)</span>
Bart Simpson<span>:</span> <span>59</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是，既然 Student 实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在 Student 类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和 Student 类本身是关联起来的，我们称之为类的方法:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

    <span>def</span> <span>print_score</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>score<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要定义一个方法，除了第一个参数是 self 外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了 self 不用传递，其他参数正常传入:</p>
<div><pre><code><span>>></span><span>></span> bart<span>.</span>print_score<span>(</span><span>)</span>
Bart Simpson<span>:</span> <span>59</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这样一来，我们从外部看 Student 类，就只需要知道，创建实例需要给出 name 和 score，而如何打印，都是在 Student 类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>
<p>封装的另一个好处是可以给 Student 类增加新的方法，比如 get_grade:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>

    <span>def</span> <span>get_grade</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> self<span>.</span>score <span>>=</span> <span>90</span><span>:</span>
            <span>return</span> <span>'A'</span>
        <span>elif</span> self<span>.</span>score <span>>=</span> <span>60</span><span>:</span>
            <span>return</span> <span>'B'</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>'C'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>同样的，get_grade 方法可以直接在实例变量上调用，不需要知道内部实现细节:</p>
<div><pre><code><span># -*- coding: utf-8 -*-</span>
<span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

    <span>def</span> <span>get_grade</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> self<span>.</span>score <span>>=</span> <span>90</span><span>:</span>
            <span>return</span> <span>'A'</span>
        <span>elif</span> self<span>.</span>score <span>>=</span> <span>60</span><span>:</span>
            <span>return</span> <span>'B'</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>'C'</span>

lisa <span>=</span> Student<span>(</span><span>'Lisa'</span><span>,</span> <span>99</span><span>)</span>
bart <span>=</span> Student<span>(</span><span>'Bart'</span><span>,</span> <span>59</span><span>)</span>
<span>print</span><span>(</span>lisa<span>.</span>name<span>,</span> lisa<span>.</span>get_grade<span>(</span><span>)</span><span>)</span>
<span># Lisa A</span>
<span>print</span><span>(</span>bart<span>.</span>name<span>,</span> bart<span>.</span>get_grade<span>(</span><span>)</span><span>)</span>
<span># Bart C</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="实例属性和类属性"> 实例属性和类属性</h2>
<p>由于 Python 是动态语言，根据类创建的实例可以任意绑定属性。</p>
<p>给实例绑定属性的方法是通过实例变量，或者通过 <code>self</code> 变量:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name

s <span>=</span> Student<span>(</span><span>'Bob'</span><span>)</span>
s<span>.</span>score <span>=</span> <span>90</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但是，如果 <code>Student</code> 类本身需要绑定一个属性呢？可以直接在 class 中定义属性，这种属性是类属性，归 <code>Student</code> 类所有:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    name <span>=</span> <span>'Student'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     name <span>=</span> <span>'Student'</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span> <span># 创建实例s</span>
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>name<span>)</span> <span># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span>
Student
<span>>></span><span>></span> <span>print</span><span>(</span>Student<span>.</span>name<span>)</span> <span># 打印类的name属性</span>
Student
<span>>></span><span>></span> s<span>.</span>name <span>=</span> <span>'Michael'</span> <span># 给实例绑定name属性</span>
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>name<span>)</span> <span># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span>
Michael
<span>>></span><span>></span> <span>print</span><span>(</span>Student<span>.</span>name<span>)</span> <span># 但是类属性并未消失，用Student.name仍然可以访问</span>
Student
<span>>></span><span>></span> <span>del</span> s<span>.</span>name <span># 如果删除实例的name属性</span>
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>name<span>)</span> <span># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span>
Student
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>从上面的例子可以看出，在编写程序的时候，千万<strong>不要对实例属性和类属性使用相同的名字</strong>，因为相同名称的实例属性将屏蔽掉类属性，但是当您删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p>
</li>
<li>
<p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p>
</li>
<li>
<p>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</p>
</li>
<li>
<p>和静态语言不同，Python 允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同:</p>
<div><pre><code><span>>></span><span>></span> bart <span>=</span> Student<span>(</span><span>'Bart Simpson'</span><span>,</span> <span>59</span><span>)</span>
<span>>></span><span>></span> lisa <span>=</span> Student<span>(</span><span>'Lisa Simpson'</span><span>,</span> <span>87</span><span>)</span>
<span>>></span><span>></span> bart<span>.</span>age <span>=</span> <span>8</span>
<span>>></span><span>></span> bart<span>.</span>age
<span>8</span>
<span>>></span><span>></span> lisa<span>.</span>age
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'Student'</span> <span>object</span> has no attribute <span>'age'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>实例属性属于各个实例所有，互不干扰；</p>
</li>
<li>
<p>类属性属于类所有，所有实例共享一个属性；</p>
</li>
<li>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">面向对象编程</title>
    <id>https://list-jiang.github.io/code/language/python/oop/intro/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>面向对象编程——Object Oriented Programming，简称 OOP，是一种程序设计思想。OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在 Python 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类 (Class) 的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个 dict 表示:</p>
<div><pre><code>std1 <span>=</span> <span>{</span> <span>'name'</span><span>:</span> <span>'Michael'</span><span>,</span> <span>'score'</span><span>:</span> <span>98</span> <span>}</span>
std2 <span>=</span> <span>{</span> <span>'name'</span><span>:</span> <span>'Bob'</span><span>,</span> <span>'score'</span><span>:</span> <span>81</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩:</p>
<div><pre><code><span>def</span> <span>print_score</span><span>(</span>std<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>std<span>[</span><span>'name'</span><span>]</span><span>,</span> std<span>[</span><span>'score'</span><span>]</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 <code>Student</code> 这种数据类型应该被视为一个对象，这个对象拥有 <code>name</code> 和 <code>score</code> 这两个属性 (Property) 。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 <code>print_score</code> 消息，让对象自己把自己的数据打印出来。</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>score <span>=</span> score

    <span>def</span> <span>print_score</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>name<span>,</span> self<span>.</span>score<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法 (Method) 。面向对象的程序写出来就像这样:</p>
<div><pre><code>bart <span>=</span> Student<span>(</span><span>'Bart Simpson'</span><span>,</span> <span>59</span><span>)</span>
lisa <span>=</span> Student<span>(</span><span>'Lisa Simpson'</span><span>,</span> <span>87</span><span>)</span>
bart<span>.</span>print_score<span>(</span><span>)</span>
lisa<span>.</span>print_score<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>面向对象的设计思想是从自然界中来的，因为在自然界中，类 (Class) 和实例 (Instance) 的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student，是指学生这个概念，而实例 (Instance) 则是一个个具体的 Student，比如，<code>Bart Simpson</code> 和 <code>Lisa Simpson</code> 是两个具体的 Student。</p>
<p>所以，面向对象的设计思想是抽象出 Class，根据 Class 创建 Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">属性</title>
    <id>https://list-jiang.github.io/code/language/python/oop/property/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/property/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="私有属性"> 私有属性</h2>
<p>在 Class 内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>但是，从前面 Student 类的定义来看，外部代码还是可以自由地修改一个实例的 <code>name</code>、<code>score</code> 属性:</p>
<div><pre><code><span>>></span><span>></span> bart <span>=</span> Student<span>(</span><span>'Bart Simpson'</span><span>,</span> <span>59</span><span>)</span>
<span>>></span><span>></span> bart<span>.</span>score
<span>59</span>
<span>>></span><span>></span> bart<span>.</span>score <span>=</span> <span>99</span>
<span>>></span><span>></span> bart<span>.</span>score
<span>99</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 <code>__</code>，在 Python 中，实例的变量名如果以 <code>__</code> 开头，就变成了一个私有变量 (private) ，只有内部可以访问，外部不能访问，所以，我们把 <code>Student</code> 类改一改:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>__name <span>=</span> name
        self<span>.</span>__score <span>=</span> score

    <span>def</span> <span>print_score</span><span>(</span>self<span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'%s: %s'</span> <span>%</span> <span>(</span>self<span>.</span>__name<span>,</span> self<span>.</span>__score<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量. <code>__name</code> 和实例变量 <code>__score</code> 了:</p>
<div><pre><code><span>>></span><span>></span> bart <span>=</span> Student<span>(</span><span>'Bart Simpson'</span><span>,</span> <span>59</span><span>)</span>
<span>>></span><span>></span> bart<span>.</span>__name
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'Student'</span> <span>object</span> has no attribute <span>'__name'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>但是如果外部代码要获取 <code>name</code> 和 <code>score</code> 怎么办？可以给 Student 类增加 <code>get_name</code> 和 <code>get_score</code> 这样的方法:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>

    <span>def</span> <span>get_name</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>__name

    <span>def</span> <span>get_score</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>__score
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果又要允许外部代码修改 score 怎么办？可以再给 Student 类增加 <code>set_score</code> 方法:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>

    <span>def</span> <span>set_score</span><span>(</span>self<span>,</span> score<span>)</span><span>:</span>
        self<span>.</span>__score <span>=</span> score
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>您也许会问，原先那种直接通过 bart.score = 99 也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span>

    <span>def</span> <span>set_score</span><span>(</span>self<span>,</span> score<span>)</span><span>:</span>
        <span>if</span> <span>0</span> <span>&lt;=</span> score <span>&lt;=</span> <span>100</span><span>:</span>
            self<span>.</span>__score <span>=</span> score
        <span>else</span><span>:</span>
            <span>raise</span> ValueError<span>(</span><span>'bad score'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>需要注意的是，在 Python 中，变量名类似 <code>__xxx__</code> 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用 <code>__name__</code>、<code>__score__</code> 这样的变量名。</p>
<p>有些时候，您会看到以一个下划线开头的实例变量名，比如 <code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当您看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问 <code>__name</code> 是因为 Python 解释器对外把 <code>__name</code> 变量改成了 <code>_Student__name</code>，所以，仍然可以通过 <code>_Student__name</code> 来访问 <code>__name</code> 变量:</p>
<div><pre><code><span>>></span><span>></span> bart<span>.</span>_Student__name
<span>'Bart Simpson'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是强烈建议您不要这么干，因为不同版本的 Python 解释器可能会把 <code>__name</code> 改成不同的变量名。</p>
<p>总的来说就是，Python 本身没有任何机制阻止您干坏事，一切全靠自觉。</p>
<div><p>错误写法</p>
<div><pre><code><span>>></span><span>></span> bart <span>=</span> Student<span>(</span><span>'Bart Simpson'</span><span>,</span> <span>59</span><span>)</span>
<span>>></span><span>></span> bart<span>.</span>get_name<span>(</span><span>)</span>
<span>'Bart Simpson'</span>
<span>>></span><span>></span> bart<span>.</span>__name <span>=</span> <span>'New Name'</span> <span># 设置__name变量!</span>
<span>>></span><span>></span> bart<span>.</span>__name
<span>'New Name'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>表面上看，外部代码“成功”地设置了 <code>__name</code> 变量，但实际上这个 <code>__name</code> 变量和 class 内部的 <code>__name</code> 变量不是一个变量! 内部的 <code>__name</code> 变量已经被 Python 解释器自动改成了 <code>_Student__name</code>，而外部代码给 bart 新增了一个 <code>__name</code> 变量。</p>
<div><pre><code><span>>></span><span>></span> bart<span>.</span>get_name<span>(</span><span>)</span> <span># get_name()内部返回self.__name</span>
<span>'Bart Simpson'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<h2 id="slots"> <code>__slots__</code></h2>
<p>Python 允许在定义 class 的时候，定义一个特殊的 <code>__slots__</code> 变量，来限制该 class 实例能添加的属性。</p>
<h3 id="不受限制的属性"> 不受限制的属性</h3>
<p>正常情况下，当我们定义了一个 class，创建了一个 class 的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义 class:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后，尝试给实例绑定一个属性:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> s<span>.</span>name <span>=</span> <span>'Michael'</span> <span># 动态给实例绑定一个属性</span>
<span>>></span><span>></span> <span>print</span><span>(</span>s<span>.</span>name<span>)</span>
Michael
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>还可以尝试给实例绑定一个方法:</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>set_age</span><span>(</span>self<span>,</span> age<span>)</span><span>:</span> <span># 定义一个函数作为实例方法</span>
<span>.</span><span>.</span><span>.</span>     self<span>.</span>age <span>=</span> age
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> <span>from</span> types <span>import</span> MethodType
<span>>></span><span>></span> s<span>.</span>set_age <span>=</span> MethodType<span>(</span>set_age<span>,</span> s<span>)</span> <span># 给实例绑定一个方法</span>
<span>>></span><span>></span> s<span>.</span>set_age<span>(</span><span>25</span><span>)</span> <span># 调用实例方法</span>
<span>>></span><span>></span> s<span>.</span>age <span># 测试结果</span>
<span>25</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是，给一个实例绑定的方法，对另一个实例是不起作用的:</p>
<div><pre><code><span>>></span><span>></span> s2 <span>=</span> Student<span>(</span><span>)</span> <span># 创建新的实例</span>
<span>>></span><span>></span> s2<span>.</span>set_age<span>(</span><span>25</span><span>)</span> <span># 尝试调用方法</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'Student'</span> <span>object</span> has no attribute <span>'set_age'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>为了给所有实例都绑定方法，可以给 class 绑定方法:</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>set_score</span><span>(</span>self<span>,</span> score<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     self<span>.</span>score <span>=</span> score
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> Student<span>.</span>set_score <span>=</span> set_score
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>给 class 绑定方法后，所有实例均可调用:</p>
<div><pre><code><span>>></span><span>></span> s<span>.</span>set_score<span>(</span><span>100</span><span>)</span>
<span>>></span><span>></span> s<span>.</span>score
<span>100</span>
<span>>></span><span>></span> s2<span>.</span>set_score<span>(</span><span>99</span><span>)</span>
<span>>></span><span>></span> s2<span>.</span>score
<span>99</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>通常情况下，上面的 <code>set_score</code> 方法可以直接定义在 class 中，但动态绑定允许我们在程序运行的过程中动态给 class 加上功能，这在静态语言中很难实现。</p>
<h3 id="使用-slots"> 使用 <code>__slots__</code></h3>
<p>想要限制实例的属性，比如只允许对 <code>Student</code> 实例添加 <code>name</code> 和 <code>age</code> 属性，就要使用 <code>__slots__</code>。Python 允许在定义 class 的时候，定义一个特殊的 <code>__slots__</code> 变量，来限制该 class 实例能添加的属性:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>
    __slots__ <span>=</span> <span>(</span><span>'name'</span><span>,</span> <span>'age'</span><span>)</span> <span># 用tuple定义允许绑定的属性名称</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后，我们试试:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span> <span># 创建新的实例</span>
<span>>></span><span>></span> s<span>.</span>name <span>=</span> <span>'Michael'</span> <span># 绑定属性'name'</span>
<span>>></span><span>></span> s<span>.</span>age <span>=</span> <span>25</span> <span># 绑定属性'age'</span>
<span>>></span><span>></span> s<span>.</span>score <span>=</span> <span>99</span> <span># 绑定属性'score'</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'Student'</span> <span>object</span> has no attribute <span>'score'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>由于 <code>'score'</code> 没有被放到 <code>__slots__</code> 中，所以不能绑定 score 属性，试图绑定 score 将得到 <code>AttributeError</code> 的错误。</p>
<p>使用 <code>__slots__</code> 要注意，<code>__slots__</code> 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的:</p>
<div><pre><code><span>>></span><span>></span> <span>class</span> <span>GraduateStudent</span><span>(</span>Student<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>pass</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> g <span>=</span> GraduateStudent<span>(</span><span>)</span>
<span>>></span><span>></span> g<span>.</span>score <span>=</span> <span>9999</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>除非在子类中也定义 <code>__slots__</code>，这样，子类实例允许定义的属性就是自身的 <code>__slots__</code> 加上父类的 <code>__slots__</code>。</p>
<h2 id="property"> @property</h2>
<p><code>@property</code> 广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<p>在绑定属性时，若直接暴露属性，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改:</p>
<div><pre><code>s <span>=</span> Student<span>(</span><span>)</span>
s<span>.</span>score <span>=</span> <span>9999</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这显然不合逻辑。为了限制 <code>score</code> 的范围，可以通过一个 <code>set_score()</code> 方法来设置成绩，再通过一个 <code>get_score()</code> 来获取成绩，这样，在 <code>set_score()</code> 方法里，就可以检查参数:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>get_score</span><span>(</span>self<span>)</span><span>:</span>
         <span>return</span> self<span>.</span>_score

    <span>def</span> <span>set_score</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>value<span>,</span> <span>int</span><span>)</span><span>:</span>
            <span>raise</span> ValueError<span>(</span><span>'score must be an integer!'</span><span>)</span>
        <span>if</span> value <span>&lt;</span> <span>0</span> <span>or</span> value <span>></span> <span>100</span><span>:</span>
            <span>raise</span> ValueError<span>(</span><span>'score must between 0 ~ 100!'</span><span>)</span>
        self<span>.</span>_score <span>=</span> value
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>现在，对任意的 <code>Student</code> 实例进行操作，就不能随心所欲地设置 <code>score</code> 了:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> s<span>.</span>set_score<span>(</span><span>60</span><span>)</span> <span># ok!</span>
<span>>></span><span>></span> s<span>.</span>get_score<span>(</span><span>)</span>
<span>60</span>
<span>>></span><span>></span> s<span>.</span>set_score<span>(</span><span>9999</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  <span>.</span><span>.</span><span>.</span>
ValueError<span>:</span> score must between <span>0</span> <span>~</span> <span>100</span>!
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的 Python 程序员来说，这是必须要做到的!</p>
<p>还记得装饰器 (decorator) 可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python 内置的 <code>@property</code> 装饰器就是负责把一个方法变成属性调用的:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>@property</span>
    <span>def</span> <span>score</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_score

    <span>@score<span>.</span>setter</span>
    <span>def</span> <span>score</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        <span>if</span> <span>not</span> <span>isinstance</span><span>(</span>value<span>,</span> <span>int</span><span>)</span><span>:</span>
            <span>raise</span> ValueError<span>(</span><span>'score must be an integer!'</span><span>)</span>
        <span>if</span> value <span>&lt;</span> <span>0</span> <span>or</span> value <span>></span> <span>100</span><span>:</span>
            <span>raise</span> ValueError<span>(</span><span>'score must between 0 ~ 100!'</span><span>)</span>
        self<span>.</span>_score <span>=</span> value
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>@property</code> 的实现比较复杂，我们先考察如何使用。把一个 <code>getter</code> 方法变成属性，只需要加上 <code>@property</code> 就可以了，此时，<code>@property</code> 本身又创建了另一个装饰器 <code>@score.setter</code>，负责把一个 <code>setter</code> 方法变成属性赋值，于是，我们就拥有一个可控的属性操作:</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> Student<span>(</span><span>)</span>
<span>>></span><span>></span> s<span>.</span>score <span>=</span> <span>60</span> <span># OK，实际转化为s.set_score(60)</span>
<span>>></span><span>></span> s<span>.</span>score <span># OK，实际转化为s.get_score()</span>
<span>60</span>
<span>>></span><span>></span> s<span>.</span>score <span>=</span> <span>9999</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  <span>.</span><span>.</span><span>.</span>
ValueError<span>:</span> score must between <span>0</span> <span>~</span> <span>100</span>!
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意到这个神奇的 <code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过 <code>getter</code> 和 <code>setter</code> 方法来实现的。</p>
<p>还可以定义只读属性，只定义 <code>getter</code> 方法，不定义 <code>setter</code> 方法就是一个只读属性:</p>
<div><pre><code><span>class</span> <span>Student</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>@property</span>
    <span>def</span> <span>birth</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> self<span>.</span>_birth

    <span>@birth<span>.</span>setter</span>
    <span>def</span> <span>birth</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        self<span>.</span>_birth <span>=</span> value

    <span>@property</span>
    <span>def</span> <span>age</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>2015</span> <span>-</span> self<span>.</span>_birth
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的 <code>birth</code> 是可读写属性，而 <code>age</code> 就是一个只读属性，因为 <code>age</code> 可以根据 <code>birth</code> 和当前时间计算出来。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">面向对象编程</title>
    <id>https://list-jiang.github.io/code/language/python/oop/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">介绍</a></p>
</li>
<li>
<p><a href="./instance.html">类和实例</a></p>
</li>
<li>
<p><a href="./extend.html">继承和多态</a></p>
</li>
<li>
<p><a href="./property.html">属性</a></p>
</li>
<li>
<p><a href="./info.html">获取对象信息</a></p>
</li>
<li>
<p><a href="./customize.html">定制类</a></p>
</li>
<li>
<p><a href="./special.html">特殊的 class</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">特殊的 class</title>
    <id>https://list-jiang.github.io/code/language/python/oop/special/</id>
    <link href="https://list-jiang.github.io/code/language/python/oop/special/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="type"> <code>type()</code></h2>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p>比方说我们要定义一个 <code>Hello</code> 的 class，就写一个 <code>hello.py</code> 模块:</p>
<div><pre><code><span>class</span> <span>Hello</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>def</span> <span>hello</span><span>(</span>self<span>,</span> name<span>=</span><span>'world'</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span>'Hello, %s.'</span> <span>%</span> name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当 Python 解释器载入 <code>hello</code> 模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个 <code>Hello</code> 的 class 对象，测试如下:</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> hello <span>import</span> Hello
<span>>></span><span>></span> h <span>=</span> Hello<span>(</span><span>)</span>
<span>>></span><span>></span> h<span>.</span>hello<span>(</span><span>)</span>
Hello<span>,</span> world<span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>type</span><span>(</span>Hello<span>)</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'type'</span><span>></span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>type</span><span>(</span>h<span>)</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'hello.Hello'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>type()</code> 函数可以查看一个类型或变量的类型，<code>Hello</code> 是一个 class，它的类型就是 type，而 <code>h</code> 是一个实例，它的类型就是 <code>class Hello</code>。</p>
<p>我们说 class 的定义是运行时动态创建的，而创建 class 的方法就是使用 <code>type()</code> 函数。</p>
<p><code>type()</code> 函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过 <code>type()</code> 函数创建出 Hello 类，而无需通过 <code>class Hello(object)...</code> 的定义:</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>fn</span><span>(</span>self<span>,</span> name<span>=</span><span>'world'</span><span>)</span><span>:</span> <span># 先定义函数</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'Hello, %s.'</span> <span>%</span> name<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> Hello <span>=</span> <span>type</span><span>(</span><span>'Hello'</span><span>,</span> <span>(</span><span>object</span><span>,</span><span>)</span><span>,</span> <span>dict</span><span>(</span>hello<span>=</span>fn<span>)</span><span>)</span> <span># 创建Hello class</span>
<span>>></span><span>></span> h <span>=</span> Hello<span>(</span><span>)</span>
<span>>></span><span>></span> h<span>.</span>hello<span>(</span><span>)</span>
Hello<span>,</span> world<span>.</span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>type</span><span>(</span>Hello<span>)</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'type'</span><span>></span>
<span>>></span><span>></span> <span>print</span><span>(</span><span>type</span><span>(</span>h<span>)</span><span>)</span>
<span>&lt;</span><span>class</span> <span>'__main__.Hello'</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>要创建一个 class 对象，<code>type()</code> 函数依次传入 3 个参数:</p>
<ol>
<li>class 的名称；</li>
<li>继承的父类集合，注意 Python 支持多重继承，如果只有一个父类，别忘了 <code>tuple</code> 的单元素写法；</li>
<li>class 的方法名称与函数绑定，这里我们把函数 <code>fn</code> 绑定到方法名 <code>hello</code> 上。</li>
</ol>
<p>通过 <code>type()</code> 函数创建的类和直接写 class 是完全一样的，因为 Python 解释器遇到 class 定义时，仅仅是扫描一下 class 定义的语法，然后调用 <code>type()</code> 函数创建出 class。</p>
<p>正常情况下，我们都用 <code>class Xxx...</code> 来定义类，但是，<code>type()</code> 函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<h2 id="enum"> Enum</h2>
<p><code>Enum</code> 可以把一组相关常量定义在一个 class 中，且 class 不可变，而且成员可以直接比较。</p>
<p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份:</p>
<div><pre><code>JAN = 1
FEB = 2
MAR = 3
...
NOV = 11
DEC = 12
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>好处是简单，缺点是类型是 <code>int</code>，并且仍然是变量。</p>
<p>更好的方法是为这样的枚举类型定义一个 class 类型，然后，每个常量都是 class 的一个唯一实例。Python 提供了 <code>Enum</code> 类来实现这个功能:</p>
<div><pre><code><span>from</span> enum <span>import</span> Enum

Month <span>=</span> Enum<span>(</span><span>'Month'</span><span>,</span> <span>(</span><span>'Jan'</span><span>,</span> <span>'Feb'</span><span>,</span> <span>'Mar'</span><span>,</span> <span>'Apr'</span><span>,</span> <span>'May'</span><span>,</span> <span>'Jun'</span><span>,</span> <span>'Jul'</span><span>,</span> <span>'Aug'</span><span>,</span> <span>'Sep'</span><span>,</span> <span>'Oct'</span><span>,</span> <span>'Nov'</span><span>,</span> <span>'Dec'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这样我们就获得了 <code>Month</code> 类型的枚举类，可以直接使用 <code>Month.Jan</code> 来引用一个常量，或者枚举它的所有成员:</p>
<div><pre><code><span>for</span> name<span>,</span> member <span>in</span> Month<span>.</span>__members__<span>.</span>items<span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>name<span>,</span> <span>'=>'</span><span>,</span> member<span>,</span> <span>','</span><span>,</span> member<span>.</span>value<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>value</code> 属性则是自动赋给成员的 <code>int</code> 常量，默认从 <code>1</code> 开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从 <code>Enum</code> 派生出自定义类:</p>
<div><pre><code><span>from</span> enum <span>import</span> Enum<span>,</span> unique

<span>@unique</span>
<span>class</span> <span>Weekday</span><span>(</span>Enum<span>)</span><span>:</span>
    Sun <span>=</span> <span>0</span> <span># Sun的value被设定为0</span>
    Mon <span>=</span> <span>1</span>
    Tue <span>=</span> <span>2</span>
    Wed <span>=</span> <span>3</span>
    Thu <span>=</span> <span>4</span>
    Fri <span>=</span> <span>5</span>
    Sat <span>=</span> <span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>@unique</code> 装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法:</p>
<div><pre><code><span>>></span><span>></span> day1 <span>=</span> Weekday<span>.</span>Mon
<span>>></span><span>></span> <span>print</span><span>(</span>day1<span>)</span>
Weekday<span>.</span>Mon
<span>>></span><span>></span> <span>print</span><span>(</span>Weekday<span>.</span>Tue<span>)</span>
Weekday<span>.</span>Tue
<span>>></span><span>></span> <span>print</span><span>(</span>Weekday<span>[</span><span>'Tue'</span><span>]</span><span>)</span>
Weekday<span>.</span>Tue
<span>>></span><span>></span> <span>print</span><span>(</span>Weekday<span>.</span>Tue<span>.</span>value<span>)</span>
<span>2</span>
<span>>></span><span>></span> <span>print</span><span>(</span>day1 <span>==</span> Weekday<span>.</span>Mon<span>)</span>
<span>True</span>
<span>>></span><span>></span> <span>print</span><span>(</span>day1 <span>==</span> Weekday<span>.</span>Tue<span>)</span>
<span>False</span>
<span>>></span><span>></span> <span>print</span><span>(</span>Weekday<span>(</span><span>1</span><span>)</span><span>)</span>
Weekday<span>.</span>Mon
<span>>></span><span>></span> <span>print</span><span>(</span>day1 <span>==</span> Weekday<span>(</span><span>1</span><span>)</span><span>)</span>
<span>True</span>
<span>>></span><span>></span> Weekday<span>(</span><span>7</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  <span>.</span><span>.</span><span>.</span>
ValueError<span>:</span> <span>7</span> <span>is</span> <span>not</span> a valid Weekday
<span>>></span><span>></span> <span>for</span> name<span>,</span> member <span>in</span> Weekday<span>.</span>__members__<span>.</span>items<span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span>name<span>,</span> <span>'=>'</span><span>,</span> member<span>)</span>
<span>.</span><span>.</span><span>.</span>
Sun <span>=</span><span>></span> Weekday<span>.</span>Sun
Mon <span>=</span><span>></span> Weekday<span>.</span>Mon
Tue <span>=</span><span>></span> Weekday<span>.</span>Tue
Wed <span>=</span><span>></span> Weekday<span>.</span>Wed
Thu <span>=</span><span>></span> Weekday<span>.</span>Thu
Fri <span>=</span><span>></span> Weekday<span>.</span>Fri
Sat <span>=</span><span>></span> Weekday<span>.</span>Sat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>可见，既可以用成员名称引用枚举常量，又可以直接根据 <code>value</code> 的值获得枚举常量。</p>
<h2 id="metaclass"> metaclass</h2>
<p>除了使用 <code>type()</code> 动态创建类以外，要控制类的创建行为，还可以使用 metaclass。</p>
<p>metaclass 是 Python 中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。</p>
<p>metaclass，直译为元类，简单的解释就是: 当我们定义了类以后，就可以根据这个类创建出实例，所以先定义类，然后创建实例。</p>
<p>但是如果我们想创建出类呢？那就必须根据 metaclass 创建出类，所以: 先定义 metaclass，然后创建类。</p>
<p>连接起来就是: 先定义 metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass 允许您创建类或者修改类。换句话说，您可以把类看成是 metaclass 创建出来的“实例”。</p>
<div><p>提示</p>
<p>metaclass 是 Python 面向对象里最难理解，也是最难使用的魔术代码。正常情况下，您不会碰到需要使用 metaclass 的情况，所以，以下内容看不懂也没关系，因为基本上您不会用到。</p>
</div>
<p>我们先看一个简单的例子，这个 metaclass 可以给我们自定义的 <code>MyList</code> 增加一个 <code>add</code> 方法:</p>
<p>定义 <code>ListMetaclass</code>，按照默认习惯，metaclass 的类名总是以 <code>Metaclass</code> 结尾，以便清楚地表示这是一个 metaclass:</p>
<div><pre><code><span># metaclass是类的模板，所以必须从`type`类型派生:</span>
<span>class</span> <span>ListMetaclass</span><span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span><span>:</span>
        attrs<span>[</span><span>'add'</span><span>]</span> <span>=</span> <span>lambda</span> self<span>,</span> value<span>:</span> self<span>.</span>append<span>(</span>value<span>)</span>
        <span>return</span> <span>type</span><span>.</span>__new__<span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>有了 <code>ListMetaclass</code>，我们在定义类的时候还要指示使用 <code>ListMetaclass</code> 来定制类，传入关键字参数 metaclass:</p>
<div><pre><code><span>class</span> <span>MyList</span><span>(</span><span>list</span><span>,</span> metaclass<span>=</span>ListMetaclass<span>)</span><span>:</span>
    <span>pass</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当我们传入关键字参数 metaclass 时，魔术就生效了，它指示 Python 解释器在创建 MyList 时，要通过 <code>ListMetaclass.__new__()</code> 来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code> 方法接收到的参数依次是:</p>
<ol>
<li>当前准备创建的类的对象</li>
<li>类的名字</li>
<li>类继承的父类集合</li>
<li>类的方法集合</li>
</ol>
<p>测试一下 <code>MyList</code> 是否可以调用 <code>add()</code> 方法:</p>
<div><pre><code><span>>></span><span>></span> L <span>=</span> MyList<span>(</span><span>)</span>
<span>>></span><span>></span> L<span>.</span>add<span>(</span><span>1</span><span>)</span>
<span>>></span> L
<span>[</span><span>1</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>而普通的 list 没有 <code>add()</code> 方法:</p>
<div><pre><code><span>>></span><span>></span> L2 <span>=</span> <span>list</span><span>(</span><span>)</span>
<span>>></span><span>></span> L2<span>.</span>add<span>(</span><span>1</span><span>)</span>
Traceback <span>(</span>most recent call last<span>)</span><span>:</span>
  File <span>"&lt;stdin>"</span><span>,</span> line <span>1</span><span>,</span> <span>in</span> <span>&lt;</span>module<span>></span>
AttributeError<span>:</span> <span>'list'</span> <span>object</span> has no attribute <span>'add'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>动态修改有什么意义？直接在 <code>MyList</code> 定义中写上 <code>add()</code> 方法不是更简单吗？正常情况下，确实应该直接写，通过 metaclass 修改纯属变态。</p>
<p>但是，总会遇到需要通过 metaclass 修改类定义的。ORM 就是一个典型的例子。</p>
<p>ORM 全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作 SQL 语句。</p>
<p>要编写一个 ORM 框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>
<p>让我们来尝试编写一个 ORM 框架。</p>
<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个 ORM 框架，想定义一个 <code>User</code> 类来操作对应的数据库表 <code>User</code>，我们期待他写出这样的代码:</p>
<div><pre><code><span>class</span> <span>User</span><span>(</span>Model<span>)</span><span>:</span>
    <span># 定义类的属性到列的映射:</span>
    <span>id</span> <span>=</span> IntegerField<span>(</span><span>'id'</span><span>)</span>
    name <span>=</span> StringField<span>(</span><span>'username'</span><span>)</span>
    email <span>=</span> StringField<span>(</span><span>'email'</span><span>)</span>
    password <span>=</span> StringField<span>(</span><span>'password'</span><span>)</span>

<span># 创建一个实例:</span>
u <span>=</span> User<span>(</span><span>id</span><span>=</span><span>12345</span><span>,</span> name<span>=</span><span>'Michael'</span><span>,</span> email<span>=</span><span>'test@orm.org'</span><span>,</span> password<span>=</span><span>'my-pwd'</span><span>)</span>
<span># 保存到数据库:</span>
u<span>.</span>save<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>其中，父类 <code>Model</code> 和属性类型 <code>StringField</code>、<code>IntegerField</code> 是由 ORM 框架提供的，剩下的魔术方法比如 <code>save()</code> 全部由 metaclass 自动完成。虽然 metaclass 的编写会比较复杂，但 ORM 的使用者用起来却异常简单。</p>
<p>现在，我们就按上面的接口来实现该 ORM。</p>
<p>首先来定义 <code>Field</code> 类，它负责保存数据库表的字段名和字段类型:</p>
<div><pre><code><span>class</span> <span>Field</span><span>(</span><span>object</span><span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>,</span> column_type<span>)</span><span>:</span>
        self<span>.</span>name <span>=</span> name
        self<span>.</span>column_type <span>=</span> column_type

    <span>def</span> <span>__str__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>'&lt;%s:%s>'</span> <span>%</span> <span>(</span>self<span>.</span>__class__<span>.</span>__name__<span>,</span> self<span>.</span>name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在 <code>Field</code> 的基础上，进一步定义各种类型的 <code>Field</code>，比如 <code>StringField</code>，<code>IntegerField</code> 等等:</p>
<div><pre><code><span>class</span> <span>StringField</span><span>(</span>Field<span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        <span>super</span><span>(</span>StringField<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span>name<span>,</span> <span>'varchar(100)'</span><span>)</span>

<span>class</span> <span>IntegerField</span><span>(</span>Field<span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> name<span>)</span><span>:</span>
        <span>super</span><span>(</span>IntegerField<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span>name<span>,</span> <span>'bigint'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>下一步，就是编写最复杂的 <code>ModelMetaclass</code> 了:</p>
<div><pre><code><span>class</span> <span>ModelMetaclass</span><span>(</span><span>type</span><span>)</span><span>:</span>

    <span>def</span> <span>__new__</span><span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span><span>:</span>
        <span>if</span> name<span>==</span><span>'Model'</span><span>:</span>
            <span>return</span> <span>type</span><span>.</span>__new__<span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span>
        <span>print</span><span>(</span><span>'Found model: %s'</span> <span>%</span> name<span>)</span>
        mappings <span>=</span> <span>dict</span><span>(</span><span>)</span>
        <span>for</span> k<span>,</span> v <span>in</span> attrs<span>.</span>items<span>(</span><span>)</span><span>:</span>
            <span>if</span> <span>isinstance</span><span>(</span>v<span>,</span> Field<span>)</span><span>:</span>
                <span>print</span><span>(</span><span>'Found mapping: %s ==> %s'</span> <span>%</span> <span>(</span>k<span>,</span> v<span>)</span><span>)</span>
                mappings<span>[</span>k<span>]</span> <span>=</span> v
        <span>for</span> k <span>in</span> mappings<span>.</span>keys<span>(</span><span>)</span><span>:</span>
            attrs<span>.</span>pop<span>(</span>k<span>)</span>
        attrs<span>[</span><span>'__mappings__'</span><span>]</span> <span>=</span> mappings <span># 保存属性和列的映射关系</span>
        attrs<span>[</span><span>'__table__'</span><span>]</span> <span>=</span> name <span># 假设表名和类名一致</span>
        <span>return</span> <span>type</span><span>.</span>__new__<span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>以及基类 <code>Model</code>:</p>
<div><pre><code><span>class</span> <span>Model</span><span>(</span><span>dict</span><span>,</span> metaclass<span>=</span>ModelMetaclass<span>)</span><span>:</span>

    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> <span>**</span>kw<span>)</span><span>:</span>
        <span>super</span><span>(</span>Model<span>,</span> self<span>)</span><span>.</span>__init__<span>(</span><span>**</span>kw<span>)</span>

    <span>def</span> <span>__getattr__</span><span>(</span>self<span>,</span> key<span>)</span><span>:</span>
        <span>try</span><span>:</span>
            <span>return</span> self<span>[</span>key<span>]</span>
        <span>except</span> KeyError<span>:</span>
            <span>raise</span> AttributeError<span>(</span><span>r"'Model' object has no attribute '%s'"</span> <span>%</span> key<span>)</span>

    <span>def</span> <span>__setattr__</span><span>(</span>self<span>,</span> key<span>,</span> value<span>)</span><span>:</span>
        self<span>[</span>key<span>]</span> <span>=</span> value

    <span>def</span> <span>save</span><span>(</span>self<span>)</span><span>:</span>
        fields <span>=</span> <span>[</span><span>]</span>
        params <span>=</span> <span>[</span><span>]</span>
        args <span>=</span> <span>[</span><span>]</span>
        <span>for</span> k<span>,</span> v <span>in</span> self<span>.</span>__mappings__<span>.</span>items<span>(</span><span>)</span><span>:</span>
            fields<span>.</span>append<span>(</span>v<span>.</span>name<span>)</span>
            params<span>.</span>append<span>(</span><span>'?'</span><span>)</span>
            args<span>.</span>append<span>(</span><span>getattr</span><span>(</span>self<span>,</span> k<span>,</span> <span>None</span><span>)</span><span>)</span>
        sql <span>=</span> <span>'insert into %s (%s) values (%s)'</span> <span>%</span> <span>(</span>self<span>.</span>__table__<span>,</span> <span>','</span><span>.</span>join<span>(</span>fields<span>)</span><span>,</span> <span>','</span><span>.</span>join<span>(</span>params<span>)</span><span>)</span>
        <span>print</span><span>(</span><span>'SQL: %s'</span> <span>%</span> sql<span>)</span>
        <span>print</span><span>(</span><span>'ARGS: %s'</span> <span>%</span> <span>str</span><span>(</span>args<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>当用户定义一个 <code>class User(Model)</code> 时，Python 解释器首先在当前类 <code>User</code> 的定义中查找 metaclass，如果没有找到，就继续在父类 <code>Model</code> 中查找 metaclass，找到了，就使用 <code>Model</code> 中定义的 metaclass 的 <code>ModelMetaclass</code> 来创建 <code>User</code> 类，也就是说，metaclass 可以隐式地继承到子类，但子类自己却感觉不到。</p>
<p>在 <code>ModelMetaclass</code> 中，一共做了几件事情:</p>
<ol>
<li>排除掉对 <code>Model</code> 类的修改；</li>
<li>在当前类 (比如 User) 中查找定义的类的所有属性，如果找到一个 <code>Field</code> 属性，就把它保存到一个 <code>__mappings__</code> 的 dict 中，同时从类属性中删除该 <code>Field</code> 属性，否则，容易造成运行时错误 (实例的属性会遮盖类的同名属性) ；</li>
<li>把表名保存到 <code>__table__</code> 中，这里简化为表名默认为类名。</li>
</ol>
<p>在 <code>Model</code> 类中，就可以定义各种操作数据库的方法，比如 <code>save()</code>，<code>delete()</code>，<code>find()</code>，<code>update()</code> 等等。</p>
<p>我们实现了 <code>save()</code> 方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出 <code>INSERT</code> 语句。</p>
<p>编写代码试试:</p>
<div><pre><code>u <span>=</span> User<span>(</span><span>id</span><span>=</span><span>12345</span><span>,</span> name<span>=</span><span>'Michael'</span><span>,</span> email<span>=</span><span>'test@orm.org'</span><span>,</span> password<span>=</span><span>'my-pwd'</span><span>)</span>
u<span>.</span>save<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出如下:</p>
<div><pre><code>Found model<span>:</span> User
Found mapping<span>:</span> email <span>==</span><span>></span> <span>&lt;</span>StringField<span>:</span>email<span>></span>
Found mapping<span>:</span> password <span>==</span><span>></span> <span>&lt;</span>StringField<span>:</span>password<span>></span>
Found mapping<span>:</span> <span>id</span> <span>==</span><span>></span> <span>&lt;</span>IntegerField<span>:</span>uid<span>></span>
Found mapping<span>:</span> name <span>==</span><span>></span> <span>&lt;</span>StringField<span>:</span>username<span>></span>
SQL<span>:</span> insert into User <span>(</span>password<span>,</span>email<span>,</span>username<span>,</span><span>id</span><span>)</span> values <span>(</span>?<span>,</span>?<span>,</span>?<span>,</span>?<span>)</span>
ARGS<span>:</span> <span>[</span><span>'my-pwd'</span><span>,</span> <span>'test@orm.org'</span><span>,</span> <span>'Michael'</span><span>,</span> <span>12345</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，<code>save()</code> 方法已经打印出了可执行的 SQL 语句，以及参数列表，只需要真正连接到数据库，执行该 SQL 语句，就可以完成真正的功能。</p>
<p>不到 100 行代码，我们就通过 metaclass 实现了一个精简的 ORM 框架，是不是非常简单？</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-03-28T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">Python 语言教程</title>
    <id>https://list-jiang.github.io/code/language/python/</id>
    <link href="https://list-jiang.github.io/code/language/python/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<ul>
<li>优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。</li>
<li>缺点: Python 是一种脚本语言，它的执行效率不是很高。</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<ul>
<li>优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。</li>
<li>缺点: Python 是一种脚本语言，它的执行效率不是很高。</li>
</ul>

<div><p>注意</p>
<p>本教程基于 Python3, Python2 已经过时停止维护多年，请不要使用学习。</p>
</div>
<h2 id="python-简介"> Python 简介</h2>
<ul>
<li>
<p><a href="./intro/intro.html">Python 介绍</a></p>
</li>
<li>
<p><a href="./intro/install.html">Python 安装</a></p>
</li>
<li>
<p><a href="./intro/interpreter.html">Python 解释器</a></p>
</li>
</ul>
<h2 id="python-快速入门"> Python 快速入门</h2>
<ul>
<li>
<p><a href="./guide/write.html">第一个 Python 程序</a></p>
</li>
<li>
<p><a href="./guide/io.html">输入与输出</a></p>
</li>
<li>
<p><a href="./guide/basic.html">基础语法</a></p>
</li>
<li>
<p><a href="./guide/string.html">字符串</a></p>
</li>
<li>
<p><a href="./guide/list-and-tuple.html">List 和 Tuple</a></p>
</li>
<li>
<p><a href="./guide/condition.html">条件判断</a></p>
</li>
<li>
<p><a href="./guide/loop.html">循环</a></p>
</li>
<li>
<p><a href="./dict-and-set.html">Dictionary 和 Set</a></p>
</li>
</ul>
<h2 id="python-函数"> Python 函数</h2>
<ul>
<li>
<p><a href="./function/intro.html">函数介绍</a></p>
</li>
<li>
<p><a href="./function/define.html">函数定义</a></p>
</li>
<li>
<p><a href="./function/call.html">函数调用</a></p>
</li>
<li>
<p><a href="./function/argument.html">函数参数</a></p>
</li>
<li>
<p><a href="./function/recursive.html">递归调用</a></p>
</li>
</ul>
<h2 id="python-高级语法"> Python 高级语法</h2>
<ul>
<li>
<p><a href="./advance/slice.html">切片</a></p>
</li>
<li>
<p><a href="./advance/iteration.html">迭代</a></p>
</li>
<li>
<p><a href="./advance/list-comprehensions.html">列表生成式</a></p>
</li>
<li>
<p><a href="./advance/generator.html">生成器</a></p>
</li>
<li>
<p><a href="./advance/iterator.html">迭代器</a></p>
</li>
</ul>
<h2 id="函数式编程"> 函数式编程</h2>
<ul>
<li>
<p><a href="./functional-programming/high-order-function/intro.html">高阶函数介绍</a></p>
</li>
<li>
<p><a href="./functional-programming/high-order-function/map-and-reduce.html">map / reduce</a></p>
</li>
<li>
<p><a href="./functional-programming/high-order-function/filter.html">filter</a></p>
</li>
<li>
<p><a href="./functional-programming/high-order-function/sorted.html">sorted</a></p>
</li>
<li>
<p><a href="./functional-programming/return-function.html">返回函数</a></p>
</li>
<li>
<p><a href="./functional-programming/anonymous-function.html">匿名函数</a></p>
</li>
<li>
<p><a href="./functional-programming/decorator.html">装饰器</a></p>
</li>
<li>
<p><a href="./functional-programming/parital-function.html">偏函数</a></p>
</li>
</ul>
<h2 id="相关工具"> 相关工具</h2>
<ul>
<li><a href="https://c.runoob.com/compile/9" target="_blank" rel="noopener noreferrer">Python 在线运行器</a></li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Python"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2020-05-18T00:00:00.000Z</published>
    <rights>Copyright by 廖雪峰</rights>
  </entry>
  <entry>
    <title type="html">代码学习教程</title>
    <id>https://list-jiang.github.io/code/language/</id>
    <link href="https://list-jiang.github.io/code/language/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="./learning.html">如何学习一门语言</a></li>
</ul>
<h2 id="教程目录"> 教程目录</h2>
<ul>
<li>
<p><a href="./js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="./typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="./python/">Python 教程</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">Java 教程</a>(廖雪峰的博客)</p>
</li>
<li>
<p><a href="./markdown/">Markdown 教程</a></p>
</li>
</ul>
<h2 id="linter"> Linter</h2>
<ul>
<li><a href="./linter/">Linter 介绍</a></li>
</ul>
<div><p>提示</p>
<p>更多正在编写中...</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="教程"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">类与接口</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/class-and-interfaces/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/class-and-interfaces/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p><a href="/code/language/typescript/basics/type-of-object-interfaces.html">之前学习过</a>，接口(Interfaces)可以用于对「对象的形状(Shape)」进行描述。</p>
<p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p>
]]></summary>
    <content type="html"><![CDATA[<p><a href="./../basics/type-of-object-interfaces.html">之前学习过</a>，接口(Interfaces)可以用于对「对象的形状(Shape)」进行描述。</p>
<p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p>

<h2 id="类实现接口"> 类实现接口</h2>
<p>实现(implements)是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口(interfaces)，用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  <span>alert</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Door</span> <span>{</span><span>}</span>

<span>class</span> <span>SecurityDoor</span> <span>extends</span> <span>Door</span> <span>implements</span> <span>Alarm</span> <span>{</span>
  <span>alert</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"SecurityDoor alert"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Car</span> <span>implements</span> <span>Alarm</span> <span>{</span>
  <span>alert</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Car alert"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>一个类可以实现多个接口:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  <span>alert</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>interface</span> <span>Light</span> <span>{</span>
  <span>lightOn</span><span>(</span><span>)</span><span>;</span>
  <span>lightOff</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Car</span> <span>implements</span> <span>Alarm</span><span>,</span> Light <span>{</span>
  <span>alert</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Car alert"</span><span>)</span><span>;</span>
  <span>}</span>
  <span>lightOn</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Car light on"</span><span>)</span><span>;</span>
  <span>}</span>
  <span>lightOff</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Car light off"</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>
<h2 id="接口继承接口"> 接口继承接口</h2>
<p>接口与接口之间可以是继承关系:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  <span>alert</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>interface</span> <span>LightableAlarm</span> <span>extends</span> <span>Alarm</span> <span>{</span>
  <span>lightOn</span><span>(</span><span>)</span><span>;</span>
  <span>lightOff</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code>。</p>
<h2 id="接口继承类"> 接口继承类</h2>
<p>接口也可以继承类:</p>
<div><pre><code><span>class</span> <span>Point</span> <span>{</span>
  x<span>:</span> <span>number</span><span>;</span>
  y<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>interface</span> <span>Point3d</span> <span>extends</span> <span>Point</span> <span>{</span>
  z<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> point3d<span>:</span> Point3d <span>=</span> <span>{</span> x<span>:</span> <span>1</span><span>,</span> y<span>:</span> <span>2</span><span>,</span> z<span>:</span> <span>3</span> <span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="混合类型"> 混合类型</h2>
<p><a href="/doc/private/language/typescript/basics/type-of-function#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状:</p>
<div><pre><code><span>interface</span> <span>SearchFunc</span> <span>{</span>
  <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span><span>;</span>
<span>}</span>

<span>let</span> mySearch<span>:</span> SearchFunc<span>;</span>
<span>mySearch</span> <span>=</span> <span>function</span> <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> source<span>.</span><span>search</span><span>(</span>subString<span>)</span> <span>!==</span> <span>-</span><span>1</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>有时候，一个函数还可以有自己的属性和方法:</p>
<div><pre><code><span>interface</span> <span>Counter</span> <span>{</span>
  <span>(</span>start<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span><span>;</span>
  interval<span>:</span> <span>number</span><span>;</span>
  <span>reset</span><span>(</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>

<span>function</span> <span>getCounter</span><span>(</span><span>)</span><span>:</span> Counter <span>{</span>
  <span>let</span> counter <span>=</span> <span>&lt;</span>Counter<span>></span><span>function</span> <span>(</span>start<span>:</span> <span>number</span><span>)</span> <span>{</span><span>}</span><span>;</span>
  counter<span>.</span>interval <span>=</span> <span>123</span><span>;</span>
  counter<span>.</span><span>reset</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
  <span>return</span> counter<span>;</span>
<span>}</span>

<span>let</span> c <span>=</span> <span>getCounter</span><span>(</span><span>)</span><span>;</span>
<span>c</span><span>(</span><span>10</span><span>)</span><span>;</span>
c<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>
c<span>.</span>interval <span>=</span> <span>5.0</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener noreferrer">Interfaces</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">类</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/class/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/class/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p>
<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>
<p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p>
]]></summary>
    <content type="html"><![CDATA[<p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p>
<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>
<p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p>

<h2 id="类的概念"> 类的概念</h2>
<p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p>
<ul>
<li>类(Class): 定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象(Object): 类的实例，通过 <code>new</code> 生成</li>
<li>面向对象(OOP)的三大特性: 封装、继承、多态</li>
<li>封装(Encapsulation): 将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要(也不可能)知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承(Inheritance): 子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态(Polymorphism): 由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li>
<li>存取器(getter &amp; setter): 用以改变属性的读取和赋值行为</li>
<li>修饰符(Modifiers): 修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li>
<li>抽象类(Abstract Class): 抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口(Interfaces): 不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现(implements)。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h2 id="es6-中类的用法"> ES6 中类的用法</h2>
<p>下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 <a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门 - Class</a>。</p>
<h3 id="属性和方法"> 属性和方法</h3>
<p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p>
<p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>My name is </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// My name is Jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="类的继承"> 类的继承</h3>
<p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p>
<div><pre><code><span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>name<span>)</span><span>;</span> <span>// 调用父类的 constructor(name)</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
  <span>}</span>
  <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"Meow, "</span> <span>+</span> <span>super</span><span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span> <span>// 调用父类的 sayHi()</span>
  <span>}</span>
<span>}</span>

<span>let</span> c <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span> <span>// Tom</span>
console<span>.</span><span>log</span><span>(</span>c<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// Meow, My name is Tom</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="存取器"> 存取器</h3>
<p>使用 getter 和 setter 可以改变属性的赋值和读取行为:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>get</span> <span>name</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"Jack"</span><span>;</span>
  <span>}</span>
  <span>set</span> <span>name</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"setter: "</span> <span>+</span> value<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Kitty"</span><span>)</span><span>;</span> <span>// setter: Kitty</span>
a<span>.</span>name <span>=</span> <span>"Tom"</span><span>;</span> <span>// setter: Tom</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span> <span>// Jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="静态方法"> 静态方法</h3>
<p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>static</span> <span>isAnimal</span><span>(</span><span>a</span><span>)</span> <span>{</span>
    <span>return</span> a <span>instanceof</span> <span>Animal</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
Animal<span>.</span><span>isAnimal</span><span>(</span>a<span>)</span><span>;</span> <span>// true</span>
a<span>.</span><span>isAnimal</span><span>(</span>a<span>)</span><span>;</span> <span>// TypeError: a.isAnimal is not a function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="es2016-中类的用法"> ES2016 中类的用法</h2>
<p>ES2016 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。</p>
<h3 id="实例属性"> 实例属性</h3>
<p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES2016 提案中可以直接在类里面定义:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  name <span>=</span> <span>"Jack"</span><span>;</span>

  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span> <span>// Jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="静态属性"> 静态属性</h3>
<p>ES2016 提案中，可以使用 <code>static</code> 定义一个静态属性:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>static</span> num <span>=</span> <span>42</span><span>;</span>

  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span>Animal<span>.</span>num<span>)</span><span>;</span> <span>// 42</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="typescript-中类的用法"> TypeScript 中类的用法</h2>
<h3 id="public-private-和-protected"> public private 和 protected</h3>
<p>TypeScript 可以使用三种访问修饰符(Access Modifiers)，分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<p>下面举一些例子:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>public</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span> <span>// Jack</span>
a<span>.</span>name <span>=</span> <span>"Tom"</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span> <span>// Tom</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>private</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span> <span>// Jack</span>
a<span>.</span>name <span>=</span> <span>"Tom"</span><span>;</span>

<span>// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span>
<span>// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code>private</code> 属性在外部的可访问性。</p>
<p>上面的例子编译后的代码是:</p>
<div><pre><code><span>var</span> Animal <span>=</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>function</span> <span>Animal</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>return</span> Animal<span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
<span>var</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span>name<span>)</span><span>;</span>
a<span>.</span>name <span>=</span> <span>"Tom"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>private</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>super</span><span>(</span>name<span>)</span><span>;</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  <span>protected</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>super</span><span>(</span>name<span>)</span><span>;</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="抽象类"> 抽象类</h3>
<p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<p>什么是抽象类?</p>
<p>首先，抽象类是不允许被实例化的:</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>Animal</span> <span>{</span>
  <span>public</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>public</span> <span>abstract</span> <span>sayHi</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>

<span>// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
<p>其次，抽象类中的抽象方法必须被子类实现:</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>Animal</span> <span>{</span>
  <span>public</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>public</span> <span>abstract</span> <span>sayHi</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
  <span>public</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span> is eating.</span><span>`</span></span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> cat <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>

<span>// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
<p>下面是一个正确使用抽象类的例子:</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>Animal</span> <span>{</span>
  <span>public</span> name<span>;</span>
  <span>public</span> <span>constructor</span><span>(</span>name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>public</span> <span>abstract</span> <span>sayHi</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
  <span>public</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>Meow, My name is </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> cat <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是:</p>
<div><pre><code><span>var</span> __extends <span>=</span>
  <span>(</span><span>this</span> <span>&amp;&amp;</span> <span>this</span><span>.</span>__extends<span>)</span> <span>||</span>
  <span>function</span> <span>(</span><span>d<span>,</span> b</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>var</span> p <span>in</span> b<span>)</span> <span>if</span> <span>(</span>b<span>.</span><span>hasOwnProperty</span><span>(</span>p<span>)</span><span>)</span> d<span>[</span>p<span>]</span> <span>=</span> b<span>[</span>p<span>]</span><span>;</span>
    <span>function</span> <span>__</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>constructor <span>=</span> d<span>;</span>
    <span>}</span>
    d<span>.</span>prototype <span>=</span>
      b <span>===</span> <span>null</span> <span>?</span> Object<span>.</span><span>create</span><span>(</span>b<span>)</span> <span>:</span> <span>(</span><span>(</span><span>__</span><span>.</span>prototype <span>=</span> b<span>.</span>prototype<span>)</span><span>,</span> <span>new</span> <span>__</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>var</span> Animal <span>=</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>function</span> <span>Animal</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>return</span> Animal<span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
<span>var</span> Cat <span>=</span> <span>(</span><span>function</span> <span>(</span><span>_super</span><span>)</span> <span>{</span>
  <span>__extends</span><span>(</span>Cat<span>,</span> _super<span>)</span><span>;</span>
  <span>function</span> <span>Cat</span><span>(</span><span>)</span> <span>{</span>
    <span>_super</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span><span>;</span>
  <span>}</span>
  <span>Cat</span><span>.</span>prototype<span>.</span><span>sayHi</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Meow, My name is "</span> <span>+</span> <span>this</span><span>.</span>name<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  <span>return</span> Cat<span>;</span>
<span>}</span><span>)</span><span>(</span>Animal<span>)</span><span>;</span>
<span>var</span> cat <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="类的类型"> 类的类型</h2>
<p>给类加上 TypeScript 的类型很简单，与接口类似:</p>
<div><pre><code><span>class</span> <span>Animal</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
  <span>}</span>
  <span>sayHi</span><span>(</span><span>)</span><span>:</span> <span>string</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>My name is </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> a<span>:</span> Animal <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Jack"</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>a<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// My name is Jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="noopener noreferrer">Classes</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Classes.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门 - Class</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">声明合并</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/declaration-merging/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/declaration-merging/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型:</p>
]]></summary>
    <content type="html"><![CDATA[<p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型:</p>

<h2 id="函数的合并"> 函数的合并</h2>
<p><a href="/doc/private/language/typescript/basics/type-of-function#%E9%87%8D%E8%BD%BD">之前学习过</a>，我们可以使用重载定义多个函数类型:</p>
<div><pre><code><span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span><span>;</span>
<span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>string</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>number</span> <span>|</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>|</span> <span>string</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"number"</span><span>)</span> <span>{</span>
    <span>return</span> <span>Number</span><span>(</span>x<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"string"</span><span>)</span> <span>{</span>
    <span>return</span> x<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="接口的合并"> 接口的合并</h2>
<p>接口中的属性在合并时会简单的合并到一个接口中:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Alarm</span> <span>{</span>
  weight<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>相当于:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
  weight<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，<strong>合并的属性的类型必须是唯一的</strong>:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span> <span>// 虽然重复了，但是类型都是 `number`，所以不会报错</span>
  weight<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>string</span><span>;</span> <span>// 类型不一致，会报错</span>
  weight<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable 'price' must be of type 'number', but here has type 'string'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>接口中方法的合并，与函数的合并一样:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
  <span>alert</span><span>(</span>s<span>:</span> <span>string</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Alarm</span> <span>{</span>
  weight<span>:</span> <span>number</span><span>;</span>
  <span>alert</span><span>(</span>s<span>:</span> <span>string</span><span>,</span> n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>相当于:</p>
<div><pre><code><span>interface</span> <span>Alarm</span> <span>{</span>
  price<span>:</span> <span>number</span><span>;</span>
  weight<span>:</span> <span>number</span><span>;</span>
  <span>alert</span><span>(</span>s<span>:</span> <span>string</span><span>)</span><span>:</span> <span>string</span><span>;</span>
  <span>alert</span><span>(</span>s<span>:</span> <span>string</span><span>,</span> n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="类的合并"> 类的合并</h2>
<p>类的合并与接口的合并规则一致。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/declaration-merging.html" target="_blank" rel="noopener noreferrer">Declaration Merging</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Declaration%20Merging.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">枚举</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/enum/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/enum/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>枚举(Enum)类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
]]></summary>
    <content type="html"><![CDATA[<p>枚举(Enum)类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<p>枚举使用 <code>enum</code> 关键字来定义:</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun<span>,</span>
  Mon<span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat<span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射:</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun<span>,</span>
  Mon<span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat<span>,</span>
<span>}</span>

<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>===</span> <span>0</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>===</span> <span>1</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>===</span> <span>2</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>===</span> <span>6</span><span>)</span><span>;</span> <span>// true</span>

<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>0</span><span>]</span> <span>===</span> <span>"Sun"</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>1</span><span>]</span> <span>===</span> <span>"Mon"</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>2</span><span>]</span> <span>===</span> <span>"Tue"</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>6</span><span>]</span> <span>===</span> <span>"Sat"</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>事实上，上面的例子会被编译为:</p>
<div><pre><code><span>var</span> Days<span>;</span>
<span>(</span><span>function</span> <span>(</span><span>Days</span><span>)</span> <span>{</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>=</span> <span>0</span><span>)</span><span>]</span> <span>=</span> <span>"Sun"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>=</span> <span>1</span><span>)</span><span>]</span> <span>=</span> <span>"Mon"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>=</span> <span>2</span><span>)</span><span>]</span> <span>=</span> <span>"Tue"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Wed"</span><span>]</span> <span>=</span> <span>3</span><span>)</span><span>]</span> <span>=</span> <span>"Wed"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Thu"</span><span>]</span> <span>=</span> <span>4</span><span>)</span><span>]</span> <span>=</span> <span>"Thu"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Fri"</span><span>]</span> <span>=</span> <span>5</span><span>)</span><span>]</span> <span>=</span> <span>"Fri"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>=</span> <span>6</span><span>)</span><span>]</span> <span>=</span> <span>"Sat"</span><span>;</span>
<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="手动赋值"> 手动赋值</h2>
<p>我们也可以给枚举项手动赋值:</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun <span>=</span> <span>7</span><span>,</span>
  Mon <span>=</span> <span>1</span><span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat<span>,</span>
<span>}</span>

<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>===</span> <span>7</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>===</span> <span>1</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>===</span> <span>2</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>===</span> <span>6</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。</p>
<p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的:</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun <span>=</span> <span>3</span><span>,</span>
  Mon <span>=</span> <span>1</span><span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat<span>,</span>
<span>}</span>

<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>===</span> <span>3</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Wed"</span><span>]</span> <span>===</span> <span>3</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>3</span><span>]</span> <span>===</span> <span>"Sun"</span><span>)</span><span>;</span> <span>// false</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>3</span><span>]</span> <span>===</span> <span>"Wed"</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 TypeScript 并没有报错，导致 <code>Days[3]</code> 的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是:</p>
<div><pre><code><span>var</span> Days<span>;</span>
<span>(</span><span>function</span> <span>(</span><span>Days</span><span>)</span> <span>{</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>=</span> <span>3</span><span>)</span><span>]</span> <span>=</span> <span>"Sun"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>=</span> <span>1</span><span>)</span><span>]</span> <span>=</span> <span>"Mon"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>=</span> <span>2</span><span>)</span><span>]</span> <span>=</span> <span>"Tue"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Wed"</span><span>]</span> <span>=</span> <span>3</span><span>)</span><span>]</span> <span>=</span> <span>"Wed"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Thu"</span><span>]</span> <span>=</span> <span>4</span><span>)</span><span>]</span> <span>=</span> <span>"Thu"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Fri"</span><span>]</span> <span>=</span> <span>5</span><span>)</span><span>]</span> <span>=</span> <span>"Fri"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>=</span> <span>6</span><span>)</span><span>]</span> <span>=</span> <span>"Sat"</span><span>;</span>
<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p>
<p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的):</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun <span>=</span> <span>7</span><span>,</span>
  Mon<span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat <span>=</span> <span>&lt;</span><span>any</span><span>></span><span>"S"</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>var</span> Days<span>;</span>
<span>(</span><span>function</span> <span>(</span><span>Days</span><span>)</span> <span>{</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>=</span> <span>7</span><span>)</span><span>]</span> <span>=</span> <span>"Sun"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>=</span> <span>8</span><span>)</span><span>]</span> <span>=</span> <span>"Mon"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>=</span> <span>9</span><span>)</span><span>]</span> <span>=</span> <span>"Tue"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Wed"</span><span>]</span> <span>=</span> <span>10</span><span>)</span><span>]</span> <span>=</span> <span>"Wed"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Thu"</span><span>]</span> <span>=</span> <span>11</span><span>)</span><span>]</span> <span>=</span> <span>"Thu"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Fri"</span><span>]</span> <span>=</span> <span>12</span><span>)</span><span>]</span> <span>=</span> <span>"Fri"</span><span>;</span>
  Days<span>[</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>=</span> <span>"S"</span><span>)</span><span>]</span> <span>=</span> <span>"Sat"</span><span>;</span>
<span>}</span><span>)</span><span>(</span>Days <span>||</span> <span>(</span>Days <span>=</span> <span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>:</p>
<div><pre><code><span>enum</span> Days <span>{</span>
  Sun <span>=</span> <span>7</span><span>,</span>
  Mon <span>=</span> <span>1.5</span><span>,</span>
  Tue<span>,</span>
  Wed<span>,</span>
  Thu<span>,</span>
  Fri<span>,</span>
  Sat<span>,</span>
<span>}</span>

<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sun"</span><span>]</span> <span>===</span> <span>7</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Mon"</span><span>]</span> <span>===</span> <span>1.5</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Tue"</span><span>]</span> <span>===</span> <span>2.5</span><span>)</span><span>;</span> <span>// true</span>
<span>console</span><span>.</span><span>log</span><span>(</span>Days<span>[</span><span>"Sat"</span><span>]</span> <span>===</span> <span>6.5</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="常数项和计算所得项"> 常数项和计算所得项</h2>
<p>枚举项有两种类型: 常数项(constant member)和计算所得项(computed member)。</p>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子:</p>
<div><pre><code><span>enum</span> Color <span>{</span>
  Red<span>,</span>
  Green<span>,</span>
  Blue <span>=</span> <span>"blue"</span><span>.</span>length<span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
<p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>:</p>
<div><pre><code><span>enum</span> Color <span>{</span>
  Red <span>=</span> <span>"red"</span><span>.</span>length<span>,</span>
  Green<span>,</span>
  Blue<span>,</span>
<span>}</span>

<span>// index.ts(1,33): error TS1061: Enum member must have initializer.</span>
<span>// index.ts(1,40): error TS1061: Enum member must have initializer.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>下面是常数项和计算所得项的完整定义，部分引用自<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html" target="_blank" rel="noopener noreferrer">中文手册 - 枚举</a>:</p>
<p>当满足以下条件时，枚举成员被当作是常数:</p>
<ul>
<li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 <code>1</code>。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li>
<li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式:
<ul>
<li>数字字面量</li>
<li>引用之前定义的常数枚举成员(可以是在不同的枚举类型中定义的)如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li>
<li>带括号的常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错</li>
</ul>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<h2 id="常数枚举"> 常数枚举</h2>
<p>常数枚举是使用 <code>const enum</code> 定义的枚举类型:</p>
<div><pre><code><span>const</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>

<span>let</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<p>上例的编译结果是:</p>
<div><pre><code><span>var</span> directions <span>=</span> <span>[</span><span>0</span> <span>/* Up */</span><span>,</span> <span>1</span> <span>/* Down */</span><span>,</span> <span>2</span> <span>/* Left */</span><span>,</span> <span>3</span> <span>/* Right */</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>假如包含了计算成员，则会在编译阶段报错:</p>
<div><pre><code><span>const</span> <span>enum</span> Color <span>{</span>
  Red<span>,</span>
  Green<span>,</span>
  Blue <span>=</span> <span>"blue"</span><span>.</span>length<span>,</span>
<span>}</span>

<span>// index.ts(1,38): error TS2474: In 'const' enum declarations member initializer must be constant expression.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="外部枚举"> 外部枚举</h2>
<p>外部枚举(Ambient Enums)是使用 <code>declare enum</code> 定义的枚举类型:</p>
<div><pre><code><span>declare</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>

<span>let</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>
<p>上例的编译结果是:</p>
<div><pre><code><span>var</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>外部枚举与声明语句一样，常出现在声明文件中。</p>
<p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的:</p>
<div><pre><code><span>declare</span> <span>const</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>

<span>let</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>编译结果:</p>
<div><pre><code><span>var</span> directions <span>=</span> <span>[</span><span>0</span> <span>/* Up */</span><span>,</span> <span>1</span> <span>/* Down */</span><span>,</span> <span>2</span> <span>/* Left */</span><span>,</span> <span>3</span> <span>/* Right */</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>TypeScript 的枚举类型的概念<a href="https://msdn.microsoft.com/zh-cn/library/sbbt4032.aspx" target="_blank" rel="noopener noreferrer">来源于 C#</a>。</p>
</blockquote>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">Enums</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/sbbt4032.aspx" target="_blank" rel="noopener noreferrer">C# Enum</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">扩展阅读</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/further-reading/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/further-reading/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>此处记录了<a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">官方手册</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/" target="_blank" rel="noopener noreferrer">中文版</a>)中包含，但是本书未涉及的概念。</p>
]]></summary>
    <content type="html"><![CDATA[<p>此处记录了<a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">官方手册</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/" target="_blank" rel="noopener noreferrer">中文版</a>)中包含，但是本书未涉及的概念。</p>

<p>我认为它们是一些不重要或者不属于 TypeScript 的概念，所以这里只给出一个简单的释义，详细内容可以点击链接深入理解。</p>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#never" target="_blank" rel="noopener noreferrer">Never</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html#never" target="_blank" rel="noopener noreferrer">中文版</a>): 永远不存在值的类型，一般用于错误处理函数</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/variable-declarations.html" target="_blank" rel="noopener noreferrer">Variable Declarations</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Variable%20Declarations.html" target="_blank" rel="noopener noreferrer">中文版</a>): 使用 <code>let</code> 和 <code>const</code> 替代 <code>var</code>，这是 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener noreferrer">ES6 的知识</a></li>
<li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html#this" target="_blank" rel="noopener noreferrer"><code>this</code></a>: 箭头函数的运用，这是 <a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener noreferrer">ES6 的知识</a></li>
<li><a href="http://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics" target="_blank" rel="noopener noreferrer">Using Class Types in Generics</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Generics.html#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E9%87%8C%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>): 创建工厂函数时，需要引用构造函数的类类型</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/type-inference.html#best-common-type" target="_blank" rel="noopener noreferrer">Best common type</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type%20Inference.html#%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>): 数组的类型推论</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-type" target="_blank" rel="noopener noreferrer">Contextual Type</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type%20Inference.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>): 函数输入的类型推论</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener noreferrer">Type Compatibility</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type%20Compatibility.html" target="_blank" rel="noopener noreferrer">中文版</a>): 允许不严格符合类型，只需要在一定规则下兼容即可</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types" target="_blank" rel="noopener noreferrer">Advanced Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B(intersection-types)" target="_blank" rel="noopener noreferrer">中文版</a>): 使用 <code>&amp;</code> 将多种类型的共有部分叠加成一种类型</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types" target="_blank" rel="noopener noreferrer">Type Guards and Differentiating Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B(type-guards-and-differentiating-types)" target="_blank" rel="noopener noreferrer">中文版</a>): 联合类型在一些情况下被识别为特定的类型</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions" target="_blank" rel="noopener noreferrer">Discriminated Unions</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88(discriminated-unions)" target="_blank" rel="noopener noreferrer">中文版</a>): 使用 <code>|</code> 联合多个接口的时候，通过一个共有的属性形成可辨识联合</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types" target="_blank" rel="noopener noreferrer">Polymorphic <code>this</code> types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E5%A4%9A%E6%80%81%E7%9A%84this%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>): 父类的某个方法返回 <code>this</code>，当子类继承父类后，子类的实例调用此方法，返回的 <code>this</code> 能够被 TypeScript 正确的识别为子类的实例。</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/symbols.html" target="_blank" rel="noopener noreferrer">Symbols</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Symbols.html" target="_blank" rel="noopener noreferrer">中文版</a>): 新原生类型，这是 <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener noreferrer">ES6 的知识</a></li>
<li><a href="http://www.typescriptlang.org/docs/handbook/iterators-and-generators.html" target="_blank" rel="noopener noreferrer">Iterators and Generators</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Iterators%20and%20Generators.html" target="_blank" rel="noopener noreferrer">中文版</a>): 迭代器，这是 <a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener noreferrer">ES6 的知识</a></li>
<li><a href="http://www.typescriptlang.org/docs/handbook/namespaces.html" target="_blank" rel="noopener noreferrer">Namespaces</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Namespaces.html" target="_blank" rel="noopener noreferrer">中文版</a>): 避免全局污染，现在已被 <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener noreferrer">ES6 Module</a> 替代</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener noreferrer">Decorators</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Decorators.html" target="_blank" rel="noopener noreferrer">中文版</a>): 修饰器，这是 <a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener noreferrer">ES2016 的一个提案</a></li>
<li><a href="http://www.typescriptlang.org/docs/handbook/mixins.html" target="_blank" rel="noopener noreferrer">Mixins</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Mixins.html" target="_blank" rel="noopener noreferrer">中文版</a>): 一种编程模式，与 TypeScript 没有直接关系，可以参考 <a href="http://es6.ruanyifeng.com/#docs/class#Mixin%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener noreferrer">ES6 中 Mixin 模式的实现</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">泛型</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/generics/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/generics/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
]]></summary>
    <content type="html"><![CDATA[<p>泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值:</p>
<div><pre><code><span>function</span> <span>createArray</span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>any</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>any</span><span>></span> <span>{</span>
  <span>let</span> result <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>

<span>createArray</span><span>(</span><span>3</span><span>,</span> <span>"x"</span><span>)</span><span>;</span> <span>// ['x', 'x', 'x']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例中，我们使用了<a href="/doc/private/language/typescript/basics/type-of-array#%E6%95%B0%E7%BB%84%E6%B3%9B%E5%9E%8B">之前提到过的数组泛型</a>来定义返回值的类型。</p>
<p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型:</p>
<p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p>
<p>这时候，泛型就派上用场了:</p>
<div><pre><code><span>function</span> <span><span>createArray</span><span><span>&lt;</span><span>T</span><span>></span></span></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>let</span> result<span>:</span> <span>T</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>

<span><span>createArray</span><span><span>&lt;</span><span>string</span><span>></span></span></span><span>(</span><span>3</span><span>,</span> <span>"x"</span><span>)</span><span>;</span> <span>// ['x', 'x', 'x']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p>
<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来:</p>
<div><pre><code><span>function</span> <span><span>createArray</span><span><span>&lt;</span><span>T</span><span>></span></span></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>let</span> result<span>:</span> <span>T</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>

<span>createArray</span><span>(</span><span>3</span><span>,</span> <span>"x"</span><span>)</span><span>;</span> <span>// ['x', 'x', 'x']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="多个类型参数"> 多个类型参数</h2>
<p>定义泛型的时候，可以一次定义多个类型参数:</p>
<div><pre><code><span>function</span> <span><span>swap</span><span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>></span></span></span><span>(</span>tuple<span>:</span> <span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span><span>)</span><span>:</span> <span>[</span><span>U</span><span>,</span> <span>T</span><span>]</span> <span>{</span>
  <span>return</span> <span>[</span>tuple<span>[</span><span>1</span><span>]</span><span>,</span> tuple<span>[</span><span>0</span><span>]</span><span>]</span><span>;</span>
<span>}</span>

<span>swap</span><span>(</span><span>[</span><span>7</span><span>,</span> <span>"seven"</span><span>]</span><span>)</span><span>;</span> <span>// ['seven', 7]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p>
<h2 id="泛型约束"> 泛型约束</h2>
<p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法:</p>
<div><pre><code><span>function</span> <span><span>loggingIdentity</span><span><span>&lt;</span><span>T</span><span>></span></span></span><span>(</span>arg<span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>arg<span>.</span>length<span>)</span><span>;</span>
  <span>return</span> arg<span>;</span>
<span>}</span>

<span>// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束:</p>
<div><pre><code><span>interface</span> <span>Lengthwise</span> <span>{</span>
  length<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>function</span> <span><span>loggingIdentity</span><span><span>&lt;</span><span>T</span> <span>extends</span> Lengthwise<span>></span></span></span><span>(</span>arg<span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>arg<span>.</span>length<span>)</span><span>;</span>
  <span>return</span> arg<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>
<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了:</p>
<div><pre><code><span>interface</span> <span>Lengthwise</span> <span>{</span>
  length<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>function</span> <span><span>loggingIdentity</span><span><span>&lt;</span><span>T</span> <span>extends</span> Lengthwise<span>></span></span></span><span>(</span>arg<span>:</span> <span>T</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>arg<span>.</span>length<span>)</span><span>;</span>
  <span>return</span> arg<span>;</span>
<span>}</span>

<span>loggingIdentity</span><span>(</span><span>7</span><span>)</span><span>;</span>

<span>// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>多个类型参数之间也可以互相约束:</p>
<div><pre><code><span>function</span> <span><span>copyFields</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>U</span><span>,</span> <span>U</span><span>></span></span></span><span>(</span>target<span>:</span> <span>T</span><span>,</span> source<span>:</span> <span>U</span><span>)</span><span>:</span> <span>T</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> id <span>in</span> source<span>)</span> <span>{</span>
    target<span>[</span>id<span>]</span> <span>=</span> <span>(</span><span>&lt;</span><span>T</span><span>></span>source<span>)</span><span>[</span>id<span>]</span><span>;</span>
  <span>}</span>
  <span>return</span> target<span>;</span>
<span>}</span>

<span>let</span> x <span>=</span> <span>{</span> a<span>:</span> <span>1</span><span>,</span> b<span>:</span> <span>2</span><span>,</span> c<span>:</span> <span>3</span><span>,</span> d<span>:</span> <span>4</span> <span>}</span><span>;</span>

<span>copyFields</span><span>(</span>x<span>,</span> <span>{</span> b<span>:</span> <span>10</span><span>,</span> d<span>:</span> <span>20</span> <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p>
<h2 id="泛型接口"> 泛型接口</h2>
<p><a href="/doc/private/language/typescript/basics/type-of-function#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状:</p>
<div><pre><code><span>interface</span> <span>SearchFunc</span> <span>{</span>
  <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span><span>;</span>
<span>}</span>

<span>let</span> mySearch<span>:</span> SearchFunc<span>;</span>
<span>mySearch</span> <span>=</span> <span>function</span> <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> source<span>.</span><span>search</span><span>(</span>subString<span>)</span> <span>!==</span> <span>-</span><span>1</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当然也可以使用含有泛型的接口来定义函数的形状:</p>
<div><pre><code><span>interface</span> <span>CreateArrayFunc</span> <span>{</span>
  <span>&lt;</span><span>T</span><span>></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span><span>;</span>
<span>}</span>

<span>let</span> createArray<span>:</span> CreateArrayFunc<span>;</span>
<span>createArray</span> <span>=</span> <span>function</span> <span>&lt;</span><span>T</span><span>></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>let</span> result<span>:</span> <span>T</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span><span>;</span>

<span>createArray</span><span>(</span><span>3</span><span>,</span> <span>"x"</span><span>)</span><span>;</span> <span>// ['x', 'x', 'x']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>进一步，我们可以把泛型参数提前到接口名上:</p>
<div><pre><code><span>interface</span> <span>CreateArrayFunc<span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
  <span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span><span>;</span>
<span>}</span>

<span>let</span> createArray<span>:</span> CreateArrayFunc<span>&lt;</span><span>any</span><span>></span><span>;</span>
<span>createArray</span> <span>=</span> <span>function</span> <span>&lt;</span><span>T</span><span>></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>let</span> result<span>:</span> <span>T</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span><span>;</span>

<span>createArray</span><span>(</span><span>3</span><span>,</span> <span>"x"</span><span>)</span><span>;</span> <span>// ['x', 'x', 'x']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p>
<h2 id="泛型类"> 泛型类</h2>
<p>与泛型接口类似，泛型也可以用于类的类型定义中:</p>
<div><pre><code><span>class</span> <span>GenericNumber<span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
  zeroValue<span>:</span> <span>T</span><span>;</span>
  <span>add</span><span>:</span> <span>(</span>x<span>:</span> <span>T</span><span>,</span> y<span>:</span> <span>T</span><span>)</span> <span>=></span> <span>T</span><span>;</span>
<span>}</span>

<span>let</span> myGenericNumber <span>=</span> <span>new</span> <span>GenericNumber<span>&lt;</span><span>number</span><span>></span></span><span>(</span><span>)</span><span>;</span>
myGenericNumber<span>.</span>zeroValue <span>=</span> <span>0</span><span>;</span>
myGenericNumber<span>.</span><span>add</span> <span>=</span> <span>function</span> <span>(</span>x<span>,</span> y<span>)</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="泛型参数的默认类型"> 泛型参数的默认类型</h2>
<p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p>
<div><pre><code><span>function</span> <span><span>createArray</span><span><span>&lt;</span><span>T</span> <span>=</span> <span>string</span><span>></span></span></span><span>(</span>length<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>T</span><span>)</span><span>:</span> <span>Array</span><span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>let</span> result<span>:</span> <span>T</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    result<span>[</span>i<span>]</span> <span>=</span> value<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="noopener noreferrer">Generics</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/generics.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults" target="_blank" rel="noopener noreferrer">Generic parameter defaults</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">进阶</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本部分介绍一些高级的类型与技术。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本部分介绍一些高级的类型与技术。</p>

<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="advanced/type-aliases">类型别名</a></p>
</li>
<li>
<p><a href="advanced/string-literal-types">字符串字面量类型</a></p>
</li>
<li>
<p><a href="advanced/tuple">元组</a></p>
</li>
<li>
<p><a href="advanced/enum">枚举</a></p>
</li>
<li>
<p><a href="advanced/class">类</a></p>
</li>
<li>
<p><a href="advanced/class-and-interfaces">类与接口</a></p>
</li>
<li>
<p><a href="advanced/generics">泛型</a></p>
</li>
<li>
<p><a href="advanced/declaration-merging">声明合并</a></p>
</li>
<li>
<p><a href="advanced/further-reading">扩展阅读</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">字符串字面量类型</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/string-literal-types/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/string-literal-types/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
]]></summary>
    <content type="html"><![CDATA[<p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<div><pre><code><span>type</span> <span>EventNames</span> <span>=</span> <span>"click"</span> <span>|</span> <span>"scroll"</span> <span>|</span> <span>"mousemove"</span><span>;</span>
<span>function</span> <span>handleEvent</span><span>(</span>ele<span>:</span> Element<span>,</span> event<span>:</span> EventNames<span>)</span> <span>{</span>
  <span>// do something</span>
<span>}</span>

<span>handleEvent</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>"hello"</span><span>)</span><span>,</span> <span>"scroll"</span><span>)</span><span>;</span> <span>// 没问题</span>
<span>handleEvent</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>"world"</span><span>)</span><span>,</span> <span>"dbclick"</span><span>)</span><span>;</span> <span>// 报错，event 不能为 'dbclick'</span>

<span>// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p>
<p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types" target="_blank" rel="noopener noreferrer">Advanced Types # Type Aliases</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">元组</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/tuple/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/tuple/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>数组合并了相同类型的对象，而元组(Tuple)合并了不同类型的对象。</p>
<p>元组起源于函数编程语言(如 F#)，这些语言中会频繁使用元组。</p>
]]></summary>
    <content type="html"><![CDATA[<p>数组合并了相同类型的对象，而元组(Tuple)合并了不同类型的对象。</p>
<p>元组起源于函数编程语言(如 F#)，这些语言中会频繁使用元组。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组:</p>
<div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span> <span>=</span> <span>[</span><span>"Tom"</span><span>,</span> <span>25</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>当赋值或访问一个已知索引的元素时，会得到正确的类型:</p>
<div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
tom<span>[</span><span>0</span><span>]</span> <span>=</span> <span>"Tom"</span><span>;</span>
tom<span>[</span><span>1</span><span>]</span> <span>=</span> <span>25</span><span>;</span>

tom<span>[</span><span>0</span><span>]</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>;</span>
tom<span>[</span><span>1</span><span>]</span><span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也可以只赋值其中一项:</p>
<div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
tom<span>[</span><span>0</span><span>]</span> <span>=</span> <span>"Tom"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</p>
<div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
tom <span>=</span> <span>[</span><span>"Tom"</span><span>,</span> <span>25</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
tom <span>=</span> <span>[</span><span>"Tom"</span><span>]</span><span>;</span>

<span>// Property '1' is missing in type '[string]' but required in type '[string, number]'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="越界的元素"> 越界的元素</h2>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型:</p>
<div><pre><code><span>let</span> tom<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
tom <span>=</span> <span>[</span><span>"Tom"</span><span>,</span> <span>25</span><span>]</span><span>;</span>
tom<span>.</span><span>push</span><span>(</span><span>"male"</span><span>)</span><span>;</span>
tom<span>.</span><span>push</span><span>(</span><span>true</span><span>)</span><span>;</span>

<span>// Argument of type 'true' is not assignable to parameter of type 'string | number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" target="_blank" rel="noopener noreferrer">Basic Types # Tuple</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html#%E5%85%83%E7%BB%84-tuple" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">类型别名</title>
    <id>https://list-jiang.github.io/code/language/typescript/advanced/type-aliases/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/advanced/type-aliases/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>类型别名用来给一个类型起个新名字。</p>
]]></summary>
    <content type="html"><![CDATA[<p>类型别名用来给一个类型起个新名字。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<div><pre><code><span>type</span> <span>Name</span> <span>=</span> <span>string</span><span>;</span>
<span>type</span> <span>NameResolver</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>string</span><span>;</span>
<span>type</span> <span>NameOrResolver</span> <span>=</span> Name <span>|</span> NameResolver<span>;</span>
<span>function</span> <span>getName</span><span>(</span>n<span>:</span> NameOrResolver<span>)</span><span>:</span> Name <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> n <span>===</span> <span>"string"</span><span>)</span> <span>{</span>
    <span>return</span> n<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>n</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<p>类型别名常用于联合类型。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases" target="_blank" rel="noopener noreferrer">Advanced Types # Type Aliases</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">任意值</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/any/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/any/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>任意值(Any)用来表示允许赋值为任意类型。</p>
]]></summary>
    <content type="html"><![CDATA[<p>任意值(Any)用来表示允许赋值为任意类型。</p>

<h2 id="什么是任意值类型"> 什么是任意值类型</h2>
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的:</p>
<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>

<span>// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p>
<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>any</span> <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="任意值的属性和方法"> 任意值的属性和方法</h2>
<p>在任意值上访问任何属性都是允许的:</p>
<div><pre><code><span>let</span> anyThing<span>:</span> <span>any</span> <span>=</span> <span>"hello"</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>anyThing<span>.</span>myName<span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>anyThing<span>.</span>myName<span>.</span>firstName<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>也允许调用任何方法:</p>
<div><pre><code><span>let</span> anyThing<span>:</span> <span>any</span> <span>=</span> <span>"Tom"</span><span>;</span>
anyThing<span>.</span><span>setName</span><span>(</span><span>"Jerry"</span><span>)</span><span>;</span>
anyThing<span>.</span><span>setName</span><span>(</span><span>"Jerry"</span><span>)</span><span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
anyThing<span>.</span>myName<span>.</span><span>setFirstName</span><span>(</span><span>"Cat"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p>
<h2 id="未声明类型的变量"> 未声明类型的变量</h2>
<p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>:</p>
<div><pre><code><span>let</span> something<span>;</span>
something <span>=</span> <span>"seven"</span><span>;</span>
something <span>=</span> <span>7</span><span>;</span>

something<span>.</span><span>setName</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>等价于</p>
<div><pre><code><span>let</span> something<span>:</span> <span>any</span><span>;</span>
something <span>=</span> <span>"seven"</span><span>;</span>
something <span>=</span> <span>7</span><span>;</span>

something<span>.</span><span>setName</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#any" target="_blank" rel="noopener noreferrer">Basic Types # Any</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html#%E4%BB%BB%E6%84%8F%E5%80%BC" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">内置对象</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/built-in-objects/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/built-in-objects/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>JavaScript 中有很多[内置对象][]，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域(Global)上存在的对象。这里的标准是指 ECMAScript 和其他环境(比如 DOM)的标准。</p>
]]></summary>
    <content type="html"><![CDATA[<p>JavaScript 中有很多<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域(Global)上存在的对象。这里的标准是指 ECMAScript 和其他环境(比如 DOM)的标准。</p>

<h2 id="ecmascript-的内置对象"> ECMAScript 的内置对象</h2>
<p>ECMAScript 标准提供的内置对象有:</p>
<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>
<p>我们可以在 TypeScript 中将变量定义为这些类型:</p>
<div><pre><code><span>let</span> b<span>:</span> Boolean <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>let</span> e<span>:</span> Error <span>=</span> <span>new</span> <span>Error</span><span>(</span><span>"Error occurred"</span><span>)</span><span>;</span>
<span>let</span> d<span>:</span> Date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
<span>let</span> r<span>:</span> RegExp <span>=</span> <span><span>/</span><span>[a-z]</span><span>/</span></span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">MDN 的文档</a>。</p>
<p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件</a>中。</p>
<h2 id="dom-和-bom-的内置对象"> DOM 和 BOM 的内置对象</h2>
<p>DOM 和 BOM 提供的内置对象有:</p>
<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>
<p>TypeScript 中会经常用到这些类型:</p>
<div><pre><code><span>let</span> body<span>:</span> HTMLElement <span>=</span> document<span>.</span>body<span>;</span>
<span>let</span> allDiv<span>:</span> NodeList <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span>"div"</span><span>)</span><span>;</span>
document<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span>e<span>:</span> MouseEvent<span>)</span> <span>{</span>
  <span>// Do something</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件</a>中。</p>
<h2 id="typescript-核心库的定义文件"> TypeScript 核心库的定义文件</h2>
<p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>
<p>当您在使用一些常用的方法的时候，TypeScript 实际上已经帮您做了很多类型判断的工作了，比如:</p>
<div><pre><code>Math<span>.</span><span>pow</span><span>(</span><span>10</span><span>,</span> <span>"2"</span><span>)</span><span>;</span>

<span>// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下:</p>
<div><pre><code><span>interface</span> <span>Math</span> <span>{</span>
  <span>/**
   * Returns the value of a base expression taken to a specified power.
   * @param x The base value of the expression.
   * @param y The exponent value of the expression.
   */</span>
  <span>pow</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>再举一个 DOM 中的例子:</p>
<div><pre><code>document<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span>e<span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>e<span>.</span>targetCurrent<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的:</p>
<div><pre><code><span>interface</span> <span>Document</span>
  <span>extends</span> <span>Node</span><span>,</span>
    GlobalEventHandlers<span>,</span>
    NodeSelector<span>,</span>
    DocumentEvent <span>{</span>
  <span>addEventListener</span><span>(</span>
    type<span>:</span> <span>string</span><span>,</span>
    <span>listener</span><span>:</span> <span>(</span>ev<span>:</span> MouseEvent<span>)</span> <span>=></span> <span>any</span><span>,</span>
    useCapture<span>?</span><span>:</span> <span>boolean</span>
  <span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>
<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>
<h2 id="用-typescript-写-node-js"> 用 TypeScript 写 Node.js</h2>
<p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件:</p>
<div><pre><code><span>npm</span> <span>install</span> @types/node --save-dev
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">内置对象</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">声明文件</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/declaration-files/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/declaration-files/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>
<h2 id="什么是声明语句"> 什么是声明语句</h2>
<p>假如我们想使用第三方库 jQuery，一种常见的方式是在 HTML 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p>
<p>我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素:</p>
<div><pre><code><span>$</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
<span>// or</span>
<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>但是在 ts 中，编译器并不知道 <code>$</code> 或 <code>jQuery</code> 是什么东西<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery" target="_blank" rel="noopener noreferrer">1</a>:</p>
<div><pre><code><span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
<span>// ERROR: Cannot find name 'jQuery'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这时，我们需要使用 <code>declare var</code> 来定义它的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var" target="_blank" rel="noopener noreferrer">2</a>:</p>
<div><pre><code><span>declare</span> <span>var</span> <span>jQuery</span><span>:</span> <span>(</span>selector<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>any</span><span>;</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是:</p>
<div><pre><code><span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p>
<h2 id="什么是声明文件"> 什么是声明文件</h2>
<p>通常我们会把声明语句放到一个单独的文件(<code>jQuery.d.ts</code>)中，这就是声明文件<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts" target="_blank" rel="noopener noreferrer">3</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>var</span> <span>jQuery</span><span>:</span> <span>(</span>selector<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>any</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>声明文件必需以 <code>.d.ts</code> 为后缀。</p>
<p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p>
<div><pre><code>/path/to/project
├── src
|  ├── index.ts
|  └── jQuery.d.ts
└── tsconfig.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<p>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p>
<h3 id="第三方声明文件"> 第三方声明文件</h3>
<p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了: <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts" target="_blank" rel="noopener noreferrer">jQuery in DefinitelyTyped</a>。</p>
<p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>
<p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例:</p>
<div><pre><code><span>npm</span> <span>install</span> @types/jquery --save-dev
</code></pre>
<div><span>1</span><br></div></div><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener noreferrer">这个页面</a>搜索您需要的声明文件。</p>
<h2 id="书写声明文件"> 书写声明文件</h2>
<p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p>
<p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>
<p>库的使用场景主要有以下几种:</p>
<ul>
<li>: 通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</li>
<li>: 通过 <code>import foo from 'foo'</code> 导入，符合 ES6 模块规范</li>
<li>: 既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</li>
<li>: 通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li>
<li>: 引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>
<li>: 通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</li>
</ul>
<h3 id="全局变量"> 全局变量</h3>
<p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p>
<p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下(或者对应的源码目录下):</p>
<div><pre><code>/path/to/project
├── src
| ├── index.ts
| └── jQuery.d.ts
└── tsconfig.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>
<p>全局变量的声明文件主要有以下几种语法:</p>
<ul>
<li> 声明全局变量</li>
<li> 声明全局方法</li>
<li> 声明全局类</li>
<li> 声明全局枚举类型</li>
<li> 声明(含有子属性的)全局对象</li>
<li> 声明全局类型</li>
</ul>
<h4 id="declare-var"> <code>declare var</code></h4>
<p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>let</span> <span>jQuery</span><span>:</span> <span>(</span>selector<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>any</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
<span>// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span>
<span>jQuery</span> <span>=</span> <span>function</span> <span>(</span>selector<span>)</span> <span>{</span>
  <span>return</span> document<span>.</span><span>querySelector</span><span>(</span>selector<span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而当我们使用 <code>const</code> 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery" target="_blank" rel="noopener noreferrer">4</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>const</span> <span>jQuery</span><span>:</span> <span>(</span>selector<span>:</span> <span>string</span><span>)</span> <span>=></span> <span>any</span><span>;</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
<span>// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量</span>
<span>jQuery</span> <span>=</span> <span>function</span> <span>(</span>selector<span>)</span> <span>{</span>
  <span>return</span> document<span>.</span><span>querySelector</span><span>(</span>selector<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p>
<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value" target="_blank" rel="noopener noreferrer">5</a>:</p>
<div><pre><code><span>declare</span> <span>const</span> <span>jQuery</span> <span>=</span> <span>function</span> <span>(</span>selector<span>)</span> <span>{</span>
  <span>return</span> document<span>.</span><span>querySelector</span><span>(</span>selector<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// ERROR: An implementation cannot be declared in ambient contexts.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="declare-function"> <code>declare function</code></h4>
<p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>function</span> <span>jQuery</span><span>(</span>selector<span>:</span> <span>string</span><span>)</span><span>:</span> <span>any</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在函数类型的声明语句中，函数重载也是支持的<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function" target="_blank" rel="noopener noreferrer">6</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>function</span> <span>jQuery</span><span>(</span>selector<span>:</span> <span>string</span><span>)</span><span>:</span> <span>any</span><span>;</span>
<span>declare</span> <span>function</span> <span>jQuery</span><span>(</span><span>domReadyCallback</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>any</span><span>)</span><span>:</span> <span>any</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
<span>jQuery</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Dom Ready!"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="declare-class"> <code>declare class</code></h4>
<p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class" target="_blank" rel="noopener noreferrer">7</a>:</p>
<div><pre><code><span>// src/Animal.d.ts</span>

<span>declare</span> <span>class</span> <span>Animal</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span><span>;</span>
  <span>sayHi</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>let</span> cat <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code> 方法的具体实现则会报错:</p>
<div><pre><code><span>// src/Animal.d.ts</span>

<span>declare</span> <span>class</span> <span>Animal</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span><span>;</span>
  <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>My name is </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>
  <span>// ERROR: An implementation cannot be declared in ambient contexts.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="declare-enum"> <code>declare enum</code></h4>
<p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举(Ambient Enums)，举例如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum" target="_blank" rel="noopener noreferrer">8</a>:</p>
<div><pre><code><span>// src/Directions.d.ts</span>

<span>declare</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>let</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p>
<p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是:</p>
<div><pre><code><span>var</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p>
<h4 id="declare-namespace"> <code>declare namespace</code></h4>
<p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。</p>
<p>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 <code>module</code> 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。</p>
<p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。</p>
<p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p>
<p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>// src/index.ts</span>

jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/get_something"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace" target="_blank" rel="noopener noreferrer">9</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
  <span>const</span> version<span>:</span> <span>number</span><span>;</span>
  <span>class</span> <span>Event</span> <span>{</span>
    <span>blur</span><span>(</span>eventType<span>:</span> EventType<span>)</span><span>:</span> <span>void</span><span>;</span>
  <span>}</span>
  <span>enum</span> EventType <span>{</span>
    CustomClick<span>,</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>// src/index.ts</span>

jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/get_something"</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>jQuery<span>.</span>version<span>)</span><span>;</span>
<span>const</span> e <span>=</span> <span>new</span> <span>jQuery</span><span>.</span><span>Event</span><span>(</span><span>)</span><span>;</span>
e<span>.</span><span>blur</span><span>(</span>jQuery<span>.</span>EventType<span>.</span>CustomClick<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h5 id="嵌套的命名空间"> 嵌套的命名空间</h5>
<p>如果对象拥有深层的层级，则需要用嵌套的 <code>namespace</code> 来声明深层的属性的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting" target="_blank" rel="noopener noreferrer">10</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
  <span>namespace</span> fn <span>{</span>
    <span>function</span> <span>extend</span><span>(</span>object<span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>// src/index.ts</span>

jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/get_something"</span><span>)</span><span>;</span>
jQuery<span>.</span>fn<span>.</span><span>extend</span><span>(</span><span>{</span>
  <span>check</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>each</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>checked <span>=</span> <span>true</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>假如 <code>jQuery</code> 下仅有 <code>fn</code> 这一个属性(没有 <code>ajax</code> 等其他属性或方法)，则可以不需要嵌套 <code>namespace</code><a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot" target="_blank" rel="noopener noreferrer">11</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>namespace</span> jQuery<span>.</span>fn <span>{</span>
  <span>function</span> <span>extend</span><span>(</span>object<span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>// src/index.ts</span>

jQuery<span>.</span>fn<span>.</span><span>extend</span><span>(</span><span>{</span>
  <span>check</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>each</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>checked <span>=</span> <span>true</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="interface-和-type"> <code>interface</code> 和 <code>type</code></h4>
<p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface" target="_blank" rel="noopener noreferrer">12</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>interface</span> <span>AjaxSettings</span> <span>{</span>
  method<span>?</span><span>:</span> <span>"GET"</span> <span>|</span> <span>"POST"</span><span>;</span>
  data<span>?</span><span>:</span> <span>any</span><span>;</span>
<span>}</span>
<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> AjaxSettings<span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这样的话，在其他文件中也可以使用这个接口或类型了:</p>
<div><pre><code><span>// src/index.ts</span>

<span>let</span> settings<span>:</span> AjaxSettings <span>=</span> <span>{</span>
  method<span>:</span> <span>"POST"</span><span>,</span>
  data<span>:</span> <span>{</span>
    name<span>:</span> <span>"foo"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/post_something"</span><span>,</span> settings<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>type</code> 与 <code>interface</code> 类似，不再赘述。</p>
<h5 id="防止命名冲突"> 防止命名冲突</h5>
<p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict" target="_blank" rel="noopener noreferrer">13</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>interface</span> <span>AjaxSettings</span> <span>{</span>
    method<span>?</span><span>:</span> <span>"GET"</span> <span>|</span> <span>"POST"</span><span>;</span>
    data<span>?</span><span>:</span> <span>any</span><span>;</span>
  <span>}</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> AjaxSettings<span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀:</p>
<div><pre><code><span>// src/index.ts</span>

<span>let</span> settings<span>:</span> jQuery<span>.</span>AjaxSettings <span>=</span> <span>{</span>
  method<span>:</span> <span>"POST"</span><span>,</span>
  data<span>:</span> <span>{</span>
    name<span>:</span> <span>"foo"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/post_something"</span><span>,</span> settings<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="声明合并"> 声明合并</h4>
<p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery('#foo')</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>(事实确实如此)，那么我们可以组合多个声明语句，它们会不冲突的合并起来<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging" target="_blank" rel="noopener noreferrer">14</a>:</p>
<div><pre><code><span>// src/jQuery.d.ts</span>

<span>declare</span> <span>function</span> <span>jQuery</span><span>(</span>selector<span>:</span> <span>string</span><span>)</span><span>:</span> <span>any</span><span>;</span>
<span>declare</span> <span>namespace</span> jQuery <span>{</span>
  <span>function</span> <span>ajax</span><span>(</span>url<span>:</span> <span>string</span><span>,</span> settings<span>?</span><span>:</span> <span>any</span><span>)</span><span>:</span> <span>void</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>jQuery</span><span>(</span><span>"#foo"</span><span>)</span><span>;</span>
jQuery<span>.</span><span>ajax</span><span>(</span><span>"/api/get_something"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>关于声明合并的更多用法，可以查看<a href="./../advanced/declaration-merging.html">声明合并</a>章节。</p>
<h3 id="npm-包"> npm 包</h3>
<p>一般我们通过 <code>import foo from 'foo'</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>
<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方:</p>
<ol>
<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>
<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>
</ol>
<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案:</p>
<ol>
<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>
<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>
</ol>
<p>目录结构:</p>
<div><pre><code>/path/to/project
├── src
| └── index.ts
├── types
| └── foo
| └── index.d.ts
└── tsconfig.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>tsconfig.json</code> 内容:</p>
<div><pre><code><span>{</span>
  <span>"compilerOptions"</span><span>:</span> <span>{</span>
    <span>"module"</span><span>:</span> <span>"commonjs"</span><span>,</span>
    <span>"baseUrl"</span><span>:</span> <span>"./"</span><span>,</span>
    <span>"paths"</span><span>:</span> <span>{</span>
      <span>"*"</span><span>:</span> <span>[</span><span>"types/*"</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>
<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>
<p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件(通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里)发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>
<p>npm 包的声明文件主要有以下几种语法:</p>
<ul>
<li> 导出变量</li>
<li> 导出(含有子属性的)对象</li>
<li> ES6 默认导出</li>
<li> commonjs 导出模块</li>
</ul>
<h4 id="export"> <code>export</code></h4>
<p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>
<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export" target="_blank" rel="noopener noreferrer">15</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>const</span> name<span>:</span> <span>string</span><span>;</span>
<span>export</span> <span>function</span> <span>getName</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>export</span> <span>class</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span><span>;</span>
  <span>sayHi</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
<span>export</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>
<span>export</span> <span>interface</span> <span>Options</span> <span>{</span>
  data<span>:</span> <span>any</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>对应的导入和使用模块应该是这样:</p>
<div><pre><code><span>// src/index.ts</span>

<span>import</span> <span>{</span> name<span>,</span> getName<span>,</span> Animal<span>,</span> Directions<span>,</span> Options <span>}</span> <span>from</span> <span>"foo"</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span>
<span>let</span> myName <span>=</span> <span>getName</span><span>(</span><span>)</span><span>;</span>
<span>let</span> cat <span>=</span> <span>new</span> <span>Animal</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
<span>let</span> directions <span>=</span> <span>[</span>
  Directions<span>.</span>Up<span>,</span>
  Directions<span>.</span>Down<span>,</span>
  Directions<span>.</span>Left<span>,</span>
  Directions<span>.</span>Right<span>,</span>
<span>]</span><span>;</span>
<span>let</span> options<span>:</span> Options <span>=</span> <span>{</span>
  data<span>:</span> <span>{</span>
    name<span>:</span> <span>"foo"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h5 id="混用-declare-和-export"> 混用 <code>declare</code> 和 <code>export</code></h5>
<p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export" target="_blank" rel="noopener noreferrer">16</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>declare</span> <span>const</span> name<span>:</span> <span>string</span><span>;</span>
<span>declare</span> <span>function</span> <span>getName</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>declare</span> <span>class</span> <span>Animal</span> <span>{</span>
  <span>constructor</span><span>(</span>name<span>:</span> <span>string</span><span>)</span><span>;</span>
  <span>sayHi</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
<span>declare</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>
<span>interface</span> <span>Options</span> <span>{</span>
  data<span>:</span> <span>any</span><span>;</span>
<span>}</span>

<span>export</span> <span>{</span> name<span>,</span> getName<span>,</span> Animal<span>,</span> Directions<span>,</span> Options <span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>
<h4 id="export-namespace"> <code>export namespace</code></h4>
<p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace" target="_blank" rel="noopener noreferrer">17</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>namespace</span> foo <span>{</span>
  <span>const</span> name<span>:</span> <span>string</span><span>;</span>
  <span>namespace</span> bar <span>{</span>
    <span>function</span> <span>baz</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>import</span> <span>{</span> foo <span>}</span> <span>from</span> <span>"foo"</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span>foo<span>.</span>name<span>)</span><span>;</span>
foo<span>.</span>bar<span>.</span><span>baz</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="export-default"> <code>export default</code></h4>
<p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from 'foo'</code> 而不是 <code>import { foo } from 'foo'</code> 来导入这个默认值。</p>
<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default" target="_blank" rel="noopener noreferrer">18</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>default</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>import</span> foo <span>from</span> <span>"foo"</span><span>;</span>

<span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error" target="_blank" rel="noopener noreferrer">19</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>default</span> <span>enum</span> Directions <span>{</span>
<span>// ERROR: Expression expected.</span>
    Up<span>,</span>
    Down<span>,</span>
    Left<span>,</span>
    Right
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>declare</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>

<span>export</span> <span>default</span> Directions<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum" target="_blank" rel="noopener noreferrer">20</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>default</span> Directions<span>;</span>

<span>declare</span> <span>enum</span> Directions <span>{</span>
  Up<span>,</span>
  Down<span>,</span>
  Left<span>,</span>
  Right<span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="export-2"> <code>export =</code></h4>
<p>在 commonjs 规范中，我们用以下方式来导出一个模块:</p>
<div><pre><code><span>// 整体导出</span>
module<span>.</span>exports <span>=</span> foo<span>;</span>
<span>// 单个导出</span>
exports<span>.</span>bar <span>=</span> bar<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>:</p>
<div><pre><code><span>// 整体导入</span>
<span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>"foo"</span><span>)</span><span>;</span>
<span>// 单个导入</span>
<span>const</span> bar <span>=</span> <span>require</span><span>(</span><span>"foo"</span><span>)</span><span>.</span>bar<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入:</p>
<div><pre><code><span>// 整体导入</span>
<span>import</span> <span>*</span> <span>as</span> foo <span>from</span> <span>"foo"</span><span>;</span>
<span>// 单个导入</span>
<span>import</span> <span>{</span> bar <span>}</span> <span>from</span> <span>"foo"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式:</p>
<div><pre><code><span>// 整体导入</span>
<span>import</span> foo <span>=</span> <span>require</span><span>(</span><span>"foo"</span><span>)</span><span>;</span>
<span>// 单个导入</span>
<span>import</span> bar <span>=</span> foo<span>.</span>bar<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal" target="_blank" rel="noopener noreferrer">21</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>=</span> foo<span>;</span>

<span>declare</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>declare</span> <span>namespace</span> foo <span>{</span>
  <span>const</span> bar<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export { bar }</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>
<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>
<h3 id="umd-库"> UMD 库</h3>
<p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>
<h4 id="export-as-namespace"> <code>export as namespace</code></h4>
<p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace" target="_blank" rel="noopener noreferrer">22</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>as</span> <span>namespace</span> foo<span>;</span>
<span>export</span> <span>=</span> foo<span>;</span>

<span>declare</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>declare</span> <span>namespace</span> foo <span>{</span>
  <span>const</span> bar<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>当然它也可以与 <code>export default</code> 一起使用:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>export</span> <span>as</span> <span>namespace</span> foo<span>;</span>
<span>export</span> <span>default</span> foo<span>;</span>

<span>declare</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>declare</span> <span>namespace</span> foo <span>{</span>
  <span>const</span> bar<span>:</span> <span>number</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="直接扩展全局变量"> 直接扩展全局变量</h3>
<p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface" target="_blank" rel="noopener noreferrer">23</a>:</p>
<div><pre><code><span>interface</span> <span>String</span> <span>{</span>
  <span>prependHello</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>

<span>"foo"</span><span>.</span><span>prependHello</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>
<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace" target="_blank" rel="noopener noreferrer">24</a>:</p>
<div><pre><code><span>// types/jquery-plugin/index.d.ts</span>

<span>declare</span> <span>namespace</span> JQuery <span>{</span>
  <span>interface</span> <span>CustomOptions</span> <span>{</span>
    bar<span>:</span> <span>string</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>interface</span> <span>JQueryStatic</span> <span>{</span>
  <span>foo</span><span>(</span>options<span>:</span> JQuery<span>.</span>CustomOptions<span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>// src/index.ts</span>

jQuery<span>.</span><span>foo</span><span>(</span><span>{</span>
  bar<span>:</span> <span>""</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="在-npm-包或-umd-库中扩展全局变量"> 在 npm 包或 UMD 库中扩展全局变量</h3>
<p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>
<h4 id="declare-global"> <code>declare global</code></h4>
<p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global" target="_blank" rel="noopener noreferrer">25</a>:</p>
<div><pre><code><span>// types/foo/index.d.ts</span>

<span>declare</span> global <span>{</span>
  <span>interface</span> <span>String</span> <span>{</span>
    <span>prependHello</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>{</span><span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>"bar"</span><span>.</span><span>prependHello</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>
<h3 id="模块插件"> 模块插件</h3>
<p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>
<h4 id="declare-module"> <code>declare module</code></h4>
<p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module" target="_blank" rel="noopener noreferrer">26</a>:</p>
<div><pre><code><span>// types/moment-plugin/index.d.ts</span>

<span>import</span> <span>*</span> <span>as</span> moment <span>from</span> <span>"moment"</span><span>;</span>

<span>declare</span> <span>module</span> <span>"moment"</span> <span>{</span>
  <span>export</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> moment<span>.</span>CalendarKey<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>import</span> <span>*</span> <span>as</span> moment <span>from</span> <span>"moment"</span><span>;</span>
<span>import</span> <span>"moment-plugin"</span><span>;</span>

moment<span>.</span><span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module" target="_blank" rel="noopener noreferrer">27</a>:</p>
<div><pre><code><span>// types/foo-bar.d.ts</span>

<span>declare</span> <span>module</span> <span>"foo"</span> <span>{</span>
  <span>export</span> <span>interface</span> <span>Foo</span> <span>{</span>
    foo<span>:</span> <span>string</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>declare</span> <span>module</span> <span>"bar"</span> <span>{</span>
  <span>export</span> <span>function</span> <span>bar</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>import</span> <span>{</span> Foo <span>}</span> <span>from</span> <span>"foo"</span><span>;</span>
<span>import</span> <span>*</span> <span>as</span> bar <span>from</span> <span>"bar"</span><span>;</span>

<span>let</span> f<span>:</span> Foo<span>;</span>
bar<span>.</span><span>bar</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="声明文件中的依赖"> 声明文件中的依赖</h3>
<p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型:</p>
<div><pre><code><span>// types/moment-plugin/index.d.ts</span>

<span>import</span> <span>*</span> <span>as</span> moment <span>from</span> <span>"moment"</span><span>;</span>

<span>declare</span> <span>module</span> <span>"moment"</span> <span>{</span>
  <span>export</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> moment<span>.</span>CalendarKey<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>
<h4 id="三斜线指令"> 三斜线指令</h4>
<p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>
<p>但是在声明文件中，它还是有一定的用武之地。</p>
<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>:</p>
<ul>
<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>
<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>
</ul>
<h5 id="书写一个全局变量的声明文件"> <strong>书写</strong>一个全局变量的声明文件</h5>
<p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives" target="_blank" rel="noopener noreferrer">28</a>:</p>
<div><pre><code><span>// types/jquery-plugin/index.d.ts</span>

<span>/// &lt;reference types="jquery" /></span>

<span>declare</span> <span>function</span> <span>foo</span><span>(</span>options<span>:</span> JQuery<span>.</span>AjaxSettings<span>)</span><span>:</span> <span>string</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>foo</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>
<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>
<h5 id="依赖一个全局变量的声明文件"> <strong>依赖</strong>一个全局变量的声明文件</h5>
<p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global" target="_blank" rel="noopener noreferrer">29</a>:</p>
<div><pre><code><span>// types/node-plugin/index.d.ts</span>

<span>/// &lt;reference types="node" /></span>

<span>export</span> <span>function</span> <span>foo</span><span>(</span>p<span>:</span> NodeJS<span>.</span>Process<span>)</span><span>:</span> <span>string</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>// src/index.ts</span>

<span>import</span> <span>{</span> foo <span>}</span> <span>from</span> <span>"node-plugin"</span><span>;</span>

<span>foo</span><span>(</span>global<span>.</span>process<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>
<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>
<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>
<h5 id="拆分声明文件"> 拆分声明文件</h5>
<p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的:</p>
<div><pre><code><span>// node_modules/@types/jquery/index.d.ts</span>

<span>/// &lt;reference types="sizzle" /></span>
<span>/// &lt;reference path="JQueryStatic.d.ts" /></span>
<span>/// &lt;reference path="JQuery.d.ts" /></span>
<span>/// &lt;reference path="misc.d.ts" /></span>
<span>/// &lt;reference path="legacy.d.ts" /></span>

<span>export</span> <span>=</span> jQuery<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是: <code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>
<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>
<h5 id="其他三斜线指令"> 其他三斜线指令</h5>
<p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a href="http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html" target="_blank" rel="noopener noreferrer">官网</a>。</p>
<h3 id="自动生成声明文件"> 自动生成声明文件</h3>
<p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p>
<p>我们可以在命令行中添加 <code>--declaration</code>(简写 <code>-d</code>)，或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例:</p>
<div><pre><code><span>{</span>
  <span>"compilerOptions"</span><span>:</span> <span>{</span>
    <span>"module"</span><span>:</span> <span>"commonjs"</span><span>,</span>
    <span>"outDir"</span><span>:</span> <span>"lib"</span><span>,</span>
    <span>"declaration"</span><span>:</span> <span>true</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p>
<p>运行 <code>tsc</code> 之后，目录结构如下<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts" target="_blank" rel="noopener noreferrer">30</a>:</p>
<div><pre><code>/path/to/project
├── lib
| ├── bar
| | ├── index.d.ts
| | └── index.js
| ├── index.d.ts
| └── index.js
├── src
| ├── bar
| | └── index.ts
| └── index.ts
├── package.json
└── tsconfig.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是:</p>
<div><pre><code><span>// src/index.ts</span>

<span>export</span> <span>*</span> <span>from</span> <span>"./bar"</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>// src/bar/index.ts</span>

<span>export</span> <span>function</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>// lib/index.d.ts</span>

<span>export</span> <span>*</span> <span>from</span> <span>"./bar"</span><span>;</span>
<span>export</span> <span>default</span> <span>function</span> <span>foo</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>// lib/bar/index.d.ts</span>

<span>export</span> <span>declare</span> <span>function</span> <span>bar</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p>
<p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from 'foo'</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from 'foo/lib/bar'</code> 导入一个子模块时，也获得对应的类型提示。</p>
<p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了:</p>
<ul>
<li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li>
<li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>(sourcemap)文件</li>
<li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li>
</ul>
<h2 id="发布声明文件"> 发布声明文件</h2>
<p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p>
<p>此时有两种方案:</p>
<ol>
<li>将声明文件和源码放在一起</li>
<li>将声明文件发布到 <code>@types</code> 下</li>
</ol>
<p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p>
<p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p>
<h3 id="将声明文件和源码放在一起"> 将声明文件和源码放在一起</h3>
<p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p>
<p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别:</p>
<ul>
<li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li>
<li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li>
<li>针对入口文件(<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件)，编写一个同名不同后缀的 <code>.d.ts</code> 文件</li>
</ul>
<p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如:</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"foo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"lib/index.js"</span><span>,</span>
  <span>"types"</span><span>:</span> <span>"foo.d.ts"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p>
<p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p>
<p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p>
<p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件(<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件)是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p>
<p>比如 <code>package.json</code> 是这样时:</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"foo"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"1.0.0"</span><span>,</span>
  <span>"main"</span><span>:</span> <span>"lib/index.js"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p>
<p>有的库为了支持导入子模块，比如 <code>import bar from 'foo/lib/bar'</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p>
<h3 id="将声明文件发布到-types-下"> 将声明文件发布到 <code>@types</code> 下</h3>
<p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p>
<p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p>
<p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p>
<p>在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 中创建一个新的类型声明，需要用到一些工具，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 的文档中已经有了<a href="https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package" target="_blank" rel="noopener noreferrer">详细的介绍</a>，这里就不赘述了，以官方文档为准。</p>
<p>如果大家有此类需求，可以参考下笔者<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30336/files" target="_blank" rel="noopener noreferrer">提交的 pull-request</a> 。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/writing-declaration-files.html" target="_blank" rel="noopener noreferrer">Writing Declaration Files</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration%20files/Introduction.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html" target="_blank" rel="noopener noreferrer">Triple-Slash Directives</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash%20Directives.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="https://github.com/Microsoft/TypeScript/issues/22217#issuecomment-369783776" target="_blank" rel="noopener noreferrer">typeRoots or paths</a></li>
<li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">原始数据类型</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/primitive-data-types/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/primitive-data-types/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>JavaScript 的类型分为两种: 原始数据类型([Primitive data types][])和对象类型(Object types)。</p>
<p>原始数据类型包括: 布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 [ES6 中的新类型 <code>Symbol</code>][]。</p>
<p>本节主要介绍<strong>前五种</strong>原始数据类型在 TypeScript 中的应用。</p>
]]></summary>
    <content type="html"><![CDATA[<p>JavaScript 的类型分为两种: 原始数据类型(<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener noreferrer">Primitive data types</a>)和对象类型(Object types)。</p>
<p>原始数据类型包括: 布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener noreferrer">ES6 中的新类型 <code>Symbol</code></a>。</p>
<p>本节主要介绍<strong>前五种</strong>原始数据类型在 TypeScript 中的应用。</p>

<h2 id="布尔值"> 布尔值</h2>
<p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型:</p>
<div><pre><code><span>let</span> isDone<span>:</span> <span>boolean</span> <span>=</span> <span>false</span><span>;</span>

<span>// 编译通过</span>
<span>// 后面约定，未强调编译错误的代码片段，默认为编译通过</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值:</p>
<div><pre><code><span>let</span> createdByNewBoolean<span>:</span> <span>boolean</span> <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>1</span><span>)</span><span>;</span>

<span>// Type 'Boolean' is not assignable to type 'boolean'.</span>
<span>//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象:</p>
<div><pre><code><span>let</span> createdByNewBoolean<span>:</span> Boolean <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型:</p>
<div><pre><code><span>let</span> createdByBoolean<span>:</span> <span>boolean</span> <span>=</span> <span>Boolean</span><span>(</span><span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在 TypeScript 中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型(除了 <code>null</code> 和 <code>undefined</code>)一样，不再赘述。</p>
<h2 id="数值"> 数值</h2>
<p>使用 <code>number</code> 定义数值类型:</p>
<div><pre><code><span>let</span> decLiteral<span>:</span> <span>number</span> <span>=</span> <span>6</span><span>;</span>
<span>let</span> hexLiteral<span>:</span> <span>number</span> <span>=</span> <span>0xf00d</span><span>;</span>
<span>// ES6 中的二进制表示法</span>
<span>let</span> binaryLiteral<span>:</span> <span>number</span> <span>=</span> <span>0b1010</span><span>;</span>
<span>// ES6 中的八进制表示法</span>
<span>let</span> octalLiteral<span>:</span> <span>number</span> <span>=</span> <span>0o744</span><span>;</span>
<span>let</span> notANumber<span>:</span> <span>number</span> <span>=</span> <span>NaN</span><span>;</span>
<span>let</span> infinityNumber<span>:</span> <span>number</span> <span>=</span> <span>Infinity</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>编译结果:</p>
<div><pre><code><span>var</span> decLiteral <span>=</span> <span>6</span><span>;</span>
<span>var</span> hexLiteral <span>=</span> <span>0xf00d</span><span>;</span>
<span>// ES6 中的二进制表示法</span>
<span>var</span> binaryLiteral <span>=</span> <span>10</span><span>;</span>
<span>// ES6 中的八进制表示法</span>
<span>var</span> octalLiteral <span>=</span> <span>484</span><span>;</span>
<span>var</span> notANumber <span>=</span> <span>NaN</span><span>;</span>
<span>var</span> infinityNumber <span>=</span> <span>Infinity</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>其中 <code>0b1010</code> 和 <code>0o744</code> 是 <a href="http://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener noreferrer">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>
<h2 id="字符串"> 字符串</h2>
<p>使用 <code>string</code> 定义字符串类型:</p>
<div><pre><code><span>let</span> myName<span>:</span> <span>string</span> <span>=</span> <span>"Tom"</span><span>;</span>
<span>let</span> myAge<span>:</span> <span>number</span> <span>=</span> <span>25</span><span>;</span>

<span>// 模板字符串</span>
<span>let</span> sentence<span>:</span> <span>string</span> <span>=</span> <span><span>`</span><span>Hello, my name is </span><span><span>${</span>myName<span>}</span></span><span>.
I'll be </span><span><span>${</span>myAge <span>+</span> <span>1</span><span>}</span></span><span> years old next month.</span><span>`</span></span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>编译结果:</p>
<div><pre><code><span>var</span> myName <span>=</span> <span>"Tom"</span><span>;</span>
<span>var</span> myAge <span>=</span> <span>25</span><span>;</span>
<span>// 模板字符串</span>
<span>var</span> sentence <span>=</span>
  <span>"Hello, my name is "</span> <span>+</span>
  myName <span>+</span>
  <span>".\nI'll be "</span> <span>+</span>
  <span>(</span>myAge <span>+</span> <span>1</span><span>)</span> <span>+</span>
  <span>" years old next month."</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>其中 <code>`</code> 用来定义 <a href="http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener noreferrer">ES6 中的模板字符串</a>，<code>${expr}</code> 用来在模板字符串中嵌入表达式。</p>
<h2 id="空值"> 空值</h2>
<p>JavaScript 没有空值(Void)的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数:</p>
<div><pre><code><span>function</span> <span>alertName</span><span>(</span><span>)</span><span>:</span> <span>void</span> <span>{</span>
  <span>alert</span><span>(</span><span>"My name is Tom"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>声明一个 <code>void</code> 类型的变量没有什么用，因为您只能将它赋值为 <code>undefined</code> 和 <code>null</code>:</p>
<div><pre><code><span>let</span> unusable<span>:</span> <span>void</span> <span>=</span> <span>undefined</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="null-和-undefined"> Null 和 Undefined</h2>
<p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型:</p>
<div><pre><code><span>let</span> u<span>:</span> <span>undefined</span> <span>=</span> <span>undefined</span><span>;</span>
<span>let</span> n<span>:</span> <span>null</span> <span>=</span> <span>null</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量:</p>
<div><pre><code><span>// 这样不会报错</span>
<span>let</span> num<span>:</span> <span>number</span> <span>=</span> <span>undefined</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 这样也不会报错</span>
<span>let</span> u<span>:</span> <span>undefined</span><span>;</span>
<span>let</span> num<span>:</span> <span>number</span> <span>=</span> u<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量:</p>
<div><pre><code><span>let</span> u<span>:</span> <span>void</span><span>;</span>
<span>let</span> num<span>:</span> <span>number</span> <span>=</span> u<span>;</span>

<span>// Type 'void' is not assignable to type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">Basic Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener noreferrer">Primitive data types</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener noreferrer">ES6 中的新类型 <code>Symbol</code></a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener noreferrer">ES6 中的二进制和八进制表示法</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener noreferrer">ES6 中的模板字符串</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">基础</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。</p>

<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./primitive-data-types.html">原始数据类型</a></p>
</li>
<li>
<p><a href="./any.html">任意值</a></p>
</li>
<li>
<p><a href="./type-inference.html">类型推论</a></p>
</li>
<li>
<p><a href="./union-types.html">联合类型</a></p>
</li>
<li>
<p><a href="./type-of-object-interfaces.html">对象的类型——接口</a></p>
</li>
<li>
<p><a href="./type-of-array.html">数组的类型</a></p>
</li>
<li>
<p><a href="./type-of-function.html">函数的类型</a></p>
</li>
<li>
<p><a href="./type-assertion.html">类型断言</a></p>
</li>
<li>
<p><a href="./declaration-files.html">声明文件</a></p>
</li>
<li>
<p><a href="./built-in-objects.html">内置对象</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">函数的类型</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/type-of-function/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/type-of-function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html" target="_blank" rel="noopener noreferrer">函数是 JavaScript 中的一等公民</a></p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html" target="_blank" rel="noopener noreferrer">函数是 JavaScript 中的一等公民</a></p>
</blockquote>

<h2 id="函数声明"> 函数声明</h2>
<p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明(Function Declaration)和函数表达式(Function Expression):</p>
<div><pre><code><span>// 函数声明(Function Declaration)</span>
<span>function</span> <span>sum</span><span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>

<span>// 函数表达式(Function Expression)</span>
<span>let</span> <span>mySum</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单:</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，<strong>输入多余的(或者少于要求的)参数，是不被允许的</strong>:</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>
<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>

<span>// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>function</span> <span>sum</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span>
<span>sum</span><span>(</span><span>1</span><span>)</span><span>;</span>

<span>// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="函数表达式"> 函数表达式</h2>
<p>如果要我们现在写一个对函数表达式(Function Expression)的定义，可能会写成这样:</p>
<div><pre><code><span>let</span> <span>mySum</span> <span>=</span> <span>function</span> <span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样:</p>
<div><pre><code><span>let</span> <span>mySum</span><span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>=></span> <span>number</span> <span>=</span> <span>function</span> <span>(</span>
  x<span>:</span> <span>number</span><span>,</span>
  y<span>:</span> <span>number</span>
<span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> x <span>+</span> y<span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>
<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener noreferrer">ES6 中的箭头函数</a>。</p>
<h2 id="用接口定义函数的形状"> 用接口定义函数的形状</h2>
<p>我们也可以使用接口的方式来定义一个函数需要符合的形状:</p>
<div><pre><code><span>interface</span> <span>SearchFunc</span> <span>{</span>
  <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span><span>;</span>
<span>}</span>

<span>let</span> mySearch<span>:</span> SearchFunc<span>;</span>
<span>mySearch</span> <span>=</span> <span>function</span> <span>(</span>source<span>:</span> <span>string</span><span>,</span> subString<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> source<span>.</span><span>search</span><span>(</span>subString<span>)</span> <span>!==</span> <span>-</span><span>1</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="可选参数"> 可选参数</h2>
<p>前面提到，输入多余的(或者少于要求的)参数，是不允许的。那么如何定义可选的参数呢?</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数:</p>
<div><pre><code><span>function</span> <span>buildName</span><span>(</span>firstName<span>:</span> <span>string</span><span>,</span> lastName<span>?</span><span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>lastName<span>)</span> <span>{</span>
    <span>return</span> firstName <span>+</span> <span>" "</span> <span>+</span> lastName<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> firstName<span>;</span>
  <span>}</span>
<span>}</span>
<span>let</span> tomcat <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>,</span> <span>"Cat"</span><span>)</span><span>;</span>
<span>let</span> tom <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>:</p>
<div><pre><code><span>function</span> <span>buildName</span><span>(</span>firstName<span>?</span><span>:</span> <span>string</span><span>,</span> lastName<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>firstName<span>)</span> <span>{</span>
    <span>return</span> firstName <span>+</span> <span>" "</span> <span>+</span> lastName<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> lastName<span>;</span>
  <span>}</span>
<span>}</span>
<span>let</span> tomcat <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>,</span> <span>"Cat"</span><span>)</span><span>;</span>
<span>let</span> tom <span>=</span> <span>buildName</span><span>(</span><span>undefined</span><span>,</span> <span>"Tom"</span><span>)</span><span>;</span>

<span>// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="参数默认值"> 参数默认值</h2>
<p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>:</p>
<div><pre><code><span>function</span> <span>buildName</span><span>(</span>firstName<span>:</span> <span>string</span><span>,</span> lastName<span>:</span> <span>string</span> <span>=</span> <span>"Cat"</span><span>)</span> <span>{</span>
  <span>return</span> firstName <span>+</span> <span>" "</span> <span>+</span> lastName<span>;</span>
<span>}</span>
<span>let</span> tomcat <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>,</span> <span>"Cat"</span><span>)</span><span>;</span>
<span>let</span> tom <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时就不受「可选参数必须接在必需参数后面」的限制了:</p>
<div><pre><code><span>function</span> <span>buildName</span><span>(</span>firstName<span>:</span> <span>string</span> <span>=</span> <span>"Tom"</span><span>,</span> lastName<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> firstName <span>+</span> <span>" "</span> <span>+</span> lastName<span>;</span>
<span>}</span>
<span>let</span> tomcat <span>=</span> <span>buildName</span><span>(</span><span>"Tom"</span><span>,</span> <span>"Cat"</span><span>)</span><span>;</span>
<span>let</span> cat <span>=</span> <span>buildName</span><span>(</span><span>undefined</span><span>,</span> <span>"Cat"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>关于默认参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC" target="_blank" rel="noopener noreferrer">ES6 中函数参数的默认值</a>。</p>
</blockquote>
<h2 id="剩余参数"> 剩余参数</h2>
<p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数(rest 参数):</p>
<div><pre><code><span>function</span> <span>push</span><span>(</span><span>array<span>,</span> <span>...</span>items</span><span>)</span> <span>{</span>
  items<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>item</span><span>)</span> <span>{</span>
    array<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>push</span><span>(</span>a<span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它:</p>
<div><pre><code><span>function</span> <span>push</span><span>(</span>array<span>:</span> <span>any</span><span>[</span><span>]</span><span>,</span> <span>...</span>items<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>
  items<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span>item<span>)</span> <span>{</span>
    array<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>push</span><span>(</span>a<span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">ES6 中的 rest 参数</a>。</p>
<h2 id="重载"> 重载</h2>
<p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>'hello'</code> 的时候，输出反转的字符串 <code>'olleh'</code>。</p>
<p>利用联合类型，我们可以这么实现:</p>
<div><pre><code><span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>number</span> <span>|</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>|</span> <span>string</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"number"</span><span>)</span> <span>{</span>
    <span>return</span> <span>Number</span><span>(</span>x<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"string"</span><span>)</span> <span>{</span>
    <span>return</span> x<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</p>
<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型:</p>
<div><pre><code><span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span><span>;</span>
<span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>string</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>function</span> <span>reverse</span><span>(</span>x<span>:</span> <span>number</span> <span>|</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>|</span> <span>string</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"number"</span><span>)</span> <span>{</span>
    <span>return</span> <span>Number</span><span>(</span>x<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>typeof</span> x <span>===</span> <span>"string"</span><span>)</span> <span>{</span>
    <span>return</span> x<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>
<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="noopener noreferrer">Functions</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types" target="_blank" rel="noopener noreferrer">Functions # Function Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener noreferrer">JS 函数式编程指南</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener noreferrer">ES6 中的箭头函数</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/function#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC" target="_blank" rel="noopener noreferrer">ES6 中函数参数的默认值</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">ES6 中的 rest 参数</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">数组的类型</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/type-of-array/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/type-of-array/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>

<h2 id="「类型-方括号」表示法"> 「类型 + 方括号」表示法</h2>
<p>最简单的方法是使用「类型 + 方括号」来表示数组:</p>
<div><pre><code><span>let</span> fibonacci<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>数组的项中<strong>不允许</strong>出现其他的类型:</p>
<div><pre><code><span>let</span> fibonacci<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>"1"</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span><span>;</span>

<span>// Type 'string' is not assignable to type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制:</p>
<div><pre><code><span>let</span> fibonacci<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span><span>;</span>
fibonacci<span>.</span><span>push</span><span>(</span><span>"8"</span><span>)</span><span>;</span>

<span>// Argument of type '"8"' is not assignable to parameter of type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>
<h2 id="数组泛型"> 数组泛型</h2>
<p>我们也可以使用数组泛型(Array Generic) <code>Array&lt;elemType&gt;</code> 来表示数组:</p>
<div><pre><code><span>let</span> fibonacci<span>:</span> <span>Array</span><span>&lt;</span><span>number</span><span>></span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>关于泛型，可以参考<a href="./../advanced/generics.html">泛型</a>一章。</p>
<h2 id="用接口表示数组"> 用接口表示数组</h2>
<p>接口也可以用来描述数组:</p>
<div><pre><code><span>interface</span> <span>NumberArray</span> <span>{</span>
  <span>[</span>index<span>:</span> <span>number</span><span>]</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>
<span>let</span> fibonacci<span>:</span> NumberArray <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>NumberArray</code> 表示: 只要索引的类型是数字时，那么值的类型必须是数字。</p>
<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>
<p>不过有一种情况例外，那就是它常用来表示类数组。</p>
<h2 id="类数组"> 类数组</h2>
<p>类数组(Array-like Object)不是数组类型，比如 <code>arguments</code>:</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> args<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> arguments<span>;</span>
<span>}</span>

<span>// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口:</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> args<span>:</span> <span>{</span>
    <span>[</span>index<span>:</span> <span>number</span><span>]</span><span>:</span> <span>number</span><span>;</span>
    length<span>:</span> <span>number</span><span>;</span>
    callee<span>:</span> <span>Function</span><span>;</span>
  <span>}</span> <span>=</span> arguments<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>
<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等:</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> args<span>:</span> IArguments <span>=</span> arguments<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是:</p>
<div><pre><code><span>interface</span> <span>IArguments</span> <span>{</span>
  <span>[</span>index<span>:</span> <span>number</span><span>]</span><span>:</span> <span>any</span><span>;</span>
  length<span>:</span> <span>number</span><span>;</span>
  callee<span>:</span> <span>Function</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>关于内置对象，可以参考<a href="./built-in-objects.html">内置对象</a>一章。</p>
<h2 id="any-在数组中的应用"> any 在数组中的应用</h2>
<p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型:</p>
<div><pre><code><span>let</span> list<span>:</span> <span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>"xcatliu"</span><span>,</span> <span>25</span><span>,</span> <span>{</span> website<span>:</span> <span>"http://xcatliu.com"</span> <span>}</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#array" target="_blank" rel="noopener noreferrer">Basic Types # Array</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic%20Types.html#%E6%95%B0%E7%BB%84" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
<li><a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types" target="_blank" rel="noopener noreferrer">Interfaces # Indexable Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">对象的类型——接口</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/type-of-object-interfaces/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/type-of-object-interfaces/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在 TypeScript 中，我们使用接口(Interfaces)来定义对象的类型。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在 TypeScript 中，我们使用接口(Interfaces)来定义对象的类型。</p>

<h2 id="什么是接口"> 什么是接口</h2>
<p>在面向对象语言中，接口(Interfaces)是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类(classes)去实现(implement)。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="./../advanced/class-and-interfaces.html#类实现接口">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状(Shape)」进行描述。</p>
<h2 id="简单的例子"> 简单的例子</h2>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>
<p>接口一般首字母大写。<a href="https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx" target="_blank" rel="noopener noreferrer">有的编程语言中会建议接口的名称加上 <code>I</code> 前缀</a>。</p>
<p>定义的变量比接口少了一些属性是不允许的:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
<span>}</span><span>;</span>

<span>// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.</span>
<span>//   Property 'age' is missing in type '{ name: string; }'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>多一些属性也是不允许的:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>

<span>// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.</span>
<span>//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>
<h2 id="可选属性"> 可选属性</h2>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可选属性的含义是该属性可以不存在。</p>
<p>这时<strong>仍然不允许添加未定义的属性</strong>:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>

<span>// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.</span>
<span>//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="任意属性"> 任意属性</h2>
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>
<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>

<span>// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span>
<span>// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.</span>
<span>//   Index signatures are incompatible.</span>
<span>//     Type 'string | number' is not assignable to type 'string'.</span>
<span>//       Type 'number' is not assignable to type 'string'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>
<p>另外，在报错信息中可以看出，此时 <code>{ name: 'Tom', age: 25, gender: 'male' }</code> 的类型被推断成了 <code>{ [x: string]: string | number; name: string; age: number; gender: string; }</code>，这是联合类型和接口的结合。</p>
<h2 id="只读属性"> 只读属性</h2>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  <span>readonly</span> id<span>:</span> <span>number</span><span>;</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  id<span>:</span> <span>89757</span><span>,</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>

tom<span>.</span>id <span>=</span> <span>9527</span><span>;</span>

<span>// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>:</p>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  <span>readonly</span> id<span>:</span> <span>number</span><span>;</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>?</span><span>:</span> <span>number</span><span>;</span>
  <span>[</span>propName<span>:</span> <span>string</span><span>]</span><span>:</span> <span>any</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> Person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  gender<span>:</span> <span>"male"</span><span>,</span>
<span>}</span><span>;</span>

tom<span>.</span>id <span>=</span> <span>89757</span><span>;</span>

<span>// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.</span>
<span>//   Property 'id' is missing in type '{ name: string; gender: string; }'.</span>
<span>// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>
<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener noreferrer">Interfaces</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">联合类型</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/union-types/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/union-types/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>联合类型(Union Types)表示取值可以为多种类型中的一种。</p>
]]></summary>
    <content type="html"><![CDATA[<p>联合类型(Union Types)表示取值可以为多种类型中的一种。</p>

<h2 id="简单的例子"> 简单的例子</h2>
<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>
myFavoriteNumber <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>
myFavoriteNumber <span>=</span> <span>true</span><span>;</span>

<span>// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.</span>
<span>//   Type 'boolean' is not assignable to type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>联合类型使用 <code>|</code> 分隔每个类型。</p>
<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p>
<h2 id="访问联合类型的属性或方法"> 访问联合类型的属性或方法</h2>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>:</p>
<div><pre><code><span>function</span> <span>getLength</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> something<span>.</span>length<span>;</span>
<span>}</span>

<span>// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span>
<span>//   Property 'length' does not exist on type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的:</p>
<div><pre><code><span>function</span> <span>getString</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>string</span> <span>{</span>
  <span>return</span> something<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型:</p>
<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>;</span>
myFavoriteNumber <span>=</span> <span>"seven"</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>myFavoriteNumber<span>.</span>length<span>)</span><span>;</span> <span>// 5</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span>myFavoriteNumber<span>.</span>length<span>)</span><span>;</span> <span>// 编译时报错</span>

<span>// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" target="_blank" rel="noopener noreferrer">Advanced Types # Union Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">代码检查</title>
    <id>https://list-jiang.github.io/code/language/typescript/engineering/lint/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/engineering/lint/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>TypeScript 的代码检查应当使用 ESLint + <code>typescript-eslint-parser</code>。</p>
<h2 id="什么是代码检查"> 什么是代码检查</h2>
<p>代码检查主要是用来发现代码错误、统一代码风格。</p>
<p>在 JavaScript 项目中，我们一般使用 ESLint 来进行代码检查。它通过插件化的特性极大的丰富了适用范围，搭配 <code>typescript-eslint-parser</code> 之后，甚至可以用来检查 TypeScript 代码。</p>
<h2 id="为什么需要代码检查"> 为什么需要代码检查</h2>
<p>有人会觉得，JavaScript 非常灵活，所以需要代码检查。而 TypeScript 已经能够在编译阶段检查出很多问题了，为什么还需要代码检查呢?</p>
<p>因为 TypeScript 关注的重心是类型的匹配，而不是代码风格。当团队的人员越来越多时，同样的逻辑不同的人写出来可能会有很大的区别:</p>
<ul>
<li>缩进应该是四个空格还是两个空格?</li>
<li>是否应该禁用 <code>var</code>?</li>
<li>接口名是否应该以 <code>I</code> 开头?</li>
<li>是否应该强制使用 <code>===</code> 而不是 <code>==</code>?</li>
</ul>
<p>这些问题 TypeScript 不会关注，但是却影响到多人协作开发时的效率、代码的可理解性以及可维护性。</p>
<p>下面来看一个具体的例子:</p>
<div><pre><code><span>let</span> myName <span>=</span> <span>"Tom"</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>My name is </span><span><span>${</span>myNane<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>My name is </span><span><span>${</span>myName<span>.</span><span>toStrng</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span><span>`</span><span>My name is </span><span><span>${</span>myName<span>}</span></span><span>`</span></span><span>)</span><span>;</span>

<span>// tsc 报错信息:</span>
<span>//</span>
<span>// index.ts(3,27): error TS2552: Cannot find name 'myNane'. Did you mean 'myName'?</span>
<span>// index.ts(4,34): error TS2551: Property 'toStrng' does not exist on type 'string'. Did you mean 'toString'?</span>
<span>//</span>
<span>//</span>
<span>//</span>
<span>// eslint 报错信息:</span>
<span>//</span>
<span>// /path/to/index.ts</span>
<span>//   3:27  error  'myNane' is not defined         no-undef</span>
<span>//   5:38  error  Missing semicolon               semi</span>
<span>//</span>
<span>// ✖ 2 problems (2 errors, 0 warnings)</span>
<span>//   1 errors, 0 warnings potentially fixable with the `--fix` option.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><table>
<thead>
<tr>
<th>存在的问题</th>
<th><code>tsc</code> 是否报错</th>
<th><code>eslint</code> 是否报错</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>myName</code> 被误写成了 <code>myNane</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>toString</code> 被误写成了 <code>toStrng</code></td>
<td>✅️</td>
<td>❌</td>
</tr>
<tr>
<td>少了一个分号</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>上例中，由于 <code>eslint</code> 无法识别 <code>myName</code> 存在哪些方法，所以对于拼写错误的 <code>toString</code> 没有检查出来。</p>
<p>而代码风格的错误不影响编译，故少了一个分号的错误 <code>tsc</code> 没有检查出来。</p>
<p>对于未定义的变量 <code>myNane</code>，<code>tsc</code> 可以检测出来。<code>eslint</code> 需要能够独立于某个编译环境运行，所以能检测出此类错误，而对于 TypeScript 代码，这其实是一种冗余的检测了。</p>
<p>虽然发现代码错误比统一的代码风格更重要，但是当一个项目越来越庞大，开发人员也越来越多的时候，代码风格的约束还是必不可少的。</p>
<h2 id="在-typescript-中使用-eslint"> 在 TypeScript 中使用 ESLint</h2>
<h3 id="安装-eslint"> 安装 ESLint</h3>
<p>ESLint 可以安装在当前项目中或全局环境下，因为代码检查是项目的重要组成部分，所以我们一般会将它安装在当前项目中。可以运行下面的脚本来安装:</p>
<div><pre><code><span>npm</span> <span>install</span> eslint --save-dev
</code></pre>
<div><span>1</span><br></div></div><p>由于 ESLint 默认使用 <a href="https://github.com/eslint/espree" target="_blank" rel="noopener noreferrer">Espree</a> 进行语法解析，无法识别 TypeScript 的一些语法，故我们需要安装 <code>typescript-eslint-parser</code>，替代掉默认的解析器，别忘了同时安装 <code>typescript</code>:</p>
<div><pre><code><span>npm</span> <span>install</span> typescript typescript-eslint-parser --save-dev
</code></pre>
<div><span>1</span><br></div></div><p>由于 <code>typescript-eslint-parser</code> 对一部分 ESLint 规则支持性不好，故我们需要安装 <code>eslint-plugin-typescript</code>，弥补一些支持性不好的规则。</p>
<div><pre><code><span>npm</span> <span>install</span> eslint-plugin-typescript --save-dev
</code></pre>
<div><span>1</span><br></div></div><h3 id="创建配置文件"> 创建配置文件</h3>
<p>ESLint 需要一个配置文件来决定对哪些规则进行检查，配置文件的名称一般是 <code>.eslintrc.js</code> 或 <code>.eslintrc.json</code>。</p>
<p>当运行 ESLint 的时候检查一个文件的时候，它会首先尝试读取该文件的目录下的配置文件，然后再一级一级往上查找，将所找到的配置合并起来，作为当前被检查文件的配置。</p>
<p>我们在项目的根目录下创建一个 <code>.eslintrc.js</code>，内容如下:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  parser<span>:</span> <span>"typescript-eslint-parser"</span><span>,</span>
  plugins<span>:</span> <span>[</span><span>"typescript"</span><span>]</span><span>,</span>
  rules<span>:</span> <span>{</span>
    <span>// @fixable 必须使用 === 或 !==，禁止使用 == 或 !=，与 null 比较时除外</span>
    eqeqeq<span>:</span> <span>[</span>
      <span>"error"</span><span>,</span>
      <span>"always"</span><span>,</span>
      <span>{</span>
        <span>null</span><span>:</span> <span>"ignore"</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>// 类和接口的命名必须遵守帕斯卡命名法，比如 PersianCat</span>
    <span>"typescript/class-name-casing"</span><span>:</span> <span>"error"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>以上配置中，我们指定了两个规则，其中 <code>eqeqeq</code> 是 ESLint 原生的规则(它要求必须使用 <code>===</code> 或 <code>!==</code>，禁止使用 <code>==</code> 或 <code>!=</code>，与 <code>null</code> 比较时除外)，<code>typescript/class-name-casing</code> 是 <code>eslint-plugin-typescript</code> 为 ESLint 增加的规则(它要求类和接口的命名必须遵守帕斯卡命名法，比如 <code>PersianCat</code>)。</p>
<p>规则的取值一般是一个数组(上例中的 <code>eqeqeq</code>)，其中第一项是 <code>off</code>、<code>warn</code> 或 <code>error</code> 中的一个，表示关闭、警告和报错。后面的项都是该规则的其他配置。</p>
<p>如果没有其他配置的话，则可以将规则的取值简写为数组中的第一项(上例中的 <code>typescript/class-name-casing</code>)。</p>
<p>关闭、警告和报错的含义如下:</p>
<ul>
<li>关闭: 禁用此规则</li>
<li>警告: 代码检查时输出错误信息，但是不会影响到 exit code</li>
<li>报错: 发现错误时，不仅会输出错误信息，而且 exit code 将被设为 1(一般 exit code 不为 0 则表示执行出现错误)</li>
</ul>
<h3 id="检查一个-ts-文件"> 检查一个 ts 文件</h3>
<p>创建了配置文件之后，我们来创建一个 ts 文件看看是否能用 ESLint 去检查它了。</p>
<p>创建一个新文件 <code>index.ts</code>，将以下内容复制进去:</p>
<div><pre><code><span>interface</span> <span>person</span> <span>{</span>
  name<span>:</span> <span>string</span><span>;</span>
  age<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>let</span> tom<span>:</span> person <span>=</span> <span>{</span>
  name<span>:</span> <span>"Tom"</span><span>,</span>
  age<span>:</span> <span>25</span><span>,</span>
<span>}</span><span>;</span>

<span>if</span> <span>(</span>tom<span>.</span>age <span>==</span> <span>25</span><span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>tom<span>.</span>name <span>+</span> <span>"is 25 years old."</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>然后执行以下命令:</p>
<div><pre><code>./node_modules/.bin/eslint index.ts
</code></pre>
<div><span>1</span><br></div></div><p>则会得到如下报错信息:</p>
<div><pre><code>/path/to/index.ts
   <span>1</span>:11  error  Interface <span>'person'</span> must be PascalCased  typescript/class-name-casing
  <span>11</span>:13  error  Expected <span>'==='</span> and instead saw <span>'=='</span>     eqeqeq

✖ <span>2</span> problems <span>(</span><span>2</span> errors, <span>0</span> warnings<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的结果显示，刚刚配置的两个规则都生效了: 接口 <code>person</code> 必须写成帕斯卡命名规范，<code>==</code> 必须写成 <code>===</code>。</p>
<p>需要注意的是，我们使用的是 <code>./node_modules/.bin/eslint</code>，而不是全局的 <code>eslint</code> 脚本，这是因为代码检查是项目的重要组成部分，所以我们一般会将它安装在当前项目中。</p>
<p>可是每次执行这么长一段脚本颇有不便，我们可以通过在 <code>package.json</code> 中添加一个 <code>script</code> 来创建一个 npm script 来简化这个步骤:</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"eslint"</span><span>:</span> <span>"eslint index.ts"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这时只需执行 <code>npm run eslint</code> 即可。</p>
<h3 id="检查整个项目的-ts-文件"> 检查整个项目的 ts 文件</h3>
<p>我们的项目源文件一般是放在 <code>src</code> 目录下，所以需要将 <code>package.json</code> 中的 <code>eslint</code> 脚本改为对一个目录进行检查。由于 <code>eslint</code> 默认不会检查 <code>.ts</code> 后缀的文件，所以需要加上参数 <code>--ext .ts</code>:</p>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"eslint"</span><span>:</span> <span>"eslint src --ext .ts"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时执行 <code>npm run eslint</code> 即会检查 <code>src</code> 目录下的所有 <code>.ts</code> 后缀的文件。</p>
<h3 id="在-vs-code-中集成-eslint-检查"> 在 VS Code 中集成 ESLint 检查</h3>
<p>在编辑器中集成 ESLint 检查，可以在开发过程中就发现错误，极大的增加了开发效率。</p>
<p>要在 VS Code 中集成 ESLint 检查，我们需要先安装 ESLint 插件，点击「扩展」按钮，搜索 ESLint，然后安装即可。</p>
<p>VS Code 中的 ESLint 插件默认是不会检查 <code>.ts</code> 后缀的，需要在「文件 =&gt; 首选项 =&gt; 设置」中，添加以下配置:</p>
<div><pre><code><span>{</span>
  <span>"eslint.validate"</span><span>:</span> <span>[</span><span>"javascript"</span><span>,</span> <span>"javascriptreact"</span><span>,</span> <span>"typescript"</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这时再打开一个 <code>.ts</code> 文件，将鼠标移到红色提示处，即可看到这样的报错信息了:</p>
<p><img src="./../assets/vscode-eslint-error.png" alt="VS Code ESLint 错误信息" loading="lazy"></p>
<h3 id="使用-alloyteam-的-eslint-配置"> 使用 AlloyTeam 的 ESLint 配置</h3>
<p>ESLint 原生的规则和 <code>eslint-plugin-typescript</code> 的规则太多了，而且原生的规则有一些在 TypeScript 中支持的不好，需要禁用掉。</p>
<p>这里我推荐使用 <a href="https://github.com/AlloyTeam/eslint-config-alloy#typescript" target="_blank" rel="noopener noreferrer">AlloyTeam ESLint 规则中的 TypeScript 版本</a>，它已经为我们提供了一套完善的配置规则。</p>
<p>安装:</p>
<div><pre><code><span>npm</span> <span>install</span> --save-dev eslint typescript typescript-eslint-parser eslint-plugin-typescript eslint-config-alloy
</code></pre>
<div><span>1</span><br></div></div><p>在您的项目根目录下创建 <code>.eslintrc.js</code>，并将以下内容复制到文件中:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>extends</span><span>:</span> <span>[</span><span>"eslint-config-alloy/typescript"</span><span>]</span><span>,</span>
  globals<span>:</span> <span>{</span>
    <span>// 这里填入您的项目需要的全局变量</span>
    <span>// 这里值为 false 表示这个全局变量不允许被重新赋值，比如:</span>
    <span>//</span>
    <span>// jQuery: false,</span>
    <span>// $: false</span>
  <span>}</span><span>,</span>
  rules<span>:</span> <span>{</span>
    <span>// 这里填入您的项目需要的个性化配置，比如:</span>
    <span>//</span>
    <span>// // @fixable 一个缩进必须用两个空格替代</span>
    <span>// 'indent': [</span>
    <span>//     'error',</span>
    <span>//     2,</span>
    <span>//     {</span>
    <span>//         SwitchCase: 1,</span>
    <span>//         flatTernaryExpressions: true</span>
    <span>//     }</span>
    <span>// ]</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="使用-eslint-检查-tsx-文件"> 使用 ESLint 检查 tsx 文件</h3>
<p>如果需要同时支持对 tsx 文件的检查，则需要对以上步骤做一些调整:</p>
<h4 id="安装-eslint-plugin-react"> 安装 <code>eslint-plugin-react</code></h4>
<div><pre><code><span>npm</span> <span>install</span> --save-dev eslint-plugin-react
</code></pre>
<div><span>1</span><br></div></div><h4 id="package-json-中的-scripts-eslint-添加-tsx-后缀"> package.json 中的 <code>scripts.eslint</code> 添加 <code>.tsx</code> 后缀</h4>
<div><pre><code><span>{</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"eslint"</span><span>:</span> <span>"eslint src --ext .ts,.tsx"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="vs-code-的配置中新增-typescriptreact-检查"> VS Code 的配置中新增 typescriptreact 检查</h4>
<div><pre><code><span>{</span>
  <span>"eslint.validate"</span><span>:</span> <span>[</span>
    <span>"javascript"</span><span>,</span>
    <span>"javascriptreact"</span><span>,</span>
    <span>"typescript"</span><span>,</span>
    <span>"typescriptreact"</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="使用-alloyteam-eslint-规则中的-typescript-react-版本"> 使用 AlloyTeam ESLint 规则中的 TypeScript React 版本</h4>
<p><a href="https://github.com/AlloyTeam/eslint-config-alloy#typescript-react" target="_blank" rel="noopener noreferrer">AlloyTeam ESLint 规则中的 TypeScript React 版本</a></p>
<h2 id="troubleshootings"> Troubleshootings</h2>
<h3 id="cannot-find-module-typescript-eslint-parser"> Cannot find module typescript-eslint-parser</h3>
<p>您运行的是全局的 eslint，需要改为运行 <code>./node_modules/.bin/eslint</code>。</p>
<h3 id="cannot-read-property-type-of-null"> cannot read property type of null</h3>
<p>需要关闭 <code>eslint-plugin-react</code> 中的规则 <code>react/jsx-indent</code>。</p>
<p>如果仍然报错，多半是因为某些规则需要被关闭，可以使用「二分排错法」检查是哪个规则造成了错误。也欢迎<a href="https://github.com/AlloyTeam/eslint-config-alloy/issues/new" target="_blank" rel="noopener noreferrer">给 eslint-config-alloy 提 issue</a>。</p>
<h3 id="vs-code-没有显示出-eslint-的报错"> VS Code 没有显示出 ESLint 的报错</h3>
<ol>
<li>检查「文件 =&gt; 首选项 =&gt; 设置」中有没有配置正确</li>
<li>检查必要的 npm 包有没有安装</li>
<li>检查 <code>.eslintrc.js</code> 有没有配置</li>
<li>检查文件是不是在 <code>.eslintignore</code> 中</li>
</ol>
<p>如果以上步骤都不奏效，则可以在「文件 =&gt; 首选项 =&gt; 设置」中配置 <code>&quot;eslint.trace.server&quot;: &quot;messages&quot;</code>，按 <code>Ctrl</code>+<code>Shift</code>+<code>U</code> 打开输出面板，然后选择 ESLint 输出，查看具体错误。</p>
<p><img src="./../assets/vscode-output-eslint.png" alt="VS Code 的 ESLint 输出" loading="lazy"></p>
<h3 id="为什么-eslint-无法检查出使用了未定义的变量-no-undef-规则为什么被关闭了"> 为什么 ESLint 无法检查出使用了未定义的变量(<code>no-undef</code> 规则为什么被关闭了)</h3>
<p>因为 <code>typescript-eslint-parser</code> <a href="https://github.com/eslint/typescript-eslint-parser/issues/416" target="_blank" rel="noopener noreferrer">无法支持 <code>no-undef</code> 规则</a>。它针对正确的接口定义会报错。</p>
<p>所以我们一般会关闭 <code>no-undef</code> 规则。</p>
<h3 id="为什么有些定义了的变量-比如使用-enum-定义的变量-未使用-eslint-却没有报错"> 为什么有些定义了的变量(比如使用 <code>enum</code> 定义的变量)未使用，ESLint 却没有报错</h3>
<p>因为无法支持这种变量定义的检查。建议在 <code>tsconfig.json</code> 中添加以下配置，使 <code>tsc</code> 编译过程能够检查出定义了未使用的变量:</p>
<div><pre><code><span>{</span>
  <span>"compilerOptions"</span><span>:</span> <span>{</span>
    <span>"noUnusedLocals"</span><span>:</span> <span>true</span><span>,</span>
    <span>"noUnusedParameters"</span><span>:</span> <span>true</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="启用了-nounusedparameters-之后-只使用了第二个参数-但是又必须传入第一个参数-这就会报错了"> 启用了 noUnusedParameters 之后，只使用了第二个参数，但是又必须传入第一个参数，这就会报错了</h3>
<p>第一个参数以下划线开头即可，参考 <a href="https://github.com/Microsoft/TypeScript/issues/9458" target="_blank" rel="noopener noreferrer">https://github.com/Microsoft/TypeScript/issues/9458</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">工程</title>
    <id>https://list-jiang.github.io/code/language/typescript/engineering/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/engineering/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>掌握了 TypeScript 的语法就像学会了砌墙的工艺。</p>
<p>我们学习 TypeScript 的目的不是为了造一间小茅屋，而是为了造高楼大厦，这也正是 TypeScript 的类型系统带来的优势。</p>
<p>那么一项大工程应该如何开展呢? 本部分的内容就会介绍 TypeScript 工程化的最佳实践，具体内容包括:</p>
<ul>
<li><a href="./lint.html">代码检查</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">安装 TypeScript</title>
    <id>https://list-jiang.github.io/code/language/typescript/intro/get-typescript/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/intro/get-typescript/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>TypeScript 的命令行工具安装方法如下:</p>
<div><pre><code><span>npm</span> <span>install</span> -g typescript
</code></pre>
<div><span>1</span><br></div></div><p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p>
]]></summary>
    <content type="html"><![CDATA[<p>TypeScript 的命令行工具安装方法如下:</p>
<div><pre><code><span>npm</span> <span>install</span> -g typescript
</code></pre>
<div><span>1</span><br></div></div><p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p>

<p>编译一个 TypeScript 文件很简单:</p>
<div><pre><code>tsc hello.ts
</code></pre>
<div><span>1</span><br></div></div><p>我们约定使用 TypeScript 编写的文件以 <code>.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code>.tsx</code> 为后缀。</p>
<h2 id="编辑器"> 编辑器</h2>
<p>TypeScript 最大的优势便是增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。</p>
<p>主流的编辑器都支持 TypeScript，这里我推荐使用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code</a>。</p>
<p>它是一款开源，跨终端的轻量级编辑器，内置了 TypeScript 支持。</p>
<p>另外它本身也是<a href="https://github.com/Microsoft/vscode/" target="_blank" rel="noopener noreferrer">用 TypeScript 编写的</a>。</p>
<p>下载安装: <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">https://code.visualstudio.com/</a></p>
<p>获取其他编辑器或 IDE 对 TypeScript 的支持:</p>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin" target="_blank" rel="noopener noreferrer">Sublime Text</a></li>
<li><a href="https://atom.io/packages/atom-typescript" target="_blank" rel="noopener noreferrer">Atom</a></li>
<li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener noreferrer">WebStorm</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support#vim" target="_blank" rel="noopener noreferrer">Vim</a></li>
<li><a href="https://github.com/ananthakumaran/tide" target="_blank" rel="noopener noreferrer">Emacs</a></li>
<li><a href="https://github.com/palantir/eclipse-typescript" target="_blank" rel="noopener noreferrer">Eclipse</a></li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=48593" target="_blank" rel="noopener noreferrer">Visual Studio 2015</a></li>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=48739" target="_blank" rel="noopener noreferrer">Visual Studio 2013</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Hello TypeScript</title>
    <id>https://list-jiang.github.io/code/language/typescript/intro/hello-typescript/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/intro/hello-typescript/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们从一个简单的例子开始。</p>
<p>将以下代码复制到 <code>hello.ts</code> 中:</p>
<div><pre><code><span>function</span> <span>sayHello</span><span>(</span>person<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> <span>"Hello, "</span> <span>+</span> person<span>;</span>
<span>}</span>

<span>let</span> user <span>=</span> <span>"Tom"</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>sayHello</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>然后执行</p>
<div><pre><code>tsc hello.ts
</code></pre>
<div><span>1</span><br></div></div><p>这时候会生成一个编译好的文件 <code>hello.js</code>:</p>
<div><pre><code><span>function</span> <span>sayHello</span><span>(</span><span>person</span><span>)</span> <span>{</span>
  <span>return</span> <span>"Hello, "</span> <span>+</span> person<span>;</span>
<span>}</span>
<span>var</span> user <span>=</span> <span>"Tom"</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>sayHello</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>TypeScript 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以。</p>
<p>上述例子中，我们用 <code>:</code> 指定 <code>person</code> 参数类型为 <code>string</code>。但是编译为 js 之后，并没有什么检查的代码被插入进来。</p>
<p><strong>TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。</strong></p>
<blockquote>
<p><code>let</code> 是 ES6 中的关键字，和 <code>var</code> 类似，用于定义一个局部变量，可以参阅 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener noreferrer">let 和 const 命令</a>。</p>
</blockquote>
<p>下面尝试把这段代码编译一下:</p>
<div><pre><code><span>function</span> <span>sayHello</span><span>(</span>person<span>:</span> <span>string</span><span>)</span> <span>{</span>
  <span>return</span> <span>"Hello, "</span> <span>+</span> person<span>;</span>
<span>}</span>

<span>let</span> user <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>sayHello</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>编辑器中会提示错误，编译的时候也会出错:</p>
<div><pre><code>index.ts<span>(</span><span>6,22</span><span>)</span>: error TS2345: Argument of <span>type</span> <span>'number[]'</span> is not assignable to parameter of <span>type</span> <span>'string'</span><span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>但是还是生成了 js 文件:</p>
<div><pre><code><span>function</span> <span>sayHello</span><span>(</span><span>person</span><span>)</span> <span>{</span>
  <span>return</span> <span>"Hello, "</span> <span>+</span> person<span>;</span>
<span>}</span>
<span>var</span> user <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>sayHello</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>TypeScript 编译的时候即使报错了，还是会生成编译结果</strong>，我们仍然可以使用这个编译之后的文件。</p>
<p>如果要在报错的时候终止 js 文件的生成，可以在 <code>tsconfig.json</code> 中配置 <code>noEmitOnError</code> 即可。关于 <code>tsconfig.json</code>，请参阅<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener noreferrer">官方手册</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener noreferrer">中文版</a>)。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">简介</title>
    <id>https://list-jiang.github.io/code/language/typescript/intro/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本部分介绍了在学习 TypeScript 之前需要了解的知识，具体内容包括:</p>
]]></summary>
    <content type="html"><![CDATA[<p>本部分介绍了在学习 TypeScript 之前需要了解的知识，具体内容包括:</p>

<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./what-is-typescript.html">什么是 TypeScript</a></p>
</li>
<li>
<p><a href="./get-typescript.html">安装 TypeScript</a></p>
</li>
<li>
<p><a href="./hello-typescript.html">Hello TypeScript</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">什么是 TypeScript</title>
    <id>https://list-jiang.github.io/code/language/typescript/intro/what-is-typescript/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/intro/what-is-typescript/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>首先，我对 TypeScript 的理解如下:</p>
<p>[TypeScript][] 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>，它由 Microsoft 开发，代码<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener noreferrer">开源于 GitHub</a> 上。</p>
<p>其次引用[官网][typescript]的定义:</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p>
</blockquote>
<p>翻译成中文即是:</p>
<blockquote>
<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p>
</blockquote>
]]></summary>
    <content type="html"><![CDATA[<p>首先，我对 TypeScript 的理解如下:</p>
<p><a href="http://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript</a> 是 JavaScript 的一个超集，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>，它由 Microsoft 开发，代码<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener noreferrer">开源于 GitHub</a> 上。</p>
<p>其次引用<a href="http://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">官网</a>的定义:</p>
<blockquote>
<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.</p>
</blockquote>
<p>翻译成中文即是:</p>
<blockquote>
<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p>
</blockquote>

<h2 id="为什么选择-typescript"> 为什么选择 TypeScript</h2>
<p><a href="http://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript 官网</a>列举了一些优势，不过我更愿意自己总结一下:</p>
<h3 id="typescript-增加了代码的可读性和可维护性"> TypeScript 增加了代码的可读性和可维护性</h3>
<ul>
<li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li>
<li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li>
<li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>
</ul>
<h3 id="typescript-非常包容"> TypeScript 非常包容</h3>
<ul>
<li>TypeScript 是 JavaScript 的超集，<code>.js</code> 文件可以直接重命名为 <code>.ts</code> 即可</li>
<li>即使不显式的定义类型，也能够自动做出<a href="./../basics/type-inference.html">类型推论</a></li>
<li>可以定义从简单到复杂的几乎一切类型</li>
<li>即使 TypeScript 编译报错，也可以生成 JavaScript 文件</li>
<li>兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</li>
</ul>
<h3 id="typescript-拥有活跃的社区"> TypeScript 拥有活跃的社区</h3>
<ul>
<li>大部分第三方库都有提供给 TypeScript 的类型定义文件</li>
<li>Google 开发的 Angular2 就是使用 TypeScript 编写的</li>
<li>TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范</li>
</ul>
<h3 id="typescript-的缺点"> TypeScript 的缺点</h3>
<p>任何事物都是有两面性的，我认为 TypeScript 的弊端在于:</p>
<ul>
<li>有一定的学习成本，需要理解接口(Interfaces)、泛型(Generics)、类(Classes)、枚举类型(Enums)等前端工程师可能不是很熟悉的概念</li>
<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li>
<li>集成到构建流程需要一些工作量</li>
<li>可能和一些库结合的不是很完美</li>
</ul>
<p>大家可以根据自己团队和项目的情况判断是否需要使用 TypeScript。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">TypeScript 教程</title>
    <id>https://list-jiang.github.io/code/language/typescript/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，扩展了 JavaScript 的语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，扩展了 JavaScript 的语法。</p>

<h2 id="语法特性"> 语法特性</h2>
<ul>
<li>类 Classes</li>
<li>接口 Interfaces</li>
<li>模块 Modules</li>
<li>类型注解 Type annotations</li>
<li>编译时类型检查 Compile time type checking</li>
<li>Arrow 函数 (类似 C# 的 Lambda 表达式)</li>
</ul>
<blockquote>
<p>更多内容可以参考: 下方目录。</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro/">简介</a></p>
<ul>
<li><a href="./intro/what-is-typescript.html">什么是 TypeScript</a></li>
<li><a href="./intro/get-typescript.html">安装 TypeScript</a></li>
<li><a href="./intro/hello-typescript.html">Hello TypeScript</a></li>
</ul>
</li>
<li>
<p><a href="./basics/readme..html">基础</a></p>
<ul>
<li><a href="./basics/primitive-data-types.html">原始数据类型</a></li>
<li><a href="./basics/any.html">任意值</a></li>
<li><a href="./basics/type-inference.html">类型推论</a></li>
<li><a href="./basics/union-types.html">联合类型</a></li>
<li><a href="./basics/type-of-object-interfaces.html">对象的类型——接口</a></li>
<li><a href="./basics/type-of-array.html">数组的类型</a></li>
<li><a href="./basics/type-of-function.html">函数的类型</a></li>
<li><a href="./basics/type-assertion.html">类型断言</a></li>
<li><a href="./basics/declaration-files.html">声明文件</a></li>
<li><a href="./basics/built-in-objects.html">内置对象</a></li>
</ul>
</li>
<li>
<p><a href="./advanced/readme..html">进阶</a></p>
<ul>
<li><a href="./advanced/type-aliases.html">类型别名</a></li>
<li><a href="./advanced/string-literal-types.html">字符串字面量类型</a></li>
<li><a href="./advanced/tuple.html">元组</a></li>
<li><a href="./advanced/enum.html">枚举</a></li>
<li><a href="./advanced/class.html">类</a></li>
<li><a href="./advanced/class-and-interfaces.html">类与接口</a></li>
<li><a href="./advanced/generics.html">泛型</a></li>
<li><a href="./advanced/declaration-merging.html">声明合并</a></li>
<li><a href="./advanced/further-reading.html">扩展阅读</a></li>
</ul>
</li>
<li>
<p><a href="./engineering/readme..html">工程</a></p>
<ul>
<li><a href="./engineering/lint.html">代码检查</a></li>
</ul>
</li>
</ul>
<h2 id="javascript-与-typescript-的区别"> JavaScript 与 TypeScript 的区别</h2>
<p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p>
<p>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>
<h2 id="typescript-官网文档"> TypeScript 官网文档</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener noreferrer">点击查看官网</a></li>
<li><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">点击查看第三方中文文档</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">搭建 Node 开发环境</title>
    <id>https://list-jiang.github.io/code/node-js/environment/</id>
    <link href="https://list-jiang.github.io/code/node-js/environment/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Hope 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>
]]></summary>
    <content type="html"><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Hope 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>

<div><p>相关信息</p>
<p>有关 VS Code 使用教程请<a href="./../../software/vscode/">访问这里</a></p>
</div>
<h2 id="运行和调试-javascript"> 运行和调试 JavaScript</h2>
<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>
<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>
<p>假设我们在 <code>C:\Work\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>
<div><pre><code>hello/ &lt;-- workspace dir
|
+- hello.js &lt;-- JavaScript file
|
+- .vscode/ &lt;-- VS Code config
|
+- launch.json &lt;-- VS Code config file for JavaScript
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>
<div><pre><code><span>{</span>
  <span>"version"</span><span>:</span> <span>"0.2.0"</span><span>,</span>
  <span>"configurations"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"name"</span><span>:</span> <span>"Run hello.js"</span><span>,</span>
      <span>"type"</span><span>:</span> <span>"node"</span><span>,</span>
      <span>"request"</span><span>:</span> <span>"launch"</span><span>,</span>
      <span>"program"</span><span>:</span> <span>"${workspaceRoot}/hello.js"</span><span>,</span>
      <span>"stopOnEntry"</span><span>:</span> <span>false</span><span>,</span>
      <span>"args"</span><span>:</span> <span>[</span><span>]</span><span>,</span>
      <span>"cwd"</span><span>:</span> <span>"${workspaceRoot}"</span><span>,</span>
      <span>"preLaunchTask"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeExecutable"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeArgs"</span><span>:</span> <span>[</span><span>"--nolazy"</span><span>]</span><span>,</span>
      <span>"env"</span><span>:</span> <span>{</span>
        <span>"NODE_ENV"</span><span>:</span> <span>"development"</span>
      <span>}</span><span>,</span>
      <span>"externalConsole"</span><span>:</span> <span>false</span><span>,</span>
      <span>"sourceMaps"</span><span>:</span> <span>false</span><span>,</span>
      <span>"outDir"</span><span>:</span> <span>null</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>
<h2 id="视频演示"> 视频演示</h2>
<ul>
<li><a href="https://www.bilibili.com/video/av5827351/" target="_blank" rel="noopener noreferrer">视频演示</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">安装 Node.js</title>
    <id>https://list-jiang.github.io/code/node-js/install/</id>
    <link href="https://list-jiang.github.io/code/node-js/install/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>
]]></summary>
    <content type="html"><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>

<h2 id="安装-node-js"> 安装 Node.js</h2>
<p>目前 Node.js 的 LTS 版本是 12.18.0。首先，从 Node.js 官网下载对应平台的安装程序。</p>
<ul>
<li><a href="https://nodejs.org/dist/v12.18.0/node-v12.18.0-x64.msi" target="_blank" rel="noopener noreferrer">Windows LTS 下载地址</a></li>
</ul>
<h3 id="安装过程"> 安装过程</h3>
<ul>
<li>
<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>在安装过程中，无需勾选 &quot;Automatically install the necessary tools&quot;。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>
<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v12.18.0</code> 这样的输出:</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>IEUser<span>></span>node -v
v12.18.0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>
<p>要退出 Node.js 环境，连按两次 <code>Ctrl+C</code> 。</p>
</li>
<li>
<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>
<div><pre><code>$ node -v
v12.18.0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="npm"> npm</h2>
<p>在正式开始 Node.js 学习之前，我们先认识一下 npm。</p>
<p>Npm 是什么东东? npm 其实是 Node.js 的包管理工具(package manager)。</p>
<p>为啥我们需要一个包管理工具呢? 因为我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm 究竟在哪?</p>
<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>
<div><pre><code>C:<span>\</span><span>></span>npm -v
<span>6.13</span>.1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm install -g npm</code>。</p>
</blockquote>
<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>
<div><pre><code>C:<span>\</span><span>></span> <span>npm</span>

Usage: <span>npm</span> <span>&lt;</span>command<span>></span>

where <span>&lt;</span>command<span>></span> is one of:
    <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的一大堆文字告诉您，npm 需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>
<h2 id="墙"> 墙</h2>
<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>
<p>所以贴心的马云爸爸提供了淘宝镜像，淘宝镜像有一个自己定制的 <code>cnpm</code> 工具，服务器在国内，十分快捷。不过大家在使用 <code>cnpm</code> 安装模块之后再使用 npm 安装会报错，只能重新删掉 <code>node_modules</code> 文件夹重新执行 <code>npm install</code> 全新安装才会不报错。</p>
<div><p>注意</p>
<p>如果大家可以使用 <code>npm</code> 命令，非常不建议大家使用 <code>cnpm</code> 命令安装模块。</p>
</div>
<p>安装 <code>cnpm</code> 的命令如下:</p>
<div><pre><code><span>npm</span> <span>install</span> -g cnpm --registry<span>=</span>https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br></div></div><h2 id="小结"> 小结</h2>
<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Node.js</title>
    <id>https://list-jiang.github.io/code/node-js/intro/</id>
    <link href="https://list-jiang.github.io/code/node-js/intro/"/>
    <updated>2021-12-11T13:42:09.000Z</updated>
    <summary type="html"><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
]]></summary>
    <content type="html"><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>

<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>
<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>
<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>
<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>
<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>
<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>
<h2 id="浏览器大战和-node-js-的关系"> 浏览器大战和 Node.js 的关系</h2>
<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>
<h2 id="在-node-js-上运行的-javascript-相比其他后端开发语言的优势"> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>
<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>
<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过 io.js，这又是什么鬼?</p>
</blockquote>
<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>
<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>
<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>
<h2 id="node-js-相关链接"> Node.js 相关链接</h2>
<ul>
<li>
<p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></p>
</li>
<li>
<p><a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener noreferrer">Node.js 最新文档</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">模块</title>
    <id>https://list-jiang.github.io/code/node-js/module/</id>
    <link href="https://list-jiang.github.io/code/node-js/module/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>

<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>
<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>", "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>
<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>// 引入hello模块:</span>
<span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Michael"</span><span>;</span>

<span>greet</span><span>(</span>s<span>)</span><span>;</span> <span>// Hello, Michael!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>
<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span> <span>// 不要忘了写相对目录!</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果只写模块名:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>
<div><pre><code>module<span>.</span>js
    <span>throw</span> err<span>;</span>
          <span>^</span>
Error<span>:</span> Cannot find module <span>'hello'</span>
    at Function<span>.</span>Module<span>.</span>_resolveFilename
    at Function<span>.</span>Module<span>.</span>_load
    <span>...</span>
    at Function<span>.</span>Module<span>.</span>_load
    at Function<span>.</span>Module<span>.</span>runMain
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>遇到这个错误，您要检查:</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h2 id="commonjs-规范"> CommonJS 规范</h2>
<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>
<h2 id="总结"> 总结</h2>
<p>要在模块中对外输出变量，用:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> variable<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用:</p>
<div><pre><code><span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>"other_module"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h2 id="深入了解模块原理"> 深入了解模块原理</h2>
<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>
<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"global"</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>
<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那 Node.js 是如何实现这一点的?</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
<span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
  <span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>// hello.js代码结束</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>
<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>
<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>
<div><pre><code><span>// 准备module对象:</span>
<span>const</span> module <span>=</span> <span>{</span>
  id<span>:</span> <span>"hello"</span><span>,</span>
  exports<span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
<span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>}</span>

  module<span>.</span>exports <span>=</span> greet<span>;</span>
  <span>// hello.js代码结束</span>
  <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>
<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>)</span><span>;</span>
<span>// 保存module:</span>
<span>save</span><span>(</span>module<span>,</span> exported<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>
<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>
<h2 id="module-exports-vs-exports"> module.exports vs exports</h2>
<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>
<p>方法一: 对 module.exports 赋值:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  hello<span>:</span> hello<span>,</span>
  greet<span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>方法二: 直接使用 exports:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

exports<span>.</span>hello <span>=</span> hello<span>;</span>
exports<span>.</span>greet <span>=</span> greet<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>但是您不可以直接对 exports 赋值:</p>
<div><pre><code><span>// 代码可以执行，但是模块并没有输出任何变量:</span>
exports <span>=</span> <span>{</span>
  hello<span>:</span> hello<span>,</span>
  greet<span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>
<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>
<div><pre><code><span>const</span> module <span>=</span> <span>{</span>
  id<span>:</span> <span>"hello"</span><span>,</span>
  exports<span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>
<div><pre><code><span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>exports<span>,</span> module</span><span>)</span> <span>{</span>
    <span>// hello.js的文件内容</span>
    <span>...</span>
    <span>// load函数返回:</span>
    <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>

<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>.</span>exports<span>,</span> module<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>
<div><pre><code>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>也可以写:</p>
<div><pre><code>module<span>.</span>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
module<span>.</span>exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>
<h2 id="结论"> 结论</h2>
<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>
<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"foo"</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>或者:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">axios</title>
    <id>https://list-jiang.github.io/code/node-js/package/axois/</id>
    <link href="https://list-jiang.github.io/code/node-js/package/axois/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>GitHub 地址: <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios</a></p>
</blockquote>
<p>axois 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 node.js</p>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>GitHub 地址: <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios</a></p>
</blockquote>
<p>axois 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 node.js</p>

<h2 id="特点"> 特点</h2>
<ul>
<li>从浏览器发出 XMLHttpRequests</li>
<li>从 Node.js 发出 HTTP 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>JSON 数据的自动转换</li>
<li>客户端防止 XSRF 支持</li>
</ul>
<h2 id="安装"> 安装</h2>
<div><pre><code><span>npm</span> <span>install</span> axois
</code></pre>
<div><span>1</span><br></div></div><p>或</p>
<div><pre><code><span>yarn</span> <span>add</span> axios
</code></pre>
<div><span>1</span><br></div></div><h2 id="使用"> 使用</h2>
<div><p>CommonJS 用法</p>
<p>为了在将 CommonJS 导入与 <code>require()</code> 一起使用时获得 TypeScript 类型(用于智能感知/自动完成)，请使用以下方法:</p>
<div><pre><code><span>const</span> axios <span>=</span> <span>require</span><span>(</span><span>"axios"</span><span>)</span><span>.</span>default<span>;</span>

<span>// axios.&lt;method> will now provide autocomplete and parameter typings</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></div>
<p>进行 GET 请求:</p>
<div><pre><code><span>const</span> axios <span>=</span> <span>require</span><span>(</span><span>"axios"</span><span>)</span><span>;</span>

<span>// Make a request for a user with a given ID</span>
axios
  <span>.</span><span>get</span><span>(</span><span>"/user?ID=12345"</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
    <span>// handle success</span>
    console<span>.</span><span>log</span><span>(</span>response<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// handle error</span>
    console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// always executed</span>
  <span>}</span><span>)</span><span>;</span>

<span>// Optionally the request above could also be done as</span>
axios
  <span>.</span><span>get</span><span>(</span><span>"/user"</span><span>,</span> <span>{</span>
    params<span>:</span> <span>{</span>
      <span>ID</span><span>:</span> <span>12345</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>response<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// always executed</span>
  <span>}</span><span>)</span><span>;</span>

<span>// Want to use async/await? Add the `async` keyword to your outer function/method.</span>
<span>async</span> <span>function</span> <span>getUser</span><span>(</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> axios<span>.</span><span>get</span><span>(</span><span>"/user?ID=12345"</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>response<span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><p>注意</p>
<p><code>async</code> / <code>await</code> is part of ECMAScript 2017 and is not supported in Internet Explorer and older browsers, so use with caution.</p>
</div>
<p>进行 POST 请求:</p>
<div><pre><code>axios
  <span>.</span><span>post</span><span>(</span><span>"/user"</span><span>,</span> <span>{</span>
    firstName<span>:</span> <span>"Fred"</span><span>,</span>
    lastName<span>:</span> <span>"Flintstone"</span><span>,</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>response<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>执行多个并发请求:</p>
<div><pre><code><span>function</span> <span>getUserAccount</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>getUserPermissions</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> axios<span>.</span><span>get</span><span>(</span><span>"/user/12345/permissions"</span><span>)</span><span>;</span>
<span>}</span>

axios<span>.</span><span>all</span><span>(</span><span>[</span><span>getUserAccount</span><span>(</span><span>)</span><span>,</span> <span>getUserPermissions</span><span>(</span><span>)</span><span>]</span><span>)</span><span>.</span><span>then</span><span>(</span>
  axios<span>.</span><span>spread</span><span>(</span><span>function</span> <span>(</span><span>acct<span>,</span> perms</span><span>)</span> <span>{</span>
    <span>// Both requests are now complete</span>
  <span>}</span><span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="api"> API</h2>
<p>可以通过将相关配置传递给 <code>axios</code> 来发出请求。</p>
<h3 id="axios-config"> axios(config)</h3>
<div><pre><code><span>// Send a POST request</span>
<span>axios</span><span>(</span><span>{</span>
  method<span>:</span> <span>"post"</span><span>,</span>
  url<span>:</span> <span>"/user/12345"</span><span>,</span>
  data<span>:</span> <span>{</span>
    firstName<span>:</span> <span>"Fred"</span><span>,</span>
    lastName<span>:</span> <span>"Flintstone"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>// GET request for remote image</span>
<span>axios</span><span>(</span><span>{</span>
  method<span>:</span> <span>"get"</span><span>,</span>
  url<span>:</span> <span>"http://bit.ly/2mTM3nY"</span><span>,</span>
  responseType<span>:</span> <span>"stream"</span><span>,</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
  response<span>.</span>data<span>.</span><span>pipe</span><span>(</span>fs<span>.</span><span>createWriteStream</span><span>(</span><span>"ada_lovelace.jpg"</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="axios-url-config"> axios(url[, config])</h3>
<div><pre><code><span>// Send a GET request (default method)</span>
<span>axios</span><span>(</span><span>"/user/12345"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="请求别名"> 请求别名</h3>
<p>为了方便起见，已为所有受支持的请求方法提供了别名。</p>
<ul>
<li><code>axios.request(config)</code></li>
<li><code>axios.get(url[, config])</code></li>
<li><code>axios.delete(url[, config])</code></li>
<li><code>axios.head(url[, config])</code></li>
<li><code>axios.options(url[, config])</code></li>
<li><code>axios.post(url[, data[, config]])</code></li>
<li><code>axios.put(url[, data[, config]])</code></li>
<li><code>axios.patch(url[, data[, config]])</code></li>
</ul>
<div><p>提示</p>
<p>当使用别名时，<code>url</code>, <code>method</code> 和 <code>data</code> 属性不需要再配置中指定。</p>
</div>
<h3 id="并发"> 并发</h3>
<p>一些用于处理并发请求的有用函数:</p>
<ul>
<li>
<p><code>axios.all(iterable)</code></p>
</li>
<li>
<p><code>axios.spread(callback)</code></p>
</li>
</ul>
<h3 id="创建实例"> 创建实例</h3>
<p>您可以使用自定义配置创建 axios 的新实例。</p>
<ul>
<li><code>axios.create([config])</code></li>
</ul>
<div><pre><code><span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>{</span>
  baseURL<span>:</span> <span>"https://some-domain.com/api/"</span><span>,</span>
  timeout<span>:</span> <span>1000</span><span>,</span>
  headers<span>:</span> <span>{</span> <span>"X-Custom-Header"</span><span>:</span> <span>"foobar"</span> <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="实例方法"> 实例方法</h3>
<p>可用的实例方法在下面列出。指定的配置将与实例配置合并。</p>
<ul>
<li><code>axios#request(config)</code></li>
<li><code>axios#get(url[, config])</code></li>
<li><code>axios#delete(url[, config])</code></li>
<li><code>axios#head(url[, config])</code></li>
<li><code>axios#options(url[, config])</code></li>
<li><code>axios#post(url[, data[, config]])</code></li>
<li><code>axios#put(url[, data[, config]])</code></li>
<li><code>axios#patch(url[, data[, config]])</code></li>
<li><code>axios#getUri([config])</code></li>
</ul>
<h2 id="请求配置"> 请求配置</h2>
<p>These are the available config options for making requests. Only the <code>url</code> is required. Requests will default to <code>GET</code> if <code>method</code> is not specified.</p>
<p>这些是发出请求的可用配置选项。只有 <code>url</code> 是必填的。如果未指定 <code>method</code>，则请求将默认为 <code>GET</code>。</p>
<div><pre><code><span>{</span>
  <span>// `url` is the server URL that will be used for the request</span>
  url<span>:</span> <span>'/user'</span><span>,</span>
  <span>// `method` is the request method to be used when making the request</span>
  method<span>:</span> <span>'get'</span><span>,</span> <span>// default</span>
  <span>// `baseURL` will be prepended to `url` unless `url` is absolute.</span>
  <span>// It can be convenient to set `baseURL` for an instance of axios to pass relative URLs</span>
  <span>// to methods of that instance.</span>
  baseURL<span>:</span> <span>'https://some-domain.com/api/'</span><span>,</span>
  <span>// `transformRequest` allows changes to the request data before it is sent to the server</span>
  <span>// This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'</span>
  <span>// The last function in the array must return a string or an instance of Buffer, ArrayBuffer,</span>
  <span>// FormData or Stream</span>
  <span>// You may modify the headers object.</span>
  transformRequest<span>:</span> <span>[</span><span>function</span> <span>(</span><span>data<span>,</span> headers</span><span>)</span> <span>{</span>
    <span>// Do whatever you want to transform the data</span>
    <span>return</span> data<span>;</span>
  <span>}</span><span>]</span><span>,</span>
  <span>// `transformResponse` allows changes to the response data to be made before</span>
  <span>// it is passed to then/catch</span>
  transformResponse<span>:</span> <span>[</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>
    <span>// Do whatever you want to transform the data</span>
    <span>return</span> data<span>;</span>
  <span>}</span><span>]</span><span>,</span>
  <span>// `headers` are custom headers to be sent</span>
  headers<span>:</span> <span>{</span><span>'X-Requested-With'</span><span>:</span> <span>'XMLHttpRequest'</span><span>}</span><span>,</span>
  <span>// `params` are the URL parameters to be sent with the request</span>
  <span>// Must be a plain object or a URLSearchParams object</span>
  params<span>:</span> <span>{</span>
    <span>ID</span><span>:</span> <span>12345</span>
  <span>}</span><span>,</span>
  <span>// `paramsSerializer` is an optional function in charge of serializing `params`</span>
  <span>// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  <span>paramsSerializer</span><span>:</span> <span>function</span> <span>(</span><span>params</span><span>)</span> <span>{</span>
    <span>return</span> Qs<span>.</span><span>stringify</span><span>(</span>params<span>,</span> <span>{</span>arrayFormat<span>:</span> <span>'brackets'</span><span>}</span><span>)</span>
  <span>}</span><span>,</span>
  <span>// `data` is the data to be sent as the request body</span>
  <span>// Only applicable for request methods 'PUT', 'POST', and 'PATCH'</span>
  <span>// When no `transformRequest` is set, must be of one of the following types:</span>
  <span>// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span>// - Browser only: FormData, File, Blob</span>
  <span>// - Node only: Stream, Buffer</span>
  data<span>:</span> <span>{</span>
    firstName<span>:</span> <span>'Fred'</span>
  <span>}</span><span>,</span>

  <span>// syntax alternative to send data into the body</span>
  <span>// method post</span>
  <span>// only the value is sent, not the key</span>
  data<span>:</span> <span>'Country=Brasil&amp;City=Belo Horizonte'</span><span>,</span>
  <span>// `timeout` specifies the number of milliseconds before the request times out.</span>
  <span>// If the request takes longer than `timeout`, the request will be aborted.</span>
  timeout<span>:</span> <span>1000</span><span>,</span> <span>// default is `0` (no timeout)</span>
  <span>// `withCredentials` indicates whether or not cross-site Access-Control requests</span>
  <span>// should be made using credentials</span>
  withCredentials<span>:</span> <span>false</span><span>,</span> <span>// default</span>
  <span>// `adapter` allows custom handling of requests which makes testing easier.</span>
  <span>// Return a promise and supply a valid response (see lib/adapters/README.md).</span>
  <span>adapter</span><span>:</span> <span>function</span> <span>(</span><span>config</span><span>)</span> <span>{</span>
    <span>/* ... */</span>
  <span>}</span><span>,</span>
  <span>// `auth` indicates that HTTP Basic auth should be used, and supplies credentials.</span>
  <span>// This will set an `Authorization` header, overwriting any existing</span>
  <span>// `Authorization` custom headers you have set using `headers`.</span>
  <span>// Please note that only HTTP Basic auth is configurable through this parameter.</span>
  <span>// For Bearer tokens and such, use `Authorization` custom headers instead.</span>
  auth<span>:</span> <span>{</span>
    username<span>:</span> <span>'janedoe'</span><span>,</span>
    password<span>:</span> <span>'s00pers3cret'</span>
  <span>}</span><span>,</span>
  <span>// `responseType` indicates the type of data that the server will respond with</span>
  <span>// options are: 'arraybuffer', 'document', 'json', 'text', 'stream'</span>
  <span>//   browser only: 'blob'</span>
  responseType<span>:</span> <span>'json'</span><span>,</span> <span>// default</span>
  <span>// `responseEncoding` indicates encoding to use for decoding responses</span>
  <span>// Note: Ignored for `responseType` of 'stream' or client-side requests</span>
  responseEncoding<span>:</span> <span>'utf8'</span><span>,</span> <span>// default</span>
  <span>// `xsrfCookieName` is the name of the cookie to use as a value for xsrf token</span>
  xsrfCookieName<span>:</span> <span>'XSRF-TOKEN'</span><span>,</span> <span>// default</span>
  <span>// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>
  xsrfHeaderName<span>:</span> <span>'X-XSRF-TOKEN'</span><span>,</span> <span>// default</span>
  <span>// `onUploadProgress` allows handling of progress events for uploads</span>
  <span>// browser only</span>
  <span>onUploadProgress</span><span>:</span> <span>function</span> <span>(</span><span>progressEvent</span><span>)</span> <span>{</span>
    <span>// Do whatever you want with the native progress event</span>
  <span>}</span><span>,</span>
  <span>// `onDownloadProgress` allows handling of progress events for downloads</span>
  <span>// browser only</span>
  <span>onDownloadProgress</span><span>:</span> <span>function</span> <span>(</span><span>progressEvent</span><span>)</span> <span>{</span>
    <span>// Do whatever you want with the native progress event</span>
  <span>}</span><span>,</span>
  <span>// `maxContentLength` defines the max size of the http response content in bytes allowed</span>
  maxContentLength<span>:</span> <span>2000</span><span>,</span>
  <span>// `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed</span>
  maxBodyLength<span>:</span> <span>2000</span><span>,</span>
  <span>// `validateStatus` defines whether to resolve or reject the promise for a given</span>
  <span>// HTTP response status code. If `validateStatus` returns `true` (or is set to `null`</span>
  <span>// or `undefined`), the promise will be resolved; otherwise, the promise will be</span>
  <span>// rejected.</span>
  <span>validateStatus</span><span>:</span> <span>function</span> <span>(</span><span>status</span><span>)</span> <span>{</span>
    <span>return</span> status <span>>=</span> <span>200</span> <span>&amp;&amp;</span> status <span>&lt;</span> <span>300</span><span>;</span> <span>// default</span>
  <span>}</span><span>,</span>
  <span>// `maxRedirects` defines the maximum number of redirects to follow in node.js.</span>
  <span>// If set to 0, no redirects will be followed.</span>
  maxRedirects<span>:</span> <span>5</span><span>,</span> <span>// default</span>
  <span>// `socketPath` defines a UNIX Socket to be used in node.js.</span>
  <span>// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>
  <span>// Only either `socketPath` or `proxy` can be specified.</span>
  <span>// If both are specified, `socketPath` is used.</span>
  socketPath<span>:</span> <span>null</span><span>,</span> <span>// default</span>
  <span>// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span>
  <span>// and https requests, respectively, in node.js. This allows options to be added like</span>
  <span>// `keepAlive` that are not enabled by default.</span>
  httpAgent<span>:</span> <span>new</span> <span>http<span>.</span>Agent</span><span>(</span><span>{</span> keepAlive<span>:</span> <span>true</span> <span>}</span><span>)</span><span>,</span>
  httpsAgent<span>:</span> <span>new</span> <span>https<span>.</span>Agent</span><span>(</span><span>{</span> keepAlive<span>:</span> <span>true</span> <span>}</span><span>)</span><span>,</span>
  <span>// `proxy` defines the hostname and port of the proxy server.</span>
  <span>// You can also define your proxy using the conventional `http_proxy` and</span>
  <span>// `https_proxy` environment variables. If you are using environment variables</span>
  <span>// for your proxy configuration, you can also define a `no_proxy` environment</span>
  <span>// variable as a comma-separated list of domains that should not be proxied.</span>
  <span>// Use `false` to disable proxies, ignoring environment variables.</span>
  <span>// `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and</span>
  <span>// supplies credentials.</span>
  <span>// This will set an `Proxy-Authorization` header, overwriting any existing</span>
  <span>// `Proxy-Authorization` custom headers you have set using `headers`.</span>
  proxy<span>:</span> <span>{</span>
    host<span>:</span> <span>'127.0.0.1'</span><span>,</span>
    port<span>:</span> <span>9000</span><span>,</span>
    auth<span>:</span> <span>{</span>
      username<span>:</span> <span>'mikeymike'</span><span>,</span>
      password<span>:</span> <span>'rapunz3l'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// `cancelToken` specifies a cancel token that can be used to cancel the request</span>
  <span>// (see Cancellation section below for details)</span>
  cancelToken<span>:</span> <span>new</span> <span>CancelToken</span><span>(</span><span>function</span> <span>(</span><span>cancel</span><span>)</span> <span>{</span>
  <span>}</span><span>)</span><span>,</span>
  <span>// `decompress` indicates whether or not the response body should be decompressed</span>
  <span>// automatically. If set to `true` will also remove the 'content-encoding' header</span>
  <span>// from the responses objects of all decompressed responses</span>
  <span>// - Node only (XHR cannot turn off decompression)</span>
  decompress<span>:</span> <span>true</span> <span>// default</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br></div></div><h2 id="相应模式"> 相应模式</h2>
<p>请求的响应包含以下信息。</p>
<div><pre><code><span>{</span>
  <span>// `data` is the response that was provided by the server</span>
  data<span>:</span> <span>{</span><span>}</span><span>,</span>
  <span>// `status` is the HTTP status code from the server response</span>
  status<span>:</span> <span>200</span><span>,</span>
  <span>// `statusText` is the HTTP status message from the server response</span>
  statusText<span>:</span> <span>'OK'</span><span>,</span>
  <span>// `headers` the HTTP headers that the server responded with</span>
  <span>// All header names are lower cased and can be accessed using the bracket notation.</span>
  <span>// Example: `response.headers['content-type']`</span>
  headers<span>:</span> <span>{</span><span>}</span><span>,</span>
  <span>// `config` is the config that was provided to `axios` for the request</span>
  config<span>:</span> <span>{</span><span>}</span><span>,</span>
  <span>// `request` is the request that generated this response</span>
  <span>// It is the last ClientRequest instance in Node.js (in redirects)</span>
  <span>// and an XMLHttpRequest instance in the browser</span>
  request<span>:</span> <span>{</span><span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>使用 <code>then</code> 时，您将收到如下响应:</p>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>response<span>.</span>data<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>response<span>.</span>status<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>response<span>.</span>statusText<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>response<span>.</span>headers<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>response<span>.</span>config<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当使用 <code>catch</code> 或传递 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">拒绝回调</a> 作为 <code>then</code> 的第二个参数时， 如 <a href="%EF%BC%83%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">处理错误</a>部分中所述，响应将通过 <code>error</code> 对象提供。</p>
<h2 id="配置默认值"> 配置默认值</h2>
<p>您可以指定将应用于每个请求的配置默认值。</p>
<h3 id="全局-axios-默认值"> 全局 axios 默认值</h3>
<div><pre><code>axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>"https://api.example.com"</span><span>;</span>
axios<span>.</span>defaults<span>.</span>headers<span>.</span>common<span>[</span><span>"Authorization"</span><span>]</span> <span>=</span> <span>AUTH_TOKEN</span><span>;</span>
axios<span>.</span>defaults<span>.</span>headers<span>.</span>post<span>[</span><span>"Content-Type"</span><span>]</span> <span>=</span>
  <span>"application/x-www-form-urlencoded"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="自定义实例默认值"> 自定义实例默认值</h3>
<div><pre><code><span>// Set config defaults when creating the instance</span>
<span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>{</span>
  baseURL<span>:</span> <span>"https://api.example.com"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// Alter defaults after instance has been created</span>
instance<span>.</span>defaults<span>.</span>headers<span>.</span>common<span>[</span><span>"Authorization"</span><span>]</span> <span>=</span> <span>AUTH_TOKEN</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="配置优先顺序"> 配置优先顺序</h3>
<p>Config 将以优先顺序合并。顺序是在 <a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L28" target="_blank" rel="noopener noreferrer">lib/defaults.js</a> 中找到的库默认值，然后是实例的 <code>defaults</code> 属性，以及 最后是请求的 <code>config</code> 参数。后者将优先于前者。这是一个例子。</p>
<div><pre><code><span>// Create an instance using the config defaults provided by the library</span>
<span>// At this point the timeout config value is `0` as is the default for the library</span>
<span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
<span>// Override timeout default for the library</span>
<span>// Now all requests using this instance will wait 2.5 seconds before timing out</span>
instance<span>.</span>defaults<span>.</span>timeout <span>=</span> <span>2500</span><span>;</span>
<span>// Override timeout for this request as it's known to take a long time</span>
instance<span>.</span><span>get</span><span>(</span><span>"/longRequest"</span><span>,</span> <span>{</span>
  timeout<span>:</span> <span>5000</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="拦截器"> 拦截器</h2>
<p>您可以先拦截请求或响应，然后再由 <code>then</code> 或 <code>catch</code> 处理。</p>
<div><pre><code><span>// Add a request interceptor</span>
axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span>
  <span>function</span> <span>(</span><span>config</span><span>)</span> <span>{</span>
    <span>// Do something before request is sent</span>
    <span>return</span> config<span>;</span>
  <span>}</span><span>,</span>
  <span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// Do something with request error</span>
    <span>return</span> Promise<span>.</span><span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span>
<span>)</span><span>;</span>
<span>// Add a response interceptor</span>
axios<span>.</span>interceptors<span>.</span>response<span>.</span><span>use</span><span>(</span>
  <span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
    <span>// Any status code that lie within the range of 2xx cause this function to trigger</span>
    <span>// Do something with response data</span>
    <span>return</span> response<span>;</span>
  <span>}</span><span>,</span>
  <span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>// Any status codes that falls outside the range of 2xx cause this function to trigger</span>
    <span>// Do something with response error</span>
    <span>return</span> Promise<span>.</span><span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>您可以在以后需要时删除拦截器。</p>
<div><pre><code><span>const</span> myInterceptor <span>=</span> axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>/*...*/</span>
<span>}</span><span>)</span><span>;</span>
axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>eject</span><span>(</span>myInterceptor<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>您可以将拦截器添加到 axios 的自定义实例中。</p>
<div><pre><code><span>const</span> instance <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
instance<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>/*...*/</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="处理错误"> 处理错误</h2>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>error<span>.</span>response<span>)</span> <span>{</span>
    <span>// The request was made and the server responded with a status code</span>
    <span>// that falls out of the range of 2xx</span>
    console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>data<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>status<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>error<span>.</span>response<span>.</span>headers<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>error<span>.</span>request<span>)</span> <span>{</span>
    <span>// The request was made but no response was received</span>
    <span>// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span>
    <span>// http.ClientRequest in node.js</span>
    console<span>.</span><span>log</span><span>(</span>error<span>.</span>request<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// Something happened in setting up the request that triggered an Error</span>
    console<span>.</span><span>log</span><span>(</span><span>"Error"</span><span>,</span> error<span>.</span>message<span>)</span><span>;</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>error<span>.</span>config<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>使用 <code>validateStatus</code> 配置选项，您可以定义应该抛出错误的 HTTP 代码。</p>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>,</span> <span>{</span>
  <span>validateStatus</span><span>:</span> <span>function</span> <span>(</span><span>status</span><span>)</span> <span>{</span>
    <span>return</span> status <span>&lt;</span> <span>500</span><span>;</span> <span>// Resolve only if the status code is less than 500</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用 <code>toJSON</code>，您将获得一个对象，其中包含有关 HTTP 错误的更多信息。</p>
<div><pre><code>axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>error</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>error<span>.</span><span>toJSON</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="取消"> 取消</h2>
<p>您可以使用<em>取消令牌</em>取消请求。</p>
<blockquote>
<p>axios 取消令牌 API 是基于撤消的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener noreferrer">可取消承诺提案</a>.</p>
</blockquote>
<p>您可以使用 <code>CancelToken.source</code> 工厂函数创建一个取消令牌，如下所示:</p>
<div><pre><code><span>const</span> CancelToken <span>=</span> axios<span>.</span>CancelToken<span>;</span>
<span>const</span> source <span>=</span> CancelToken<span>.</span><span>source</span><span>(</span><span>)</span><span>;</span>
axios
  <span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>,</span> <span>{</span>
    cancelToken<span>:</span> source<span>.</span>token<span>,</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>function</span> <span>(</span><span>thrown</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>axios<span>.</span><span>isCancel</span><span>(</span>thrown<span>)</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>"Request canceled"</span><span>,</span> thrown<span>.</span>message<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// handle error</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
axios<span>.</span><span>post</span><span>(</span>
  <span>"/user/12345"</span><span>,</span>
  <span>{</span>
    name<span>:</span> <span>"new name"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>{</span>
    cancelToken<span>:</span> source<span>.</span>token<span>,</span>
  <span>}</span>
<span>)</span><span>;</span>
<span>// cancel the request (the message parameter is optional)</span>
source<span>.</span><span>cancel</span><span>(</span><span>"Operation canceled by the user."</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>您还可以通过将执行程序函数传递给 <code>CancelToken</code> 构造函数来创建取消令牌:</p>
<div><pre><code><span>const</span> CancelToken <span>=</span> axios<span>.</span>CancelToken<span>;</span>
<span>let</span> cancel<span>;</span>
axios<span>.</span><span>get</span><span>(</span><span>"/user/12345"</span><span>,</span> <span>{</span>
  cancelToken<span>:</span> <span>new</span> <span>CancelToken</span><span>(</span><span>function</span> <span>executor</span><span>(</span><span>c</span><span>)</span> <span>{</span>
    <span>// An executor function receives a cancel function as a parameter</span>
    cancel <span>=</span> c<span>;</span>
  <span>}</span><span>)</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// cancel the request</span>
<span>cancel</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><p>提示</p>
<p>您可以使用相同的取消令牌取消多个请求。</p>
</div>
<h2 id="using-application-x-www-form-urlencoded-format"> Using application/x-www-form-urlencoded format</h2>
<p>默认情况下，axios 将 JavaScript 对象序列化为 <code>JSON</code>。要改为以 <code>application/x-www-form-urlencoded</code> 格式发送数据，可以使用以下选项之一。</p>
<h3 id="浏览器"> 浏览器</h3>
<p>在浏览器中，您可以按以下方式使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener noreferrer"><code>URLSearchParams</code></a> API:</p>
<div><pre><code><span>const</span> params <span>=</span> <span>new</span> <span>URLSearchParams</span><span>(</span><span>)</span><span>;</span>
params<span>.</span><span>append</span><span>(</span><span>"param1"</span><span>,</span> <span>"value1"</span><span>)</span><span>;</span>
params<span>.</span><span>append</span><span>(</span><span>"param2"</span><span>,</span> <span>"value2"</span><span>)</span><span>;</span>
axios<span>.</span><span>post</span><span>(</span><span>"/foo"</span><span>,</span> params<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="node-js"> Node.js</h3>
<h4 id="query-string"> Query string</h4>
<p>在 Node.js 中，您可以按照如下方式使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener noreferrer"><code>querystring</code></a> 模块:</p>
<div><pre><code><span>const</span> querystring <span>=</span> <span>require</span><span>(</span><span>"querystring"</span><span>)</span><span>;</span>
axios<span>.</span><span>post</span><span>(</span><span>"http://something.com/"</span><span>,</span> querystring<span>.</span><span>stringify</span><span>(</span><span>{</span> foo<span>:</span> <span>"bar"</span> <span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>您也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"><code>qs</code></a> 库.</p>
<div><p>注意</p>
<p>如果需要对嵌套对象进行字符串化处理，则最好使用 qs 库，因为 <code>querystring</code> 方法在该用例中存在已知问题(<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener noreferrer">https://github.com/nodejs/node-v0.x-archive/issues/1665</a>)</p>
</div>
<h4 id="表格数据"> 表格数据</h4>
<p>在 Node.js 中，您可以使用 <a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"><code>form-data</code></a> 库，如下所示:</p>
<div><pre><code><span>const</span> FormData <span>=</span> <span>require</span><span>(</span><span>"form-data"</span><span>)</span><span>;</span>

<span>const</span> form <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>
form<span>.</span><span>append</span><span>(</span><span>"my_field"</span><span>,</span> <span>"my value"</span><span>)</span><span>;</span>
form<span>.</span><span>append</span><span>(</span><span>"my_buffer"</span><span>,</span> <span>new</span> <span>Buffer</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span>
form<span>.</span><span>append</span><span>(</span><span>"my_file"</span><span>,</span> fs<span>.</span><span>createReadStream</span><span>(</span><span>"/foo/bar.jpg"</span><span>)</span><span>)</span><span>;</span>
axios<span>.</span><span>post</span><span>(</span><span>"https://example.com"</span><span>,</span> form<span>,</span> <span>{</span> headers<span>:</span> form<span>.</span><span>getHeaders</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>或者，使用拦截器:</p>
<div><pre><code>axios<span>.</span>interceptors<span>.</span>request<span>.</span><span>use</span><span>(</span><span>(</span><span>config</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>config<span>.</span>data <span>instanceof</span> <span>FormData</span><span>)</span> <span>{</span>
    Object<span>.</span><span>assign</span><span>(</span>config<span>.</span>headers<span>,</span> config<span>.</span>data<span>.</span><span>getHeaders</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> config<span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">常见 Node 库</title>
    <id>https://list-jiang.github.io/code/node-js/package/</id>
    <link href="https://list-jiang.github.io/code/node-js/package/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./axois.html">axois</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">第一个 Node 程序</title>
    <id>https://list-jiang.github.io/code/node-js/program/</id>
    <link href="https://list-jiang.github.io/code/node-js/program/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>

<p>那么问题来了: 文本编辑器到底哪家强?</p>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="./../windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>
<p>最方便的，当然是 Mr.Hope 强力安利的 VS Code 了。</p>
<p>输入以下代码:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>"Hello, world."</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如 <code>C:\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
Hello, world.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
module.js:338
    throw err<span>;</span>
          ^
Error: Cannot <span>find</span> module <span>'C:\Workspace\hello.js'</span>
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h2 id="命令行模式和-node-js-交互模式"> 命令行模式和 Node.js 交互模式</h2>
<p>请注意区分命令行模式和 Node.js 交互模式。</p>
<p>看到类似 <code>C:\&gt;</code> 是在 Windows 提供的命令行模式:</p>
<p><img src="./assets/run-node-hello.png" alt="run-node-hello" loading="lazy"></p>
<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>
<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>
<p><img src="./assets/node-interactive-env.png" alt="node-interactive-env" loading="lazy"></p>
<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>
<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>
<p>例如，在 Node.js 交互式环境下，输入:</p>
<div><pre><code><span>></span> <span>100</span> + <span>200</span> + <span>300</span><span>;</span>
<span>600</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>直接可以看到结果 600。</p>
<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>
<div><pre><code><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后在命令行模式下执行:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
</code></pre>
<div><span>1</span><br></div></div><p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>再执行，就可以看到结果:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
<span>600</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="使用严格模式"> 使用严格模式</h2>
<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>
<div><pre><code>node --use_strict calc.js
</code></pre>
<div><span>1</span><br></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>
<h2 id="小结"> 小结</h2>
<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>
<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>
<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Node.js</title>
    <id>https://list-jiang.github.io/code/node-js/</id>
    <link href="https://list-jiang.github.io/code/node-js/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>

<h2 id="教程目录"> 教程目录</h2>
<ul>
<li>
<p><a href="./intro.html">Node.js 介绍</a></p>
</li>
<li>
<p><a href="./install.html">Node.js 与 npm 安装</a></p>
</li>
<li>
<p><a href="./environment.html">Node.js 环境</a></p>
</li>
<li>
<p><a href="./program.html">编程</a></p>
</li>
<li>
<p><a href="./module.html">Node.js 模块</a></p>
</li>
</ul>
<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>
<h2 id="初学者教程"> 初学者教程</h2>
<ul>
<li>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener noreferrer">Node.js 入门</a></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn/nodejs/" target="_blank" rel="noopener noreferrer">W3CSchool</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">地址</a></li>
</ul>
<h2 id="yarn"> Yarn</h2>
<p>快速、可靠、安全的依赖管理工具。</p>
<ul>
<li>
<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>
</li>
<li>
<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>
</li>
<li>
<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ul>
<h3 id="命令"> 命令</h3>
<ul>
<li>
<p><code>yarn install</code>: 执行安装</p>
</li>
<li>
<p><code>yarn upgrade</code>: 执行升级</p>
</li>
<li>
<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>
</li>
<li>
<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>
</li>
<li>
<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>
<div><p>提示</p>
<p>在国内，建议换成淘宝源 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org</a></p>
<p>即执行</p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre>
<div><span>1</span><br></div></div></div>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Node.js"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">React</title>
    <id>https://list-jiang.github.io/code/react/</id>
    <link href="https://list-jiang.github.io/code/react/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="创建-react-项目"> 创建 React 项目</h2>
<p>使用 <code>create-react-app</code> 工具。</p>
<p>创建普通模板:</p>
<div><pre><code>npx create-react-app xxx
</code></pre>
<div><span>1</span><br></div></div><p>创建 TS 模板:</p>
<div><pre><code>npx create-react-app xxx --template typescript
</code></pre>
<div><span>1</span><br></div></div><h2 id="react-文档"> React 文档</h2>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-05-08T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">开发入门</title>
    <id>https://list-jiang.github.io/code/</id>
    <link href="https://list-jiang.github.io/code/"/>
    <updated>2022-01-19T09:48:59.000Z</updated>
    <summary type="html"><![CDATA[<p>此处是 List·Jiang 存放的一些开发入门知识。</p>
]]></summary>
    <content type="html"><![CDATA[<p>此处是 List·Jiang 存放的一些开发入门知识。</p>

<h2 id="目录"> 目录</h2>
<h3 id="基础"> 基础</h3>
<ul>
<li>
<p><a href="./basic/">基础常识</a></p>
</li>
<li>
<p><a href="./windows/">Windows 基础</a></p>
</li>
<li>
<p><a href="./github/">GitHub 介绍</a></p>
</li>
</ul>
<h3 id="前端体系"> 前端体系</h3>
<ul>
<li>
<p><a href="./website/">网站相关</a></p>
</li>
<li>
<p><a href="./vue/">Vue 相关</a></p>
</li>
<li>
<p><a href="./mini-app/">小程序教程</a></p>
</li>
<li>
<p><a href="./node-js/">Node.js</a></p>
</li>
</ul>
<h3 id="代码学习"> 代码学习</h3>
<ul>
<li>
<p><a href="./language/learning.html">如何学习一门语言</a></p>
</li>
<li>
<p><a href="https://book.kotlincn.net/" target="_blank" rel="noopener noreferrer">Kotlin 教程</a></p>
</li>
<li>
<p><a href="./language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="./language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="./language/python/">Python 教程</a></p>
</li>
<li>
<p><a href="./language/markdown/">Markdown 教程</a></p>
</li>
</ul>
<h3 id="代码学习网站"> 代码学习网站</h3>
<h3 id="优质网站"> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/" target="_blank" rel="noopener noreferrer">哔哩哔哩</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3 id="杂牌网站"> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> <i>Not supported content</i></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> <i>Not supported content</i> <i>Not supported content</i> <i>Not supported content</i></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> <i>Not supported content</i></p>
</li>
</ul>
<h3 id="全球程序员交友网站"> 全球程序员交友网站</h3>
<ul>
<li>
<p><a href="https://github.com/" target="_blank" rel="noopener noreferrer">GitHub</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/" target="_blank" rel="noopener noreferrer">Stack Overflow</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">盒模型简介</title>
    <id>https://list-jiang.github.io/code/website/css/guide/box/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/box/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括: 边距，边框，填充，和实际内容。</p>
]]></summary>
    <content type="html"><![CDATA[<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括: 边距，边框，填充，和实际内容。</p>

<h2 id="盒模型介绍"> 盒模型介绍</h2>
<p>下面的图片说明了盒子模型 (Box Model):</p>
<p><img src="./assets/box-model.gif" alt="Box Model 示意图" loading="lazy"></p>
<p>不同部分的说明:</p>
<ul>
<li>Content box (内容) - 盒子的内容，显示文本和图像，可以通过 <code>width</code> 和 <code>height</code> 设置大小。</li>
<li>Padding box (内边距) - 包围在内容区域外部的空白区域，通过 <code>padding</code> 属性设置。</li>
<li>Border box (边框) - 围绕在填充和内容外的边框，通过 <code>border</code> 属性设置。</li>
<li>Margin box (外边距) - 这是最外面的区域，是盒子和其他元素之间的空白区域，通过 <code>margin</code> 属性设置。</li>
</ul>
<div><pre><code><span>div</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>border</span><span>:</span> 25px solid green<span>;</span>
  <span>padding</span><span>:</span> 25px<span>;</span>
  <span>margin</span><span>:</span> 25px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>为了正确设置元素在所有浏览器中的宽度和高度，您需要知道的盒模型是如何工作的。</p>
<h2 id="元素的宽度和高度"> 元素的宽度和高度</h2>
<p>当您指定一个 CSS 元素的宽度和高度属性时，您只是设置内容区域(content box)的宽度和高度。<code>padding</code> 和 <code>border</code> 再加上设置的宽高一起决定整个盒子的大小。</p>

          <div
            id="code-demo-ae466326"
           
  
 data-title="%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%AB%98%E5%BA%A6"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22div.box%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20border%3A%2025px%20solid%20green%3B%5Cn%20%20padding%3A%2025px%3B%5Cn%20%20margin%3A%2025px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>div.box</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>border</span><span>:</span> 25px solid green<span>;</span>
  <span>padding</span><span>:</span> 25px<span>;</span>
  <span>margin</span><span>:</span> 25px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>元素盒子的大小为: 300px (宽) + 50px (左 + 右填充) + 50px (左 + 右边框) = 400px</p>
<p>元素占据的空间为: 300px (宽) + 50px (左 + 右填充) + 50px (左 + 右边框) + 50px (左 + 右边距) = 450px</p>

            </div>
          </div>
          
        </div>
<p>试想一下，您只有 250px 的空间。让我们设置总宽度为 250px 的元素:</p>

          <div
            id="code-demo-41c13d64"
           
  
 data-title="%E6%80%BB%E5%AE%BD%E5%BA%A6%20250px%20%E7%9A%84%E5%85%83%E7%B4%A0"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22div.box%20%7B%5Cn%20%20width%3A%20220px%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20border%3A%205px%20solid%20gray%3B%5Cn%20%20margin%3A%200%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>div.box</span> <span>{</span>
  <span>width</span><span>:</span> 220px<span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>border</span><span>:</span> 5px solid gray<span>;</span>
  <span>margin</span><span>:</span> 0<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>最终元素的总宽度计算公式是这样的:</p>
<p>元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框
元素占据的水平空间 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</p>
<p>元素的总高度最终计算公式是这样的:</p>
<p>元素的高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框
元素占据的垂直空间 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</p>
<div><p>提示</p>
<p>更多相关可见 <a href="./../intro/box.html">盒模型</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">优先级和继承</title>
    <id>https://list-jiang.github.io/code/website/css/guide/cascade/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/cascade/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本文介绍 CSS 的一些最基本的概念: 层叠、优先级和继承。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本文介绍 CSS 的一些最基本的概念: 层叠、优先级和继承。</p>

<h2 id="冲突规则"> 冲突规则</h2>
<p>CSS 代表层叠样式表，我们需要理解第一个词 cascading。</p>
<p><strong>Cascade</strong>, 和它密切相关的概念是 <strong>Specificity</strong>，决定在发生冲突的时候应该使用哪条规则。</p>
<p>这里也有继承的概念，也就是在默认情况下，一些 CSS 属性继承当前元素的父元素上设置的值，有些则不继承。这也可能导致一些和期望不同的结果。</p>
<h3 id="层叠"> 层叠</h3>
<p>Style sheets cascade(样式表层叠) 决定了 CSS 规则的顺序很重要。</p>
<p>当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</p>
<p><strong>案例</strong>: 我们有两个关于 <code>h1</code> 的规则。这些规则有相同的优先级，顺序在最后的生效，所以 <code>h1</code> 最后显示为蓝色。</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope is handsome!<span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>h1</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>h1</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="优先级"> 优先级</h3>
<p>浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度:</p>
<ul>
<li>一个元素选择器不是很具体 (它会选择页面上该类型的所有元素)，所以它的优先级就会低一些。</li>
<li>一个类选择器稍微具体点 (它会选择该页面中有特定 class 属性值的元素)，所以它的优先级就要高一点。</li>
</ul>

          <div
            id="code-demo-92dd51ca"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Ch1%20class%3D%5C%22main-heading%5C%22%3EMr.Hope%20is%20handsome!%3C%2Fh1%3E%5Cn%22%2C%22css%22%3A%22.main-heading%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%5Cnh1%20%7B%5Cn%20%20color%3A%20blue%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>上面的 <code>h1</code> 会显示红色 (类选择器有更高的优先级，即使元素选择器顺序在它后面)。</p>
<div><pre><code><span><span><span>&lt;</span>h1</span> <span>class</span><span><span>=</span><span>"</span>main-heading<span>"</span></span><span>></span></span>Mr.Hope is handsome!<span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.main-heading</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>h1</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="继承"> 继承</h3>
<p>一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能。</p>
<p><strong>案例</strong>: 如果您设置一个元素的 <code>color</code> 和 <code>font-family</code> ，默认情况下每个在里面的元素也都会有相同的属性。</p>
<div><pre><code><span>/* 整个文档的文字默认情况下都是蓝的，除非针对性的设置为其他颜色 */</span>
<span>body</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>一些属性是不能继承的。比如您在一个元素上设置 <code>width: 50%</code> ，所有的后代不会是父元素的宽度的 50%。如果这个也可以继承的话，CSS 就会很难使用了!</p>
</div>
<h2 id="理解继承"> 理解继承</h2>
<p>我们从继承开始。下面的例子中我们有一个 <code>ul</code>，里面有两个无序列表。我们已经给 <code>&lt;ul&gt;</code> 设置了 <code>border</code>， <code>padding</code> 和 <code>color</code>.</p>
<p><code>color</code> 应用在直接子元素，也影响其他后代，如子元素 <code>&lt;li&gt;</code>，和第一个嵌套列表中的子项。然后添加了一个 <code>special</code> 类到第二个嵌套列表。该类声明了不同的颜色。然后通过它的子元素继承。</p>

          <div
            id="code-demo-c3835dbe"
           
  
 data-title="%E7%BB%A7%E6%89%BF%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cul%20class%3D%5C%22main%5C%22%3E%5Cn%20%20%3Cli%3EItem%20One%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20Item%20Two%5Cn%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%3Cli%3E2.1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%3Cli%3E2.2%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20Item%20Three%5Cn%20%20%20%20%3Cul%20class%3D%5C%22special%5C%22%3E%5Cn%20%20%20%20%20%20%3Cli%3E%5Cn%20%20%20%20%20%20%20%203.1%5Cn%20%20%20%20%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%20%20%20%20%3Cli%3E3.1.1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%20%20%20%20%3Cli%3E3.1.2%3C%2Fli%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Ful%3E%5Cn%20%20%20%20%20%20%3C%2Fli%3E%5Cn%20%20%20%20%20%20%3Cli%3E3.2%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%22%2C%22css%22%3A%22.main%20%7B%5Cn%20%20color%3A%20rebeccapurple%3B%5Cn%20%20border%3A%202px%20solid%20%23ccc%3B%5Cn%20%20padding%3A%201em%3B%5Cn%7D%5Cn%5Cn.special%20%7B%5Cn%20%20color%3A%20black%3B%5Cn%20%20font-weight%3A%20bold%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>main<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Item One<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    Item Two
    <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>2.1<span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>2.2<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    Item Three
    <span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>special<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>
        3.1
        <span><span><span>&lt;</span>ul</span><span>></span></span>
          <span><span><span>&lt;</span>li</span><span>></span></span>3.1.1<span><span><span>&lt;/</span>li</span><span>></span></span>
          <span><span><span>&lt;</span>li</span><span>></span></span>3.1.2<span><span><span>&lt;/</span>li</span><span>></span></span>
        <span><span><span>&lt;/</span>ul</span><span>></span></span>
      <span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>3.2<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>.main</span> <span>{</span>
  <span>color</span><span>:</span> rebeccapurple<span>;</span>
  <span>border</span><span>:</span> 2px solid #ccc<span>;</span>
  <span>padding</span><span>:</span> 1em<span>;</span>
<span>}</span>

<span>.special</span> <span>{</span>
  <span>color</span><span>:</span> black<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>像 <code>width</code> (上面提到的), <code>margin</code>, <code>padding</code>, 和 <code>border</code> 不会被继承。如果 <code>border</code> 可以被继承，每个列表和列表项都会获得一个边框 — 可能就不是我们想要的结果!</p>
<p>哪些属性属于默认继承很大程度上是由常识决定的。</p>
<h3 id="控制继承"> 控制继承</h3>
<p>CSS 为控制继承提供了四个特殊的通用属性值。每个 CSS 属性都接收这些值。</p>
<ul>
<li><code>inherit</code>: 使子元素属性和父元素相同。实际上就是 &quot;开启继承&quot;.</li>
<li><code>initial</code>: 与浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 <code>inherit</code>。</li>
<li><code>unset</code>: 将属性重置为自然值，也就是如果属性是自然继承那么就是 <code>inherit</code>，否则和 <code>initial</code> 一样</li>
</ul>
<div><p>相关信息</p>
<p>还有一个属性 <code>revert</code>，但只有很少的浏览器支持。</p>
</div>
<h3 id="重设所有属性值"> 重设所有属性值</h3>
<p>CSS 的缩写属性 <code>all</code> 可以用于同时将这些继承值中的一个应用于(几乎)所有属性。它的值可以是其中任意一个(<code>inherit</code>, <code>initial</code>, <code>unset</code>, <code>revert</code>)。这是一种撤销对样式所做更改的简便方法，以便回到默认状态。</p>

          <div
            id="code-demo-258845a8"
           
  
 data-title="%E9%87%8D%E8%AE%BE%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7%E5%80%BC"

            data-code="%7B%22html%22%3A%22%3Cblockquote%3E%5Cn%20%20%3Cp%3EThis%20blockquote%20is%20styled%3C%2Fp%3E%5Cn%3C%2Fblockquote%3E%5Cn%5Cn%3Cblockquote%20class%3D%5C%22fix-this%5C%22%3E%5Cn%20%20%3Cp%3EThis%20blockquote%20is%20not%20styled%3C%2Fp%3E%5Cn%3C%2Fblockquote%3E%5Cn%22%2C%22css%22%3A%22blockquote%20%7B%5Cn%20%20background-color%3A%20red%3B%5Cn%20%20border%3A%202px%20solid%20green%3B%5Cn%7D%5Cn%5Cn.fix-this%20%7B%5Cn%20%20all%3A%20unset%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>blockquote</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>This blockquote is styled<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>blockquote</span><span>></span></span>

<span><span><span>&lt;</span>blockquote</span> <span>class</span><span><span>=</span><span>"</span>fix-this<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>This blockquote is not styled<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>blockquote</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>blockquote</span> <span>{</span>
  <span>background-color</span><span>:</span> red<span>;</span>
  <span>border</span><span>:</span> 2px solid green<span>;</span>
<span>}</span>

<span>.fix-this</span> <span>{</span>
  <span>all</span><span>:</span> unset<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="理解层叠"> 理解层叠</h2>
<p>有三个因素需要考虑，根据重要性排序如下:</p>
<ol>
<li>重要程度</li>
<li>优先级</li>
<li>资源顺序</li>
</ol>
<p>我们从下往上，看看浏览器是如何决定该应用哪个 CSS 规则的。</p>
<h3 id="资源顺序"> 资源顺序</h3>
<p>我们已经看到了顺序对于层叠的重要性。如果您有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式。</p>
<h3 id="优先级计算"> 优先级计算</h3>
<p>在您了解了顺序的重要性后，会发现在一些情况下，有些规则在最后出现，但是却应用了前面的规则。</p>
<p>只要前面的有更高的优先级，浏览器就把它选择为元素的样式。就像前面看到的，类选择器的权重大于元素选择器，因此类上定义的属性将覆盖应用于元素上的属性。</p>
<div><p>注意</p>
<p>虽然我们考虑的是选择器，但是只有相同的属性会被覆盖，不会覆盖所有规则，也就是说优先级低的选择器的其他不冲突声明仍会生效。</p>
</div>
<div><p>技巧</p>
<p>一种常见的做法是给基本元素定义通用样式，然后给不同的元素创建对应的类。</p>
<p>比如我的博客对很多标签的样式进行了调整(比如减小了 <code>&lt;h1&gt;</code> 的字体大小以及标题的字体粗细)，并通过类来对特定区域的标签进行进一步的样式调整。</p>
</div>
<p>本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。</p>
<p>一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数:</p>
<ul>
<li>千位: 如果声明在 style 的属性(内联样式)则该位得一分。这样的声明没有选择器，所以它得分总是 1000。</li>
<li>百位: 选择器中包含 ID 选择器则该位得一分。</li>
<li>十位: 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li>
<li>个位: 选择器中包含元素、伪元素选择器则该位得一分。</li>
</ul>
<div><p>注意</p>
<p>通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, 空格)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</div>
<div><p>警告</p>
<p>在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
</div>
<h2 id="important"> !important</h2>
<p><code>!important</code> 可以用来覆盖所有上面所有优先级计算。</p>
<div><pre><code><span>button</span> <span>{</span>
  <span>border</span><span>:</span> none <span>!important</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>请不要滥用 <code>!important</code>，只有在不得不使用的情况下再进行使用。</p>
<p>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有相同优先级而且顺序靠后，或者更高优先级。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">常见属性说明</title>
    <id>https://list-jiang.github.io/code/website/css/guide/common/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/common/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章节介绍 CSS 的最常见，也是最基础属性。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章节介绍 CSS 的最常见，也是最基础属性。</p>

<h2 id="文本"> 文本</h2>
<table>
<thead>
<tr>
<th>格式</th>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>对齐方式</td>
<td>text-align</td>
<td><code>left</code> (默认) / <code>right</code> / <code>center</code> / <code>justify</code> / <code>inherit</code></td>
</tr>
<tr>
<td>字体</td>
<td>font-family</td>
<td>各种字体对应的代号</td>
</tr>
<tr>
<td>斜体样式</td>
<td>font-style</td>
<td><code>normal</code> (默认) /<code>italic</code></td>
</tr>
<tr>
<td>字体粗细</td>
<td>font-weight</td>
<td>描述值 <code>light</code> / <code>normal</code> / <code>bold</code>，数字 100 - 900 (400 为 normal)</td>
</tr>
<tr>
<td>字体大小</td>
<td>font-size</td>
<td>像素如 <code>14px</code>，磅如 <code>8pt</code>，字体大小如 <code>1em</code>、<code>0.5rem</code></td>
</tr>
<tr>
<td>行高</td>
<td>line-height</td>
<td>像素如 <code>14px</code>，数字如 <code>2</code>(代表 2 倍字高)</td>
</tr>
<tr>
<td>字体间距</td>
<td>letter-spacing</td>
<td>像素如 <code>14px</code>，百分比如 <code>10%</code>，磅如 <code>8pt</code>，字体大小如 <code>1em</code>、<code>0.5rem</code></td>
</tr>
<tr>
<td>字体装饰</td>
<td>text-decoration</td>
<td><code>none</code> (默认) / <code>underline</code>/<code>overline</code>/<code>line-through</code> / <code>blink</code> / <code>inherit</code></td>
</tr>
</tbody>
</table>
<p>案例:</p>
<div><pre><code><span>p.normal</span> <span>{</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
  <span>font-size</span><span>:</span> 18px<span>;</span>
  <span>line-height</span><span>:</span> 1.5<span>;</span>
  <span>text-align</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="颜色"> 颜色</h2>
<ol>
<li>
<p>HEX(十六进制)表示方法</p>
<p><code>#__ __ __(__)</code> 前三个空白位置分别代表 <strong>R</strong> (red)，<strong>G</strong> (green)，<strong>B</strong> (blue)，即红、绿、蓝显示三原色。最后一位代表 <strong>A</strong> (alpha)，即透明度通道。四个位置要统一填写 1 或 2 位十六进制数。</p>
<div><p>提示</p>
<p>例子:</p>
<ul>
<li><code>#fff</code>: 3 位，16 色 RGB，灰度为 16，即 RGB 分别只有 16 色(从最淡到最浓为 <code>0</code> - <code>f</code>)。</li>
<li><code>#ffff</code>: 4 位，16 色 RGBA。新增的透明度通道只有 16 个级别(<code>0</code> 为 <code>0%</code> 完全透明，<code>f</code> 为 <code>100%</code> 完全不透明)。</li>
<li><code>#ffffff</code>: 6 位是 256 色 RGB，灰度为 256，即 RGB 分别拥有 256 色(从最淡到最浓为 <code>00</code> - <code>ff</code>)。</li>
<li><code>#ffffffff</code>: 8 位是 256 色 RGBA。同上新增的透明度通道有 256 个级别(<code>00</code> 为 <code>0%</code> 完全透明，<code>ff</code> 为 <code>100%</code> 完全不透明)。</li>
</ul>
</div>
</li>
<li>
<p>RGB 与 RGBA 表示方法</p>
<p><strong>格式:</strong><br>
RGB(R,G,B)<br>
RGBA(R,G,B,A)</p>
<p>R: 红色值。正整数 | 百分数</p>
<p>G: 绿色值。正整数 | 百分数</p>
<p>B: 蓝色值。正整数 | 百分数</p>
<p>正整数值的取值范围为: 0 - 255。百分数值的取值范围为: 0.0% - 100.0%</p>
<p>A: Alpha 透明度。取值 0~1 之间。</p>
<p>例子:</p>
<ul>
<li>
<p>RGB: <code>rgb(142 229 238)</code></p>
</li>
<li>
<p>RGBA: <code>rgba(142 229 238 0)</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="配色网站"> 配色网站</h3>
<ul>
<li><a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener noreferrer">颜色网站</a></li>
<li><a href="https://webgradients.com/" target="_blank" rel="noopener noreferrer">渐进色网站</a></li>
</ul>
<div><p>提示</p>
<p>由于黑色和白色是纯色，直接使用 16 色 HEX 表示方法即可。</p>
<p>即:
黑色 <code>#000</code>，白色 <code>#fff</code></p>
</div>
<div><pre><code><span>body,
h1,
p</span> <span>{</span>
  <span>background-color</span><span>:</span> #b0c4de<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="链接"> 链接</h2>
<div><pre><code><span>/* 未访问链接*/</span>
<span>a:link</span> <span>{</span>
  <span>color</span><span>:</span> #000000<span>;</span>
  <span>background-color</span><span>:</span> #b2ff99<span>;</span>
<span>}</span>

<span>/*已访问链接 */</span>
<span>a:visited</span> <span>{</span>
  <span>color</span><span>:</span> #00ff00<span>;</span>
  <span>background-color</span><span>:</span> #ffff85<span>;</span>
<span>}</span>

<span>/*鼠标移动到链接上 */</span>
<span>a:hover</span> <span>{</span>
  <span>color</span><span>:</span> #ff00ff<span>;</span>
  <span>background-color</span><span>:</span> #ff704d<span>;</span>
<span>}</span>

<span>/* 鼠标点击时 */</span>
<span>a:active</span> <span>{</span>
  <span>color</span><span>:</span> #0000ff<span>;</span>
  <span>background-color</span><span>:</span> #ff704d<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>以上要注意优先级顺序，因为同样生效的 CSS，后面的优先级更高，例如将 <code>a:link</code> 放在最后，则剩余三个的颜色永远不会生效。</p>
<h2 id="盒模型"> 盒模型</h2>
<div><p>提示</p>
<p>您可能需要先查看 <a href="./box.html">盒模型</a> 以理解此部分</p>
</div>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/08/VlwVi.png" alt="盒模型示意图" loading="lazy"></p>
<p><code>margin</code> 和 <code>padding</code> 都可以接受 1 - 4 个参数。其参数默认以 <code>上</code> 侧为起始点，按照顺时针排序，即<strong>上右下左</strong>。</p>
<p>当 <code>下</code> / <code>左</code> 没有指定时，跟随 <code>上</code> / <code>右</code>；当 <code>右</code> 也没有指定时，全部跟随 <code>上</code>。</p>
<p>案例:</p>
<div><pre><code><span>div</span> <span>{</span>
  <span>/** 上 右 下 左 */</span>
  <span>margin</span><span>:</span> 25px 50px 75px 100px<span>;</span>
<span>}</span>

<span>div</span> <span>{</span>
  <span>/** 上 右+左(跟随右) 下 */</span>
  <span>margin</span><span>:</span> 25px 50px 75px<span>;</span>
<span>}</span>

<span>div</span> <span>{</span>
  <span>/** 上下 右左 */</span>
  <span>margin</span><span>:</span> 25px 50px<span>;</span>
<span>}</span>

<span>div</span> <span>{</span>
  <span>/** 上右下左 全部25px */</span>
  <span>margin</span><span>:</span> 25px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>同时，也支持只对一侧设置，如:</p>
<div><pre><code><span>/** 只有左外边距，为3px */</span>
<span>div</span> <span>{</span>
  <span>margin-left</span><span>:</span> 3px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>提示</p>
<p><code>padding</code> 与 <code>margin</code> 在格式上完全相同。</p>
</div>
<h2 id="背景色"> 背景色</h2>
<p>使用 <code>background-color</code> 或 <code>background-image</code> 属性进行设置。</p>
<p>案例:</p>
<div><pre><code><span>.red</span> <span>{</span>
  <span>background-color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="位置"> 位置</h2>
<p><code>position</code> 属性规定元素的定位类型。元素的位置通过 <code>left</code>, <code>top</code>, <code>right</code> 以及 <code>bottom</code> 属性进行规定。</p>
<p>可能的值:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于 <code>static</code> 定位以外的第一个父元素进行定位。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，&quot;<code>left: 20px</code>&quot; 会让元素向右偏移 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中 (忽略 top, bottom, left, right 或者 z-index 声明)。</td>
</tr>
<tr>
<td>sticky</td>
<td>在文档中正常定位，但当向上滚动到达屏幕顶端时，固定在顶部不再随页面上移</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 <code>position</code> 属性的值。</td>
</tr>
</tbody>
</table>
<p>如果设置为 <code>absolute</code> 或者 <code>fixed</code> 的话，元素将会脱离文档流，也就是正常的文档布局里面不再有它的位置，不会给它留空，完全视它不存在。它会根据最后渲染出的其他元素位置寻找自己的定位。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">CSS 声明</title>
    <id>https://list-jiang.github.io/code/website/css/guide/declaration/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/declaration/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="值的专一性"> 值的专一性</h2>
<p>CSS 每个属性都会有且仅有一个值。</p>
<ul>
<li>如果您设置了多个值，最终优先级最高的值会被应用、</li>
<li>如果您没有设置值，则会应用默认值。默认值可以是 <code>unset</code>(未设置), <code>inherit</code> (继承父属性值), <code>initial</code> (初始值)。</li>
</ul>
<div><p>提示</p>
<p>如果属性未知或某个值对给定属性无效，则声明被视为无效，并被浏览器的 CSS 引擎完全忽略。</p>
</div>
<h2 id="函数"> 函数</h2>
<p>虽然大多数值是相对简单的关键字或数值，但也有一些可能的值以函数的形式出现。一个函数由函数名和一些括号组成，其中放置了该函数的允许值。</p>
<p><strong>案例</strong>: <code>calc()</code> 函数允许您在 CSS 中进行简单的计算:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>width</span><span>:</span> <span>calc</span><span>(</span>90% - 30px<span>)</span><span>;</span>
  <span>background-color</span><span>:</span> rebeccapurple<span>;</span>
  <span>color</span><span>:</span> white<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>案例</strong>: <code>url()</code> 允许您引入外部资源:</p>
<div><pre><code><span>.logo</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>/logo.png<span>)</span></span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="速记属性"> 速记属性</h2>
<p>一些属性，如 <code>font</code>, <code>background</code>, <code>padding</code>, <code>border</code>, <code>margin</code> 等属性称为速记属性--这是因为它们允许您在一行中设置多个属性值，从而节省时间并使代码更整洁。</p>
<p><strong>案例</strong>: 以下两个 CSS 是完全等价的</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>padding</span><span>:</span> 10px 15px 15px 5px<span>;</span>
  <span>background</span><span>:</span> red <span><span>url</span><span>(</span>bg-graphic.png<span>)</span></span> 10px 10px repeat-x fixed<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>padding-top</span><span>:</span> 10px<span>;</span>
  <span>padding-right</span><span>:</span> 15px<span>;</span>
  <span>padding-bottom</span><span>:</span> 15px<span>;</span>
  <span>padding-left</span><span>:</span> 5px<span>;</span>
  <span>background-color</span><span>:</span> red<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>bg-graphic.png<span>)</span></span><span>;</span>
  <span>background-position</span><span>:</span> 10px 10px<span>;</span>
  <span>background-repeat</span><span>:</span> repeat-x<span>;</span>
  <span>background-attachment</span><span>:</span> fixed<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">引入 CSS</title>
    <id>https://list-jiang.github.io/code/website/css/guide/import/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/import/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>有三种方式引入并应用 CSS。</p>
<h2 id="外部样式表"> 外部样式表</h2>
<p>外部样式表将样式写入 CSS 文件中，在 HTML 中使用 <code>&lt;link&gt;</code> 引用，可以根据实际需要放在 <code>&lt;head&gt;</code> 标签里或 <code>&lt;body&gt;</code> 标签的末尾。比如:</p>
<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>mystyle.css<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>浏览器会从文件 <code>mystyle.css</code> 中读到样式声明，并根据它来格式文档。</p>
<p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 HTML 标签。样式表应该以 <code>.css</code> 扩展名进行保存。</p>
<h2 id="内部样式表"> 内部样式表</h2>
<p>当单个文档需要特殊的样式时，就应该使用内部样式表。您可以使用 <code>&lt;style&gt;</code> 标签定义内部样式表，就像这样:</p>
<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>hr</span> <span>{</span>
      <span>color</span><span>:</span> sienna<span>;</span>
    <span>}</span>

    <span>p</span> <span>{</span>
      <span>margin-left</span><span>:</span> 20px<span>;</span>
    <span>}</span>

    <span>body</span> <span>{</span>
      <span>background-image</span><span>:</span> <span><span>url</span><span>(</span><span>"images/back40.gif"</span><span>)</span></span><span>;</span>
    <span>}</span>
  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="内联样式"> 内联样式</h2>
<p>在 HTML 中使用 style 属性指定。</p>
<p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势，请慎用这种方法。</p>
<p>您可以在特定情况下使用它，例如当 1 -3 个样式仅需要在一个元素上应用一次时。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>&lt;!-- 改变了这个段落的字体颜色和左外边距 --></span>
<span><span><span>&lt;</span>p</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>color</span><span>:</span> sienna<span>;</span> <span>margin-left</span><span>:</span> 20px</span><span>"</span></span></span><span>></span></span>这是一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">快速上手</title>
    <id>https://list-jiang.github.io/code/website/css/guide/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)。</p>

<h2 id="简介"> 简介</h2>
<p>和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。它是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。举例来说，要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSS:</p>
<div><pre><code><span>p</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>您可以很方便的创建一个 <code>&lt;style&gt;</code> 标签并将上述样式表作为该标签的内容，这样页面所有段落的文字就会变成红色。</p>
<h2 id="css-规则集"> CSS 规则集</h2>
<p>CSS 规则集由两个主要的部分构成: 选择器，以及一条或多条声明:</p>
<p><img src="./assets/css-rule.jpg" alt="CSS 规则图示" loading="lazy"></p>
<ul>
<li>
<p><strong>选择器</strong> (Selector): 通常是您需要改变样式的 HTML 元素。</p>
</li>
<li>
<p><strong>声明</strong> (Declaration): 每条声明由一个属性和一个值组成。每个属性有一个值。</p>
<ul>
<li><strong>属性</strong> (Properties): 您希望设置的样式属性 (style attribute)，也是改变 HTML 元素样式的途径。(本例中 color 就是 <code>&lt;h1&gt;</code> 元素的属性) CSS 中，由编写人员决定修改哪个属性以改变规则。</li>
<li><strong>属性的值</strong> (Property value): 在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值 (我们除了 blue 之外还有很多属性值可以用于 color )。</li>
</ul>
</li>
</ul>
<div><p>语法</p>
<ul>
<li>每个规则集声明都应该包含在成对的花括号 <code>{}</code> 里</li>
<li>在每个声明里要用冒号 <code>:</code> 将属性与属性值分隔开</li>
<li>每个声明总是以分号 <code>;</code> 结束，以分隔多个声明。</li>
</ul>
<p>更多声明详情，请见 <a href="./declaration.html">CSS → 快速上手 → 声明</a></p>
</div>
<div><pre><code><span>p</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
  <span>text-align</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>注意</p>
<p>CSS 块内的每一条声明都必须以分号结束，否则会报错(最后一条除外)，而每个 CSS 块不是以分号结束的!</p>
</div>
<h3 id="css-注释"> CSS 注释</h3>
<p>与 HTML 一样，CSS 也可以包含注释来解释您的代码，浏览器会忽略它。</p>
<p>CSS 注释以 <code>/*</code> 开始, 以 <code>*/</code> 结束。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>/* 这是个注释 */</span>
<span>p</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
  <span>/* 这是另一个注释 */</span>
  <span>color</span><span>:</span> black<span>;</span>
  <span>font-family</span><span>:</span> arial<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>总结</p>
<ul>
<li>样式定义如何显示 HTML 元素</li>
<li>样式通常存储在样式表中</li>
<li>CSS 可以将多个样式层叠为一</li>
</ul>
</div>
<h2 id="css-选择器"> CSS 选择器</h2>
<p>CSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>
<p>选择器所选择的元素，叫做“选择器的对象”。</p>
<ul>
<li><a href="./selector.html">查看详情</a></li>
</ul>
<h2 id="引入-css"> 引入 CSS</h2>
<p>共有三种方式引入并应用 CSS。</p>
<ul>
<li><a href="./import.html">查看详情</a></li>
</ul>
<h2 id="规则"> @ 规则</h2>
<p><code>@rules</code> 是一些特殊的规则，为 CSS 提供了一些关于如何表现的指导。有些 <code>@rules</code> 规则很简单，有规则名和值。</p>
<p>例如，要将额外的样式表导入主 CSS 样式表，可以使用 <code>@import</code>:</p>
<div><pre><code><span><span>@import</span> <span>"styles2.css"</span><span>;</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>最常见的 <code>@rules</code> 之一是 <code>@media</code>，它允许您使用 媒体查询 来应用 CSS，仅当某些条件成立 (例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时)。</p>
<div><pre><code><span>body</span> <span>{</span>
  <span>background-color</span><span>:</span> pink<span>;</span>
<span>}</span>

<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 540px<span>)</span></span> <span>{</span>
  <span>body</span> <span>{</span>
    <span>background-color</span><span>:</span> blue<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>相关信息</p>
<p>更多详情，请见 <a href="./../intro/media.html">CSS → 媒体查询</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">选择器简介</title>
    <id>https://list-jiang.github.io/code/website/css/guide/selector/</id>
    <link href="https://list-jiang.github.io/code/website/css/guide/selector/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>CSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>
<p>选择器所选择的元素，叫做“选择器的对象”。</p>
]]></summary>
    <content type="html"><![CDATA[<p>CSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>
<p>选择器所选择的元素，叫做“选择器的对象”。</p>


          <div
            id="code-demo-7090ee9f"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cimg%20src%3D%5C%22%2Flogo.png%5C%22%20alt%3D%5C%22logo%5C%22%20style%3D%5C%22max-width%3A%20150px%5C%22%20%2F%3E%5Cn%5Cn%3Cp%20class%3D%5C%22paragraph%5C%22%3EMr.Hope%20is%20handsome!%3C%2Fp%3E%5Cn%3Cp%20id%3D%5C%22par%5C%22%3EMr.Hope%20is%20very%20handsome!%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%5Cn.paragraph%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%5Cn%23par%20%7B%5Cn%20%20color%3A%20blue%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/logo.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>logo<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>max-width</span><span>:</span> 150px</span><span>"</span></span></span> <span>/></span></span>

<span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>paragraph<span>"</span></span><span>></span></span>Mr.Hope is handsome!<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>id</span><span><span>=</span><span>"</span>par<span>"</span></span><span>></span></span>Mr.Hope is very handsome!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>.paragraph</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>#par</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>在上文中，CSS 选择器选中了对应的 HTML 元素并为其应用样式规则。</p>
<h2 id="三个常见选择器"> 三个常见选择器</h2>
<h3 id="id-选择器"> ID 选择器</h3>
<p>ID 选择器可以为标有特定 ID 的 HTML 元素指定特定的样式。</p>
<p>HTML 可以用 ID 属性来设置 ID 选择器，CSS 中 ID 选择器以 <code>#</code> 来定义。</p>
<p>以下的样式规则应用于元素属性 <code>id=&quot;para1&quot;</code>:</p>
<div><pre><code><span>#para1</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>提示</p>
<p>ID 的全称是 Identify，是身份标识的意思。ID 的实际作用是为这个 HTML 标签绑定一个页面内唯一的标识符。因此，每一个 HTML 页面出现的 ID 应该仅被使用一次，以 ID 来代指这个元素。</p>
</div>
<h3 id="class-选择器"> Class 选择器</h3>
<p>Class 选择器用于描述一组元素的样式，class 选择器有别于 ID 选择器，class 可以在多个元素中使用。</p>
<p>Class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以句点 (<code>.</code>) 显示:</p>
<p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p>
<div><pre><code><span>.center</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="标签选择器"> 标签选择器</h3>
<p>标签选择器用于指定一个 HTML 标签的样式。通常，浏览器会为每个特定的 HTML 标签指定一个默认样式，但是不同的浏览器的默认样式可能有细微的区别。</p>
<p>有些时候想要覆盖浏览器的默认样式，或者说想在所有浏览器中保持统一样式，即可使用标签选择器指定标签的默认样式。在 CSS 指定的标签样式会覆盖掉浏览器默认指定的样式。</p>
<div><pre><code><span>/* 确保所有浏览器的段落标签的字体大小均为16像素。*/</span>
<span>p</span> <span>{</span>
  <span>font-size</span><span>:</span> 16px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="运算符"> 运算符</h2>
<p>选择器可以通过运算符，构成更加复杂的选择器。</p>
<p>最常见的是<strong>后代选择器</strong>，以空格分隔，用于选取某元素的后代元素</p>
<div><p>选择器案例</p>
<ul>
<li>
<p><code>p{ }</code>: 为所有 <strong>p</strong> 元素指定一个样式。</p>
</li>
<li>
<p><code>.marked{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 的元素指定一个样式。</p>
</li>
<li>
<p><code>.marked p{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</p>
</li>
<li>
<p><code>p.marked{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 的 <strong>p</strong> 元素指定一个样式。</p>
</li>
</ul>
</div>
<div><p>相关信息</p>
<p>选择器详细介绍，请见 <a href="./../intro/selector.html">选择器</a>。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">背景与边框</title>
    <id>https://list-jiang.github.io/code/website/css/intro/background-and-border/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/background-and-border/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景样式"> 背景样式</h2>
<h3 id="背景颜色"> 背景颜色</h3>
<p><code>background-color</code> 属性定义了 CSS 中任何元素的背景颜色。属性接受任何有效的颜色值。背景色扩展到元素的内容和内边距的下面。</p>

          <div
            id="code-demo-a8ca53ea"
           
  
 data-title="%E4%B8%BA%E5%85%83%E7%B4%A0%E7%9B%92%E5%AD%90%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%3Ch2%3EBackground%20Colors%3C%2Fh2%3E%5Cn%20%20%3Cp%3ETry%20changing%20the%20background%20%3Cspan%3Ecolors%3C%2Fspan%3E.%3C%2Fp%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20background-color%3A%20%23567895%3B%5Cn%7D%5Cn%5Cnh2%20%7B%5Cn%20%20background-color%3A%20black%3B%5Cn%20%20color%3A%20white%3B%5Cn%7D%5Cnspan%20%7B%5Cn%20%20background-color%3A%20rgba(255%2C%20255%2C%20255%2C%200.5)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h2</span><span>></span></span>Background Colors<span><span><span>&lt;/</span>h2</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>Try changing the background <span><span><span>&lt;</span>span</span><span>></span></span>colors<span><span><span>&lt;/</span>span</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>background-color</span><span>:</span> #567895<span>;</span>
<span>}</span>

<span>h2</span> <span>{</span>
  <span>background-color</span><span>:</span> black<span>;</span>
  <span>color</span><span>:</span> white<span>;</span>
<span>}</span>
<span>span</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span> 255<span>,</span> 255<span>,</span> 0.5<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="背景图片"> 背景图片</h3>
<p><code>background-image</code> 属性允许在元素的背景中显示图像。</p>
<p>默认情况下，大图不会缩小以适应方框，因此我们只能看到它的一个小角，而小图则是平铺以填充方框。</p>

          <div
            id="code-demo-eda51462"
           
  
 data-title="%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%A1%86%E4%B8%80%E4%B8%AA%E6%9C%89%E6%96%B9%E6%A1%86%E5%A4%A7%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E3%80%81%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9C%89%E6%98%9F%E6%98%9F%E7%9A%84%E5%B0%8F%E5%9B%BE%E5%83%8F%E3%80%82"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20a%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20b%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20200px%3B%5Cn%7D%5Cn%5Cn.a%20%7B%5Cn%20%20background-image%3A%20url(http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fballoons.jpg)%3B%5Cn%7D%5Cn%5Cn.b%20%7B%5Cn%20%20background-image%3A%20url(http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fstar.png)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box a<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box b<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
<span>}</span>

<span>.a</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/balloons.jpg<span>)</span></span><span>;</span>
<span>}</span>

<span>.b</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>如果除了背景图像外，还指定了背景颜色，则图像将显示在颜色的顶部。尝试向上面的示例添加一个 <code>background-color</code> 属性，看看效果如何。</p>
<h4 id="控制背景平铺"> 控制背景平铺</h4>
<p><code>background-repeat</code> 属性用于控制图像的平铺行为。可用的值是:</p>
<ul>
<li><code>no-repeat</code> — 不重复。</li>
<li><code>repeat-x</code> —水平重复。</li>
<li><code>repeat-y</code> —垂直重复。</li>
<li><code>repeat</code> — 在两个方向重复。</li>
</ul>

          <div
            id="code-demo-d418178e"
           
  
 data-title="%E8%AF%B7%E8%87%AA%E8%A1%8C%E6%9B%B4%E6%94%B9%E5%B9%B6%E5%B0%9D%E8%AF%95"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20200px%3B%5Cn%20%20background-image%3A%20url(http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fstar.png)%3B%5Cn%20%20background-repeat%3A%20no-repeat%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="调整背景图像的大小"> 调整背景图像的大小</h4>
<p>如果我们有一个很大的图像，但是不想它被裁剪掉，我们可以使用 <code>background-size</code> 属性。</p>
<p>它可以设置长度或百分比值，来调整图像的大小以适应背景。</p>
<p>您也可以使用关键字:</p>
<ul>
<li><code>cover</code>: 浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li>
<li><code>contain</code>: 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li>
</ul>

          <div
            id="code-demo-a7cb92b6"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20200px%3B%5Cn%20%20background-image%3A%20url(http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fballoons.jpg)%3B%5Cn%20%20background-repeat%3A%20no-repeat%3B%5Cn%20%20background-size%3A%20100px%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>请自行更改并尝试:</p>
<ul>
<li>改变用于修改背景大小的长度单位。</li>
<li>去掉长度单位，看看使用 <code>background-size: cover</code> or <code>background-size: contain</code> 的状态。</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/balloons.jpg<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-size</span><span>:</span> 100px 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="背景图像定位"> 背景图像定位</h4>
<p><code>background-position</code> 属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是 (0,0)，框沿着水平(x)和垂直(y)轴定位。</p>
<div><p>相关信息</p>
<p>默认的背景位置值是 (0,0)。</p>
</div>
<p>最常见的背景位置值有两个单独的值: 一个水平值后面跟着一个垂直值。</p>
<p>您可以使用像 <code>top</code> 和 <code>right</code> 这样的关键字</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> top center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>或者使用长度值与百分比:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> 20px 10%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>您也可以混合使用关键字，长度值以及百分比，例如:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> top 20px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>最后，您还可以使用四个值语法来指示到盒子的某些边的距离。长度单位是与其前面的值的偏移量。所以在下面的 CSS 中，我们将背景从顶部调整 20px，从右侧调整 10px:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> top 20px right 10px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
          <div
            id="code-demo-8a321586"
           
  
 data-title="%E5%8A%A8%E6%89%8B%E6%93%8D%E4%BD%9C%E4%BD%93%E4%BC%9A%E8%BF%99%E4%BA%9B%E5%80%BC"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20200px%3B%5Cn%20%20background-image%3A%20url(http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fstar.png)%3B%5Cn%20%20background-repeat%3A%20no-repeat%3B%5Cn%20%20background-position%3A%20top%2020px%20right%2010px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>http://mrhope.site/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> top 20px right 10px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>相关信息</p>
<p><code>background-position</code> 是 <code>background-position-x</code> 和 <code>background-position-y</code> 的简写，它们允许您分别设置不同的坐标轴的值。</p>
</div>
<h3 id="渐变背景"> 渐变背景</h3>
<p>当渐变用于背景时，也可以使用像图像一样的 <code>background-image</code> 属性设置。</p>
<div><p>相关信息</p>
<p>渐变色的案例可以从 <a href="https://webgradients.com/" target="_blank" rel="noopener noreferrer">Web Gradients</a> 寻找，此处不再举例</p>
</div>
<h3 id="多个背景图像"> 多个背景图像</h3>
<p>CSS 允许您有多个背景图像。您需要在 <code>background-image</code> 设置多个值，并用逗号分隔每个值。</p>
<p>当您这样做时，您可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p>
<div><p>提示</p>
<p>渐变可以与常规的背景图像很好地混合在一起。</p>
</div>
<p>其它 <code>background-*</code> 属性的值需要同样用逗号分隔的方式设置。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>background-image</span><span>:</span> <span><span>url</span><span>(</span>image1.png<span>)</span></span><span>,</span> <span><span>url</span><span>(</span>image2.png<span>)</span></span><span>,</span> <span><span>url</span><span>(</span>image3.png<span>)</span></span><span>,</span>
  <span><span>url</span><span>(</span>image1.png<span>)</span></span><span>;</span>
<span>background-repeat</span><span>:</span> no-repeat<span>,</span> repeat-x<span>,</span> repeat<span>;</span>
<span>background-position</span><span>:</span> 10px 20px<span>,</span> top right<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不同属性的每个值，将与其他属性中相同位置的值匹配。例如，上面的 image1 的 <code>background-repeat</code> 值将是 <code>no-repeat</code>。</p>
<p>当不同的属性具有不同数量的值时，较小数量的值会循环继续使用。</p>
<h3 id="背景附加"> 背景附加</h3>
<p><code>background-attachment</code> 属性控制内容滚动时背景何滚动。</p>
<p>它可以接受以下值:</p>
<ul>
<li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li>
<li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li>
<li><code>local</code>: 因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li>
</ul>
<p><code>background-attachment</code> 属性只有在有内容要滚动时才会有效果。</p>
<div><p>案例</p>
<p><a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html" target="_blank" rel="noopener noreferrer">案例地址</a></p>
</div>
<h3 id="background-简写"> background 简写</h3>
<p>CSS <code>background</code> 属性是许多普通背景属性的简写，它允许您一次设置所有不同的属性。</p>
<p>如果您在样式表中发现了一个复杂的背景属性，可能会觉得难以理解，因为可以同时传入这么多值。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>background</span><span>:</span> <span>linear-gradient</span><span>(</span>
        105deg<span>,</span>
        <span>rgba</span><span>(</span>255<span>,</span> 255<span>,</span> 255<span>,</span> 0.2<span>)</span> 39%<span>,</span>
        <span>rgba</span><span>(</span>51<span>,</span> 56<span>,</span> 57<span>,</span> 1<span>)</span> 96%
      <span>)</span> center center / 400px 200px no-repeat<span>,</span> <span><span>url</span><span>(</span>big-star.png<span>)</span></span> center
      no-repeat<span>,</span> rebeccapurple<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。</p>
<p>这里有一些规则，需要在简写背景属性时遵循，例如:</p>
<ul>
<li><code>background-color</code> 只能在逗号之后指定。</li>
<li><code>background-size</code> 值只能包含在背景位置之后，用 <code>/</code> 字符分隔，例如: <code>center/80%</code>。</li>
</ul>
<p>全部规则请见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div><p>注意</p>
<p>Mr.Hope 极其不建议使用这个简写，因为它比较复杂，很容易导致预期之外的结果。</p>
</div>
<h3 id="背景的可访问性考虑"> 背景的可访问性考虑</h3>
<p>当您把文字放在背景图片或颜色上面时，需要保持足够的对比度让文字清晰易读。如果指定了一个图像，并且文本将被放置在该图像的顶部，您还应该指定一个 <code>background-color</code> ，以便在图像未加载时文本也足够清晰。</p>
<div><p>注意</p>
<p>屏幕阅读器不能解析背景图像，因此背景图片应该只是纯粹的装饰；任何重要的内容都应该是 HTML 页面的一部分，而不是包含在背景中。</p>
</div>
<h2 id="边框"> 边框</h2>
<p>在学习盒模型时，我们发现了边框如何影响盒子的大小。在这节课中，我们将看看如何创造性地使用边界。通常，当我们使用 CSS 向元素添加边框时，我们使用一个简写属性在一行 CSS 中设置边框的颜色、宽度和样式。我们可以使用 <code>border</code> 为一个框的所有四个边设置边框。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid black<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或者我们可以只设置盒子的一个边，例如:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border-top</span><span>:</span> 1px solid black<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上述简写属性等价于:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border-width</span><span>:</span> 1px<span>;</span>
  <span>border-style</span><span>:</span> solid<span>;</span>
  <span>border-color</span><span>:</span> black<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当然您也可以使用分别设置某个边:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border-top-width</span><span>:</span> 1px<span>;</span>
  <span>border-top-style</span><span>:</span> solid<span>;</span>
  <span>border-top-color</span><span>:</span> black<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="圆角"> 圆角</h3>
<p>使用 <code>border-radius</code> 属性可以实现边框的圆角。属性需要填入两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，同时作用在两个半径上。</p>
<p>例如，要使一个盒子的四个角都有 10px 的圆角半径:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border-radius</span><span>:</span> 10px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>或使右上角的水平半径为 1em，垂直半径为 10%:</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border-top-right-radius</span><span>:</span> 1em 10%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">盒模型</title>
    <id>https://list-jiang.github.io/code/website/css/intro/box/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/box/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在 CSS 中，所有的元素都被一个个的“盒子(box)”包围着。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在 CSS 中，所有的元素都被一个个的“盒子(box)”包围着。</p>

<h2 id="块级与内联"> 块级与内联</h2>
<p>在 CSS 中我们广泛地使用两种“盒子” —— 块级盒子 (block box) 和 内联盒子 (inline box)。这两种盒子会在页面流(page flow)和元素之间的关系方面表现出不同的行为:</p>
<p>一个被定义成块级的(block)盒子会表现出以下行为:</p>
<ul>
<li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li>
<li>每个盒子都会换行</li>
<li><code>width</code> 和 <code>height</code> 属性可以发挥作用</li>
<li>内边距 (padding), 外边距 (margin) 和边框 (border) 会将其他元素从当前盒子周围“推开”</li>
</ul>
<p>除非特殊指定，诸如标题 (<code>&lt;h1&gt;</code> 等) 和段落 (<code>&lt;p&gt;</code>) 默认情况下都是块级的盒子。</p>
<p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p>
<ul>
<li>盒子不会产生换行。</li>
<li><code>width</code> 和 <code>height</code> 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
<p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p>
<p>我们通过对盒子 <code>display</code> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p>
<div><p>相关信息</p>
<p>显示类型分为 <strong>内部</strong> 和 <strong>外部</strong> 显示类型。如上所述， CSS 的 box 模型有一个外部显示类型，来决定盒子是块级还是内联。</p>
<p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照正常文档流布局，也意味着它们和其他块元素以及内联元素一样(如上所述).</p>
<p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。该盒子的所有直接子元素都会成为 <code>flex</code> 元素，会根据 弹性盒子(Flexbox )规则进行布局。同样，我们也可以设置诸如 <code>inline-block</code> <code>inline-flex</code> 这种混合显示类型。</p>
<p>块级和内联布局是 web 上默认的行为，它被称为正常文档流， 因为如果没有其他说明，我们的盒子布局默认是块级或者内联。</p>
</div>
<h2 id="盒模型介绍"> 盒模型介绍</h2>
<p>所有 HTML 元素可以看作盒子，在 CSS 中，&quot;<strong>Box Model</strong>&quot; 这一术语是用来设计和布局时使用。</p>
<p>CSS 盒模型定义了封装 HTML 元素的方式，它包括: 外边距，边框，内边距，和实际内容。</p>
<p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。</p>
<p>下面的图片说明了盒子模型 (Box Model):</p>
<p><img src="./assets/box-model.gif" alt="Box Model 示意图" loading="lazy"></p>
<p>不同部分的说明:</p>
<ul>
<li>Content box (内容) - 盒子的内容，显示文本和图像，可以通过 <code>width</code> 和 <code>height</code> 设置大小。</li>
<li>Padding box (内边距) - 包围在内容区域外部的空白区域，通过 <code>padding</code> 属性设置。</li>
<li>Border box (边框) - 围绕在填充和内容外的边框，通过 <code>border</code> 属性设置。</li>
<li>Margin box (外边距) - 这是最外面的区域，是盒子和其他元素之间的空白区域，通过 <code>margin</code> 属性设置。</li>
</ul>
<div><pre><code><span>div</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>border</span><span>:</span> 25px solid green<span>;</span>
  <span>padding</span><span>:</span> 25px<span>;</span>
  <span>margin</span><span>:</span> 25px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>为了正确设置元素在所有浏览器中的宽度和高度，您需要知道的盒模型是如何工作的。</p>
<div><p>提示</p>
<p><code>padding</code> 和 <code>margin</code> 直译为 “填充” 和 “边距”，有些教程也会这么叫。</p>
<p>所以您需要清楚 “填充” 和 “内边距”、“边距” 和 “外边距” 说的是一回事。</p>
</div>
<h3 id="标准盒模型"> 标准盒模型</h3>
<p>当您指定一个 CSS 元素的宽度和高度属性时，您只是设置内容区域(content box)的宽度和高度。<code>padding</code> 和 <code>border</code> 再加上设置的宽高一起决定整个盒子的大小。</p>
<div><p>注意</p>
<p>margin 不计入实际大小，但它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。</p>
</div>

          <div
            id="code-demo-ae466326"
           
  
 data-title="%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%AB%98%E5%BA%A6"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22div.box%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20border%3A%2025px%20solid%20green%3B%5Cn%20%20padding%3A%2025px%3B%5Cn%20%20margin%3A%2025px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>div.box</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>border</span><span>:</span> 25px solid green<span>;</span>
  <span>padding</span><span>:</span> 25px<span>;</span>
  <span>margin</span><span>:</span> 25px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>元素盒子的大小为: 300px (宽) + 50px (左 + 右填充) + 50px (左 + 右边框) = 400px</p>
<p>元素占据的空间为: 300px (宽) + 50px (左 + 右填充) + 50px (左 + 右边框) + 50px (左 + 右边距) = 450px</p>
<p>试想一下，您只有 250px 的空间。让我们设置总宽度为 250px 的元素:</p>

          <div
            id="code-demo-41c13d64"
           
  
 data-title="%E6%80%BB%E5%AE%BD%E5%BA%A6%20250px%20%E7%9A%84%E5%85%83%E7%B4%A0"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22div.box%20%7B%5Cn%20%20width%3A%20220px%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20border%3A%205px%20solid%20gray%3B%5Cn%20%20margin%3A%200%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>div.box</span> <span>{</span>
  <span>width</span><span>:</span> 220px<span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>border</span><span>:</span> 5px solid gray<span>;</span>
  <span>margin</span><span>:</span> 0<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>最终元素的总宽度计算公式是这样的:</p>
<p>元素的宽度 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框
元素占据的水平空间 = 宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距</p>
<p>元素的总高度最终计算公式是这样的:</p>
<p>元素的高度 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框
元素占据的垂直空间 = 高度 + 顶部填充 + 底部填充 + 上边框 + 下边框 + 上边距 + 下边距</p>
<h3 id="替代-ie-盒模型"> 替代(IE)盒模型</h3>
<p>您可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且您的想法是对的! 因为这个原因，CSS 还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px).</p>
<p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。这样就可以告诉浏览器使用 <code>border-box</code> 来定义区域，从而设定您想要的大小。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性。这是一个很有用的小技巧:</p>
<div><pre><code><span>html</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
<span>}</span>
<span>*,
*::before,
*::after</span> <span>{</span>
  <span>box-sizing</span><span>:</span> inherit<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="使用调试工具来查看盒模型"> 使用调试工具来查看盒模型</h3>
<p>浏览器开发者工具 可以使您更容易地理解 box 模型。您可以看到元素的大小以及它的外边距、内边距和边框。这是一个很好的检查元素大小的方式，可以便捷的判断您的盒子大小是否符合预期。</p>
<div><p>相关信息</p>
<p>更多盒模型相关内容可见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener noreferrer">MDN</a></p>
</div>
<h2 id="控制盒模型"> 控制盒模型</h2>
<p><code>margin</code>、<code>padding</code> 和 <code>border</code> 是属性的简写，允许我们一次设置盒子的四个边。这些简写等价于分别控制盒子的不同边的普通写法。</p>
<h3 id="外边距"> 外边距</h3>
<p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p>
<p>我们可以使用 <code>margin</code> 属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制:</p>
<ul>
<li><code>margin-top</code></li>
<li><code>margin-right</code></li>
<li><code>margin-bottom</code></li>
<li><code>margin-left</code></li>
</ul>
<h4 id="外边距折叠"> 外边距折叠</h4>
<p>如果您有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p>

          <div
            id="code-demo-16ce3299"
           
  
 data-title="%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Cp%20class%3D%5C%22one%5C%22%3EI%20am%20paragraph%20one.%3C%2Fp%3E%5Cn%20%20%3Cp%20class%3D%5C%22two%5C%22%3EI%20am%20paragraph%20two.%3C%2Fp%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20margin-bottom%3A%2050px%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20margin-top%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>我们有两个段落。顶部段落 <code>margin-bottom</code> 为 <code>50px</code>。第二段的 <code>margin-top</code> 为 <code>30px</code>。因为外边距折叠的概念，所以框之间的实际外边距是 <code>50px</code>，而不是两个外边距的总和。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>one<span>"</span></span><span>></span></span>I am paragraph one.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>two<span>"</span></span><span>></span></span>I am paragraph two.<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>margin-bottom</span><span>:</span> 50px<span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>margin-top</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>外边距重叠</p>
<p>有许多规则规定了什么时候外边距会折叠，什么时候不会折叠。相关更多信息，请参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener noreferrer">外边距重叠</a>。初学时您需要首先记住外边距会折叠，如果您用外边距创建空间而没有得到您想要的效果，请参阅上方链接寻找原因。</p>
</div>
<h3 id="边框"> 边框</h3>
<p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p>
<p>为边框设置样式时，有大量的属性可以使用。由于有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p>
<p>可以使用 <code>border</code> 属性一次设置所有四个边框的宽度、颜色和样式。</p>
<p>分别设置每边的宽度、颜色和样式，可以使用:</p>
<ul>
<li><code>border-top</code></li>
<li><code>border-right</code></li>
<li><code>border-bottom</code></li>
<li><code>border-left</code></li>
</ul>
<p>设置所有边的颜色、样式或宽度，请使用以下属性:</p>
<ul>
<li><code>border-width</code></li>
<li><code>border-style</code></li>
<li><code>border-color</code></li>
</ul>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一:</p>
<ul>
<li><code>border-top-width</code></li>
<li><code>border-top-style</code></li>
<li><code>border-top-color</code></li>
<li><code>border-right-width</code></li>
<li><code>border-right-style</code></li>
<li><code>border-right-color</code></li>
<li><code>border-bottom-width</code></li>
<li><code>border-bottom-style</code></li>
<li><code>border-bottom-color</code></li>
<li><code>border-left-width</code></li>
<li><code>border-left-style</code></li>
<li><code>border-left-color</code></li>
</ul>
<p>设置边框的颜色、样式或宽度，可以使用最细粒度的普通属性或者简写属性。</p>

          <div
            id="code-demo-216e86ce"
           
  
 data-title="%E8%BE%B9%E6%A1%86%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3EChange%20my%20borders.%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%7B%5Cn%20%20border-top%3A%205px%20dotted%20green%3B%5Cn%20%20border-right%3A%201px%20solid%20black%3B%5Cn%20%20border-bottom%3A%2020px%20double%20rgb(23%2C%2045%2C%20145)%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20border%3A%201px%20solid%20%23333333%3B%5Cn%20%20border-top-style%3A%20dotted%3B%5Cn%20%20border-right-width%3A%2020px%3B%5Cn%20%20border-bottom-color%3A%20hotpink%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>Change my borders.<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>
  <span>border-top</span><span>:</span> 5px dotted green<span>;</span>
  <span>border-right</span><span>:</span> 1px solid black<span>;</span>
  <span>border-bottom</span><span>:</span> 20px double <span>rgb</span><span>(</span>23<span>,</span> 45<span>,</span> 145<span>)</span><span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #333333<span>;</span>
  <span>border-top-style</span><span>:</span> dotted<span>;</span>
  <span>border-right-width</span><span>:</span> 20px<span>;</span>
  <span>border-bottom-color</span><span>:</span> hotpink<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="内边距"> 内边距</h3>
<p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是 0 或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p>
<p>同 <code>margin</code>，我们可以使用 <code>padding</code> 简写属性控制元素所有边，或者每边单独使用等价的普通属性:</p>
<ul>
<li><code>padding-top</code></li>
<li><code>padding-right</code></li>
<li><code>padding-bottom</code></li>
<li><code>padding-left</code></li>
</ul>
<h2 id="inline-block"> inline-block</h2>
<p><code>display</code> 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用: 您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p>
<p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果:</p>
<ul>
<li>设置 <code>width</code> 和 <code>height</code> 属性会生效。</li>
<li><code>padding</code>, <code>margin</code>, 以及 <code>border</code> 会推开其他元素。</li>
</ul>
<p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p>
<div><p>提示</p>
<p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。</p>
<p>比如 <code>&lt;a&gt;</code> 是像 <code>&lt;span&gt;</code> 一样的内联元素；您可以使用 <code>display: inline-block</code> 来设置内边距，让用户更容易点击链接。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文字样式</title>
    <id>https://list-jiang.github.io/code/website/css/intro/font/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/font/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文本"> 文本</h2>
<p>元素中的文本是布置在元素的内容框中。以内容区域的左上角作为起点 (或者是右上角，是在 RTL 语言的情况下)，一直延续到行的结束部分。一旦达到行的尽头，它就会进到下一行，然后继续，再接着下一行，直到所有内容都放入了盒子中。文本内容表现地像一些内联元素，被布置到相邻的行上，除非到达了行的尽头，否则不会换行，或者您想强制地手动造成换行的话，您可以使用 <code>&lt;br&gt;</code> 元素。</p>
<p>用于样式文本的 CSS 属性通常可以分为两类:</p>
<ul>
<li><strong>字体样式</strong>: 作用于字体的属性，会直接应用到文本中，比如使用哪种字体，字体的大小是怎样的，字体是粗体还是斜体，等等。</li>
<li><strong>文本布局风格</strong>: 作用于文本的间距以及其他布局功能的属性，比如，允许操纵行与字之间的空间，以及在内容框中，文本如何对齐。</li>
</ul>
<div><p>注意</p>
<p>包含在元素中的文本是作为一个单一的实体。您不能将文字其中一部分选中或添加样式。</p>
<p>如果您要这么做，那么您必须要用适合的元素来包装它们，比如 (<code>&lt;span&gt;</code> 或者 <code>&lt;strong&gt;</code>)。</p>
<p>您也可以使用伪元素，比如 <code>::first-letter</code> (选中元素文本的第一个字母), <code>::first-line</code> (选中元素文本的第一行), 或者 <code>::selection</code> (当前光标双击选中的文本)</p>
</div>
<h2 id="字体"> 字体</h2>
<h3 id="颜色"> 颜色</h3>
<p><code>color</code> 属性设置选中元素的前景内容的颜色 (通常指文本，也包括诸如 <code>text-decoration</code> 属性设置的文本下方或上方的线)。</p>
<p>color 也可以接受任何合法的 CSS 颜色单位。</p>

          <div
            id="code-demo-76b2994f"
           
  
 data-title="%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E6%88%91%E6%98%AF%E7%BA%A2%E8%89%B2%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>我是红色<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="字体种类"> 字体种类</h3>
<p>要在您的文本上设置一个不同的字体，您可以使用 font-family 属性，这个允许您为浏览器指定一个字体 (或者一个字体的列表)，然后浏览器可以将这种字体应用到选中的元素上。浏览器只会把在当前机器上可用的字体应用到当前正在访问的网站上；如果字体不可用，那么就会用浏览器默认的字体代替。</p>
<div><pre><code><span>p</span> <span>{</span>
  <span>font-family</span><span>:</span> arial<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="网页安全字体"> 网页安全字体</h4>
<p>只有某几个字体通常可以应用到所有系统，因此可以毫无顾忌地使用。这些都是所谓的<strong>网页安全字体</strong>。</p>
<table>
<thead>
<tr>
<th>字体名称</th>
<th>泛型</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arial</td>
<td>sans-serif</td>
<td>通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使 Arial 更广泛地可用。</td>
</tr>
<tr>
<td>Courier New</td>
<td>monospace</td>
<td>某些操作系统有一个 Courier New 字体的替代(可能较旧的)版本叫 Courier。使用 Courier New 作为 Courier 的首选替代方案，被认为是最佳做法。</td>
</tr>
<tr>
<td>Georgia</td>
<td>serif</td>
<td></td>
</tr>
<tr>
<td>Times New Roman</td>
<td>serif</td>
<td>某些操作系统有一个 Times New Roman 字体的替代(可能较旧的)版本叫 Times。使用 Times 作为 Times New Roman 的首选替代方案，被认为是最佳做法。</td>
</tr>
<tr>
<td>Trebuchet MS</td>
<td>sans-serif</td>
<td>您应该小心使用这种字体——它在移动操作系统上并不广泛。</td>
</tr>
<tr>
<td>Verdana</td>
<td>sans-serif</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="默认字体"> 默认字体</h4>
<p>CSS 定义了 5 个常用的字体名称: <code>serif</code>, <code>sans-serif</code>, <code>monospace</code>, <code>cursive</code>,和 <code>fantasy</code>. 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。</p>
<p>五个名称定义如下:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>serif</td>
<td>有衬线的字体 (衬线一词是指字体笔画尾端的小装饰，存在于某些印刷体字体中)</td>
</tr>
<tr>
<td>sans-serif</td>
<td>没有衬线的字体。</td>
</tr>
<tr>
<td>monospace</td>
<td>每个字符具有相同宽度的字体，通常用于代码列表。</td>
</tr>
<tr>
<td>cursive</td>
<td>用于模拟笔迹的字体，具有流动的连接笔画。</td>
</tr>
<tr>
<td>fantasy</td>
<td>用来装饰的字体</td>
</tr>
</tbody>
</table>
<h4 id="字体栈"> 字体栈</h4>
<p>由于您无法保证您想在您的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 您可以提供一个字体栈 (font stack)，这样的话，浏览器就有多种字体可以选择了。只需包含一个 <code>font-family</code> 属性，其值由几个用逗号分离的字体名称组成。</p>
<div><pre><code><span>p</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>"Trebuchet MS"</span><span>,</span> Verdana<span>,</span> sans-serif<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。在字体栈的最后提供一个合适的通用的字体名称是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。</p>
<h3 id="字体大小"> 字体大小</h3>
<p>字体大小可以通过 font-size 属性设置。</p>
<p>常用单位:</p>
<ul>
<li>px (像素): 将像素的值赋予给您的文本。这是一个绝对单位， 它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。</li>
<li>em: 1em 等于我们设计的当前元素的父元素上设置的字体大小。如果您有大量设置了不同字体大小的嵌套元素，可能会变得复杂。</li>
<li>rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小(即 <code>&lt;html&gt;</code>) ，而不是父元素。这可以让您更容易计算字体大小。</li>
</ul>
<p>元素的 font-size 属性是从该元素的父元素继承的。所以这一切都是从整个文档的根元素 <code>&lt;html&gt;</code> 开始，浏览器的 font-size 标准设置的值为 16px。在根元素中的任何段落 (或者那些浏览器没有设置默认大小的元素)，会有一个最终的大小值: 16px。其他元素也许有默认的大小，比如 <code>&lt;h1&gt;</code> 元素有一个 2em 的默认值，所以它的最终大小值为 32px。</p>

          <div
            id="code-demo-33420523"
           
  
 data-title="em%20%E7%9A%84%E8%AE%A1%E7%AE%97"

            data-code="%7B%22html%22%3A%22%3C!--%20%E6%96%87%E6%A1%A3%20font-size%20%E4%B8%BA%2016px%20--%3E%5Cn%3Carticle%3E%5Cn%20%20%3C!--%20%E5%A6%82%E4%BD%95%E7%BB%99%E5%87%BA%2020px%20%E7%9A%84%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%20--%3E%5Cn%20%20%3Cp%3E%E6%AE%B5%E8%90%BD%E6%96%87%E5%AD%97%3C%2Fp%3E%5Cn%3C%2Farticle%3E%5Cn%22%2C%22css%22%3A%22article%20%7B%5Cn%20%20font-size%3A%201.5em%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span>&lt;!-- 文档 font-size 为 16px --></span>
<span><span><span>&lt;</span>article</span><span>></span></span>
  <span>&lt;!-- 如何给出 20px 的字体大小 --></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>段落文字<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>article</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>article</span> <span>{</span>
  <span>font-size</span><span>:</span> 1.5em<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>很容易计算 article 字体大小为 24px，那么 p 的字体大小就要为 0.83333333em</p>

            </div>
          </div>
          
        </div>
<h3 id="字体样式-字体粗细-文本转换和文本装饰"> 字体样式，字体粗细，文本转换和文本装饰</h3>
<p>CSS 提供了 4 种常用的属性来改变文本的样子:</p>
<h3 id="font-style"> font-style</h3>
<p>用来设置文本斜体。可能的值如下:</p>
<ul>
<li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li>
<li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 <code>oblique</code> 状态来模拟 italics。</li>
<li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li>
</ul>
<h3 id="font-weight"> font-weight</h3>
<p>设置文字的粗体大小。这里有很多值可选 (比如 <code>light</code>, <code>normal</code>, <code>bold</code>, <code>extrabold</code>, <code>black</code>)</p>
<ul>
<li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li>
<li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。</li>
<li>100 – 900: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li>
</ul>
<h3 id="text-transform"> text-transform</h3>
<p>允许您设置要转换的字体。值包括:</p>
<ul>
<li><code>none</code>: 防止任何转型。</li>
<li><code>uppercase</code>: 将所有文本转为大写。</li>
<li><code>lowercase</code>: 将所有文本转为小写。</li>
<li><code>capitalize</code>: 转换所有单词让其首字母大写。</li>
<li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形(如中文，日文，韩文)对齐。</li>
</ul>
<h3 id="text-decoration"> text-decoration</h3>
<p>设置/取消字体上的文本装饰，主要使用此方法在设置链接时取消设置链接上的默认下划线。可用值为:</p>
<ul>
<li><code>none</code>: 取消已经存在的任何文本装饰。</li>
<li><code>underline</code>: 文本下划线.</li>
<li><code>overline</code>: 文本上划线</li>
<li><code>line-through</code>: 穿过文本的线，可以创造删除线。</li>
</ul>
<p><code>text-decoration</code> 可以一次接受多个值，比如 <code>text-decoration: underline overline</code>。</p>
<p><code>text-decoration</code> 是一个缩写形式，它由 <code>text-decoration-line</code>, <code>text-decoration-style</code> 和 <code>text-decoration-color</code> 构成。您可以使用这些属性值的组合来创建有趣的效果，比如 <code>text-decoration: line-through red wavy</code>。</p>
<h3 id="文字阴影"> 文字阴影</h3>
<p>您可以使用 <code>text-shadow</code> 属性为您的文本应用阴影。</p>
<div><pre><code><span>text-shadow</span><span>:</span> 4px 4px 5px red<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>4 个属性如下:</p>
<ol>
<li>阴影与原始文本的水平偏移: 可以使用大多数的 CSS 长度和尺寸单位, 但是 px 是比较合适的。这个值必须指定。</li>
<li>阴影与原始文本的垂直偏移: 效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。</li>
<li>模糊半径: 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 长度和尺寸单位.</li>
<li>阴影的基础颜色: 可以使用大多数的 CSS 颜色单位. 如果没有指定，默认为 <code>black</code>.</li>
</ol>
<div><p>提示</p>
<p>正偏移值会向右向下移动阴影，但也可以使用负偏移值来向左向上移动阴影，例如 <code>-1px -1px</code>.</p>
</div>
<h4 id="多种阴影"> 多种阴影</h4>
<p>您可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本</p>
<div><pre><code><span>text-shadow</span><span>:</span> -1px -1px 1px #aaa<span>,</span> 0px 4px 1px <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.5<span>)</span><span>,</span>
  4px 4px 5px <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.7<span>)</span><span>,</span> 0px 0px 7px <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.4<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="文本布局"> 文本布局</h2>
<h3 id="文本对齐"> 文本对齐</h3>
<p><code>text-align</code> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同:</p>
<ul>
<li>
<p><code>left</code>: 左对齐文本。</p>
</li>
<li>
<p><code>right</code>: 右对齐文本。</p>
</li>
<li>
<p><code>center</code>: 居中文字</p>
</li>
<li>
<p><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。</p>
<p>您需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果您要使用这个，您也应该考虑一起使用别的东西，比如 <code>hyphens</code>，打破一些更长的词语。</p>
</li>
</ul>
<h3 id="行高"> 行高</h3>
<p><code>line-height</code> 属性设置文本每行之间的高，可以接受大多数长度与尺寸单位，不过也可以设置一个无单位的值，作为乘数。</p>
<p>通常无单位是比较好的做法。行高由此值乘以 <code>font-size</code> 生成。</p>
<p>当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距)。</p>
<div><pre><code><span>line-height</span><span>:</span> 1.5<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="字母和单词间距"> 字母和单词间距</h3>
<p><code>letter-spacing</code> 和 <code>word-spacing</code> 属性允许您设置您的文本中的字母与字母之间的间距、或是单词与单词之间的间距，可以接受大多数长度与尺寸单位。</p>
<div><pre><code><span>p::first-line</span> <span>{</span>
  <span>letter-spacing</span><span>:</span> 2px<span>;</span>
  <span>word-spacing</span><span>:</span> 4px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="其他属性"> 其他属性</h2>
<h3 id="字体样式"> 字体样式</h3>
<ul>
<li><code>font-variant</code>: 在小型大写字母和普通文本选项之间切换。</li>
<li><code>font-kerning</code>: 开启或关闭字体间距选项。</li>
<li><code>font-feature-settings</code>: 开启或关闭不同的 OpenType 字体特性。</li>
<li><code>font-variant-alternates</code>: 控制给定的自定义字体的替代字形的使用。</li>
<li><code>font-variant-caps</code>: 控制大写字母替代字形的使用。</li>
<li><code>font-variant-east-asian</code>: 控制东亚文字替代字形的使用, 像日语和汉语。</li>
<li><code>font-variant-ligatures</code>: 控制文本中使用的连写和上下文形式。</li>
<li><code>font-variant-numeric</code>: 控制数字，分式和序标的替代字形的使用。</li>
<li><code>font-variant-position</code>: 控制位于上标或下标处，字号更小的替代字形的使用。</li>
<li><code>font-size-adjust</code>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li>
<li><code>font-stretch</code>: 在给定字体的可选拉伸版本中切换。</li>
<li><code>text-underline-position</code>: 指定下划线的排版位置，通过使用 <code>text-decoration-line</code> 属性的 <code>underline</code> 值。</li>
<li><code>text-rendering</code>: 尝试执行一些文本渲染优化。</li>
</ul>
<h3 id="文本布局样式"> 文本布局样式</h3>
<ul>
<li><code>text-indent</code>: 指定文本内容的第一行前面应该留出多少的水平空间。</li>
<li><code>text-overflow</code>: 定义如何向用户表示存在被隐藏的溢出内容。</li>
<li><code>white-space</code>: 定义如何处理元素内部的空白和换行。</li>
<li><code>word-break</code>: 指定是否能在单词内部换行。</li>
<li><code>direction</code>: 定义文本的方向 (这取决于语言，并且通常最好让 HTML 来处理这部分，因为它是和文本内容相关联的。)</li>
<li><code>hyphens</code>: 为支持的语言开启或关闭连字符。</li>
<li><code>line-break</code>: 对东亚语言采用更强或更弱的换行规则。</li>
<li><code>text-align-last</code>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li>
<li><code>text-orientation</code>: 定义行内文本的方向。</li>
<li><code>word-wrap</code>: 指定浏览器是否可以在单词内换行以避免超出范围。</li>
<li><code>writing-mode</code>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li>
</ul>
<h2 id="font-简写"> Font 简写</h2>
<p>许多字体的属性也可以通过 font 的简写方式来设置。</p>
<p>您应该按照以下顺序来写:</p>
<ul>
<li><code>font-style</code></li>
<li><code>font-variant</code></li>
<li><code>font-weight</code></li>
<li><code>font-stretch</code></li>
<li><code>font-size</code></li>
<li><code>line-height</code></li>
<li><code>font-family</code></li>
</ul>
<p>如果您想要使用 font 的简写形式，在所有这些属性中，只有 <code>font-size</code> 和 <code>font-family</code> 是一定要指定的。另外 <code>font-size</code> 和 <code>line-height</code> 属性之间必须放一个正斜杠。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>font</span><span>:</span> italic normal bold normal 3em/1.5 Helvetica<span>,</span> Arial<span>,</span> sans-serif<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="web-字体"> Web 字体</h2>
<p>Web 字体是一种 CSS 特性，允许您指定在访问时随您的网站一起下载的字体文件，这意味着任何支持 Web 字体的浏览器都可以使用您指定的字体。</p>
<p>首先，您需要尽早声明 <code>@font-face</code> 块，它指定要下载的字体文件:</p>
<div><pre><code><span><span>@font-face</span></span> <span>{</span>
  <span>font-family</span><span>:</span> <span>"myFont"</span><span>;</span>
  <span>src</span><span>:</span> <span><span>url</span><span>(</span><span>"myFont.ttf"</span><span>)</span></span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>之后，您就可以使用 <code>@font-face</code> 中指定的字体种类名称来将您的定制字体应用到您喜欢的任何东西上，如:</p>
<div><pre><code><span>html</span> <span>{</span>
  <span>font-family</span><span>:</span> <span>"myFont"</span><span>,</span> <span>"Bitstream Vera Serif"</span><span>,</span> serif<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关于网页字体有两件重要的事情要记住:</p>
<ol>
<li>浏览器支持不同的字体格式，因此您需要多种字体格式以获得良好的跨浏览器支持。例如,大多数现代浏览器都支持 WOFF / WOFF2(Web Open Font Format versions 1 and 2，Web 开放字体格式版本 1 和 2)，它是最有效的格式，但是旧版本 IE 只支持 EOT (Embedded Open Type，嵌入式开放类型)的字体,您可能需要包括一个 SVG 版本的字体支持旧版本的 iPhone 和 Android 浏览器。</li>
<li>字体一般都不能自由使用。您必须为他们付费，或者遵循其他许可条件，比如在代码中(或者在您的站点上)提供字体创建者。您不应该在没有适当的授权的情况下偷窃字体。</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">媒体查询</title>
    <id>https://list-jiang.github.io/code/website/css/intro/media/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/media/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>媒体查询</strong> (Media queries) 非常实用，尤其是当您想要根据设备的大致类型 (如打印设备与带屏幕的设备) 或者特定的特征和设备参数 (例如屏幕分辨率和浏览器视窗宽度) 来修改网站或应用程序时。</p>
]]></summary>
    <content type="html"><![CDATA[<p><strong>媒体查询</strong> (Media queries) 非常实用，尤其是当您想要根据设备的大致类型 (如打印设备与带屏幕的设备) 或者特定的特征和设备参数 (例如屏幕分辨率和浏览器视窗宽度) 来修改网站或应用程序时。</p>

<p>媒体查询常被用于以下目的:</p>
<ul>
<li>
<p>有条件的通过 <code>@media</code> 和 <code>@import</code> 用 CSS 装饰样式。</p>
</li>
<li>
<p>用 <code>media=</code> 属性为 <code>&lt;style&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;source&gt;</code> 和其他 HTML 元素指定特定的媒体类型。如:</p>
<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>styles.css<span>"</span></span> <span>media</span><span><span>=</span><span>"</span>screen<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>styles.css<span>"</span></span> <span>media</span><span><span>=</span><span>"</span>print<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>使用 <code>Window.matchMedia()</code> 和 <code>MediaQueryList.addListener()</code> 方法来测试和监控媒体状态。</p>
</li>
</ul>
<h2 id="语法"> 语法</h2>
<p>每条媒体查询语句都由一个可选的媒体类型和任意数量的媒体特性表达式构成。可以使用多种逻辑操作符合并多条媒体查询语句。媒体查询语句不区分大小写。</p>
<p>当媒体类型(如果指定)与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为 <code>true</code> 时，媒体查询将计算为 <code>true</code>。涉及未知媒体类型的查询始终为 <code>false</code>。</p>
<div><p>注意</p>
<p>有媒体查询附加到其 <code>&lt;link&gt;</code> 的样式表在媒体查询返回 <code>false</code> 时也会下载。只有查询结果变为 <code>true</code> 时才会应用内容。</p>
</div>
<h3 id="媒体类型"> 媒体类型</h3>
<p>媒体类型(Media types)描述设备的一般类别。除非使用 <code>not</code> 或 <code>only</code> 逻辑操作符，媒体类型是可选的，并且会(隐式地)应用 <code>all</code> 类型。</p>
<ul>
<li><strong>all</strong>: 适用于所有设备。</li>
<li><strong>print</strong>: 适用于在打印预览模式下在屏幕上查看的分页材料和文档。</li>
<li><strong>screen</strong>: 主要用于屏幕。</li>
<li><strong>speech</strong>: 主要用于语音合成器。</li>
</ul>
<h3 id="媒体特性"> 媒体特性</h3>
<p>媒体特性(Media features)描述了 user agent、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>any-hover</td>
<td>是否有任何可用的输入机制允许用户(将鼠标等)悬停在元素上?</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>any-pointer</td>
<td>可用的输入机制中是否有任何指针设备，如果有，它的精度如何?</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>视窗(viewport)的宽高比</td>
<td></td>
</tr>
<tr>
<td>color</td>
<td>输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0</td>
<td></td>
</tr>
<tr>
<td>color-gamut</td>
<td>用户代理和输出设备大致程度上支持的色域</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>color-index</td>
<td>输出设备的颜色查询表(color lookup table)中的条目数量，如果设备不使用颜色查询表，则该值为 0</td>
<td></td>
</tr>
<tr>
<td>display-mode</td>
<td>应用程序的显示模式，如 web app 的 manifest 中的 display 成员所指定</td>
<td>在 Web App Manifest spec 被定义.</td>
</tr>
<tr>
<td>forced-colors</td>
<td>检测是 user agent 否限制调色板</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>grid</td>
<td>输出设备使用网格屏幕还是点阵屏幕?</td>
<td></td>
</tr>
<tr>
<td>height</td>
<td>视窗(viewport)的高度</td>
<td></td>
</tr>
<tr>
<td>hover</td>
<td>主要输入模式是否允许用户在元素上悬停</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>inverted-colors</td>
<td>user agent 或者底层操作系统是否反转了颜色</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>light-level</td>
<td>环境光亮度</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>monochrome</td>
<td>输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0</td>
<td></td>
</tr>
<tr>
<td>orientation</td>
<td>视窗(viewport)的旋转方向</td>
<td></td>
</tr>
<tr>
<td>overflow-block</td>
<td>输出设备如何处理沿块轴溢出视窗(viewport)的内容</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>overflow-inline</td>
<td>沿内联轴溢出视窗(viewport)的内容是否可以滚动?</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>pointer</td>
<td>主要输入机制是一个指针设备吗?如果是，它的精度如何?</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>prefers-color-scheme</td>
<td>探测用户倾向于选择亮色还是暗色的配色方案</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-contrast</td>
<td>探测用户是否有向系统要求提高或降低相近颜色之间的对比度</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-motion</td>
<td>用户是否希望页面上出现更少的动态效果</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>prefers-reduced-transparency</td>
<td>用户是否倾向于选择更低的透明度</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>resolution</td>
<td>输出设备的像素密度(分辨率)</td>
<td></td>
</tr>
<tr>
<td>scan</td>
<td>输出设备的扫描过程(适用于电视等)</td>
<td></td>
</tr>
<tr>
<td>scripting</td>
<td>探测脚本(例如 JavaScript)是否可用</td>
<td>在 Media Queries Level 5 中被添加。</td>
</tr>
<tr>
<td>update</td>
<td>输出设备更新内容的渲染结果的频率</td>
<td>在 Media Queries Level 4 中被添加。</td>
</tr>
<tr>
<td>width</td>
<td>视窗(viewport)的宽度，包括纵向滚动条的宽度</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="逻辑操作符"> 逻辑操作符</h3>
<p>逻辑操作符(logical operators) <code>not</code>, <code>and</code>, 和 <code>only</code> 可用于联合构造复杂的媒体查询，您还可以通过用逗号分隔多个媒体查询，将它们组合为一个规则。</p>
<h4 id="and"> and</h4>
<p><code>and</code> 操作符用于将多个媒体查询规则组合成单条媒体查询，当每个查询规则都为真时则该条媒体查询为真，它还用于将媒体功能与媒体类型结合在一起。</p>
<h4 id="not"> not</h4>
<p><code>not</code> 运算符用于否定媒体查询，如果不满足这个条件则返回 <code>true</code>，否则返回 <code>false</code>。如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询。如果使用 <code>not</code> 运算符，则还必须指定媒体类型。</p>
<h4 id="only"> only</h4>
<p><code>only</code> 运算符仅在整个查询匹配时才用于应用样式，并且对于防止较早的浏览器应用所选样式很有用。当不使用 <code>only</code> 时，旧版本的浏览器会将 <code>screen and (max-width: 500px)</code> 简单地解释为 <code>screen</code>，忽略查询的其余部分，并将其样式应用于所有屏幕。如果使用 <code>only</code> 运算符，则还必须指定媒体类型。</p>
<h4 id="逗号"> , (逗号)</h4>
<p>逗号用于将多个媒体查询合并为一个规则。逗号分隔列表中的每个查询都与其他查询分开处理。因此，如果列表中的任何查询为 true，则整个 media 语句均返回 true。换句话说，列表的行为类似于逻辑或 or 运算符。</p>
<h2 id="定位媒体类型"> 定位媒体类型</h2>
<p>媒体类型描述了给定设备的一般类别。尽管通常在设计网站时会考虑屏幕，但您可能希望创建针对特殊设备(例如打印机或基于音频的屏幕阅读器)的样式。例如，此 CSS 针对打印机:</p>
<div><pre><code><span><span>@media</span> print</span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>您还可以定位多个设备。例如，此 <code>@media</code> 规则使用两个媒体查询来同时定位屏幕和打印设备</p>
<div><pre><code><span><span>@media</span> screen<span>,</span> print</span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="定位媒体特性"> 定位媒体特性</h2>
<p>媒体功能描述了给定的 user agent 的输出设备或环境的特定特征。例如，您可以将特定样式应用于宽屏显示器，使用鼠标的计算机，或应用于在弱光条件下使用的设备。当用户的主要输入机制(例如鼠标)可以悬停在元素上时，如下为一个示例:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>hover</span><span>:</span> hover<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>许多媒体功能都是范围功能，这意味着可以在它们前面加上“最小”或“最大”来表示“最小条件”或“最大条件”约束。例如，仅当您的浏览器的 viewport 宽度等于或小于 12450px 时，此 CSS 才会应用样式:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>max-width</span><span>:</span> 12450px<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您在未指定值的情况下创建媒体功能查询，则该样式将全部被应用，只要该查询的值不为零即可。例如，此 CSS 将适用于任何带有彩色屏幕的设备:</p>
<div><pre><code><span><span>@media</span> <span>(</span>color<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果某个功能不适用于运行浏览器的设备，则涉及该媒体功能的表达式始终为 <code>false</code>。例如，将不会使用嵌套在以下查询中的样式，因为没有语音专用设备具有屏幕长宽比:</p>
<div><pre><code><span><span>@media</span> speech <span>and</span> <span>(</span><span>aspect-ratio</span><span>:</span> 11/5<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="创建复杂查询"> 创建复杂查询</h2>
<p>有时您可能想创建一个取决于多个条件的媒体查询。这就是逻辑运算符使用的场景: <code>not</code>，<code>and</code>，和 <code>only</code>。此外，您可以将多个媒体查询合并到一个逗号分隔的列表中。这使您可以在不同情况下应用相同的样式。</p>
<p>在前面的示例中，我们已经看到 <code>and</code> 运算符用于将媒体类型与媒体功能分组。<code>and</code> 运算符还可以将多个媒体功能组合到单个媒体查询中。同时， <code>not</code> 运算符会否定媒体查询，从而基本上颠倒了它的正常含义。唯一的运算符可防止较早的浏览器应用样式。</p>
<div><p>注意</p>
<p>在大多数情况下，默认情况下，如果未指定其他类型，则使用 <code>all</code> 媒体类型。但是，如果使用 <code>not</code> 或 <code>only</code> 运算符，则必须显式指定媒体类型。</p>
</div>
<h3 id="结合多种类型和特性"> 结合多种类型和特性</h3>
<p><code>and</code> 关键字将媒体功能与媒体类型或其他媒体功能组合在一起。此示例结合了两种媒体功能，以将样式限制为宽度至少为 30em 的横向的设备:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 30em<span>)</span> <span>and</span> <span>(</span><span>orientation</span><span>:</span> landscape<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要将样式限制为带有屏幕的设备，可以将媒体功能链接到 screen 媒体类型:</p>
<div><pre><code><span><span>@media</span> screen <span>and</span> <span>(</span><span>min-width</span><span>:</span> 30em<span>)</span> <span>and</span> <span>(</span><span>orientation</span><span>:</span> landscape<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="测试多重查询"> 测试多重查询</h3>
<p>当用户的设备与各种媒体类型，功能或状态中的任何一种匹配时，可以使用逗号分隔的列表来应用样式。例如，如果用户设备的最小高度为 680px 或为纵向模式的屏幕设备，则以下规则将应用其样式:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>min-height</span><span>:</span> 680px<span>)</span><span>,</span> screen <span>and</span> <span>(</span><span>orientation</span><span>:</span> portrait<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以上面的示例为例，如果用户使用的打印机的页面高度为 800 像素，则 media 语句将返回 <code>true</code>，因为将应用第一个查询。同样，如果用户使用的是纵向模式的智能手机，并且视口高度为 480px，则将应用第二个查询，并且 media 语句仍将返回 <code>true</code>。</p>
<h3 id="反转查询的含义"> 反转查询的含义</h3>
<p><code>not</code> 关键字会反转整个媒体查询的含义。它只会否定要应用的特定媒体查询。(因此，它不会应用于以逗号分隔的媒体查询列表中的每个媒体查询。)<code>not</code> 关键字不能用于否定单个功能查询，只能用于否定整个媒体查询。看看以下 <code>not</code> 关键字的例子:</p>
<div><pre><code><span><span>@media</span> <span>not</span> all <span>and</span> <span>(</span>monochrome<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>所以上述查询等价于:</p>
<div><pre><code><span><span>@media</span> <span>not</span> <span>(</span>all <span>and</span> <span>(</span>monochrome<span>)</span><span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>而不是:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>not</span> all<span>)</span> <span>and</span> <span>(</span>monochrome<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>再看另一个例子，如下媒体查询:</p>
<div><pre><code><span><span>@media</span> <span>not</span> screen <span>and</span> <span>(</span>color<span>)</span><span>,</span> print <span>and</span> <span>(</span>color<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>等价于:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>not</span> <span>(</span>screen <span>and</span> <span>(</span>color<span>)</span><span>)</span><span>)</span><span>,</span> print <span>and</span> <span>(</span>color<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="提升老版本浏览器兼容性"> 提升老版本浏览器兼容性</h3>
<p><code>only</code> 关键字可防止不支持带有媒体功能的媒体查询的旧版浏览器应用给定的样式。它对现代浏览器没有影响。</p>
<div><pre><code><span><span>@media</span> <span>only</span> screen <span>and</span> <span>(</span>color<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="版本-4-中的语法改进"> 版本 4 中的语法改进</h2>
<p>媒体查询 4 级规范对语法进行了一些改进，以使用具有“范围”类型(例如宽度或高度，减少冗余)的功能进行媒体查询。级别 4 添加了用于编写此类的查询范围上下文。例如，使用最大宽度 <code>max-</code> 功能，我们可以编写以下代码:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>max-width</span><span>:</span> 30em<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在媒体查询 4 级规范可以这样写:</p>
<div><pre><code><span><span>@media</span> <span>(</span>width &lt;= 30em<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>min-</code> 和 <code>max-</code> 可以测试一个在两个值之间的宽度</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 30em<span>)</span> <span>and</span> <span>(</span><span>max-width</span><span>:</span> 50em<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用 4 级语法书写如下</p>
<div><pre><code><span><span>@media</span> <span>(</span>30em &lt;= width &lt;= 50em<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>媒体查询 4 级规范还添加了用 <code>and</code>, <code>not</code>, 和 <code>or</code> 实现的完整的布尔运算来合并媒体查询的方法。</p>
<h3 id="使用-not-否定一个特性"> 使用 <code>not</code> 否定一个特性</h3>
<p>在媒体功能周围使用 <code>not()</code> 会否定查询中的该特性。例如，如果设备没有悬停功能，则 <code>not(hover)</code> 将被匹配:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>not</span><span>(</span>hover<span>)</span><span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="用-or-测试多个特性"> 用 <code>or</code> 测试多个特性</h3>
<p>您可以使用 <code>or</code> 测试多个功能之间的匹配，如果任何功能为 <code>true</code>，则解析为 <code>true</code>。例如，以下查询测试具有单色显示或悬停功能的设备:</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>not</span> <span>(</span>color<span>)</span><span>)</span> <span>or</span> <span>(</span>hover<span>)</span></span> <span>{</span>
  ...<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">溢出</title>
    <id>https://list-jiang.github.io/code/website/css/intro/overflow/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/overflow/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>溢出是在盒子无法容纳下太多的内容的时候发生的。</p>
<h2 id="概念"> 概念</h2>
<p>我们知道，CSS 中万物皆盒，因此我们可以通过给 <code>width</code> 和 <code>height</code>(或者 <code>inline-size</code> 和 <code>block-size</code>) 赋值的方式来约束盒子的尺寸。溢出是在您往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。CSS 给了您好几种工具来控制溢出。</p>
<h2 id="css-尽可能不丢弃内容"> CSS 尽可能不丢弃内容</h2>
<p>在默认情况下，CSS 会将元素溢出的部分显示在和盒子外。</p>

          <div
            id="code-demo-16ba8ff1"
           
  
 data-title="%E4%BE%8B%E5%AD%90"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22word%5C%22%3EOverflow%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20This%20box%20has%20a%20height%20and%20a%20width.%20This%20means%20that%20if%20there%20is%20too%20much%5Cn%20%20content%20to%20be%20displayed%20within%20the%20assigned%20height%2C%20there%20will%20be%20an%20overflow%5Cn%20%20situation.%20If%20overflow%20is%20set%20to%20hidden%20then%20any%20overflow%20will%20not%20be%20visible.%5Cn%3C%2Fdiv%3E%5Cn%5Cn%3Cp%3EThis%20content%20is%20outside%20of%20the%20box.%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22.word%20%7B%5Cn%20%20border%3A%201px%20solid%20%23333333%3B%5Cn%20%20width%3A%20100px%3B%5Cn%20%20font-size%3A%20250%25%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20border%3A%201px%20solid%20%23333333%3B%5Cn%20%20width%3A%20200px%3B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>word<span>"</span></span><span>></span></span>Overflow<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
  This box has a height and a width. This means that if there is too much
  content to be displayed within the assigned height, there will be an overflow
  situation. If overflow is set to hidden then any overflow will not be visible.
<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>This content is outside of the box.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.word</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #333333<span>;</span>
  <span>width</span><span>:</span> 100px<span>;</span>
  <span>font-size</span><span>:</span> 250%<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #333333<span>;</span>
  <span>width</span><span>:</span> 200px<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>只要有可能，CSS 就不会隐藏您的内容，隐藏引起的数据损失通常会造成困扰。</p>
<p>如果您已经用 <code>width</code> 或者 <code>height</code> 限制住了一个盒子，CSS 假定，您知道您在做什么，而且您已经控制住了溢出的隐患。总之，在盒子里面需要放置文本的时候，限制住块方向的尺寸是会引起问题的，比如用户增加字体大小，或者填入了远超您设计时预计数量的文本。</p>
<h2 id="overflow-属性"> overflow 属性</h2>
<p><code>overflow</code> 属性是您控制一个元素溢出的方式，它告诉浏览器您想怎样处理溢出。<code>overflow</code> 的默认值为 <code>visible</code>，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p>
<p>如果您想在内容溢出的时候把它裁剪掉，设置 <code>overflow: hidden</code>。这就会隐藏掉溢出。这可能会很自然地让东西消失掉，所以您只应该在判断隐藏内容不会引起问题的时候这样做。</p>
<p>如果您想在有内容溢出的时候加个滚动条，设置 <code>overflow: scroll</code>，那么即使没有足够多引起溢出的内容，您的浏览器也总会显示滚动条。您可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。</p>
<p>如果仅仅需要在 y 轴方向上滚动，可以使用 <code>overflow-y</code> 属性，设置 <code>overflow-y: scroll</code> 来仅在 y 轴方向滚动。您也可以用 <code>overflow-x</code>，以在 x 轴方向上滚动。</p>
<div><p>注意</p>
<p>请注意，<code>overflow-x</code> 不是处理长单词的好办法! 如果您真的需要在小盒子里面和长英文词打交道，使用 <code>word-break</code> 或者 <code>overflow-wrap</code> 属性。</p>
</div>
<p>和 <code>scroll</code> 一样，在无论内容是否会溢出，页面上都会显示一个滚动条。</p>
<div><p>提示</p>
<p>您可以用 <code>overflow</code> 属性指定 x 轴和 y 轴方向的滚动，同时使用两个值进行传递。如果指定了两个关键字，第一个对 <code>overflow-x</code> 生效而第二个对 <code>overflow-y</code> 生效。否则，<code>overflow-x</code> 和 <code>overflow-y</code> 将会被设置成同样的值。例如，<code>overflow: scroll hidden</code> 会把 <code>overflow-x</code> 设置成 <code>scroll</code>，而 <code>overflow-y</code> 则为 <code>hidden</code>。</p>
</div>
<p>如果您想让滚动条只在必要时才显示，那么使用 <code>overflow: auto</code>。此时由浏览器决定是否显示滚动条。浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p>
<h2 id="块级排版上下文"> 块级排版上下文</h2>
<p>CSS 中有所谓块级排版上下文(Block Formatting Context，BFC)的概念。在您使用诸如 <code>scroll</code> 或者 <code>auto</code> 的时候，您就建立了一个块级排版上下文。结果就是，您改变了 <code>overflow</code> 的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，您的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件，于是就产生了一个协调的滚动体验。</p>
<h2 id="网页设计时不需要的溢出"> 网页设计时不需要的溢出</h2>
<p>现代网页布局的方式 (正如 CSS layout 模块中所介绍的那些) 可以很好地处理溢出。我们不一定能预料到网页上会有多少内容，您很好地设计它们，使得它们能与这种现状协调。在开发网站的时候，您应该一直把溢出的问题挂在心头，您应该用或多或少的内容测试设计，增加文本的字号，确保您的 CSS 可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是您仅仅在少数特别情况下需要的，例如在您确实需要一个可滚动盒子的时候。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">CSS 介绍</title>
    <id>https://list-jiang.github.io/code/website/css/intro/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./selector.html">CSS 选择器</a></p>
</li>
<li>
<p><a href="./box.html">CSS 盒模型</a></p>
</li>
<li>
<p><a href="./background-and-border.html">背景与边框</a></p>
</li>
<li>
<p><a href="./font.html">CSS 字体</a></p>
</li>
<li>
<p><a href="./text-direction.html">文本方向</a></p>
</li>
<li>
<p><a href="./overflow.html">溢出</a></p>
</li>
<li>
<p><a href="./value.html">CSS 值</a></p>
</li>
<li>
<p><a href="./replaced.html">可替换元素</a></p>
</li>
<li>
<p><a href="./media.html">媒体查询</a></p>
</li>
</ul>
<h2 id="样式化详解"> 样式化详解</h2>
<p>这三个章节是非常好的样式化实战练习，您可以在 MDN 上查看它。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_lists" target="_blank" rel="noopener noreferrer">样式化列表</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Styling_links" target="_blank" rel="noopener noreferrer">样式化链接</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Styling_tables" target="_blank" rel="noopener noreferrer">样式化表单</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">可替换元素</title>
    <id>https://list-jiang.github.io/code/website/css/intro/replaced/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/replaced/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="替换元素"> 替换元素</h2>
<p>图像和视频被描述为替换元素。 这意味着 CSS 不能影响这些元素的内部布局，仅影响它们在页面上于其他元素中的位置。</p>
<div><p>可替换元素</p>
<p>在 CSS 中，可替换元素(replaced element)的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p>
<p>简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <code>&lt;iframe&gt;</code> 元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p>
<p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。</p>
</div>
<p>某些替换元素(例如图像和视频)也被描述为具有宽高比。这意味着它在水平(x)和垂直(y)尺寸上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。</p>
<h2 id="调整图像大小"> 调整图像大小</h2>
<p>一个常用的技术是将一张图片的 <code>max-width</code> 设为 100%。这将会允许图片尺寸上小于但不大于盒子。这个技术也会对其他替换元素(例如 <code>&lt;video&gt;</code>，或者 <code>&lt;iframe&gt;</code>)起作用。</p>
<p>为了把一张图像调整到能够完全盖住一个盒子的大小，您可以使用 <code>object-fit</code> 属性。使用 <code>object-fit</code> 时，替换元素可以以多种方式被调整到合乎盒子的大小。</p>
<ul>
<li><code>cover</code> 会缩小图像，维持图像的比例。图像可以整齐地充满盒子，同时由于比例保持不变，图像的一部分将会被盒子裁切掉。</li>
<li><code>contain</code> 会缩放图片到足以放到盒子里面的大小。如果它和盒子的比例不同，会在某侧留白。</li>
<li><code>fill</code> 可以让图像充满盒子，但是不会维持比例。</li>
</ul>

          <div
            id="code-demo-4d61cd9e"
           
  
 data-title="%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fballoons.jpg%5C%22%20alt%3D%5C%22balloons%5C%22%20class%3D%5C%22cover%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fballoons.jpg%5C%22%20alt%3D%5C%22balloons%5C%22%20class%3D%5C%22contain%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20200px%3B%5Cn%20%20height%3A%20200px%3B%5Cn%7D%5Cn%5Cnimg%20%7B%5Cn%20%20height%3A%20100%25%3B%5Cn%20%20width%3A%20100%25%3B%5Cn%7D%5Cn%5Cn.cover%20%7B%5Cn%20%20object-fit%3A%20cover%3B%5Cn%7D%5Cn%5Cn.contain%20%7B%5Cn%20%20object-fit%3A%20contain%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/balloons.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>balloons<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>cover<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/balloons.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>balloons<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>contain<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 200px<span>;</span>
  <span>height</span><span>:</span> 200px<span>;</span>
<span>}</span>

<span>img</span> <span>{</span>
  <span>height</span><span>:</span> 100%<span>;</span>
  <span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>

<span>.cover</span> <span>{</span>
  <span>object-fit</span><span>:</span> cover<span>;</span>
<span>}</span>

<span>.contain</span> <span>{</span>
  <span>object-fit</span><span>:</span> contain<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="布局中的替换元素"> 布局中的替换元素</h2>
<p>替换元素使用各式 CSS 布局技巧时，他们的展现略微与其他元素不同。</p>

          <div
            id="code-demo-3c3d1429"
           
  
 data-title="%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fstar.png%5C%22%20alt%3D%5C%22star%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20%2F%3E%5Cn%20%20%3Cdiv%20%2F%3E%5Cn%20%20%3Cdiv%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%201fr%201fr%3B%5Cn%20%20grid-template-rows%3A%20200px%20200px%3B%5Cn%20%20gap%3A%2020px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20background-color%3A%20rebeccapurple%3B%5Cn%20%20border-radius%3A%200.5em%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>在一个 flex 或者 grid 布局中，元素默认会把拉伸到充满整块区域。图像不会拉伸，而是会被对齐到网格区域或者弹性容器的起始处。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/star.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>star<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 1fr<span>;</span>
  <span>grid-template-rows</span><span>:</span> 200px 200px<span>;</span>
  <span>gap</span><span>:</span> 20px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>background-color</span><span>:</span> rebeccapurple<span>;</span>
  <span>border-radius</span><span>:</span> 0.5em<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="form-元素"> form 元素</h2>
<h3 id="表单元素的继承"> 表单元素的继承</h3>
<p>在一些浏览器中，表单元素默认不会继承字体样式，因此如果您想要确保您的表单填入区域使用 body 中或者一个父元素中定义的字体，您需要向您的 CSS 中加入这条规则。</p>
<div><pre><code><span>button,
input,
select,
textarea</span> <span>{</span>
  <span>font-family</span><span>:</span> inherit<span>;</span>
  <span>font-size</span><span>:</span> 100%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="form-的-box-sizing"> form 的 box-sizing</h3>
<p>form 元素可能会针对不同元素使用不同的盒子约束规则。</p>
<p>为了保证统一，将所有元素的内外边距均设为 0 是个好主意，然后在单独进行样式化控制的时候将这些加回来。</p>
<div><pre><code><span>button,
input,
select,
textarea</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
  <span>padding</span><span>:</span> 0<span>;</span>
  <span>margin</span><span>:</span> 0<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="其他有用的设置"> 其他有用的设置</h3>
<p>除了上面提到的规则以外，您也应该在 <code>&lt;textarea&gt;</code> 上设置 <code>overflow: auto</code> 以避免 IE 在不需要滚动条的时候显示滚动条:</p>
<div><pre><code><span>textarea</span> <span>{</span>
  <span>overflow</span><span>:</span> auto<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">调整大小</title>
    <id>https://list-jiang.github.io/code/website/css/intro/sizing/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/sizing/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="原始尺寸与固有尺寸"> 原始尺寸与固有尺寸</h2>
<p>在受 CSS 设置影响之前，HTML 元素有其原始的尺寸。一个直观的例子就是图像。一副图像的长和宽由这个图像文件自身确定。这个尺寸就是固有尺寸。</p>
<p>一个空的 <code>&lt;div&gt;</code> 是没有尺寸的。如果您在您的 HTML 文件中添加一个空 <code>&lt;div&gt;</code> 并给予其边框，您会在页面上看到一条线。</p>

          <div
            id="code-demo-82cce13e"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fstar.png%5C%22%20alt%3D%5C%22star%5C%22%20%2F%3E%5Cn%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22img%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/star.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>star<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>img</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="设置具体的尺寸"> 设置具体的尺寸</h2>
<p>当给元素指定尺寸时，我们将其称为<strong>外部尺寸</strong>。 我们可以给它一个具体的 <code>width</code> 和 <code>height</code> 值, 不论它的内容是什么，它将都是该尺寸。</p>

          <div
            id="code-demo-1c902759"
           
  
 data-title="%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%9B%92%E5%AD%90%E9%83%BD%E8%AE%BE%E7%BD%AE%E4%BA%86%E9%AB%98%E5%BA%A6%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E7%9B%92%E5%AD%90%E5%9B%A0%E4%B8%BA%E5%86%85%E5%AE%B9%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%97%A0%E6%B3%95%E8%A3%85%E4%B8%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%80%E7%BB%88%E4%BA%A7%E7%94%9F%E4%BA%86%E6%BA%A2%E5%87%BA%E3%80%82Mr.Hope%5Cn%20%20%20%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%20%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%20%20height%3A%20150px%3B%5Cn%20%20width%3A%20200px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    这两个盒子都设置了高度，但是这个盒子因为内容很多，无法装下，所以最终产生了溢出。Mr.Hope
    很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
    Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
  <span>height</span><span>:</span> 150px<span>;</span>
  <span>width</span><span>:</span> 200px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="使用百分数"> 使用百分数</h3>
<p>当使用百分数时，您需要清楚，它是什么东西的百分数。对于一个处于另外一个容器当中的盒子，如果您给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。</p>

          <div
            id="code-demo-1ed904e6"
           
  
 data-title="%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%95%B0"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%3E%E6%88%91%E6%98%AF%E7%99%BE%E5%88%86%E6%AF%94%E9%95%BF%E5%BA%A6%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%20%20width%3A%2050%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>我是百分比长度<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
  <span>width</span><span>:</span> 50%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>百分数是以包含盒子的块为根据解析的。如果我们的 <code>&lt;div&gt;</code> 没有被指定百分数的值，那么它会占据 100%的可用空间，因为它是块级别的元素。如果我们给了它一个百分数作为宽度，那么这就是它原来情况下可以占据空间的百分数。</p>
<h3 id="把百分数作为内外边距"> 把百分数作为内外边距</h3>
<p>如果您把 <code>margin</code> 和 <code>padding</code> 设置为百分数的话，您会注意到一些奇怪的表现。</p>
<p>您也许会希望上下的外边距是元素高的一个百分数，左右外边距是元素宽的百分数。但是，情况不是这样的!</p>
<p>当您用百分数设定内外边距的时候，值是以<strong>内联尺寸</strong>进行计算的，也即对于左右书写的语言来说的宽度。在我们的例子里面，所有的内外边距是这一宽度的 10%，也就是说，您可以让盒子周围的内外边距大小相同。在您以这种方式使用百分数的时候，这是一个需要记住的事实。</p>

          <div
            id="code-demo-1486c992"
           
  
 data-title="%E8%BE%B9%E8%B7%9D"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%3E%E6%89%80%E6%9C%89%E6%96%B9%E5%90%91%E7%9A%84%20margin%20and%20padding%20%E9%83%BD%E6%98%AF%2010%25%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20margin%3A%2010%25%3B%5Cn%20%20padding%3A%2010%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>所有方向的 margin and padding 都是 10%<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>margin</span><span>:</span> 10%<span>;</span>
  <span>padding</span><span>:</span> 10%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="min-和-max"> <code>min-</code> 和 <code>max-</code></h2>
<p>我们可以让 CSS 给定一个元素的最大或最小尺寸。</p>
<p>如果您有一个包含了变化容量的内容的盒子，而且您总是想让它至少有个确定的高度，您应该给它设置一个 <code>min-height</code> 属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p>

          <div
            id="code-demo-5581f10c"
           
  
 data-title="%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%B0%BA%E5%AF%B8"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%9B%92%E5%AD%90%E9%83%BD%E8%AE%BE%E7%BD%AE%E4%BA%86%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E7%9B%92%E5%AD%90%E5%9B%A0%E4%B8%BA%E5%86%85%E5%AE%B9%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%97%A0%E6%B3%95%E8%A3%85%E4%B8%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%80%E7%BB%88%E9%AB%98%E5%BA%A6%E4%BA%A7%E7%94%9F%E4%BA%86%E6%89%A9%E5%A4%A7%E3%80%82Mr.Hope%5Cn%20%20%20%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%20%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20border%3A%205px%20solid%20darkblue%3B%5Cn%20%20min-height%3A%20150px%3B%5Cn%20%20width%3A%20200px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    这两个盒子都设置了最小高度，但是这个盒子因为内容很多，无法装下，所以最终高度产生了扩大。Mr.Hope
    很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
    Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>border</span><span>:</span> 5px solid darkblue<span>;</span>
  <span>min-height</span><span>:</span> 150px<span>;</span>
  <span>width</span><span>:</span> 200px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>max-width</code> 的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。这个技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放。</p>

          <div
            id="code-demo-04dce506"
           
  
 data-title="%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E4%B8%8E%E5%9B%BE%E5%83%8F"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fstar.png%5C%22%20alt%3D%5C%22star%5C%22%20class%3D%5C%22width%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fstar.png%5C%22%20alt%3D%5C%22star%5C%22%20class%3D%5C%22max%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22minibox%5C%22%3E%5Cn%20%20%20%20%3Cimg%20src%3D%5C%22%2Fassets%2Fimg%2Fstar.png%5C%22%20alt%3D%5C%22star%5C%22%20class%3D%5C%22max%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20width%3A%20200px%3B%5Cn%7D%5Cn%5Cn.minibox%20%7B%5Cn%20%20width%3A%2050px%3B%5Cn%7D%5Cn%5Cn.width%20%7B%5Cn%20%20width%3A%20100%25%3B%5Cn%7D%5Cn%5Cn.max%20%7B%5Cn%20%20max-width%3A%20100%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/star.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>star<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>width<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/star.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>star<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>max<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>minibox<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/assets/img/star.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>star<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>max<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 200px<span>;</span>
<span>}</span>

<span>.minibox</span> <span>{</span>
  <span>width</span><span>:</span> 50px<span>;</span>
<span>}</span>

<span>.width</span> <span>{</span>
  <span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>

<span>.max</span> <span>{</span>
  <span>max-width</span><span>:</span> 100%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="viewpoint"> viewpoint</h2>
<p>viewpoint，即您在浏览器中看到的部分页面，也是有尺寸的。在 CSS 中，我们有 viewpoint 宽度相关的 vw 单位，以及 viewpoint 高度相关的 vh 单位。</p>
<p>1vh 等于 viewpoint 高度的 1%，1vw 则为 viewpoint 宽度的 1%.您可以用这些单位约束盒子的大小，还有文字的大小。</p>
<p>如果您改变了 vh 和 vw 的对应值，盒子和字体的大小也会改变； viewpoint 大小的变化也会让它们的大小变化，因为它们是依照 viewpoint 来定大小的。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">选择器</title>
    <id>https://list-jiang.github.io/code/website/css/intro/selector/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/selector/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>CSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>
<p>选择器所选择的元素，叫做“选择器的对象”。</p>
]]></summary>
    <content type="html"><![CDATA[<p>CSS 选择器是 CSS 规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>
<p>选择器所选择的元素，叫做“选择器的对象”。</p>


          <div
            id="code-demo-7090ee9f"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cimg%20src%3D%5C%22%2Flogo.png%5C%22%20alt%3D%5C%22logo%5C%22%20style%3D%5C%22max-width%3A%20150px%5C%22%20%2F%3E%5Cn%5Cn%3Cp%20class%3D%5C%22paragraph%5C%22%3EMr.Hope%20is%20handsome!%3C%2Fp%3E%5Cn%3Cp%20id%3D%5C%22par%5C%22%3EMr.Hope%20is%20very%20handsome!%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%5Cn.paragraph%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%5Cn%23par%20%7B%5Cn%20%20color%3A%20blue%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/logo.png<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>logo<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>max-width</span><span>:</span> 150px</span><span>"</span></span></span> <span>/></span></span>

<span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>paragraph<span>"</span></span><span>></span></span>Mr.Hope is handsome!<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>id</span><span><span>=</span><span>"</span>par<span>"</span></span><span>></span></span>Mr.Hope is very handsome!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>.paragraph</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>#par</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>在上文中，CSS 选择器选中了对应的 HTML 元素并为其应用样式规则。</p>
<h2 id="id-选择器"> ID 选择器</h2>
<p>ID 选择器可以为标有特定 ID 的 HTML 元素指定特定的样式。</p>
<p>HTML 可以用 ID 属性来设置 ID 选择器，CSS 中 ID 选择器以 <code>#</code> 来定义。</p>
<p>以下的样式规则应用于元素属性 <code>id=&quot;para1&quot;</code>:</p>
<div><pre><code><span>#para1</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>提示</p>
<p>ID 的全称是 Identify，是身份标识的意思。ID 的实际作用是为这个 HTML 标签绑定一个页面内唯一的标识符。因此，每一个 HTML 页面出现的 ID 应该仅被使用一次，以 ID 来代指这个元素。</p>
</div>
<div><p>注意</p>
<p>ID 属性不要以数字开头，数字开头的 ID 在 <code>Mozilla/Firefox</code> 浏览器中不起作用。</p>
</div>
<h2 id="class-选择器"> Class 选择器</h2>
<p>Class 选择器用于描述一组元素的样式，class 选择器有别于 ID 选择器，class 可以在多个元素中使用。</p>
<p>Class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以句点 (<code>.</code>) 显示:</p>
<p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p>
<div><pre><code><span>.center</span> <span>{</span>
  <span>text-align</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="标签选择器"> 标签选择器</h2>
<p>标签选择器用于指定一个 HTML 标签的样式。通常，浏览器会为每个特定的 HTML 标签指定一个默认样式，但是不同的浏览器的默认样式可能有细微的区别。</p>
<p>有些时候想要覆盖浏览器的默认样式，或者说想在所有浏览器中保持统一样式，即可使用标签选择器指定标签的默认样式。在 CSS 指定的标签样式会覆盖掉浏览器默认指定的样式。</p>
<div><pre><code><span>/* 确保所有浏览器的段落标签的字体大小均为16像素。*/</span>
<span>p</span> <span>{</span>
  <span>font-size</span><span>:</span> 16px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="属性选择器"> 属性选择器</h2>
<p>属性选择器根据一个元素上的某个标签的属性的存在以选择元素的不同方式:</p>
<div><pre><code><span>a[title]</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者根据一个有特定值的标签属性是否存在来选择:</p>
<div><pre><code><span>a[href="https://example.com"]</span>
<span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="伪类与伪元素"> 伪类与伪元素</h2>
<h3 id="伪类"> 伪类</h3>
<p>选择器可以包含伪类，用来样式化一个元素的特定状态。</p>
<p>例如 <code>:hover</code> 伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素:</p>
<div><pre><code><span>a:hover</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其他的常见伪类还有 <code>:visited</code> <code>:active</code> <code>:focus</code> 等。</p>
<h3 id="伪元素"> 伪元素</h3>
<p>选择器也可以包含伪元素，选择一个元素的某个部分而不是元素自己。</p>
<p>例如 <code>::first-line</code> 会选择一个元素(下面的情况中是 <code>&lt;p&gt;</code>)中的第一行。</p>
<div><pre><code><span>p::first-line</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其他的常见伪元素还有 <code>::before</code> <code>::after</code> <code>::fist-letter</code> <code>::last-child</code> 等。</p>
<div><p>相关信息</p>
<p>关于全部的伪类与伪元素选择器，请见 <a href="https://www.runoob.com/cssref/css-selectors.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener noreferrer">MDN 伪类</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener noreferrer">MDN 伪元素</a>。</p>
</div>
<h2 id="通用选择器"> 通用选择器</h2>
<p>通用选择器 <code>*</code> 会选中所有元素</p>
<h2 id="选择器列表"> 选择器列表</h2>
<p>可以选择多种类型的元素并为它们添加一组相同的样式。将不同的选择器用逗号分开。例如:</p>
<div><pre><code><span>p,
li,
.tag,
#link</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="运算符"> 运算符</h2>
<p>选择器可以通过运算符，构成更加复杂的选择器。</p>
<p>常见的运算符主要有四种:</p>
<ul>
<li>
<p>后代选择器</p>
<p>以空格分隔，用于选取某元素的后代元素</p>
</li>
<li>
<p>子元素选择器</p>
<p>以大于号 <code>&gt;</code> 分隔，只能选择作为某元素子元素的元素</p>
</li>
<li>
<p>相邻兄弟选择器</p>
<p>加号 <code>+</code> 分隔，选择紧接某元素后的另一元素。</p>
</li>
<li>
<p>通用兄弟选择器</p>
<p>波浪线 <code>~</code> 分隔，选择紧接一元素后所有的同级的另一元素</p>
</li>
</ul>
<div><p>选择器案例</p>
<ul>
<li>
<p><code>p{ }</code>: 为所有 <strong>p</strong> 元素指定一个样式。</p>
</li>
<li>
<p><code>.marked{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 的元素指定一个样式。</p>
</li>
<li>
<p><code>.marked p{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</p>
</li>
<li>
<p><code>p.marked{ }</code>: 为所有 <strong>class=&quot;marked&quot;</strong> 的 <strong>p</strong> 元素指定一个样式。</p>
</li>
</ul>
</div>
<div><p>相关信息</p>
<p>更多高级选择器，请见 <a href="https://www.runoob.com/cssref/css-selectors.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors#%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8" target="_blank" rel="noopener noreferrer">MDN 参考表</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文本方向</title>
    <id>https://list-jiang.github.io/code/website/css/intro/text-direction/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/text-direction/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="书写模式"> 书写模式</h2>
<p>CSS 中的书写模式是指文本的排列方向是横向还是纵向的。<code>writing-mode</code> 属性使我们从一种模式切换到另一种模式。为此，您不必使用一种竖向的语言——您还可以更改部分文字的方向以实现创新性的布局。</p>
<p>可以使用 <code>writing-mode: vertical-rl</code> 对一个标题的显示进行设置，将标题文本变为竖向。</p>
<p>竖向文本在平面设计中很常见，也可以为您的网页设计增添更加有趣的外观。</p>

          <div
            id="code-demo-53c6d322"
           
  
 data-title="%E7%AB%96%E5%90%91%E6%A0%87%E9%A2%98%E6%96%87%E6%9C%AC"

            data-code="%7B%22html%22%3A%22%3Ch1%3EPlay%20with%20writing%20modes%3C%2Fh1%3E%5Cn%22%2C%22css%22%3A%22h1%20%7B%5Cn%20%20writing-mode%3A%20vertical-rl%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Play with writing modes<span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>h1</span> <span>{</span>
  <span>writing-mode</span><span>:</span> vertical-rl<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>writing-mode</code> 的三个值分别是:</p>
<ul>
<li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li>
<li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li>
<li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li>
</ul>
<p>因此，<code>writing-mode</code> 属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这决定了文本的方向。</p>
<div><p>注意</p>
<p>没有从下到上的方向。</p>
</div>
<h2 id="书写模式、块级布局和内联布局"> 书写模式、块级布局和内联布局</h2>
<p>我们已经讨论了块级布局和内联布局(block and inline layout)，也知道外部显示类型元素分为块级元素和内联元素。如上所述，块级显示和内联显示与文本的书写模式(而非屏幕的物理显示)密切相关。如果您使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的。</p>
<p>当我们切换书写模式时，我们也在改变块和内联文本的方向。<code>horizontal-tb</code> 书写模式下块的方向是从上到下的横向的，而 <code>vertical-rl</code> 书写模式下块的方向是从右到左的纵向的。因此，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。</p>
<p><img src="./assets/horizontal-tb.png" alt="这张图展示了在水平书写模式下的两种维度" loading="lazy"></p>
<p><img src="./assets/vertical.png" alt="这张图片展示了纵向书写模式下的两种维度" loading="lazy"></p>
<h3 id="方向"> 方向</h3>
<p>除了书写模式，我们还可以设置文本方向。正如上面所言，有些语言(如阿拉伯语)是横向书写的，但是是从右向左。</p>
<p>由于书写模式和文本方向都是可变的，新的 CSS 布局方法不再定义从左到右和从上到下，而是将这些连同内联元素和块级元素的开头和结尾一起考量。</p>
<h2 id="逻辑属性和逻辑值"> 逻辑属性和逻辑值</h2>
<p>正常情况下，您可以设置 width 和 height，但是它们并不会跟随书写模式的改编而进行调整。</p>
<p>CSS 的映射属性用逻辑(logical)和相对变化(flow relative)代替了像宽 width 和高 height 一样的物理属性。</p>
<p>横向书写模式下，映射到 width 的属性被称作内联尺寸(inline-size)——内联维度的尺寸。而映射 height 的属性被称为块级尺寸(block-size)，这是块级维度的尺寸。下面的例子展示了替换掉 width 的 inline-size 是如何生效的。</p>

          <div
            id="code-demo-5e1cf809"
           
  
 data-title="%E6%98%A0%E5%B0%84%E5%B1%9E%E6%80%A7"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20horizontal%5C%22%3E%5Cn%20%20%20%20%3Ch2%3EHeading%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3EA%20paragraph.%20Demonstrating%20Writing%20Modes%20in%20CSS.%3C%2Fp%3E%5Cn%20%20%20%20%3Cp%3EThese%20boxes%20have%20inline-size.%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20vertical%5C%22%3E%5Cn%20%20%20%20%3Ch2%3EHeading%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3EA%20paragraph.%20Demonstrating%20Writing%20Modes%20in%20CSS.%3C%2Fp%3E%5Cn%20%20%20%20%3Cp%3EThese%20boxes%20have%20inline-size.%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20inline-size%3A%20150px%3B%5Cn%7D%5Cn%5Cn.horizontal%20%7B%5Cn%20%20writing-mode%3A%20horizontal-tb%3B%5Cn%7D%5Cn%5Cn.vertical%20%7B%5Cn%20%20writing-mode%3A%20vertical-rl%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box horizontal<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Heading<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>A paragraph. Demonstrating Writing Modes in CSS.<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>These boxes have inline-size.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box vertical<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Heading<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>A paragraph. Demonstrating Writing Modes in CSS.<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>These boxes have inline-size.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>inline-size</span><span>:</span> 150px<span>;</span>
<span>}</span>

<span>.horizontal</span> <span>{</span>
  <span>writing-mode</span><span>:</span> horizontal-tb<span>;</span>
<span>}</span>

<span>.vertical</span> <span>{</span>
  <span>writing-mode</span><span>:</span> vertical-rl<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="逻辑外边距、边框和内边距属性"> 逻辑外边距、边框和内边距属性</h3>
<p>外边距、边框和内边距属性中，物理属性，例如 <code>margin-top</code>、<code>padding-left</code> 和 <code>border-bottom</code>。同样像 <code>width</code> 和 <code>height</code> 一样不会随着书写模式进行变化，当然这些属性也有相应的映射。</p>
<p><code>margin-top</code> 属性的映射是 <code>margin-block-start</code> : 总是指向块级维度开始处的边距。</p>
<p><code>padding-left</code> 属性映射到 <code>padding-inline-start</code>: 这是应用到内联开始方向(这是该书写模式文本开始的地方)上的内边距。</p>
<p><code>border-bottom</code> 属性映射到的是 <code>border-block-end</code>: 也就是块级维度结尾处的边框。</p>
<p>其他的 9 个属性应该很很容易写出，不做赘述。</p>
<div><p>注意</p>
<p>请注意，在这种状态下，您就不能再用 <code>margin</code> <code>padding</code> <code>border</code> 这三个简写属性了。</p>
</div>
<h3 id="逻辑值"> 逻辑值</h3>
<p>物理值(如 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> )。这些值同样拥有逻辑值映射(<code>block-start</code>、<code>inline-end</code>、<code>block-end</code> 和 <code>inline-start</code> )。</p>
<h3 id="是否使用逻辑属性"> 是否使用逻辑属性</h3>
<p>如果您并没有应用多种书写模式，那么现在您可能更倾向于使用物理属性，因为这些在您使用弹性布局和网格布局时非常有用。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">值与单位</title>
    <id>https://list-jiang.github.io/code/website/css/intro/value/</id>
    <link href="https://list-jiang.github.io/code/website/css/intro/value/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="css-的值"> CSS 的值</h2>
<p>在 CSS 规范上，您将能够发现值的存在，CSS 有多种值类型，它们被尖括号包围，如 <code>&lt;color&gt;</code> 或 <code>&lt;length&gt;</code>。</p>
<p>当您看到值 <code>&lt;color&gt;</code> 对特定属性有效时，这意味着您可以使用任何有效的颜色作为该属性的值。</p>
<h3 id="数字-长度和百分比"> 数字，长度和百分比</h3>
<table>
<thead>
<tr>
<th>数值类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;integer&gt;</code></td>
<td>整数。如 <code>1024</code> 或 <code>-55</code>。</td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>小数 (也可以为整数)。如: <code>0.255</code>、<code>128</code> 或 <code>-1.2</code>。</td>
</tr>
<tr>
<td><code>&lt;dimension&gt;</code></td>
<td><code>&lt;number&gt;</code> + 附加单位。如: <code>45deg</code>、<code>5s</code> 或 <code>10px</code>。<br /><code>&lt;dimension&gt;</code> 是一个大类别，包括 <code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code> 和 <code>&lt;resolution&gt;</code> 类型。</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>一些其他值的一部分，例如 <code>50%</code>。<br />百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td>
</tr>
</tbody>
</table>
<h3 id="长度"> 长度</h3>
<p>最常见的数字类型是 <code>&lt;length&gt;</code>，例如 10px(像素)或 30em。CSS 中有两种类型的长度: 相对长度和绝对长度。</p>
<h4 id="绝对长度单位"> 绝对长度单位</h4>
<p>以下都是绝对长度单位。它们总是相同的大小。</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>名称</th>
<th>等价换算</th>
</tr>
</thead>
<tbody>
<tr>
<td>cm</td>
<td>厘米</td>
<td>1cm = 96px/2.54</td>
</tr>
<tr>
<td>mm</td>
<td>毫米</td>
<td>1mm = 1/10th of 1cm</td>
</tr>
<tr>
<td>Q</td>
<td>四分之一毫米</td>
<td>1Q = 1/40th of 1cm</td>
</tr>
<tr>
<td>in</td>
<td>英寸</td>
<td>1in = 2.54cm = 96px</td>
</tr>
<tr>
<td>pc</td>
<td>十二点活字</td>
<td>1pc = 1/16th of 1in</td>
</tr>
<tr>
<td>pt</td>
<td>点</td>
<td>1pt = 1/72th of 1in</td>
</tr>
<tr>
<td>px</td>
<td>像素</td>
<td>1px = 1/96th of 1in</td>
</tr>
</tbody>
</table>
<h4 id="相对长度单位"> 相对长度单位</h4>
<p>相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。利用它们，您可以使文本或其他元素的大小与页面上的其他内容相对应。</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>相对于</th>
</tr>
</thead>
<tbody>
<tr>
<td>em</td>
<td>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td>
</tr>
<tr>
<td>ex</td>
<td>字符“x”的高度</td>
</tr>
<tr>
<td>ch</td>
<td>数字“0”的宽度</td>
</tr>
<tr>
<td>rem</td>
<td>根元素的字体大小</td>
</tr>
<tr>
<td>lh</td>
<td>元素的 line-height</td>
</tr>
<tr>
<td>vw</td>
<td>视窗宽度的 1%</td>
</tr>
<tr>
<td>vh</td>
<td>视窗高度的 1%</td>
</tr>
<tr>
<td>vmin</td>
<td>视窗较小尺寸的 1%</td>
</tr>
<tr>
<td>vmax</td>
<td>视图大尺寸的 1%</td>
</tr>
</tbody>
</table>

          <div
            id="code-demo-d6df669a"
           
  
 data-title="%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20px%5C%22%3E%E5%AE%BD%E5%BA%A6%E4%B8%BA%20200px%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20vw%5C%22%3E%E5%AE%BD%E5%BA%A6%E4%B8%BA%2010vw%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20em%5C%22%3E%E5%AE%BD%E5%BA%A6%E4%B8%BA%2010em%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20font-size%3A%201em%3B%5Cn%7D%5Cn%5Cn.px%20%7B%5Cn%20%20width%3A%20200px%3B%5Cn%7D%5Cn%5Cn.vw%20%7B%5Cn%20%20width%3A%2010vw%3B%5Cn%7D%5Cn%5Cn.em%20%7B%5Cn%20%20width%3A%2010em%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box px<span>"</span></span><span>></span></span>宽度为 200px<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box vw<span>"</span></span><span>></span></span>宽度为 10vw<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box em<span>"</span></span><span>></span></span>宽度为 10em<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>font-size</span><span>:</span> 1em<span>;</span>
<span>}</span>

<span>.px</span> <span>{</span>
  <span>width</span><span>:</span> 200px<span>;</span>
<span>}</span>

<span>.vw</span> <span>{</span>
  <span>width</span><span>:</span> 10vw<span>;</span>
<span>}</span>

<span>.em</span> <span>{</span>
  <span>width</span><span>:</span> 10em<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="em-和-rem"> em 和 rem</h4>
<p>em 和 rem 是您在从框到文本调整大小时最常遇到的两个相对长度。</p>
<ul>
<li><code>em</code> 单位的意思是“父元素的字体大小”。</li>
<li><code>rem</code> 单位的意思是“根元素的字体大小”。</li>
</ul>
<p>也就是一个是相对于父元素，一个是相对于整个文档的默认字号。</p>

          <div
            id="code-demo-858b202a"
           
  
 data-title="em%20%E4%B8%8E%20rem%20%E6%BC%94%E7%A4%BA"

            data-code="%7B%22html%22%3A%22%3Cul%20class%3D%5C%22em%5C%22%3E%5Cn%20%20%3Cli%3E%E4%B8%80%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E4%BA%8C%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E4%B8%89%5Cn%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%3Cli%3E%E4%B8%89-1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%3Cli%3E%5Cn%20%20%20%20%20%20%20%20%E4%B8%89-2%5Cn%20%20%20%20%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%20%20%20%20%3Cli%3E%E4%B8%89-2-1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Ful%3E%5Cn%20%20%20%20%20%20%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%22%2C%22css%22%3A%22html%20%7B%5Cn%20%20font-size%3A%2016px%3B%5Cn%7D%5Cn%5Cn.em%20li%20%7B%5Cn%20%20font-size%3A%201.3em%3B%5Cn%7D%5Cn%5Cn.rem%20li%20%7B%5Cn%20%20font-size%3A%201.3rem%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>em<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>一<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>二<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    三
    <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>三-1<span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>
        三-2
        <span><span><span>&lt;</span>ul</span><span>></span></span>
          <span><span><span>&lt;</span>li</span><span>></span></span>三-2-1<span><span><span>&lt;/</span>li</span><span>></span></span>
        <span><span><span>&lt;/</span>ul</span><span>></span></span>
      <span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>html</span> <span>{</span>
  <span>font-size</span><span>:</span> 16px<span>;</span>
<span>}</span>

<span>.em li</span> <span>{</span>
  <span>font-size</span><span>:</span> 1.3em<span>;</span>
<span>}</span>

<span>.rem li</span> <span>{</span>
  <span>font-size</span><span>:</span> 1.3rem<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="百分比"> 百分比</h3>
<p>在许多情况下，百分比与长度的处理方法是一样的。百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</p>

          <div
            id="code-demo-6ddeb91e"
           
  
 data-title="%E7%99%BE%E5%88%86%E6%AF%94%E4%B8%8E%E7%BB%9D%E5%AF%B9%E9%95%BF%E5%BA%A6"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%20px%5C%22%3E200px%20%E5%AE%BD%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22box%20percent%5C%22%3E40%25%20%E5%AE%BD%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20px%5C%22%3E200px%20%E5%AE%BD%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20percent%5C%22%3E40%25%20%E5%AE%BD%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cul%3E%5Cn%20%20%3Cli%3E%E4%B8%80%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E4%BA%8C%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E4%B8%89%5Cn%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%3Cli%3E%E4%B8%89-1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%3Cli%3E%5Cn%20%20%20%20%20%20%20%20%E4%B8%89-2%5Cn%20%20%20%20%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%20%20%20%20%3Cli%3E%E4%B8%89-2-1%3C%2Fli%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Ful%3E%5Cn%20%20%20%20%20%20%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20border%3A%205px%20solid%20rebeccapurple%3B%5Cn%7D%5Cn%5Cn.px%20%7B%5Cn%20%20width%3A%20200px%3B%5Cn%7D%5Cn%5Cn.percent%20%7B%5Cn%20%20width%3A%2040%25%3B%5Cn%7D%5Cn%5Cnli%20%7B%5Cn%20%20font-size%3A%2080%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box px<span>"</span></span><span>></span></span>200px 宽<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box percent<span>"</span></span><span>></span></span>40% 宽<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box px<span>"</span></span><span>></span></span>200px 宽<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box percent<span>"</span></span><span>></span></span>40% 宽<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>一<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>二<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    三
    <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>三-1<span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>
        三-2
        <span><span><span>&lt;</span>ul</span><span>></span></span>
          <span><span><span>&lt;</span>li</span><span>></span></span>三-2-1<span><span><span>&lt;/</span>li</span><span>></span></span>
        <span><span><span>&lt;/</span>ul</span><span>></span></span>
      <span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>border</span><span>:</span> 5px solid rebeccapurple<span>;</span>
<span>}</span>

<span>.px</span> <span>{</span>
  <span>width</span><span>:</span> 200px<span>;</span>
<span>}</span>

<span>.percent</span> <span>{</span>
  <span>width</span><span>:</span> 40%<span>;</span>
<span>}</span>

<span>li</span> <span>{</span>
  <span>font-size</span><span>:</span> 80%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>注意</p>
<p>虽然许多值接受长度或百分比，但也有一些值只接受长度。您可以在 MDN 属性 引用页面上看到它能接受哪些值。如果允许的值包括 <code>&lt;length-percent&gt;</code>，则可以使用长度或百分比。如果允许的值只包含 <code>&lt;length&gt;</code>，则不可能使用百分比。</p>
</div>
<h3 id="数字"> 数字</h3>
<p>有些值接受数字，不添加任何单位。</p>

          <div
            id="code-demo-849a4dc8"
           
  
 data-title="%E6%95%B0%E5%AD%97%E5%80%BC"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E8%AE%BE%E7%BD%AE%E9%80%8F%E6%98%8E%E5%BA%A6%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20backgroud-color%3A%20red%3B%5Cn%20%20opacity%3A%200.6%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>设置透明度<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>backgroud-color</span><span>:</span> red<span>;</span>
  <span>opacity</span><span>:</span> 0.6<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="颜色"> 颜色</h2>
<h3 id="颜色关键词"> 颜色关键词</h3>
<p>CSS 预设了一些关键词，比如 <code>black</code> <code>white</code> <code>red</code> 等。</p>
<div><p>相关信息</p>
<p>颜色词的完整列表，请看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value" target="_blank" rel="noopener noreferrer">MDN → color</a></p>
</div>
<h3 id="十六进制-rgb-值"> 十六进制 RGB 值</h3>
<p>这种颜色值类型是十六进制代码。每个十六进制值由一个 <code>#</code> 和六个十六进制数字组成，每个十六进制数字都可以取 0 到 f(代表 15)之间的 16 个值中的一个。每对值表示一个通道。通道依次为: 红色、绿色和蓝色。每个通道可以指定 256 个可用值中的任意一个。</p>

          <div
            id="code-demo-054359e3"
           
  
 data-title="%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20one%5C%22%3E%2302798b%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20two%5C%22%3E%23c55da1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20three%5C%22%3E128a7d%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20background-color%3A%20%2302798b%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20background-color%3A%20%23c55da1%3B%5Cn%7D%5Cn%5Cn.three%20%7B%5Cn%20%20background-color%3A%20%23128a7d%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box one<span>"</span></span><span>></span></span>#02798b<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box two<span>"</span></span><span>></span></span>#c55da1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box three<span>"</span></span><span>></span></span>128a7d<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>background-color</span><span>:</span> #02798b<span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>background-color</span><span>:</span> #c55da1<span>;</span>
<span>}</span>

<span>.three</span> <span>{</span>
  <span>background-color</span><span>:</span> #128a7d<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="rgb-和-rgba"> RGB 和 RGBA</h3>
<p>RGB 值是一个函数 <code>RGB()</code>。它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB 的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于 0 到 255 之间的十进制数字表示的。</p>

          <div
            id="code-demo-2e4b0a50"
           
  
 data-title="RGB%20%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20one%5C%22%3Ergb(2%2C%20121%2C%20139)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20two%5C%22%3Ergb(197%2C%2093%2C%20161)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20three%5C%22%3Ergb(18%2C%20138%2C%20125)%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20background-color%3A%20rgb(2%2C%20121%2C%20139)%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20background-color%3A%20rgb(197%2C%2093%2C%20161)%3B%5Cn%7D%5Cn%5Cn.three%20%7B%5Cn%20%20background-color%3A%20rgb(18%2C%20138%2C%20125)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box one<span>"</span></span><span>></span></span>rgb(2, 121, 139)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box two<span>"</span></span><span>></span></span>rgb(197, 93, 161)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box three<span>"</span></span><span>></span></span>rgb(18, 138, 125)<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>2<span>,</span> 121<span>,</span> 139<span>)</span><span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>197<span>,</span> 93<span>,</span> 161<span>)</span><span>;</span>
<span>}</span>

<span>.three</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>18<span>,</span> 138<span>,</span> 125<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>RGBA 的工作方式与 RGB 完全相同，但有第四个值表示颜色的 alpha 通道，它控制不透明度。如果将这个值设置为 0，它将使颜色完全透明，而设置为 1 将使颜色完全不透明。介于两者之间的值提供了不同级别的透明度。</p>

          <div
            id="code-demo-d9d0f1ee"
           
  
 data-title="RGBA%20%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20one%5C%22%3Ergba(2%2C%20121%2C%20139%2C%20.3)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20two%5C%22%3Ergba(197%2C%2093%2C%20161%2C%20.7)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20three%5C%22%3Ergba(18%2C%20138%2C%20125%2C%20.9)%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20background-color%3A%20rgba(2%2C%20121%2C%20139%2C%200.3)%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20background-color%3A%20rgba(197%2C%2093%2C%20161%2C%200.7)%3B%5Cn%7D%5Cn%5Cn.three%20%7B%5Cn%20%20background-color%3A%20rgba(18%2C%20138%2C%20125%2C%200.9)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box one<span>"</span></span><span>></span></span>rgba(2, 121, 139, .3)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box two<span>"</span></span><span>></span></span>rgba(197, 93, 161, .7)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box three<span>"</span></span><span>></span></span>rgba(18, 138, 125, .9)<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgba</span><span>(</span>2<span>,</span> 121<span>,</span> 139<span>,</span> 0.3<span>)</span><span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgba</span><span>(</span>197<span>,</span> 93<span>,</span> 161<span>,</span> 0.7<span>)</span><span>;</span>
<span>}</span>

<span>.three</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgba</span><span>(</span>18<span>,</span> 138<span>,</span> 125<span>,</span> 0.9<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>注意</p>
<p>在颜色上设置 alpha 通道与使用我们前面看到的 opacity 属性有一个关键区别。当您使用不透明度时，您让元素和它里面的所有东西都不透明，而使用 RGBA 颜色只让您指定的颜色不透明。</p>
</div>
<h3 id="hsl-和-hsla"> HSL 和 HSLA</h3>
<p><code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分 1670 万种颜色:</p>
<ul>
<li>色调: 值在 0 和 360 之间，表示色轮周围的角度。</li>
<li>饱和度: 值为 0 - 100%，其中 0 为无颜色(它将显示为灰色阴影)，100%为全色饱和度</li>
<li>亮度: 从 0 - 100%中获取一个值，其中 0 表示没有光(它将完全显示为黑色)，100%表示完全亮(它将完全显示为白色)</li>
</ul>

          <div
            id="code-demo-15a3f7a1"
           
  
 data-title="HSL%20%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20one%5C%22%3Ehsl(188%2C%2097%25%2C%2028%25)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20two%5C%22%3Ehsl(321%2C%2047%25%2C%2057%25)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20three%5C%22%3Ehsl(174%2C%2077%25%2C%2031%25)%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20background-color%3A%20hsl(188%2C%2097%25%2C%2028%25)%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20background-color%3A%20hsl(321%2C%2047%25%2C%2057%25)%3B%5Cn%7D%5Cn%5Cn.three%20%7B%5Cn%20%20background-color%3A%20hsl(174%2C%2077%25%2C%2031%25)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box one<span>"</span></span><span>></span></span>hsl(188, 97%, 28%)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box two<span>"</span></span><span>></span></span>hsl(321, 47%, 57%)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box three<span>"</span></span><span>></span></span>hsl(174, 77%, 31%)<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>188<span>,</span> 97%<span>,</span> 28%<span>)</span><span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>321<span>,</span> 47%<span>,</span> 57%<span>)</span><span>;</span>
<span>}</span>

<span>.three</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>174<span>,</span> 77%<span>,</span> 31%<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>就像 RGB 和 RGBA，HSL 有 HSLA，它使您能够指定 alpha 通道值。</p>

          <div
            id="code-demo-747aa065"
           
  
 data-title="HSLA%20%E9%A2%9C%E8%89%B2"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20one%5C%22%3Ehsla(188%2C%2097%25%2C%2028%25%2C%20.3)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20two%5C%22%3Ehsla(321%2C%2047%25%2C%2057%25%2C%20.7)%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%20three%5C%22%3Ehsla(174%2C%2077%25%2C%2031%25%2C%20.9)%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.one%20%7B%5Cn%20%20background-color%3A%20hsla(188%2C%2097%25%2C%2028%25%2C%200.3)%3B%5Cn%7D%5Cn%5Cn.two%20%7B%5Cn%20%20background-color%3A%20hsla(321%2C%2047%25%2C%2057%25%2C%200.7)%3B%5Cn%7D%5Cn%5Cn.three%20%7B%5Cn%20%20background-color%3A%20hsla(174%2C%2077%25%2C%2031%25%2C%200.9)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box one<span>"</span></span><span>></span></span>hsla(188, 97%, 28%, .3)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box two<span>"</span></span><span>></span></span>hsla(321, 47%, 57%, .7)<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box three<span>"</span></span><span>></span></span>hsla(174, 77%, 31%, .9)<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.one</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsla</span><span>(</span>188<span>,</span> 97%<span>,</span> 28%<span>,</span> 0.3<span>)</span><span>;</span>
<span>}</span>

<span>.two</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsla</span><span>(</span>321<span>,</span> 47%<span>,</span> 57%<span>,</span> 0.7<span>)</span><span>;</span>
<span>}</span>

<span>.three</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>hsla</span><span>(</span>174<span>,</span> 77%<span>,</span> 31%<span>,</span> 0.9<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="图片"> 图片</h2>
<p><code>&lt;image&gt;</code> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code> 函数指向的实际图像文件，也可以是一个渐变。</p>

          <div
            id="code-demo-1d17a516"
           
  
 data-title="%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%20image%5C%22%20%2F%3E%5Cn%3Cdiv%20class%3D%5C%22box%20gradient%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20300px%3B%5Cn%7D%5Cn%5Cn.image%20%7B%5Cn%20%20background-image%3A%20url(%2Fassets%2Fimg%2Fstar.png)%3B%5Cn%7D%5Cn%5Cn.gradient%20%7B%5Cn%20%20background-image%3A%20linear-gradient(%5Cn%20%20%20%2090deg%2C%5Cn%20%20%20%20rgba(119%2C%200%2C%20255%2C%201)%2039%25%2C%5Cn%20%20%20%20rgba(0%2C%20212%2C%20255%2C%201)%20100%25%5Cn%20%20)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box image<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box gradient<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 300px<span>;</span>
<span>}</span>

<span>.image</span> <span>{</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>/assets/img/star.png<span>)</span></span><span>;</span>
<span>}</span>

<span>.gradient</span> <span>{</span>
  <span>background-image</span><span>:</span> <span>linear-gradient</span><span>(</span>
    90deg<span>,</span>
    <span>rgba</span><span>(</span>119<span>,</span> 0<span>,</span> 255<span>,</span> 1<span>)</span> 39%<span>,</span>
    <span>rgba</span><span>(</span>0<span>,</span> 212<span>,</span> 255<span>,</span> 1<span>)</span> 100%
  <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="位置"> 位置</h2>
<p><code>&lt;position&gt;</code> 数据类型表示一组 2D 坐标，用于定位一个元素，如背景图像(通过 background-position)。它可以使用关键字(如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code> 以及 <code>center</code> )将元素与 2D 框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p>
<p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 center。</p>

          <div
            id="code-demo-bd26f1ae"
           
  
 data-title="%E4%BD%8D%E7%BD%AE"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22box%5C%22%20%2F%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20height%3A%20300px%3B%5Cn%20%20background-image%3A%20url(%2Fassets%2Fimg%2Fstar.png)%3B%5Cn%20%20background-repeat%3A%20no-repeat%3B%5Cn%20%20background-position%3A%20right%2040px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>height</span><span>:</span> 300px<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>/assets/img/star.png<span>)</span></span><span>;</span>
  <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
  <span>background-position</span><span>:</span> right 40px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="字符串和标识符"> 字符串和标识符</h2>
<p>CSS 中的某些值接受字符串，字符串必须用引号包裹起来。</p>
<div><p>标识符</p>
<p>某些关键词是合法的值(例如 <code>&lt;color&gt;</code> 关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个 CSS 可以理解的特殊值。它们并不是字符串，因此它们不能使用引号括起来。</p>
</div>
<h2 id="函数"> 函数</h2>
<p>在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与 JavaScript、Python 或 c++等语言相关联，但它们也以属性值的形式存在于 CSS 中。我们已经在颜色部分看到了函数: <code>rgb()</code>、<code>hsl()</code> 等。用于从文件返回图像的值 <code>url()</code> 也是一个函数。</p>
<p>行为更类似于传统编程语言的值是 <code>calc()</code> 函数。这个函数使您能够在 CSS 中进行简单的计算。如果您希望计算出在为项目编写 CSS 时无法定义的值，并且需要浏览器在运行时为您计算出这些值，那么它特别有用。</p>

          <div
            id="code-demo-7b5112ae"
           
  
 data-title="calc()%20%E8%AE%A1%E7%AE%97"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E6%88%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E6%98%AF%E8%A2%AB%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%7D%5Cn%5Cn.box%20%7B%5Cn%20%20width%3A%20calc(20%25%20%2B%20100px)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>我的宽度是被计算出来的<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span>width</span><span>:</span> <span>calc</span><span>(</span>20% + 100px<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">布局实战</title>
    <id>https://list-jiang.github.io/code/website/css/layout/exercise/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/exercise/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章包括了一些经典的布局实战案例。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章包括了一些经典的布局实战案例。</p>

<h2 id="flex-布局实战"> Flex 布局实战</h2>
<p>下面我们将通过骰子，来很好的在实战中展示 Flex 布局的功能与美丽。</p>
<p>骰子的一面，最多可以放置 9 个点。</p>
<p><img src="./assets/dice-axis.png" alt="骰子轴线" loading="lazy"></p>
<p>下面，就来看看 Flex 如何实现，从 1 个点到 9 个点的布局。<code>div</code> 元素 (代表骰子的一个面) 是 Flex 容器，<code>span</code> 元素 (代表一个点) 是 Flex 项目。如果有多个项目，就要添加多个 <code>span</code> 元素，以此类推。</p>
<details><summary>本项目通用样式</summary>
<div><pre><code><span>.dice-container</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
  <span>height</span><span>:</span> 150px<span>;</span>
  <span>background-color</span><span>:</span> #000<span>;</span>
<span>}</span>

<span>.dice-container .box</span> <span>{</span>
  <span>width</span><span>:</span> 90px<span>;</span>
  <span>height</span><span>:</span> 90px<span>;</span>
  <span>padding</span><span>:</span> 8px<span>;</span>
  <span>border-radius</span><span>:</span> 8px<span>;</span>
  <span>background-color</span><span>:</span> #f8f8f8<span>;</span>
<span>}</span>

<span>.dice-container .item</span> <span>{</span>
  <span>width</span><span>:</span> 24px<span>;</span>
  <span>height</span><span>:</span> 24px<span>;</span>
  <span>margin</span><span>:</span> 3px<span>;</span>
  <span>border-radius</span><span>:</span> 50%<span>;</span>
  <span>background-color</span><span>:</span> #000<span>;</span>
<span>}</span>

<span>.grid-cell</span> <span>{</span>
  <span>margin</span><span>:</span> 4px<span>;</span>
  <span>padding</span><span>:</span> 12px<span>;</span>
  <span>border-radius</span><span>:</span> 4px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>color</span><span>:</span> #666<span>;</span>
  <span>font-size</span><span>:</span> 14px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div></details>


<h3 id="单项目"> 单项目</h3>
<p>首先，只有左上角 1 个点的情况。Flex 布局默认就是首行左对齐，所以一行代码就够了。</p>

          <div
            id="code-demo-914fe3ee"
           
  
 data-title="%E7%82%B9%E4%BD%8D%201"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>设置项目的对齐方式，就能实现居中对齐和右对齐。</p>

          <div
            id="code-demo-143f0b9d"
           
  
 data-title="%E7%82%B9%E4%BD%8D%202"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20center%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-7dec637a"
           
  
 data-title="%E7%82%B9%E4%BD%8D%203"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>设置交叉轴对齐方式，可以垂直移动主轴。</p>

          <div
            id="code-demo-7473af99"
           
  
 data-title="%E7%82%B9%E4%BD%8D%204"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20align-items%3A%20center%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-5cc68c63"
           
  
 data-title="%E7%82%B9%E4%BD%8D%205"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20center%3B%5Cn%20%20align-items%3A%20center%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-3d046d7d"
           
  
 data-title="%E7%82%B9%E4%BD%8D%208"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20center%3B%5Cn%20%20align-items%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
  <span>align-items</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-677da877"
           
  
 data-title="%E7%82%B9%E4%BD%8D%209"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20flex-end%3B%5Cn%20%20align-items%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> flex-end<span>;</span>
  <span>align-items</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="双项目"> 双项目</h3>

          <div
            id="code-demo-33ae725e"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2013"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-d36f0386"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2017"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-direction%3A%20column%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-3fcc565d"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2028"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-direction%3A%20column%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20center%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-4cb59751"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2039"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-direction%3A%20column%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-2df20b9e"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2015"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.item%3Anth-child(2)%20%7B%5Cn%20%20align-self%3A%20center%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.item:nth-child(2)</span> <span>{</span>
  <span>align-self</span><span>:</span> center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-e81ff9c2"
           
  
 data-title="%E5%8F%8C%E7%82%B9%E4%BD%8D%2019"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%5Cn.item%3Anth-child(2)%20%7B%5Cn%20%20align-self%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>

<span>.item:nth-child(2)</span> <span>{</span>
  <span>align-self</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="三项目"> 三项目</h3>

          <div
            id="code-demo-4ece627b"
           
  
 data-title="%E4%B8%89%E7%82%B9"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.item%3Anth-child(2)%20%7B%5Cn%20%20align-self%3A%20center%3B%5Cn%7D%5Cn%5Cn.item%3Anth-child(3)%20%7B%5Cn%20%20align-self%3A%20flex-end%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.item:nth-child(2)</span> <span>{</span>
  <span>align-self</span><span>:</span> center<span>;</span>
<span>}</span>

<span>.item:nth-child(3)</span> <span>{</span>
  <span>align-self</span><span>:</span> flex-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="四项目"> 四项目</h3>

          <div
            id="code-demo-7911a961"
           
  
 data-title="%E5%9B%9B%E7%82%B9"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cdiv%20class%3D%5C%22column%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%20class%3D%5C%22column%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20wrap%3B%5Cn%20%20align-content%3A%20space-between%3B%5Cn%7D%5Cn%5Cn.column%20%7B%5Cn%20%20flex-basis%3A%20100%25%3B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap<span>;</span>
  <span>align-content</span><span>:</span> space-between<span>;</span>
<span>}</span>

<span>.column</span> <span>{</span>
  <span>flex-basis</span><span>:</span> 100%<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="六项目"> 六项目</h3>

          <div
            id="code-demo-1b7a712c"
           
  
 data-title="%E5%85%AD%E7%82%B9"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20wrap%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-12b7066f"
           
  
 data-title="%E5%85%AD%E7%82%B9%202"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-direction%3A%20column%3B%5Cn%20%20flex-wrap%3A%20wrap%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>您还可以使用高级选择器:</p>

          <div
            id="code-demo-9c18d87e"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%A1%88"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22dice-container%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20%3Cdiv%20class%3D%5C%22row%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%20class%3D%5C%22row%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%20class%3D%5C%22row%5C%22%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%20%20%3Cspan%20class%3D%5C%22item%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20wrap%3B%5Cn%7D%5Cn%5Cn.row%20%7B%5Cn%20%20flex-basis%3A%20100%25%3B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.row%3Anth-child(2)%20%7B%5Cn%20%20justify-content%3A%20center%3B%5Cn%7D%5Cn%5Cn.row%3Anth-child(3)%20%7B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>dice-container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap<span>;</span>
<span>}</span>

<span>.row</span> <span>{</span>
  <span>flex-basis</span><span>:</span> 100%<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.row:nth-child(2)</span> <span>{</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
<span>}</span>

<span>.row:nth-child(3)</span> <span>{</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="网格布局"> 网格布局</h2>
<h3 id="基本网格布局"> 基本网格布局</h3>
<p>最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。</p>

          <div
            id="code-demo-4c885268"
           
  
 data-title="%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%2F2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%2F2%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%2F3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%2F3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E1%2F3%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3EMr.Hope%20%E5%BE%88%E5%B8%85!%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%20%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%20%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%20Mr.Hope%20%E5%BE%88%E5%B8%85!%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.grid-cell%20%7B%5Cn%20%20flex%3A%201%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1/2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1/2<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1/3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1/3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>1/3<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>Mr.Hope 很帅!<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell<span>"</span></span><span>></span></span>
    Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
    Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
    Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅! Mr.Hope 很帅!
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>CSS 代码如下。</p>
<div><pre><code><span>.grid-wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.grid-cell</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="百分比布局"> 百分比布局</h3>
<p>某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。</p>

          <div
            id="code-demo-50c233dd"
           
  
 data-title="%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-2%5C%22%3E1%2F2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-auto%5C%22%3Eauto%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-auto%5C%22%3Eauto%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-auto%5C%22%3Eauto%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-auto%5C%22%3Eauto%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-3%5C%22%3E1%2F3%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cdiv%20class%3D%5C%22grid-wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-4%5C%22%3E1%2F4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-auto%5C%22%3Eauto%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22grid-cell%20grid-cell-3%5C%22%3E1%2F3%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.grid-cell-auto%20%7B%5Cn%20%20flex%3A%201%3B%5Cn%7D%5Cn%5Cn.grid-cell-2%20%7B%5Cn%20%20width%3A%2050%25%3B%5Cn%7D%5Cn.grid-cell-3%20%7B%5Cn%20%20width%3A%20calc(100%25%20%2F%203)%3B%5Cn%7D%5Cn%5Cn.grid-cell-4%20%7B%5Cn%20%20width%3A%2025%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-2<span>"</span></span><span>></span></span>1/2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-auto<span>"</span></span><span>></span></span>auto<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-auto<span>"</span></span><span>></span></span>auto<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-auto<span>"</span></span><span>></span></span>auto<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-auto<span>"</span></span><span>></span></span>auto<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-3<span>"</span></span><span>></span></span>1/3<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-4<span>"</span></span><span>></span></span>1/4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-auto<span>"</span></span><span>></span></span>auto<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-cell grid-cell-3<span>"</span></span><span>></span></span>1/3<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>.grid-wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.grid-cell-auto</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>

<span>.grid-cell-2</span> <span>{</span>
  <span>width</span><span>:</span> 50%<span>;</span>
<span>}</span>
<span>.grid-cell-3</span> <span>{</span>
  <span>width</span><span>:</span> <span>calc</span><span>(</span>100% / 3<span>)</span><span>;</span>
<span>}</span>

<span>.grid-cell-4</span> <span>{</span>
  <span>width</span><span>:</span> 25%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="圣杯布局"> 圣杯布局</h2>
<p>圣杯布局 (Holy Grail Layout) 指的是一种最常见的网站布局。</p>
<p>页面从上到下，分成三个部分: 头部 (header) ，躯干 (body) ，尾部 (footer) 。其中躯干又水平分成三栏，从左到右为: 导航、主栏、副栏。</p>
<p><img src="./assets/holy.png" alt="圣杯布局" loading="lazy"></p>
<p>HTML 代码如下。</p>
<div><pre><code><span><span><span>&lt;</span>body</span> <span>class</span><span><span>=</span><span>"</span>HolyGrail<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>header</span><span>></span></span>...<span><span><span>&lt;/</span>header</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>HolyGrail-body<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>main</span> <span>class</span><span><span>=</span><span>"</span>HolyGrail-content<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>main</span><span>></span></span>
    <span><span><span>&lt;</span>nav</span> <span>class</span><span><span>=</span><span>"</span>HolyGrail-nav<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>nav</span><span>></span></span>
    <span><span><span>&lt;</span>aside</span> <span>class</span><span><span>=</span><span>"</span>HolyGrail-ads<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>aside</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>footer</span><span>></span></span>...<span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>CSS 代码如下。</p>
<div><pre><code><span>.HolyGrail</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>min-height</span><span>:</span> 100vh<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
<span>}</span>

<span>header,
footer</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>

<span>.HolyGrail-body</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>

<span>.HolyGrail-content</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>

<span>.HolyGrail-nav,
.HolyGrail-ads</span> <span>{</span>
  <span>/* 两个边栏的宽度设为 12em */</span>
  <span>flex</span><span>:</span> 0 0 12em<span>;</span>
<span>}</span>

<span>.HolyGrail-nav</span> <span>{</span>
  <span>/* 导航放到最左边 */</span>
  <span>order</span><span>:</span> -1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>如果是小屏幕，躯干的三栏自动变为垂直叠加。</p>
<div><pre><code><span><span>@media</span> <span>(</span><span>max-width</span><span>:</span> 768px<span>)</span></span> <span>{</span>
  <span>.HolyGrail-body</span> <span>{</span>
    <span>flex-direction</span><span>:</span> column<span>;</span>
    <span>flex</span><span>:</span> 1<span>;</span>
  <span>}</span>
  <span>.HolyGrail-nav,
  .HolyGrail-ads,
  .HolyGrail-content</span> <span>{</span>
    <span>flex</span><span>:</span> auto<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="输入框的布局"> 输入框的布局</h2>
<p>我们常常需要在输入框的前方添加提示，后方添加按钮。</p>
<p><img src="./assets/input.png" alt="输入框" loading="lazy"></p>
<p>HTML 代码如下。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>InputAddOn<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>InputAddOn-item<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>span</span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>class</span><span><span>=</span><span>"</span>InputAddOn-field<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>button</span> <span>class</span><span><span>=</span><span>"</span>InputAddOn-item<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>CSS 代码如下。</p>
<div><pre><code><span>.InputAddOn</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.InputAddOn-field</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="悬挂式布局"> 悬挂式布局</h2>
<p>有时，主栏的左侧或右侧，需要添加一个图片栏。</p>
<p><img src="./assets/hang.png" alt="悬挂式布局" loading="lazy"></p>
<p>HTML 代码如下。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>Media<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>"</span>Media-figure<span>"</span></span> <span>src</span><span><span>=</span><span>"</span><span>"</span></span> <span>alt</span><span><span>=</span><span>"</span><span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>Media-body<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>CSS 代码如下。</p>
<div><pre><code><span>.Media</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>align-items</span><span>:</span> flex-start<span>;</span>
<span>}</span>

<span>.Media-figure</span> <span>{</span>
  <span>margin-right</span><span>:</span> 1em<span>;</span>
<span>}</span>

<span>.Media-body</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="固定的底栏"> 固定的底栏</h2>
<p>有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用 Flex 布局，让底栏总是出现在页面的底部。</p>
<p><img src="./assets/footer.png" alt="固定底栏" loading="lazy"></p>
<p>HTML 代码如下。</p>
<div><pre><code><span><span><span>&lt;</span>body</span> <span>class</span><span><span>=</span><span>"</span>Site<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>header</span><span>></span></span>...<span><span><span>&lt;/</span>header</span><span>></span></span>
  <span><span><span>&lt;</span>main</span> <span>class</span><span><span>=</span><span>"</span>Site-content<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>main</span><span>></span></span>
  <span><span><span>&lt;</span>footer</span><span>></span></span>...<span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>CSS 代码如下。</p>
<div><pre><code><span>.Site</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>min-height</span><span>:</span> 100vh<span>;</span>
  <span>flex-direction</span><span>:</span> column<span>;</span>
<span>}</span>

<span>.Site-content</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="流式布局"> 流式布局</h2>
<p><img src="./assets/flow.png" alt="流式布局" loading="lazy"></p>
<p>每行的项目数固定，会自动分行。</p>
<p>CSS 的写法。</p>
<div><pre><code><span>.parent</span> <span>{</span>
  <span>width</span><span>:</span> 200px<span>;</span>
  <span>height</span><span>:</span> 150px<span>;</span>
  <span>background-color</span><span>:</span> black<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-flow</span><span>:</span> row wrap<span>;</span>
  <span>align-content</span><span>:</span> flex-start<span>;</span>
<span>}</span>

<span>.child</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
  <span>background-color</span><span>:</span> white<span>;</span>
  <span>flex</span><span>:</span> 0 0 25%<span>;</span>
  <span>height</span><span>:</span> 50px<span>;</span>
  <span>border</span><span>:</span> 1px solid red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2020-10-20T00:00:00.000Z</published>
    <rights>自由转载-非商用-非衍生-保持署名 (创意共享3.0许可证)</rights>
  </entry>
  <entry>
    <title type="html">弹性模型</title>
    <id>https://list-jiang.github.io/code/website/css/layout/flex/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/flex/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>

<h2 id="简介"> 简介</h2>
<p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>行内元素也可以使用 Flex 布局。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>display</span><span>:</span> inline-flex<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>注意</p>
<p>设为 Flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p>
</div>
<h2 id="基本概念"> 基本概念</h2>
<p>采用 Flex 布局的元素，称为 Flex 容器(flex container)，简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目(flex item)，简称&quot;项目&quot;。</p>
<p><img src="./assets/flex.png" alt="Flex 示意图" loading="lazy"></p>
<ul>
<li>主轴 (main axis) 是沿着 flex 元素放置的方向延伸的轴(比如页面上的横向的行、纵向的列)。该轴的开始和结束被称为 main start 和 main end。</li>
<li>交叉轴 (cross axis) 是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。</li>
<li>设置了 <code>display: flex</code> 的父元素被称之为 flex 容器(flex container)。</li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 flex 项(flex item)</li>
<li>单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</li>
</ul>
<div><p>提示</p>
<p>这张图很有用，可以多看看。</p>
<p>在默认情况下，主轴水平，方向是从左到右；交叉轴垂直，方向是从上到下。</p>
</div>
<h2 id="容器的属性"> 容器的属性</h2>
<p>以下 6 个属性设置在容器上。</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h3 id="flex-direction"> flex-direction</h3>
<p><code>flex-direction</code> 属性决定主轴的方向(即项目的排列方向)。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>flex-direction</span><span>:</span> row | row-reverse | column | column-reverse<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/flex-direction.png" alt="flex-direction" loading="lazy"></p>
<p>它可能有 4 个值。</p>
<ul>
<li><code>row</code>(默认值): 主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>: 主轴为水平方向，起点在右端。</li>
<li><code>column</code>: 主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>: 主轴为垂直方向，起点在下沿。</li>
</ul>
<div><p>注意</p>
<p>请注意，在任何情况下，交叉轴的均为主轴顺时针旋转 90°</p>
</div>
<h3 id="flex-wrap"> flex-wrap</h3>
<p>默认情况下，项目都排在一条线(又称&quot;轴线&quot;)上。<code>flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="./assets/flex-wrap.png" alt="flex-wrap" loading="lazy"></p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>flex-wrap</span><span>:</span> nowrap | wrap | wrap-reverse<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>它可能取三个值。</p>
<ol>
<li>
<p><code>nowrap</code>(默认): 不换行。</p>

          <div
            id="code-demo-63c57436"
           
  
 data-title="nowrap"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item10%5C%22%3E10%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item11%5C%22%3E11%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item12%5C%22%3E12%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20no-wrap%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%20%20height%3A%2080px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item10<span>"</span></span><span>></span></span>10<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item11<span>"</span></span><span>></span></span>11<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item12<span>"</span></span><span>></span></span>12<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> no-wrap<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
  <span>height</span><span>:</span> 80px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
</li>
<li>
<p><code>wrap</code>: 换行，第一行在上方。</p>

          <div
            id="code-demo-e7a699a6"
           
  
 data-title="wrap"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item10%5C%22%3E10%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item11%5C%22%3E11%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item12%5C%22%3E12%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20wrap%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%20%20height%3A%2080px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item10<span>"</span></span><span>></span></span>10<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item11<span>"</span></span><span>></span></span>11<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item12<span>"</span></span><span>></span></span>12<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
  <span>height</span><span>:</span> 80px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
</li>
<li>
<p><code>wrap-reverse</code>: 换行，第一行在下方。</p>

          <div
            id="code-demo-4135b1e3"
           
  
 data-title="wrap-reverse"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item10%5C%22%3E10%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item11%5C%22%3E11%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item12%5C%22%3E12%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20flex-wrap%3A%20wrap-reverse%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%20%20height%3A%2080px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item10<span>"</span></span><span>></span></span>10<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item11<span>"</span></span><span>></span></span>11<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item12<span>"</span></span><span>></span></span>12<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>flex-wrap</span><span>:</span> wrap-reverse<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
  <span>height</span><span>:</span> 80px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
</li>
</ol>
<h3 id="flex-flow"> flex-flow</h3>
<p><code>flex-flow</code> 属性是 <code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式，默认值为 <code>row nowrap</code>。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>flex-flow</span><span>:</span> &lt;flex-direction> || &lt;flex-wrap><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="justify-content"> justify-content</h3>
<p><code>justify-content</code> 属性定义了项目在主轴上的对齐方式。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>justify-content</span><span>:</span> flex-start | flex-end | center | space-between | space-around<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
          <div
            id="code-demo-115fd2ee"
           
  
 data-title="flex-start"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20flex-start%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> flex-start<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-786cb125"
           
  
 data-title="flex-end"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20flex-end%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> flex-end<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-547f0a5e"
           
  
 data-title="center"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20center%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> center<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-1af1ae11"
           
  
 data-title="space-between"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-499b0128"
           
  
 data-title="space-around"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-around%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-around<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-5d3fa3f5"
           
  
 data-title="space-evenly"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-evenly%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20width%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20width%3A%2080px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-evenly<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>width</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>width</span><span>:</span> 80px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li><code>flex-start</code>(默认值): 左对齐</li>
<li><code>flex-end</code>: 右对齐</li>
<li><code>center</code>: 居中</li>
<li><code>space-between</code>: 两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
<li><code>space-evenly</code>: 均匀排列每个元素，每个元素之间的间隔相等。</li>
</ul>
<h3 id="align-items"> align-items</h3>
<p><code>align-items</code> 属性定义项目在交叉轴上如何对齐。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>align-items</span><span>:</span> flex-start | flex-end | center | baseline | stretch<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
          <div
            id="code-demo-6b4b753b"
           
  
 data-title="flex-start"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20flex-start%3B%5Cn%20%20height%3A%20160px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20height%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20height%3A%2080px%3B%5Cn%7D%5Cn%5Cn.item4%20%7B%5Cn%20%20height%3A%2040px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> flex-start<span>;</span>
  <span>height</span><span>:</span> 160px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>height</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>height</span><span>:</span> 80px<span>;</span>
<span>}</span>

<span>.item4</span> <span>{</span>
  <span>height</span><span>:</span> 40px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-fd185f8e"
           
  
 data-title="flex-end"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20flex-end%3B%5Cn%20%20height%3A%20160px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20height%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20height%3A%2080px%3B%5Cn%7D%5Cn%5Cn.item4%20%7B%5Cn%20%20height%3A%2040px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> flex-end<span>;</span>
  <span>height</span><span>:</span> 160px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>height</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>height</span><span>:</span> 80px<span>;</span>
<span>}</span>

<span>.item4</span> <span>{</span>
  <span>height</span><span>:</span> 40px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-78fbd567"
           
  
 data-title="center"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20center%3B%5Cn%20%20height%3A%20160px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20height%3A%20120px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20height%3A%2080px%3B%5Cn%7D%5Cn%5Cn.item4%20%7B%5Cn%20%20height%3A%2040px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> center<span>;</span>
  <span>height</span><span>:</span> 160px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>height</span><span>:</span> 120px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>height</span><span>:</span> 80px<span>;</span>
<span>}</span>

<span>.item4</span> <span>{</span>
  <span>height</span><span>:</span> 40px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-6c080c67"
           
  
 data-title="baseline"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3Etext%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3Etext%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3Etext%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3Etext%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20baseline%3B%5Cn%20%20height%3A%20160px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%5Cn.item1%20%7B%5Cn%20%20height%3A%2060px%3B%5Cn%7D%5Cn%5Cn.item2%20%7B%5Cn%20%20padding-top%3A%2020px%3B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%5Cn.item3%20%7B%5Cn%20%20padding-top%3A%2040px%3B%5Cn%20%20height%3A%2040px%3B%5Cn%7D%5Cn%5Cn.item4%20%7B%5Cn%20%20height%3A%2040px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>text<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>text<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>text<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>text<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> baseline<span>;</span>
  <span>height</span><span>:</span> 160px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>

<span>.item1</span> <span>{</span>
  <span>height</span><span>:</span> 60px<span>;</span>
<span>}</span>

<span>.item2</span> <span>{</span>
  <span>padding-top</span><span>:</span> 20px<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>

<span>.item3</span> <span>{</span>
  <span>padding-top</span><span>:</span> 40px<span>;</span>
  <span>height</span><span>:</span> 40px<span>;</span>
<span>}</span>

<span>.item4</span> <span>{</span>
  <span>height</span><span>:</span> 40px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>
            </div>
          </div>
          
        </div>

          <div
            id="code-demo-6c66dead"
           
  
 data-title="stretch"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%20%2F%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%20%2F%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%20%20align-items%3A%20stretch%3B%5Cn%20%20height%3A%20160px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20width%3A%2060px%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>justify-content</span><span>:</span> space-between<span>;</span>
  <span>align-items</span><span>:</span> stretch<span>;</span>
  <span>height</span><span>:</span> 160px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li><code>flex-start</code>: 交叉轴的起点对齐。</li>
<li><code>flex-end</code>: 交叉轴的终点对齐。</li>
<li><code>center</code>: 交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>(默认值): 如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>
</ul>
<h3 id="align-content"> align-content</h3>
<p><code>align-content</code> 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>align-content</span><span>:</span> flex-start | flex-end | center | space-between | space-around |
    stretch<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./assets/align-content.png" alt="align-content" loading="lazy"></p>
<p>该属性可能取 6 个值。</p>
<ul>
<li><code>flex-start</code>: 与交叉轴的起点对齐。</li>
<li><code>flex-end</code>: 与交叉轴的终点对齐。</li>
<li><code>center</code>: 与交叉轴的中点对齐。</li>
<li><code>space-between</code>: 与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>: 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴- 线与边框的间隔大一倍。</li>
<li><code>stretch</code>(默认值): 轴线占满整个交叉轴。</li>
</ul>
<h2 id="项目的属性"> 项目的属性</h2>
<p>以下 6 个属性设置在项目上。</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h3 id="order"> order</h3>
<p><code>order</code> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 <code>0</code>。</p>
<p><img src="./assets/order.png" alt="order" loading="lazy"></p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>order</span><span>:</span> &lt;integer><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="flex-grow"> flex-grow</h3>
<p><code>flex-grow</code> 属性定义项目的放大比例，默认为 <code>0</code>，即如果存在剩余空间，也不放大。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>flex-grow</span><span>:</span> &lt;number><span>;</span> <span>/* default 0 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/flex-grow.png" alt="flex-grow" loading="lazy"></p>
<p>如果所有项目的 <code>flex-grow</code> 属性都为 <code>1</code>，则它们将等分剩余空间(如果有的话)。如果一个项目的 <code>flex-grow</code> 属性为 <code>2</code>，其他项目都为 <code>1</code>，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="flex-shrink"> flex-shrink</h3>
<p><code>flex-shrink</code> 属性定义了项目的缩小比例，默认为 <code>1</code>，即如果空间不足，该项目将缩小。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>flex-shrink</span><span>:</span> &lt;number><span>;</span> <span>/* default 1 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/flex-shrink.jpg" alt="flex-shrink" loading="lazy"></p>
<p>如果所有项目的 <code>flex-shrink</code> 属性都为 <code>1</code>，当空间不足时，都将等比例缩小。如果一个项目的 <code>flex-shrink</code> 属性为 <code>0</code>，其他项目都为 <code>1</code>，则空间不足时，前者不缩小。</p>
<div><p>提示</p>
<p>负值对该属性无效。</p>
</div>
<h3 id="flex-basis"> flex-basis</h3>
<p><code>flex-basis</code> 属性定义了在分配多余空间之前，项目占据的主轴空间 (main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 <code>auto</code>，即项目的本来大小。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>flex-basis</span><span>:</span> &lt;length> | auto<span>;</span> <span>/* default auto */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>它可以设为跟 <code>width</code> 或 <code>height</code> 属性一样的值(比如 350px)，则项目将占据固定空间。</p>
<h3 id="flex"> flex</h3>
<p><code>flex</code> 属性是 <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code> 的简写，默认值为 <code>0 1 auto</code>。后两个属性可选。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>flex</span><span>:</span> none | [ &lt; <span>"flex-grow"</span> > &lt; <span>"flex-shrink"</span> >? || &lt; <span>"flex-basis"</span> > ]<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该属性有两个快捷值: <code>auto</code> (<code>1 1 auto</code>) 和 <code>non</code>e (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="align-self"> align-self</h3>
<p><code>align-self</code> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 <code>align-items</code> 属性。默认值为 <code>auto</code>，表示继承父元素的 <code>align-items</code> 属性，如果没有父元素，则等同于 <code>stretch</code>。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>align-self</span><span>:</span> auto | flex-start | flex-end | center | baseline | stretch<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/align-self.png" alt="align-self" loading="lazy"></p>
<p>该属性可能取 6 个值，除了 <code>auto</code>，其他都与 <code>align-items</code> 属性完全一
致。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>自由转载-非商用-非衍生-保持署名 (创意共享3.0许可证)</rights>
  </entry>
  <entry>
    <title type="html">浮动</title>
    <id>https://list-jiang.github.io/code/website/css/layout/float/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/float/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在网站布局中，应当以 normal flow, flex 和 grid 布局为主。只有在需要特殊样式无法满足时，再考虑 float 布局。</p>
<h2 id="简介"> 简介</h2>
<p>把一个元素“浮动”(float)起来，会改变该元素本身和在正常布局流(normal flow)中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流(normal flow)中移除，这时候其他的周围内容就会在这个被设置浮动(float)的元素周围环绕。</p>
<p><code>float</code> 属性有四个可能的值:</p>
<ul>
<li><code>inherit</code>: 继承父元素的浮动属性。</li>
<li><code>left</code>: 将元素浮动到左侧。</li>
<li><code>right</code>: 将元素浮动到右侧。</li>
<li><code>none</code>: 默认值, 不浮动。</li>
</ul>

          <div
            id="code-demo-091794da"
           
  
 data-title="float%20%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Ch1%3ESimple%20float%20example%3C%2Fh1%3E%5Cn%5Cn%3Cdiv%20class%3D%5C%22box%5C%22%3EFloat%3C%2Fdiv%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%20aliquam%5Cn%20%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%20pulvinar%20id%20metus%5Cn%20%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%20at%20ultricies%20tellus%5Cn%20%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%20Integer%20ligula%20ipsum%2C%5Cn%20%20tristique%20sit%20amet%20orci%20vel%2C%20viverra%20egestas%20ligula.%20Curabitur%20vehicula%20tellus%5Cn%20%20neque%2C%20ac%20ornare%20ex%20malesuada%20et.%20In%20vitae%20convallis%20lacus.%20Aliquam%20erat%5Cn%20%20volutpat.%20Suspendisse%20ac%20imperdiet%20turpis.%20Aenean%20finibus%20sollicitudin%20eros%5Cn%20%20pharetra%20congue.%20Duis%20ornare%20egestas%20augue%20ut%20luctus.%20Proin%20blandit%20quam%20nec%5Cn%20%20lacus%20varius%20commodo%20et%20a%20urna.%20Ut%20id%20ornare%20felis%2C%20eget%20fermentum%20sapien.%5Cn%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20float%3A%20left%3B%5Cn%20%20width%3A%20150px%3B%5Cn%20%20height%3A%20150px%3B%5Cn%20%20margin-right%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Simple float example<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>Float<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam
  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus
  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus
  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,
  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus
  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat
  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros
  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec
  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>width</span><span>:</span> 150px<span>;</span>
  <span>height</span><span>:</span> 150px<span>;</span>
  <span>margin-right</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>注意浮动内容仍然遵循盒子模型诸如外边距和边界。</p>
<h2 id="首字下沉"> 首字下沉</h2>

          <div
            id="code-demo-236f39a1"
           
  
 data-title="%E9%A6%96%E5%AD%97%E4%B8%8B%E6%B2%89"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20This%20is%20my%20very%20important%20paragraph.%20I%20am%20a%20distinguished%20gentleman%20of%20such%5Cn%20%20renown%20that%20my%20paragraph%20needs%20to%20be%20styled%20in%20a%20manner%20befitting%20my%20majesty.%5Cn%20%20Bow%20before%20my%20splendour%2C%20dear%20students%2C%20and%20go%20forth%20and%20learn%20CSS!%5Cn%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20width%3A%20400px%3B%5Cn%20%20margin%3A%200%20auto%3B%5Cn%7D%5Cn%5Cnp%3A%3Afirst-line%20%7B%5Cn%20%20text-transform%3A%20uppercase%3B%5Cn%7D%5Cn%5Cnp%3A%3Afirst-letter%20%7B%5Cn%20%20font-size%3A%203em%3B%5Cn%20%20border%3A%201px%20solid%20black%3B%5Cn%20%20background%3A%20red%3B%5Cn%20%20float%3A%20left%3B%5Cn%20%20padding%3A%202px%3B%5Cn%20%20margin-right%3A%204px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  This is my very important paragraph. I am a distinguished gentleman of such
  renown that my paragraph needs to be styled in a manner befitting my majesty.
  Bow before my splendour, dear students, and go forth and learn CSS!
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>width</span><span>:</span> 400px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>

<span>p::first-line</span> <span>{</span>
  <span>text-transform</span><span>:</span> uppercase<span>;</span>
<span>}</span>

<span>p::first-letter</span> <span>{</span>
  <span>font-size</span><span>:</span> 3em<span>;</span>
  <span>border</span><span>:</span> 1px solid black<span>;</span>
  <span>background</span><span>:</span> red<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>padding</span><span>:</span> 2px<span>;</span>
  <span>margin-right</span><span>:</span> 4px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="多列浮动布局"> 多列浮动布局</h2>

          <div
            id="code-demo-170710c3"
           
  
 data-title="%E5%A4%9A%E5%88%97%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Ch1%3E2%20column%20layout%20example%3C%2Fh1%3E%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3EFirst%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%5Cn%20%20%20%20%20%20aliquam%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%5Cn%20%20%20%20%20%20pulvinar%20id%20metus%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%5Cn%20%20%20%20%20%20at%20ultricies%20tellus%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%5Cn%20%20%20%20%20%20Integer%20ligula%20ipsum%2C%20tristique%20sit%20amet%20orci%20vel%2C%20viverra%20egestas%20ligula.%5Cn%20%20%20%20%20%20Curabitur%20vehicula%20tellus%20neque%2C%20ac%20ornare%20ex%20malesuada%20et.%20In%20vitae%5Cn%20%20%20%20%20%20convallis%20lacus.%20Aliquam%20erat%20volutpat.%20Suspendisse%20ac%20imperdiet%20turpis.%5Cn%20%20%20%20%20%20Aenean%20finibus%20sollicitudin%20eros%20pharetra%20congue.%20Duis%20ornare%20egestas%5Cn%20%20%20%20%20%20augue%20ut%20luctus.%20Proin%20blandit%20quam%20nec%20lacus%20varius%20commodo%20et%20a%20urna.%20Ut%5Cn%20%20%20%20%20%20id%20ornare%20felis%2C%20eget%20fermentum%20sapien.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3ESecond%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20vulputate%20diam%20nec%20tempor%20bibendum.%20Donec%20luctus%20augue%20eget%20malesuada%5Cn%20%20%20%20%20%20ultrices.%20Phasellus%20turpis%20est%2C%20posuere%20sit%20amet%20dapibus%20ut%2C%20facilisis%20sed%5Cn%20%20%20%20%20%20est.%20Nam%20id%20risus%20quis%20ante%20semper%20consectetur%20eget%20aliquam%20lorem.%20Vivamus%5Cn%20%20%20%20%20%20tristique%20elit%20dolor%2C%20sed%20pretium%20metus%20suscipit%20vel.%20Mauris%20ultricies%5Cn%20%20%20%20%20%20lectus%20sed%20lobortis%20finibus.%20Vivamus%20eu%20urna%20eget%20velit%20cursus%20viverra%5Cn%20%20%20%20%20%20quis%20vestibulum%20sem.%20Aliquam%20tincidunt%20eget%20purus%20in%20interdum.%20Cum%20sociis%5Cn%20%20%20%20%20%20natoque%20penatibus%20et%20magnis%20dis%20parturient%20montes%2C%20nascetur%20ridiculus%20mus.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%3E%20div%3Anth-of-type(1)%20%7B%5Cn%20%20width%3A%2048%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(2)%20%7B%5Cn%20%20width%3A%2048%25%3B%5Cn%20%20float%3A%20right%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>2 column layout example<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>First column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus
      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,
      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,
      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.
      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.
      Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae
      convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.
      Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas
      augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut
      id ornare felis, eget fermentum sapien.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Second column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada
      ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed
      est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus
      tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies
      lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra
      quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis
      natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><pre><code><span>.container > div:nth-of-type(1)</span> <span>{</span>
  <span>width</span><span>:</span> 48%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(2)</span> <span>{</span>
  <span>width</span><span>:</span> 48%<span>;</span>
  <span>float</span><span>:</span> right<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>所有列使用宽度百分比会创建一个流式布局(liquid layout)。请尝试调整浏览器窗口的宽度，以便自己查看。需要注意的一件事是，当它们变得非常窄时，列就会变得很糟糕。切换回窄屏幕的单列布局通常是有意义的 (如手机)，使用媒体查询可以实现这一功能。</p>
<p>另一种选择是将宽度设置为一个固定的单位如 rem 或像素，这就是固定宽度布局(fixed-width layout)</p>
<h2 id="清除浮动"> 清除浮动</h2>
<p>有些情况下，浮动元素内容过多会错乱排版。</p>

          <div
            id="code-demo-077b0e3e"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E7%B3%9F%E7%B3%95%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Ch1%3EFloat%20disaster%3C%2Fh1%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3EFirst%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%5Cn%20%20%20%20%20%20aliquam%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%5Cn%20%20%20%20%20%20pulvinar%20id%20metus%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%5Cn%20%20%20%20%20%20at%20ultricies%20tellus%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3ESecond%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20vulputate%20diam%20nec%20tempor%20bibendum.%20Donec%20luctus%20augue%20eget%20malesuada%5Cn%20%20%20%20%20%20ultrices.%20Phasellus%20turpis%20est%2C%20posuere%20sit%20amet%20dapibus%20ut%2C%20facilisis%20sed%5Cn%20%20%20%20%20%20est.%20Nam%20id%20risus%20quis%20ante%20semper%20consectetur%20eget%20aliquam%20lorem.%20Vivamus%5Cn%20%20%20%20%20%20tristique%20elit%20dolor%2C%20sed%20pretium%20metus%20suscipit%20vel.%20Mauris%20ultricies%5Cn%20%20%20%20%20%20lectus%20sed%20lobortis%20finibus.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3EThird%20column%3C%2Fh2%3E%5Cn%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20consequat%20scelerisque%20mattis.%20Duis%20pulvinar%20dapibus%20magna%2C%20eget%20congue%5Cn%20%20%20%20%20%20purus%20mollis%20sit%20amet.%20Sed%20euismod%20lacus%20sit%20amet%20ex%20tempus%2C%20a%20semper%5Cn%20%20%20%20%20%20felis%20ultrices.%20Maecenas%20a%20efficitur%20metus.%20Nullam%20tempus%20pharetra%5Cn%20%20%20%20%20%20pharetra.%20Morbi%20in%20leo%20mauris.%20Nullam%20gravida%20ligula%20eros%2C%20lacinia%5Cn%20%20%20%20%20%20sagittis%20lorem%20fermentum%20ut.%20Praesent%20dapibus%20eros%20vel%20mi%20pretium%2C%20nec%5Cn%20%20%20%20%20%20convallis%20nibh%20blandit.%20Sed%20scelerisque%20justo%20ac%20ligula%20mollis%20laoreet.%20In%5Cn%20%20%20%20%20%20mattis%2C%20risus%20et%20porta%20scelerisque%2C%20augue%20neque%20hendrerit%20orci%2C%20sit%20amet%5Cn%20%20%20%20%20%20imperdiet%20risus%20neque%20vitae%20lectus.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cfooter%3E%5Cn%20%20%20%20%3Cp%3E%C2%A92020%20Mr.Hope%20A%20very%20handsooooooooooooooooome%20man.%3C%2Fp%3E%5Cn%20%20%3C%2Ffooter%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%7B%5Cn%20%20width%3A%2090%25%3B%5Cn%20%20max-width%3A%20900px%3B%5Cn%20%20margin%3A%200%20auto%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(1)%20%7B%5Cn%20%20width%3A%2036%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(2)%20%7B%5Cn%20%20width%3A%2030%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%20%20margin-left%3A%204%25%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(3)%20%7B%5Cn%20%20width%3A%2026%25%3B%5Cn%20%20float%3A%20right%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>Float disaster<span><span><span>&lt;/</span>h1</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>First column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus
      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,
      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,
      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Second column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada
      ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed
      est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus
      tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies
      lectus sed lobortis finibus.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Third column<span><span><span>&lt;/</span>h2</span><span>></span></span>

    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue
      purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper
      felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra
      pharetra. Morbi in leo mauris. Nullam gravida ligula eros, lacinia
      sagittis lorem fermentum ut. Praesent dapibus eros vel mi pretium, nec
      convallis nibh blandit. Sed scelerisque justo ac ligula mollis laoreet. In
      mattis, risus et porta scelerisque, augue neque hendrerit orci, sit amet
      imperdiet risus neque vitae lectus.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>footer</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>©2020 Mr.Hope A very handsooooooooooooooooome man.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>
  <span>width</span><span>:</span> 90%<span>;</span>
  <span>max-width</span><span>:</span> 900px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(1)</span> <span>{</span>
  <span>width</span><span>:</span> 36%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(2)</span> <span>{</span>
  <span>width</span><span>:</span> 30%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>margin-left</span><span>:</span> 4%<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(3)</span> <span>{</span>
  <span>width</span><span>:</span> 26%<span>;</span>
  <span>float</span><span>:</span> right<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>为了解决这个问题，您需要在页脚清除浮动。</p>
<div><pre><code><span>footer</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>clear 可以取三个值:</p>
<ul>
<li><code>left</code>: 停止任何活动的左浮动</li>
<li><code>right</code>: 停止任何活动的右浮动</li>
<li><code>both</code>: 停止任何活动的左右浮动</li>
</ul>

          <div
            id="code-demo-56db7f95"
           
  
 data-title="%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Ch1%3EFloat%20disaster%3C%2Fh1%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3EFirst%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%5Cn%20%20%20%20%20%20aliquam%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%5Cn%20%20%20%20%20%20pulvinar%20id%20metus%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%5Cn%20%20%20%20%20%20at%20ultricies%20tellus%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3ESecond%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20vulputate%20diam%20nec%20tempor%20bibendum.%20Donec%20luctus%20augue%20eget%20malesuada%5Cn%20%20%20%20%20%20ultrices.%20Phasellus%20turpis%20est%2C%20posuere%20sit%20amet%20dapibus%20ut%2C%20facilisis%20sed%5Cn%20%20%20%20%20%20est.%20Nam%20id%20risus%20quis%20ante%20semper%20consectetur%20eget%20aliquam%20lorem.%20Vivamus%5Cn%20%20%20%20%20%20tristique%20elit%20dolor%2C%20sed%20pretium%20metus%20suscipit%20vel.%20Mauris%20ultricies%5Cn%20%20%20%20%20%20lectus%20sed%20lobortis%20finibus.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Ch2%3EThird%20column%3C%2Fh2%3E%5Cn%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20consequat%20scelerisque%20mattis.%20Duis%20pulvinar%20dapibus%20magna%2C%20eget%20congue%5Cn%20%20%20%20%20%20purus%20mollis%20sit%20amet.%20Sed%20euismod%20lacus%20sit%20amet%20ex%20tempus%2C%20a%20semper%5Cn%20%20%20%20%20%20felis%20ultrices.%20Maecenas%20a%20efficitur%20metus.%20Nullam%20tempus%20pharetra%5Cn%20%20%20%20%20%20pharetra.%20Morbi%20in%20leo%20mauris.%20Nullam%20gravida%20ligula%20eros%2C%20lacinia%5Cn%20%20%20%20%20%20sagittis%20lorem%20fermentum%20ut.%20Praesent%20dapibus%20eros%20vel%20mi%20pretium%2C%20nec%5Cn%20%20%20%20%20%20convallis%20nibh%20blandit.%20Sed%20scelerisque%20justo%20ac%20ligula%20mollis%20laoreet.%20In%5Cn%20%20%20%20%20%20mattis%2C%20risus%20et%20porta%20scelerisque%2C%20augue%20neque%20hendrerit%20orci%2C%20sit%20amet%5Cn%20%20%20%20%20%20imperdiet%20risus%20neque%20vitae%20lectus.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cfooter%3E%5Cn%20%20%20%20%3Cp%3E%C2%A92020%20Mr.Hope%20A%20very%20handsooooooooooooooooome%20man.%3C%2Fp%3E%5Cn%20%20%3C%2Ffooter%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%7B%5Cn%20%20width%3A%2090%25%3B%5Cn%20%20max-width%3A%20900px%3B%5Cn%20%20margin%3A%200%20auto%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(1)%20%7B%5Cn%20%20width%3A%2036%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(2)%20%7B%5Cn%20%20width%3A%2030%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%20%20margin-left%3A%204%25%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(3)%20%7B%5Cn%20%20width%3A%2026%25%3B%5Cn%20%20float%3A%20right%3B%5Cn%7D%5Cn%5Cnfooter%20%7B%5Cn%20%20clear%3A%20both%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>Float disaster<span><span><span>&lt;/</span>h1</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>First column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus
      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,
      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,
      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Second column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada
      ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed
      est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus
      tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies
      lectus sed lobortis finibus.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Third column<span><span><span>&lt;/</span>h2</span><span>></span></span>

    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue
      purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper
      felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra
      pharetra. Morbi in leo mauris. Nullam gravida ligula eros, lacinia
      sagittis lorem fermentum ut. Praesent dapibus eros vel mi pretium, nec
      convallis nibh blandit. Sed scelerisque justo ac ligula mollis laoreet. In
      mattis, risus et porta scelerisque, augue neque hendrerit orci, sit amet
      imperdiet risus neque vitae lectus.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>footer</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>©2020 Mr.Hope A very handsooooooooooooooooome man.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>
  <span>width</span><span>:</span> 90%<span>;</span>
  <span>max-width</span><span>:</span> 900px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(1)</span> <span>{</span>
  <span>width</span><span>:</span> 36%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(2)</span> <span>{</span>
  <span>width</span><span>:</span> 30%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>margin-left</span><span>:</span> 4%<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(3)</span> <span>{</span>
  <span>width</span><span>:</span> 26%<span>;</span>
  <span>float</span><span>:</span> right<span>;</span>
<span>}</span>

<span>footer</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>您通常只想设定一个 <code>clear: both</code> 在您想让浮动停止的元素上。在某些情况下，您会想要只取消 left 或 right 引用。</p>
<h2 id="其他浮动问题"> 其他浮动问题</h2>
<h3 id="宽度计算"> 宽度计算</h3>
<p>到目前为止，我们的例子是没有应用样式的浮动框——这很容易。当您开始给这些框加上样式时，比如添加背景、外边距、内边距等等，问题就来了。</p>
<div><pre><code><span>div,
footer</span> <span>{</span>
  <span>padding</span><span>:</span> 1%<span>;</span>
  <span>border</span><span>:</span> 2px solid black<span>;</span>
  <span>background-color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>有两个方法可以解决问题，最好的方法是给您的 HTML 加上下面的 CSS。</p>
<div><pre><code><span>*</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>box-sizing</code> 通过更改盒模型将宽度取值为 <code>content + padding + border</code>，而不仅是之前的 <code>content</code>。所以当增加内边距或边界的宽度时，不会使盒子更宽——而是会使内容调整得更窄。</p>
<p>我们有另一个问题: 页脚正压在最长列上。但是如果试着清除页脚浮动的同时给出一些顶部外边距 <code>margin-top</code></p>
<div><pre><code><span>footer</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
  <span>margin-top</span><span>:</span> 4%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>您会发现它们不起作用。</p>
<p>浮动元素有以下性质:</p>
<ul>
<li>他们在父元素中所占的面积的有效高度为 0</li>
<li>非浮动元素的外边距不能用于它们和浮动元素之间来创建空间</li>
</ul>
<p>为了解决这个问题，我们需要添加新的 <code>&lt;div&gt;</code> 元素，位于在 <code>&lt;footer&gt;</code> 标签的上方:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>clearfix<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>如果您没有一个可用的元素来清除您的浮动(比如我们的页脚)，在您想要清除的浮动之后添加一个看不见的“clearfix div”是非常有用的，但是在这里页脚也要用到。接下来我们要做的是，移除页脚样式规则中的 <code>clear: both;</code> 声明，取而代之将其放在 clearfix div 中:</p>
<div><pre><code><span>.clearfix</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个时候页脚现顶部外边距就会生效。</p>
<p>但是这会造成另一个问题: clearfix div 背景、内边距和边界与我们的列和页脚相同</p>
<p>为了解决这个问题，让我们先给每个列块一个类( class )column:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>之后改变应用盒子样式的规则到这些块和页脚，这样只有列块被样式化:</p>
<div><pre><code><span>.column,
footer</span> <span>{</span>
  <span>padding</span><span>:</span> 1%<span>;</span>
  <span>border</span><span>:</span> 2px solid black<span>;</span>
  <span>background-color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
          <div
            id="code-demo-273c458e"
           
  
 data-title="%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Ch1%3EFixed%20layout%20border-box%3C%2Fh1%3E%5Cn%5Cn%20%20%3Cdiv%20class%3D%5C%22column%5C%22%3E%5Cn%20%20%20%20%3Ch2%3EFirst%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%5Cn%20%20%20%20%20%20aliquam%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%5Cn%20%20%20%20%20%20pulvinar%20id%20metus%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%5Cn%20%20%20%20%20%20at%20ultricies%20tellus%20laoreet%20sit%20amet.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%20class%3D%5C%22column%5C%22%3E%5Cn%20%20%20%20%3Ch2%3ESecond%20column%3C%2Fh2%3E%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20vulputate%20diam%20nec%20tempor%20bibendum.%20Donec%20luctus%20augue%20eget%20malesuada%5Cn%20%20%20%20%20%20ultrices.%20Phasellus%20turpis%20est%2C%20posuere%20sit%20amet%20dapibus%20ut%2C%20facilisis%20sed%5Cn%20%20%20%20%20%20est.%20Nam%20id%20risus%20quis%20ante%20semper%20consectetur%20eget%20aliquam%20lorem.%20Vivamus%5Cn%20%20%20%20%20%20tristique%20elit%20dolor%2C%20sed%20pretium%20metus%20suscipit%20vel.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%20class%3D%5C%22column%5C%22%3E%5Cn%20%20%20%20%3Ch2%3EThird%20column%3C%2Fh2%3E%5Cn%5Cn%20%20%20%20%3Cp%3E%5Cn%20%20%20%20%20%20Nam%20consequat%20scelerisque%20mattis.%20Duis%20pulvinar%20dapibus%20magna%2C%20eget%20congue%5Cn%20%20%20%20%20%20purus%20mollis%20sit%20amet.%20Sed%20euismod%20lacus%20sit%20amet%20ex%20tempus%2C%20a%20semper%5Cn%20%20%20%20%20%20felis%20ultrices.%20Maecenas%20a%20efficitur%20metus.%20Nullam%20tempus%20pharetra%5Cn%20%20%20%20%20%20pharetra.%20Morbi%20in%20leo%20mauris.%20Nullam%20gravida%20ligula%20eros%2C%20lacinia%5Cn%20%20%20%20%20%20sagittis%20lorem%20fermentum%20ut.%20Praesent%20dapibus%20eros%20vel%20mi%20pretium%2C%20nec%5Cn%20%20%20%20%20%20convallis%20nibh%20blandit.%20Sed%20scelerisque%20justo%20ac%20ligula%20mollis%20laoreet.%5Cn%20%20%20%20%3C%2Fp%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cdiv%20class%3D%5C%22clearfix%5C%22%3E%3C%2Fdiv%3E%5Cn%5Cn%20%20%3Cfooter%3E%5Cn%20%20%20%20%3Cp%3E%C2%A92020%20Mr.Hope%20A%20very%20handsooooooooooooooooome%20man.%3C%2Fp%3E%5Cn%20%20%3C%2Ffooter%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%7B%5Cn%20%20width%3A%2090%25%3B%5Cn%20%20max-width%3A%20900px%3B%5Cn%20%20margin%3A%200%20auto%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(1)%20%7B%5Cn%20%20width%3A%2036%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(2)%20%7B%5Cn%20%20width%3A%2030%25%3B%5Cn%20%20float%3A%20left%3B%5Cn%20%20margin-left%3A%204%25%3B%5Cn%7D%5Cn%5Cn.container%20%3E%20div%3Anth-of-type(3)%20%7B%5Cn%20%20width%3A%2026%25%3B%5Cn%20%20float%3A%20right%3B%5Cn%7D%5Cn%5Cnfooter%20%7B%5Cn%20%20margin-top%3A%204%25%3B%5Cn%7D%5Cn%5Cn.clearfix%20%7B%5Cn%20%20clear%3A%20both%3B%5Cn%7D%5Cn%5Cn.column%2C%5Cnfooter%20%7B%5Cn%20%20padding%3A%201%25%3B%5Cn%20%20border%3A%202px%20solid%20rgb(255%2C%2084%2C%20104)%3B%5Cn%20%20background%3A%20rgba(255%2C%2084%2C%20104%2C%200.3)%3B%5Cn%7D%5Cn%5Cn*%20%7B%5Cn%20%20box-sizing%3A%20border-box%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>Fixed layout border-box<span><span><span>&lt;/</span>h1</span><span>></span></span>

  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>First column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus
      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,
      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,
      at ultricies tellus laoreet sit amet.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Second column<span><span><span>&lt;/</span>h2</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada
      ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed
      est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus
      tristique elit dolor, sed pretium metus suscipit vel.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>column<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h2</span><span>></span></span>Third column<span><span><span>&lt;/</span>h2</span><span>></span></span>

    <span><span><span>&lt;</span>p</span><span>></span></span>
      Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue
      purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper
      felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra
      pharetra. Morbi in leo mauris. Nullam gravida ligula eros, lacinia
      sagittis lorem fermentum ut. Praesent dapibus eros vel mi pretium, nec
      convallis nibh blandit. Sed scelerisque justo ac ligula mollis laoreet.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>clearfix<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

  <span><span><span>&lt;</span>footer</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>©2020 Mr.Hope A very handsooooooooooooooooome man.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>
  <span>width</span><span>:</span> 90%<span>;</span>
  <span>max-width</span><span>:</span> 900px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(1)</span> <span>{</span>
  <span>width</span><span>:</span> 36%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(2)</span> <span>{</span>
  <span>width</span><span>:</span> 30%<span>;</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>margin-left</span><span>:</span> 4%<span>;</span>
<span>}</span>

<span>.container > div:nth-of-type(3)</span> <span>{</span>
  <span>width</span><span>:</span> 26%<span>;</span>
  <span>float</span><span>:</span> right<span>;</span>
<span>}</span>

<span>footer</span> <span>{</span>
  <span>margin-top</span><span>:</span> 4%<span>;</span>
<span>}</span>

<span>.clearfix</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>

<span>.column,
footer</span> <span>{</span>
  <span>padding</span><span>:</span> 1%<span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>)</span><span>;</span>
  <span>background</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>,</span> 0.3<span>)</span><span>;</span>
<span>}</span>

<span>*</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">网格布局</title>
    <id>https://list-jiang.github.io/code/website/css/layout/grid/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/grid/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述"> 概述</h2>
<p>网格布局 (Grid) 是最强大的 CSS 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p>
<p><img src="./assets/grid-example.png" alt="布局案例" loading="lazy"></p>
<p>上图这样的布局，就是 Grid 布局的拿手好戏。</p>
<div><p>与 flex 的区别</p>
<p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p>
</div>
<details><summary>本章通用样式</summary>
<div><pre><code><span>.grid-demo > div</span> <span>{</span>
  <span>color</span><span>:</span> black<span>;</span>
  <span>font-size</span><span>:</span> 40px<span>;</span>
<span>}</span>

<span>.grid-demo > .item1</span> <span>{</span>
  <span>background-color</span><span>:</span> #ff69b4<span>;</span>
<span>}</span>

<span>.grid-demo > .item2</span> <span>{</span>
  <span>background-color</span><span>:</span> #ffa500<span>;</span>
<span>}</span>

<span>.grid-demo > .item3</span> <span>{</span>
  <span>background-color</span><span>:</span> #3cb371<span>;</span>
<span>}</span>

<span>.grid-demo > .item4</span> <span>{</span>
  <span>background-color</span><span>:</span> #87cefa<span>;</span>
<span>}</span>

<span>.grid-demo > .item5</span> <span>{</span>
  <span>background-color</span><span>:</span> #9370db<span>;</span>
<span>}</span>

<span>.grid-demo > .item6</span> <span>{</span>
  <span>background-color</span><span>:</span> #f0e68c<span>;</span>
<span>}</span>

<span>.grid-demo > .item7</span> <span>{</span>
  <span>background-color</span><span>:</span> #fa8072<span>;</span>
<span>}</span>

<span>.grid-demo > .item7</span> <span>{</span>
  <span>background-color</span><span>:</span> #008b8b<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></details>


<h2 id="基本概念"> 基本概念</h2>
<h3 id="容器和项目"> 容器和项目</h3>
<p>采用网格布局的区域，称为&quot;容器&quot; (container) 。容器内部采用网格定位的子元素，称为&quot;项目&quot; (item) 。</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>1<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>2<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>3<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，最外层的 <code>&lt;div&gt;</code> 元素就是容器，内层的三个 <code>&lt;div&gt;</code> 元素就是项目。</p>
<div><p>注意</p>
<p>项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 <code>&lt;p&gt;</code> 元素就不是项目。Grid 布局只对项目生效。</p>
</div>
<h3 id="行和列"> 行和列</h3>
<p><img src="./assets/rowAndColumn.png" alt="行和列" loading="lazy"></p>
<p>容器里面的水平区域称为&quot;行&quot; (row) ，垂直区域称为&quot;列&quot; (column) 。</p>
<p>上图中，水平的深色区域就是&quot;行&quot;，垂直的深色区域就是&quot;列&quot;。</p>
<h3 id="单元格"> 单元格</h3>
<p>行和列的交叉区域，称为&quot;单元格&quot; (cell) 。</p>
<p>正常情况下，n 行和 m 列会产生 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.4306em;"></span><span>m</span></span></span></span> 个单元格。比如，3 行 3 列会产生 9 个单元格。</p>
<h3 id="网格线"> 网格线</h3>
<p>划分网格的线，称为&quot;网格线&quot; (grid line) 。水平网格线划分出行，垂直网格线划分出列。</p>
<p><img src="./assets/grid-line.png" alt="网格线" loading="lazy"></p>
<p>正常情况下，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>n</span></span></span></span> 行有 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>n</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 根水平网格线，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span>m</span></span></span></span> 列有 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6667em;vertical-align:-0.0833em;"></span><span>m</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span> 根垂直网格线，比如三行就有四根水平网格线。</p>
<p>上图是一个 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7278em;vertical-align:-0.0833em;"></span><span>4</span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>4</span></span></span></span> 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p>
<h3 id="沟槽"> 沟槽</h3>
<p>行与行、列与列之间的间隙，这个间隙一般被称为沟槽(gutter)。</p>
<h2 id="容器属性"> 容器属性</h2>
<p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p>
<h3 id="display-属性"> display 属性</h3>
<p><code>display: grid</code> 指定一个容器采用网格布局。</p>

          <div
            id="code-demo-331b5291"
           
  
 data-title="%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cspan%20style%3D%5C%22font-size%3A%2022px%5C%22%3EMr.Hope%3C%2Fspan%3E%5Cn%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cspan%20style%3D%5C%22font-size%3A%2022px%5C%22%3Eis%20handsome%3C%2Fspan%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>span</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 22px</span><span>"</span></span></span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>span</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 22px</span><span>"</span></span></span><span>></span></span>is handsome<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p>

          <div
            id="code-demo-b901dcae"
           
  
 data-title="%E8%A1%8C%E5%86%85%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cspan%20style%3D%5C%22font-size%3A%2022px%5C%22%3EMr.Hope%3C%2Fspan%3E%5Cn%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%3Cspan%20style%3D%5C%22font-size%3A%2022px%5C%22%3Eis%20handsome%3C%2Fspan%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20inline-grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>span</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 22px</span><span>"</span></span></span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>span</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 22px</span><span>"</span></span></span><span>></span></span>is handsome<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> inline-grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>提示</p>
<p>设为网格布局以后，容器子元素 (项目) 的 <code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code> 和 <code>column-*</code> 等设置都将失效。</p>
</div>
<h3 id="grid-template-columns-和-grid-template-rows-属性"> grid-template-columns 和 grid-template-rows 属性</h3>
<p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code> 属性定义每一列的列宽，<code>grid-template-rows</code> 属性定义每一行的行高。</p>

          <div
            id="code-demo-11984f0a"
           
  
 data-title="%E5%88%92%E5%88%86%E8%A1%8C%E5%92%8C%E5%88%97"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>上面代码指定了一个三行三列的网格，列宽和行高都是 100px。</p>
<p>除了使用绝对单位，也可以使用百分比。</p>

          <div
            id="code-demo-e86ff1fa"
           
  
 data-title=""

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20height%3A%20300px%3B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%2033.33%25%2033.33%25%2033.33%25%3B%5Cn%20%20grid-template-rows%3A%2033.33%25%2033.33%25%2033.33%25%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>height</span><span>:</span> 300px<span>;</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 33.33% 33.33% 33.33%<span>;</span>
  <span>grid-template-rows</span><span>:</span> 33.33% 33.33% 33.33%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="repeat"> repeat()</h4>
<p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用 <code>repeat()</code> 函数，简化重复的值。</p>

          <div
            id="code-demo-14679fae"
           
  
 data-title="repeat()"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20height%3A%20300px%3B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20repeat(3%2C%2033.33%25)%3B%5Cn%20%20grid-template-rows%3A%20repeat(3%2C%2033.33%25)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>上面的代码用 <code>repeat()</code> 改写如下。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>height</span><span>:</span> 300px<span>;</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 33.33%<span>)</span><span>;</span>
  <span>grid-template-rows</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 33.33%<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>repeat()</code> 接受两个参数，第一个参数是重复的次数 (上例是 <code>3</code>) ，第二个参数是所要重复的值。</p>
<p><code>repeat()</code> 重复某种模式也是可以的。</p>

          <div
            id="code-demo-eb3ff14a"
           
  
 data-title="%E9%87%8D%E5%A4%8D%E6%A8%A1%E5%BC%8F"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20height%3A%20300px%3B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20repeat(2%2C%20100px%2020px%2080px)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>height</span><span>:</span> 300px<span>;</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>2<span>,</span> 100px 20px 80px<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>上面代码定义了 6 列，第一列和第四列的宽度为 <code>100px</code>，第二列和第五列为 <code>20px</code>，第三列和第六列为 <code>80px</code>。</p>
<h4 id="auto-fill-关键字"> auto-fill 关键字</h4>
<p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行 (或每一列) 容纳尽可能多的单元格，这时可以使用 <code>auto-fill</code> 关键字表示自动填充。</p>

          <div
            id="code-demo-5df2b88d"
           
  
 data-title="%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20repeat(auto-fill%2C%20100px)%3B%5Cn%7D%5Cn%5Cn.grid-demo%20%3E%20div%20%7B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fill<span>,</span> 100px<span>)</span><span>;</span>
<span>}</span>

<span>.grid-demo > div</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>上面代码表示每列宽度 <code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p>
<h4 id="fr-关键字"> fr 关键字</h4>
<p>为了方便表示比例关系，网格布局提供了 <code>fr</code> 关键字 (fraction 的缩写，意为&quot;片段&quot;) 。如果两列的宽度分别为 <code>1fr</code> 和 <code>2fr</code>，就表示后者是前者的两倍。</p>

          <div
            id="code-demo-f5c65856"
           
  
 data-title="fr"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%201fr%201fr%3B%5Cn%7D%5Cn%5Cn.grid-demo%20%3E%20div%20%7B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>下面代码表示两个相同宽度的列。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 1fr<span>;</span>
<span>}</span>

<span>.grid-demo > div</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>fr</code> 可以与绝对长度的单位结合使用，这时会非常方便。</p>

          <div
            id="code-demo-ef41a39e"
           
  
 data-title="fr%20%E7%9A%84%E6%B7%B7%E7%94%A8"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20150px%201fr%202fr%3B%5Cn%7D%5Cn%5Cn.grid-demo%20%3E%20div%20%7B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>下面代码表示，第一列的宽度为 150 像素，第二列的宽度是第三列的一半。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 150px 1fr 2fr<span>;</span>
<span>}</span>

<span>.grid-demo > div</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="minmax"> minmax()</h4>
<p><code>minmax()</code> 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>

          <div
            id="code-demo-030dd5bd"
           
  
 data-title="minmax()"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%201fr%201fr%20minmax(100px%2C%201fr)%3B%5Cn%7D%5Cn%5Cn.grid-demo%20%3E%20div%20%7B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>下面代码中，<code>minmax(100px, 1fr)</code> 表示列宽不小于 <code>100px</code>，不大于 <code>1fr</code>。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 1fr <span>minmax</span><span>(</span>100px<span>,</span> 1fr<span>)</span><span>;</span>
<span>}</span>

<span>.grid-demo > div</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="auto-关键字"> auto 关键字</h4>
<p><code>auto</code> 关键字表示由浏览器自己决定长度。</p>

          <div
            id="code-demo-3af28d62"
           
  
 data-title="auto"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20auto%20100px%3B%5Cn%7D%5Cn%5Cn.grid-demo%20%3E%20div%20%7B%5Cn%20%20height%3A%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>下面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 <code>min-width</code>，且这个值大于最大宽度。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px auto 100px<span>;</span>
<span>}</span>

<span>.grid-demo > div</span> <span>{</span>
  <span>height</span><span>:</span> 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>
            </div>
          </div>
          
        </div>
<h4 id="网格线的名称"> 网格线的名称</h4>
<p><code>grid-template-columns</code> 属性和 <code>grid-template-rows</code> 属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>

          <div
            id="code-demo-5ac5ee55"
           
  
 data-title="%E7%BD%91%E6%A0%BC%E7%BA%BF%E7%9A%84%E5%90%8D%E7%A7%B0"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20%5Bc1%5D%20100px%20%5Bc2%5D%20100px%20%5Bc3%5D%20auto%20%5Bc4%5D%3B%5Cn%20%20grid-template-rows%3A%20%5Br1%5D%20100px%20%5Br2%5D%20100px%20%5Br3%5D%20auto%20%5Br4%5D%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>下面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> [c1] 100px [c2] 100px [c3] auto [c4]<span>;</span>
  <span>grid-template-rows</span><span>:</span> [r1] 100px [r2] 100px [r3] auto [r4]<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>网格布局允许同一根线有多个名字，比如 <code>[fifth-line row-5]</code>。</p>
<h4 id="布局实例"> 布局实例</h4>
<p><code>grid-template-columns</code> 属性对于网页布局非常有用。两栏式布局只需要一行代码。</p>
<div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 70% 30%<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码将左边栏设为 <code>70%</code>，右边栏设为 <code>30%</code>。</p>
<p>传统的十二网格布局，写起来也很容易。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>12<span>,</span> 1fr<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="row-gap-属性、column-gap-属性-和-gap-属性"> row-gap 属性、column-gap 属性 和 gap 属性</h3>
<p><code>row-gap</code> 属性设置行与行的间隔 (行间距) ，<code>column-gap</code> 属性设置列与列的间隔 (列间距) 。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>row-gap</span><span>:</span> 20px<span>;</span>
  <span>column-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
          <div
            id="code-demo-6831b26e"
           
  
 data-title="%E9%97%B4%E8%B7%9D%E8%AE%BE%E7%BD%AE"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%20%20row-gap%3A%2020px%3B%5Cn%20%20column-gap%3A%2020px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>row-gap</span><span>:</span> 20px<span>;</span>
  <span>column-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>上面代码中，<code>row-gap</code> 用于设置行间距，<code>column-gap</code> 用于设置列间距。</p>
<p><code>gap</code> 属性是 <code>column-gap</code> 和 <code>row-gap</code> 的合并简写形式，语法如下。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>gap</span><span>:</span> &lt;row-gap> &lt;column-gap><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>因此，上面一段 CSS 代码等同于下面的代码。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>gap</span><span>:</span> 20px 20px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果 <code>gap</code> 省略了第二个值，浏览器认为第二个值等于第一个值。</p>
<h3 id="grid-template-areas-属性"> grid-template-areas 属性</h3>
<p>网格布局允许指定&quot;区域&quot; (area) ，一个区域由单个或多个单元格组成。<code>grid-template-areas</code> 属性用于定义区域。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-areas</span><span>:</span>
    <span>"a b c"</span>
    <span>"d e f"</span>
    <span>"g h i"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码先划分出 9 个单元格，然后将其定名为 <code>a</code> 到 <code>i</code> 的九个区域，分别对应这九个单元格。</p>
<p>多个单元格合并成一个区域的写法如下。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-template-areas</span><span>:</span>
    <span>"a a a"</span>
    <span>"b b b"</span>
    <span>"c c c"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码将 9 个单元格分成 <code>a</code>、<code>b</code>、<code>c</code> 三个区域。</p>
<p>下面是一个布局实例。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-template-areas</span><span>:</span>
    <span>"header header header"</span>
    <span>"main main sidebar"</span>
    <span>"footer footer footer"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，顶部是页眉区域 <code>header</code>，底部是页脚区域 <code>footer</code>，中间部分则为 <code>main</code> 和 <code>sidebar</code>。</p>
<p>如果某些区域不需要利用，则使用&quot;点&quot; (<code>.</code>) 表示。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-template-areas</span><span>:</span>
    <span>"a . c"</span>
    <span>"d . f"</span>
    <span>"g . i"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p>
<div><p>提示</p>
<p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 <code>区域名-start</code>，终止网格线自动命名为 <code>区域名-end</code>。</p>
<p>比如，区域名为 <code>header</code>，则起始位置的水平网格线和垂直网格线叫做 <code>header-start</code>，终止位置的水平网格线和垂直网格线叫做 <code>header-end</code>。</p>
</div>
<h3 id="grid-auto-flow-属性"> grid-auto-flow 属性</h3>
<p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是&quot;先行后列&quot;，即先填满第一行，再开始放入第二行，即下方数字的顺序。</p>

          <div
            id="code-demo-11984f0a"
           
  
 data-title="%E9%BB%98%E8%AE%A4%E9%A1%BA%E5%BA%8F%E2%80%9C%E5%85%88%E8%A1%8C%E5%90%8E%E5%88%97%E2%80%9D"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>这个顺序由 <code>grid-auto-flow</code> 属性决定，默认值是 <code>row</code>，即&quot;先行后列&quot;。也可以将它设成 <code>column</code>，变成&quot;先列后行&quot;。</p>

          <div
            id="code-demo-3f8e2035"
           
  
 data-title="grid-auto-flow%3A%20column"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-auto-flow%3A%20column%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>设置了 <code>column</code> 以后，放置顺序就变成了下图。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-auto-flow</span><span>:</span> column<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>grid-auto-flow</code> 属性除了设置成 <code>row</code> 和 <code>column</code>，还可以设成 <code>row dense</code> 和 <code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p>
<p>下面的例子让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 <code>grid-auto-flow: row</code> 情况下，会产生下面这样的布局。</p>
<p><img src="./assets/grid-auto-flow-1.png" alt="grid-auto-flow 1" loading="lazy"></p>

          <div
            id="code-demo-49c01bf6"
           
  
 data-title="grid-auto-flow%3A%20column"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22grid-demo%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item1%5C%22%3E1%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item2%5C%22%3E2%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item3%5C%22%3E3%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item4%5C%22%3E4%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item5%5C%22%3E5%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item6%5C%22%3E6%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item7%5C%22%3E7%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item8%5C%22%3E8%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22item9%5C%22%3E9%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.grid-demo%20%7B%5Cn%20%20width%3A%20300px%3B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%20repeat(auto-fill)%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%20100px%3B%5Cn%20%20grid-auto-flow%3A%20column%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>设置了 <code>column</code> 以后，放置顺序就变成了下图。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>grid-demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>item9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>.grid-demo</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fill<span>)</span><span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-auto-flow</span><span>:</span> column<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p>
<p>现在修改设置，设为 <code>row dense</code>，表示&quot;先行后列&quot;，并且尽可能紧密填满，尽量不出现空格。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-auto-flow</span><span>:</span> row dense<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码的效果如下。</p>
<p><img src="./assets/grid-auto-flow2.png" alt="grid-auto-flow 2" loading="lazy"></p>
<p>上图会先填满第一行，再填满第二行，所以 3 号项目就会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p>
<p>如果将设置改为 <code>column dense</code>，表示&quot;先列后行&quot;，并且尽量填满空格。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>grid-auto-flow</span><span>:</span> column dense<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码的效果如下。</p>
<p><img src="./assets/grid-auto-flow3.png" alt="grid-auto-flow 3" loading="lazy"></p>
<p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p>
<h3 id="justify-items-属性-align-items-属性-和-place-items-属性"> justify-items 属性，align-items 属性 和 place-items 属性</h3>
<p><code>justify-items</code> 属性设置单元格内容的水平位置 (左中右) ，<code>align-items</code> 属性设置单元格内容的垂直位置 (上中下) 。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>justify-items</span><span>:</span> start | end | center | stretch<span>;</span>
  <span>align-items</span><span>:</span> start | end | center | stretch<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这两个属性的写法完全相同，都可以取下面这些值。</p>
<ul>
<li>start: 对齐单元格的起始边缘。</li>
<li>end: 对齐单元格的结束边缘。</li>
<li>center: 单元格内部居中。</li>
<li>stretch: 拉伸，占满单元格的整个宽度 (默认值) 。</li>
</ul>
<div><pre><code><span>.container</span> <span>{</span>
  <span>justify-items</span><span>:</span> start<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码表示，单元格的内容左对齐，效果如下图。</p>
<p><img src="./assets/grid-justify-start.png" alt="justify-items: start" loading="lazy"></p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>align-items</span><span>:</span> start<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码表示，单元格的内容头部对齐，效果如下图。</p>
<p><img src="./assets/grid-align-start.png" alt="align-items: start" loading="lazy"></p>
<p><code>place-items</code> 属性是 <code>align-items</code> 属性和 <code>justify-items</code> 属性的合并简写形式。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>place-items</span><span>:</span> &lt;align-items> &lt;justify-items><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>place-items</span><span>:</span> start end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果省略第二个值，则浏览器认为与第一个值相等。</p>
<h3 id="justify-content-属性-align-content-属性-和-place-content-属性"> justify-content 属性，align-content 属性 和 place-content 属性</h3>
<p><code>justify-content</code> 属性是整个内容区域在容器里面的水平位置 (左中右) ，<code>align-content</code> 属性是整个内容区域的垂直位置 (上中下) 。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>justify-content</span><span>:</span> start | end | center | stretch | space-around | space-between
    | space-evenly<span>;</span>
  <span>align-content</span><span>:</span> start | end | center | stretch | space-around | space-between |
    space-evenly<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两个属性的写法完全相同，都可以取下面这些值。(下面的图都以 <code>justify-content</code> 属性为例，<code>align-content</code> 属性的图完全一样，只是将水平方向改成垂直方向。)</p>
<ul>
<li>
<p>start - 对齐容器的起始边框。</p>
<p><img src="./assets/grid-content-start.png" alt="start" loading="lazy"></p>
</li>
<li>
<p>end - 对齐容器的结束边框。</p>
<p><img src="./assets/grid-content-end.png" alt="end" loading="lazy"></p>
</li>
<li>
<p>center - 容器内部居中。</p>
<p><img src="./assets/grid-content-center.png" alt="center" loading="lazy"></p>
</li>
<li>
<p>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</p>
<p><img src="./assets/grid-content-stretch.png" alt="stretch" loading="lazy"></p>
</li>
<li>
<p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p>
<p><img src="./assets/grid-content-space-around.png" alt="space-around" loading="lazy"></p>
</li>
<li>
<p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p>
<p><img src="./assets/grid-content-space-between.png" alt="space-between" loading="lazy"></p>
</li>
<li>
<p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p>
<p><img src="./assets/grid-content-space-evenly.png" alt="space-evenly" loading="lazy"></p>
</li>
</ul>
<p><code>place-content</code> 属性是 <code>align-content</code> 属性和 <code>justify-content</code> 属性的合并简写形式。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>place-content</span><span>:</span> &lt;align-content> &lt;justify-content><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>place-content</span><span>:</span> space-around space-evenly<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
<h3 id="grid-auto-columns-属性-和-grid-auto-rows-属性"> grid-auto-columns 属性 和 grid-auto-rows 属性</h3>
<p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。</p>
<p><code>grid-auto-columns</code> 属性和 <code>grid-auto-rows</code> 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p>下面的例子里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px 100px<span>;</span>
  <span>grid-auto-rows</span><span>:</span> 50px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码指定新增的行高统一为 50px (原始的行高为 100px) 。</p>
<p><img src="./assets/grid-auto-rows.png" alt="grid-auto-rows" loading="lazy"></p>
<h3 id="grid-template-属性-和-grid-属性"> grid-template 属性 和 grid 属性</h3>
<p><code>grid-template</code> 属性是 <code>grid-template-columns</code>、<code>grid-template-rows</code> 和 <code>grid-template-areas</code> 这三个属性的合并简写形式。</p>
<p><code>grid</code> 属性是 <code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、<code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code> 这六个属性的合并简写形式。</p>
<div><p>提示</p>
<p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p>
</div>
<h2 id="项目属性"> 项目属性</h2>
<p>下面这些属性定义在项目上面。</p>
<h3 id="位置指定"> 位置指定</h3>
<p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<ul>
<li><code>grid-column-start</code> 属性: 左边框所在的垂直网格线</li>
<li><code>grid-column-end</code> 属性: 右边框所在的垂直网格线</li>
<li><code>grid-row-start</code> 属性: 上边框所在的水平网格线</li>
<li><code>grid-row-end</code> 属性: 下边框所在的水平网格线</li>
</ul>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column-start</span><span>:</span> 2<span>;</span>
  <span>grid-column-end</span><span>:</span> 4<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p>
<p><img src="./assets/grid5.png" alt="grid 5" loading="lazy"></p>
<p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p>
<p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的 <code>grid-auto-flow</code> 属性决定，这个属性的默认值是 <code>row</code>，因此会&quot;先行后列&quot;进行排列。您可以把这个属性的值分别改成 <code>column</code>、<code>row dense</code> 和 <code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p>
<p>下面的例子是指定四个边框位置的效果。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column-start</span><span>:</span> 1<span>;</span>
  <span>grid-column-end</span><span>:</span> 3<span>;</span>
  <span>grid-row-start</span><span>:</span> 2<span>;</span>
  <span>grid-row-end</span><span>:</span> 4<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./assets/grid6.png" alt="grid 6" loading="lazy"></p>
<p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column-start</span><span>:</span> header-start<span>;</span>
  <span>grid-column-end</span><span>:</span> header-end<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p>
<p>这四个属性的值还可以使用 <code>span</code> 关键字，表示&quot;跨越&quot;，即左右边框 (上下边框) 之间跨越多少个网格。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column-start</span><span>:</span> span 2<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码表示，1 号项目的左边框距离右边框跨越 2 个网格。</p>
<p><img src="./assets/grid7.png" alt="grid 7" loading="lazy"></p>
<p>这与下面的代码效果完全一样。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column-end</span><span>:</span> span 2<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用这四个属性，如果产生了项目的重叠，则使用 <code>z-index</code> 属性指定项目的重叠顺序。</p>
<h3 id="grid-column-属性-和-grid-row-属性"> grid-column 属性 和 grid-row 属性</h3>
<ul>
<li><code>grid-column</code> 属性是 <code>grid-column-start</code> 和 <code>grid-column-end</code> 的合并简写形式</li>
<li><code>grid-row</code> 属性是 <code>grid-row-start</code> 属性和 <code>grid-row-end</code> 的合并简写形式。</li>
</ul>
<div><pre><code><span>.item</span> <span>{</span>
  <span>grid-column</span><span>:</span> &lt;start-line> / &lt;end-line><span>;</span>
  <span>grid-row</span><span>:</span> &lt;start-line> / &lt;end-line><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column</span><span>:</span> 1 / 3<span>;</span>
  <span>grid-row</span><span>:</span> 1 / 2<span>;</span>
<span>}</span>
<span>/* 等同于 */</span>
<span>.item-1</span> <span>{</span>
  <span>grid-column-start</span><span>:</span> 1<span>;</span>
  <span>grid-column-end</span><span>:</span> 3<span>;</span>
  <span>grid-row-start</span><span>:</span> 1<span>;</span>
  <span>grid-row-end</span><span>:</span> 2<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，项目 <code>item-1</code> 占据第一行，从第一根列线到第三根列线。</p>
<p>这两个属性之中，也可以使用 <code>span</code> 关键字，表示跨越多少个网格。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>background</span><span>:</span> #b03532<span>;</span>
  <span>grid-column</span><span>:</span> 1 / 3<span>;</span>
  <span>grid-row</span><span>:</span> 1 / 3<span>;</span>
<span>}</span>
<span>/* 等同于 */</span>
<span>.item-1</span> <span>{</span>
  <span>background</span><span>:</span> #b03532<span>;</span>
  <span>grid-column</span><span>:</span> 1 / span 2<span>;</span>
  <span>grid-row</span><span>:</span> 1 / span 2<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，项目 <code>item-1</code> 占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p>
<p><img src="./assets/grid8.png" alt="grid 8" loading="lazy"></p>
<p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-column</span><span>:</span> 1<span>;</span>
  <span>grid-row</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，项目 <code>item-1</code> 占据左上角第一个网格。</p>
<h3 id="grid-area-属性"> grid-area 属性</h3>
<p><code>grid-area</code> 属性指定项目放在哪一个区域。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-area</span><span>:</span> e<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，1 号项目位于 <code>e</code> 区域，效果如下图。</p>
<p><img src="./assets/grid-area.png" alt="grid-area" loading="lazy"></p>
<p><code>grid-area</code> 属性还可用作 <code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code> 的合并简写形式，直接指定项目的位置。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>grid-area</span><span>:</span> &lt;row-start> / &lt;column-start> / &lt;row-end> / &lt;column-end><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>grid-area</span><span>:</span> 1 / 1 / 3 / 3<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="justify-self-属性-align-self-属性-和-place-self-属性"> justify-self 属性，align-self 属性 和 place-self 属性</h3>
<p><code>justify-self</code> 属性设置单元格内容的水平位置 (左中右) ，跟 <code>justify-items</code> 属性的用法完全一致，但只作用于单个项目。</p>
<p><code>align-self</code> 属性设置单元格内容的垂直位置 (上中下) ，跟 <code>align-items</code> 属性的用法完全一致，也是只作用于单个项目。</p>
<div><pre><code><span>.item</span> <span>{</span>
  <span>justify-self</span><span>:</span> start | end | center | stretch<span>;</span>
  <span>align-self</span><span>:</span> start | end | center | stretch<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这两个属性都可以取下面四个值。</p>
<ul>
<li>start: 对齐单元格的起始边缘。</li>
<li>end: 对齐单元格的结束边缘。</li>
<li>center: 单元格内部居中。</li>
<li>stretch: 拉伸，占满单元格的整个宽度 (默认值) 。</li>
</ul>
<p>下面是 <code>justify-self: start</code> 的例子。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>justify-self</span><span>:</span> start<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/grid-justify-self.png" alt="justify-self: start" loading="lazy"></p>
<p><code>place-self</code> 属性是 <code>align-self</code> 属性和 <code>justify-self</code> 属性的合并简写形式。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>place-self</span><span>:</span> &lt;align-self> &lt;justify-self><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>.item-1</span> <span>{</span>
  <span>place-self</span><span>:</span> center center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果省略第二个值，<code>place-self</code> 属性会认为这两个值相等。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2020-10-20T00:00:00.000Z</published>
    <rights>自由转载-非商用-非衍生-保持署名 (创意共享3.0许可证)</rights>
  </entry>
  <entry>
    <title type="html">正常布局流</title>
    <id>https://list-jiang.github.io/code/website/css/layout/flow/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/flow/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="元素特性"> 元素特性</h3>
<ul>
<li>
<p>一个块级元素的内容宽度是其父元素的 100%，其高度与其内容高度一致。</p>
</li>
<li>
<p>内联元素的 <code>width</code> <code>height</code> 与内容一致。您无法设置内联元素的 <code>width</code> <code>height</code>。</p>
</li>
<li>
<p>如果您想控制内联元素的尺寸，您需要为元素设置 <code>display: block;</code> 或 <code>display: inline-block</code>。<code>inline-block</code> 混合了 <code>inline</code> 和 <code>block</code> 的特性。</p>
</li>
</ul>
<h3 id="摆放特性"> 摆放特性</h3>
<p>正常布局流(在布局介绍里提到过)是一套在浏览器视口内放置、组织元素的系统。默认的，块级元素按照基于其父元素的书写顺序(默认值: <code>horizontal-tb</code>)的块流动方向(block flow direction)放置。</p>
<p>每个块级元素会在上一个元素下面另起一行，它们会被设置好的 <code>margin</code> 分隔。在英语，或者其他水平书写、自上而下模式里，块级元素是垂直组织的。</p>
<p>内联元素的表现有所不同: 它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，它们与其他内联元素、相邻的文本内容(或者被包裹的)被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</p>
<p>如果两个相邻的元素都设置了 <code>margin</code> 并且两个 <code>margin</code> 有重叠，那么更大的设置会被保留，小的则会消失。这被称为外边距叠加。</p>

          <div
            id="code-demo-b618258e"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"

            data-code="%7B%22html%22%3A%22%3Ch1%3EBasic%20document%20flow%3C%2Fh1%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20I%20am%20a%20basic%20block%20level%20element.%20My%20adjacent%20block%20level%20elements%20sit%20on%20new%5Cn%20%20lines%20below%20me.%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20By%20default%20we%20span%20100%25%20of%20the%20width%20of%20our%20parent%20element%2C%20and%20we%20are%20as%20tall%5Cn%20%20as%20our%20child%20content.%20Our%20total%20width%20and%20height%20is%20our%20content%20%2B%20padding%20%2B%5Cn%20%20border%20width%2Fheight.%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20We%20are%20separated%20by%20our%20margins.%20Because%20of%20margin%20collapsing%2C%20we%20are%5Cn%20%20separated%20by%20the%20width%20of%20one%20of%20our%20margins%2C%20not%20both.%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20inline%20elements%20%3Cspan%3Elike%20this%20one%3C%2Fspan%3E%20and%20%3Cspan%3Ethis%20one%3C%2Fspan%3E%20sit%20on%5Cn%20%20the%20same%20line%20as%20one%20another%2C%20and%20adjacent%20text%20nodes%2C%20if%20there%20is%20space%20on%5Cn%20%20the%20same%20line.%20Overflowing%20inline%20elements%20will%5Cn%20%20%3Cspan%3Ewrap%20onto%20a%20new%20line%20if%20possible%20(like%20this%20one%20containing%20text)%3C%2Fspan%3E%2C%5Cn%20%20or%20just%20go%20on%20to%20a%20new%20line%20if%20not%2C%20much%20like%20this%20image%20will%20do%3A%5Cn%20%20%3Cimg%20src%3D%5C%22https%3A%2F%2Fmdn.mozillademos.org%2Ffiles%2F13360%2Flong.jpg%5C%22%20%2F%3E%5Cn%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20background%3A%20rgba(255%2C%2084%2C%20104%2C%200.3)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(255%2C%2084%2C%20104)%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20margin%3A%2010px%3B%5Cn%7D%5Cn%5Cnspan%20%7B%5Cn%20%20background%3A%20white%3B%5Cn%20%20border%3A%201px%20solid%20black%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Basic document flow<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  I am a basic block level element. My adjacent block level elements sit on new
  lines below me.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  By default we span 100% of the width of our parent element, and we are as tall
  as our child content. Our total width and height is our content + padding +
  border width/height.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  We are separated by our margins. Because of margin collapsing, we are
  separated by the width of one of our margins, not both.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  inline elements <span><span><span>&lt;</span>span</span><span>></span></span>like this one<span><span><span>&lt;/</span>span</span><span>></span></span> and <span><span><span>&lt;</span>span</span><span>></span></span>this one<span><span><span>&lt;/</span>span</span><span>></span></span> sit on
  the same line as one another, and adjacent text nodes, if there is space on
  the same line. Overflowing inline elements will
  <span><span><span>&lt;</span>span</span><span>></span></span>wrap onto a new line if possible (like this one containing text)<span><span><span>&lt;/</span>span</span><span>></span></span>,
  or just go on to a new line if not, much like this image will do:
  <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>https://mdn.mozillademos.org/files/13360/long.jpg<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>background</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>,</span> 0.3<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>)</span><span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>margin</span><span>:</span> 10px<span>;</span>
<span>}</span>

<span>span</span> <span>{</span>
  <span>background</span><span>:</span> white<span>;</span>
  <span>border</span><span>:</span> 1px solid black<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">排版介绍</title>
    <id>https://list-jiang.github.io/code/website/css/layout/intro/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="正常布局流"> 正常布局流</h2>
<p>正常布局流(normal flow)是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。HTML 元素完全按照源码中出现的先后次序显示。</p>

          <div
            id="code-demo-0cd9046e"
           
  
 data-title="%E6%AD%A3%E5%B8%B8%E5%B8%83%E5%B1%80%E6%B5%81"

            data-code="%7B%22html%22%3A%22%3Cp%3EMr.Hope%20%E5%BE%88%E5%B8%85%3C%2Fp%3E%5Cn%3Cul%3E%5Cn%20%20%3Cli%3EHTML%3C%2Fli%3E%5Cn%20%20%3Cli%3ECSS%3C%2Fli%3E%5Cn%20%20%3Cli%3EJS%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Mr.Hope 很帅<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>HTML<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>CSS<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>JS<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>出现在另一个元素下面的元素被描述为块元素，与出现在另一个元素旁边的内联元素不同，内联元素就像段落中的单个单词一样。</p>
<div><p>相关信息</p>
<p>关于内联元素和块元素，请见 <a href="./../intro/box.html">CSS 介绍 → 盒模型</a></p>
</div>
<div><p>注意</p>
<p>块元素内容的布局方向被描述为块方向。块方向在英语等具有水平书写模式(writing mode)的语言中垂直运行。它可以在任何垂直书写模式的语言中水平运行。对应的内联方向是内联内容(如句子)的运行方向。</p>
<p>关于文字方向请看 <a href="./../intro/text-direction.html">CSS 介绍 → 文字方向</a></p>
</div>
<p>当您使用 CSS 创建一个布局时，您正在离开<strong>正常布局流</strong>，但是对于页面上的多数元素，<strong>正常布局流</strong>将完全可以创建您所需要的布局。</p>
<p>下列布局技术会覆盖默认的布局行为:</p>
<ul>
<li><code>display</code> 属性: 标准值为 <code>block</code>, <code>inline</code> 或者 <code>inline-block</code> ，这是素在正常布局流中的表现形式. 过设置 <code>display</code> 的值, 可以使元素使用 <a href="./flex.html">弹性布局</a> 或 <a href="./grid.html">网格布局</a>。</li>
<li><code>float</code> 属性: 诸如 <code>left</code> 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li>
<li><code>position</code> 属性: 允许您精准设置盒子中的盒子的位置，正常布局流中，默认为 <code>static</code> ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li>
<li>表格布局: 表格的布局方式可以用在非表格内容上，可以使用 <code>display: table</code> 和相关属性在非表元素上使用。</li>
<li>多列布局: 可以让块按列布局，比如报纸的内容就是一列一列排布的。</li>
</ul>
<h2 id="display-属性"> display 属性</h2>
<p>在 CSS 中实现页面布局的主要方法是设定 <code>display</code> 属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容都有一个 <code>display</code> 的值，用作元素的默认行为方式。</p>
<div><p>案例</p>
<p>段落显示在一个段落的下面，这是因为它们的样式是 <code>display:block</code>。</p>
<p>在段落中的某个文本周围创建链接，则该链接将与文本的其余部分保持内联，并且不会打断到新行。这是因为 <code>&lt;a&gt;</code> 元素默认为 <code>display:inline</code>。</p>
</div>
<p>您可以更改此默认显示行为。</p>
<div><p>案例</p>
<p><code>&lt;li&gt;</code> 元素默认为 <code>display:block</code>，这意味着列表项显示为一个在另一个之下。将显示值更改为 <code>inline</code>，会令它们显示在彼此旁边，就像单词在句子中所做的那样。</p>
</div>
<p>您可以更改任何元素的 <code>display</code> 值，这意味着您可以根据内容的语义选择合适的 HTML 元素，而不必关心它们的外观。它们的样子是您可以改变的。</p>
<h2 id="弹性盒子-flexbox"> 弹性盒子(Flexbox)</h2>
<p>Flexbox 是 CSS 弹性盒子布局模块(Flexible Box Layout Module)的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，您只需要在想要进行 flex 布局的父元素上应用 <code>display: flex</code> ，所有直接子元素都将会按照 flex 进行布局。</p>

          <div
            id="code-demo-60e81843"
           
  
 data-title="Flexbox"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%80%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%BA%8C%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%89%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20margin%3A%204px%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>当我们把 <code>display: flex</code> 添加到父元素时，三个元素就自动按列进行排列。这是由于它们变成了 flex 项(flex items)，按照 flex 容器(也就是它们的父元素)的一些 flex 相关的初值进行 flex 布局: 它们整整齐齐排成一行，是因为父元素上 flex-direction 的初值是 row。它们全都被拉伸至和最高的元素高度相同，是因为父元素上 <code>align-items</code> 属性的初值是 <code>stretch</code>。这就意味着所有的子元素都会被拉伸到它们的 flex 容器的高度，在这个案例里就是所有 flex 项中最高的一项。所有项目都从容器的开始位置进行排列，排列成一行后，在尾部留下一片空白。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>一<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>二<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>三<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>margin</span><span>:</span> 4px<span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>很多属性可以被应用到 flex 项(flex items)上面。这些属性可以改变 flex 项在 flex 布局中占用宽/高的方式，允许它们通过伸缩来适应可用空间。</p>

          <div
            id="code-demo-dadd129e"
           
  
 data-title="flex%20%E5%B1%9E%E6%80%A7"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%80%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%BA%8C%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%89%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20flex%3A%201%3B%5Cn%20%20margin%3A%204px%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<p>作为一个简单的例子，我们可以在我们的所有子元素上添加 flex 属性，并赋值为 1，这会使得所有的子元素都伸展并填充容器，而不是在尾部留下空白，如果有更多空间，那么子元素们就会变得更宽，反之，他们就会变得更窄。除此之外，如果您在 HTML 标记中添加了一个新元素，那么它们也会变得更小，来为新元素创造空间——不管怎样，最终它们会调整自己直到占用相同宽度的空间。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>一<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>二<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>三<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>flex</span><span>:</span> 1<span>;</span>
  <span>margin</span><span>:</span> 4px<span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>相关信息</p>
<p>更多详情请见 <a href="./flex.html">CSS 布局 → 弹性模型</a></p>
</div>
<h2 id="grid-布局"> Grid 布局</h2>
<p>Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在两个维度上把元素按行和列排列整齐。</p>
<p>指定 <code>display: grid</code> 会转为 Grid 布局。</p>
<p>使用 <code>grid-template-rows</code> 和 <code>grid-template-columns</code> 两个属性定义行和列的轨道。</p>

          <div
            id="code-demo-41f0a67a"
           
  
 data-title="Grid%20%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%80%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%BA%8C%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%B8%89%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E5%9B%9B%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E4%BA%94%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%E5%85%AD%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%201fr%201fr%201fr%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%3B%5Cn%20%20grid-gap%3A%2010px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>一<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>二<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>三<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>四<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>五<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>六<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 1fr 1fr<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px<span>;</span>
  <span>grid-gap</span><span>:</span> 10px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>一旦您拥有了一个 grid，您也可以显式地将元素摆放在里面，而不是依赖于浏览器进行自动排列。</p>
<p>利用 <code>grid-column</code> 和 <code>grid-row</code> 两个属性，您可以指定每一个子元素应该从哪一行/列开始，并在哪一行/列结束。这就能够让子元素在多个行/列上展开。</p>

          <div
            id="code-demo-2dde1dcc"
           
  
 data-title="%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E6%91%86%E6%94%BE"

            data-code="%7B%22html%22%3A%22%3Cdiv%20class%3D%5C%22wrapper%5C%22%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box1%5C%22%3E%E4%B8%80%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box2%5C%22%3E%E4%BA%8C%3C%2Fdiv%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box3%5C%22%3E%E4%B8%89%3C%2Fdiv%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.wrapper%20%7B%5Cn%20%20display%3A%20grid%3B%5Cn%20%20grid-template-columns%3A%201fr%201fr%201fr%3B%5Cn%20%20grid-template-rows%3A%20100px%20100px%3B%5Cn%20%20grid-gap%3A%2010px%3B%5Cn%7D%5Cn%5Cn.wrapper%20%3E%20div%20%7B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%7D%5Cn%5Cn.box1%20%7B%5Cn%20%20grid-column%3A%202%20%2F%204%3B%5Cn%20%20grid-row%3A%201%3B%5Cn%7D%5Cn%5Cn.box2%20%7B%5Cn%20%20grid-column%3A%201%3B%5Cn%20%20grid-row%3A%201%20%2F%203%3B%5Cn%7D%5Cn%5Cn.box3%20%7B%5Cn%20%20grid-row%3A%202%3B%5Cn%20%20grid-column%3A%203%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>wrapper<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box1<span>"</span></span><span>></span></span>一<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box2<span>"</span></span><span>></span></span>二<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box3<span>"</span></span><span>></span></span>三<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.wrapper</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 1fr 1fr<span>;</span>
  <span>grid-template-rows</span><span>:</span> 100px 100px<span>;</span>
  <span>grid-gap</span><span>:</span> 10px<span>;</span>
<span>}</span>

<span>.wrapper > div</span> <span>{</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
<span>}</span>

<span>.box1</span> <span>{</span>
  <span>grid-column</span><span>:</span> 2 / 4<span>;</span>
  <span>grid-row</span><span>:</span> 1<span>;</span>
<span>}</span>

<span>.box2</span> <span>{</span>
  <span>grid-column</span><span>:</span> 1<span>;</span>
  <span>grid-row</span><span>:</span> 1 / 3<span>;</span>
<span>}</span>

<span>.box3</span> <span>{</span>
  <span>grid-row</span><span>:</span> 2<span>;</span>
  <span>grid-column</span><span>:</span> 3<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>相关信息</p>
<p>更多详情请见 <a href="./grid.html">CSS 布局 → 网格布局</a></p>
</div>
<h2 id="定位"> 定位</h2>
<p>定位(positioning)能够让我们把一个元素从它原本在正常布局流(normal flow)中应该在的位置移动到另一个位置。定位(positioning)并不是一种用来给您做主要页面布局的方式，它更像是让您去管理和微调页面中的一个特殊项的位置。</p>
<p>有五种主要的定位类型:</p>
<ul>
<li><strong>静态定位</strong>(Static positioning)是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li>
<li><strong>相对定位</strong>(Relative positioning)允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。</li>
<li><strong>绝对定位</strong>(Absolute positioning)将元素完全从页面的正常布局流(normal layout flow)中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的最近被定位祖先元素(nearest positioned ancestor element)。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li>
<li><strong>固定定位</strong>(Fixed positioning)与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li>
<li><strong>粘性定位</strong>(Sticky positioning)是一种新的定位方式，它会让元素先保持和 <code>position: static</code> 一样的定位，当它的相对视口位置(offset from the viewport)达到某一个预设值时，他就会像 <code>position: fixed</code> 一样定位。</li>
</ul>
<h3 id="简单定位"> 简单定位</h3>

          <div
            id="code-demo-239f4b6a"
           
  
 data-title="%E9%BB%98%E8%AE%A4%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E5%AE%9A%E4%BD%8D%3C%2Fh1%3E%5Cn%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%20class%3D%5C%22positioned%5C%22%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22body%20%7B%5Cn%20%20width%3A%20500px%3B%5Cn%20%20margin%3A%200%20auto%3B%5Cn%7D%5Cn%5Cnp%20%7B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20margin%3A%2010px%3B%5Cn%20%20border-radius%3A%205px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>定位<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>positioned<span>"</span></span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>body</span> <span>{</span>
  <span>width</span><span>:</span> 500px<span>;</span>
  <span>margin</span><span>:</span> 0 auto<span>;</span>
<span>}</span>

<span>p</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>margin</span><span>:</span> 10px<span>;</span>
  <span>border-radius</span><span>:</span> 5px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="相对定位"> 相对定位</h3>
<p>相对定位(relative positioning)让您能够把一个正常布局流(normal flow)中的元素从它的默认位置按坐标进行相对移动。比如将一个图标往下调一点，以便放置文字。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> relative<span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>请注意，<code>top</code> 和 <code>left</code> 不能被理解成向上或向左，而是顶部与左侧与初始距离的位置。</p>

          <div
            id="code-demo-66055320"
           
  
 data-title="%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%3C%2Fh1%3E%5Cn%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%20class%3D%5C%22positioned%5C%22%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20margin%3A%2010px%3B%5Cn%20%20border-radius%3A%205px%3B%5Cn%7D%5Cn%5Cn.positioned%20%7B%5Cn%20%20position%3A%20relative%3B%5Cn%20%20background%3A%20rgba(255%2C%2084%2C%20104%2C%200.3)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(255%2C%2084%2C%20104)%3B%5Cn%20%20top%3A%2030px%3B%5Cn%20%20left%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>相对定位<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>positioned<span>"</span></span><span>></span></span>这是一个相对定位块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>margin</span><span>:</span> 10px<span>;</span>
  <span>border-radius</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> relative<span>;</span>
  <span>background</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>,</span> 0.3<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>)</span><span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="绝对定位"> 绝对定位</h3>
<p>绝对定位用于将元素移出正常布局流(normal flow)，以坐标的形式相对于它的容器定位到 web 页面的任何位置，以创建复杂的布局。有趣的是，它经常被用于与相对定位和浮动的协同工作。</p>
<p><strong>案例</strong>:</p>
<div><pre><code><span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
          <div
            id="code-demo-485eea96"
           
  
 data-title="%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%3C%2Fh1%3E%5Cn%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%20class%3D%5C%22positioned%5C%22%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22p%20%7B%5Cn%20%20background-color%3A%20rgb(207%2C%20232%2C%20220)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(79%2C%20185%2C%20227)%3B%5Cn%20%20padding%3A%2010px%3B%5Cn%20%20margin%3A%2010px%3B%5Cn%20%20border-radius%3A%205px%3B%5Cn%7D%5Cn%5Cn.positioned%20%7B%5Cn%20%20position%3A%20absolute%3B%5Cn%20%20background%3A%20rgba(255%2C%2084%2C%20104%2C%200.3)%3B%5Cn%20%20border%3A%202px%20solid%20rgb(255%2C%2084%2C%20104)%3B%5Cn%20%20top%3A%2030px%3B%5Cn%20%20left%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>绝对定位<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>positioned<span>"</span></span><span>></span></span>这是一个绝对定位元素<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是一个普通的块级元素<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>p</span> <span>{</span>
  <span>background-color</span><span>:</span> <span>rgb</span><span>(</span>207<span>,</span> 232<span>,</span> 220<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>79<span>,</span> 185<span>,</span> 227<span>)</span><span>;</span>
  <span>padding</span><span>:</span> 10px<span>;</span>
  <span>margin</span><span>:</span> 10px<span>;</span>
  <span>border-radius</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>background</span><span>:</span> <span>rgba</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>,</span> 0.3<span>)</span><span>;</span>
  <span>border</span><span>:</span> 2px solid <span>rgb</span><span>(</span>255<span>,</span> 84<span>,</span> 104<span>)</span><span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>定位元素现在已经与页面布局的其余部分完全分离，并位于页面的顶部。其他两段现在靠在一起，好像之前那个中间段落不存在一样。<code>top</code> 和 <code>left</code> 属性对绝对位置元素的影响不同于相对位置元素。在这一案例当中，他们没有指定元素相对于原始位置的移动程度。相反，在这一案例当中，它们指定元素应该从父元素的顶部和左边的距离(确切地说，是演示窗口元素的距离)。</p>
<h3 id="固定定位"> 固定定位</h3>
<p>固定定位(fixed positioning)同绝对定位(absolute positioning)一样，将元素从文档流(document flow)当中移出了。但是，定位的坐标不会应用于&quot;容器&quot;边框来计算元素的位置，而是会应用于视口(viewport)边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。</p>

          <div
            id="code-demo-37679611"
           
  
 data-title="%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%3C%2Fh1%3E%5Cn%5Cn%3C!--%20%E6%82%A8%E4%BC%9A%E5%9C%A8%E6%9C%AC%E9%A1%B5%E9%A1%B6%E9%83%A8%E6%89%BE%E5%88%B0%E5%AE%83%20--%3E%5Cn%3Cdiv%20class%3D%5C%22positioned%5C%22%3E%E5%9B%BA%E5%AE%9A%E5%AE%9A%E4%BD%8D%3C%2Fdiv%3E%5Cn%5Cn%3Cp%3E%E6%AE%B5%E8%90%BD%201%3C%2Fp%3E%5Cn%3Cp%3E%E6%AE%B5%E8%90%BD%202%3C%2Fp%3E%5Cn%3Cp%3E%E6%AE%B5%E8%90%BD%203%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22.positioned%20%7B%5Cn%20%20position%3A%20fixed%3B%5Cn%20%20top%3A%2030px%3B%5Cn%20%20left%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>固定定位<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span>&lt;!-- 您会在本页顶部找到它 --></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>positioned<span>"</span></span><span>></span></span>固定定位<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>段落 1<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>段落 2<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>段落 3<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> fixed<span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="粘性定位"> 粘性定位</h3>
<p>粘性定位(sticky positioning)是最后一种我们能够使用的定位方式。它将默认的静态定位(static positioning)和固定定位(fixed positioning)相混合。当一个元素被指定了 <code>position: sticky</code> 时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了 <code>position: fixed</code> 一样。</p>

          <div
            id="code-demo-825586b6"
           
  
 data-title="%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D"

            data-code="%7B%22html%22%3A%22%3Ch1%3ESticky%20positioning%3C%2Fh1%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%20aliquam%5Cn%20%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%20pulvinar%20id%20metus%5Cn%20%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%20at%20ultricies%20tellus%5Cn%20%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%20Integer%20ligula%20ipsum%2C%5Cn%20%20tristique%20sit%20amet%20orci%20vel%2C%20viverra%20egestas%20ligula.%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cdiv%20class%3D%5C%22positioned%5C%22%3E%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D%3C%2Fdiv%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20Nam%20vulputate%20diam%20nec%20tempor%20bibendum.%20Donec%20luctus%20augue%20eget%20malesuada%5Cn%20%20ultrices.%20Phasellus%20turpis%20est%2C%20posuere%20sit%20amet%20dapibus%20ut%2C%20facilisis%20sed%5Cn%20%20est.%20Nam%20id%20risus%20quis%20ante%20semper%20consectetur%20eget%20aliquam%20lorem.%20Vivamus%5Cn%20%20tristique%20elit%20dolor%2C%20sed%20pretium%20metus%20suscipit%20vel.%20Mauris%20ultricies%20lectus%5Cn%20%20sed%20lobortis%20finibus.%20Vivamus%20eu%20urna%20eget%20velit%20cursus%20viverra%20quis%5Cn%20%20vestibulum%20sem.%20Aliquam%20tincidunt%20eget%20purus%20in%20interdum.%20Cum%20sociis%20natoque%5Cn%20%20penatibus%20et%20magnis%20dis%20parturient%20montes%2C%20nascetur%20ridiculus%20mus.%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%20aliquam%5Cn%20%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%20pulvinar%20id%20metus%5Cn%20%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%20at%20ultricies%20tellus%5Cn%20%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%20Integer%20ligula%20ipsum%2C%5Cn%20%20tristique%20sit%20amet%20orci%20vel%2C%20viverra%20egestas%20ligula.%20Curabitur%20vehicula%20tellus%5Cn%20%20neque%2C%20ac%20ornare%20ex%20malesuada%20et.%20In%20vitae%20convallis%20lacus.%20Aliquam%20erat%5Cn%20%20volutpat.%20Suspendisse%20ac%20imperdiet%20turpis.%20Aenean%20finibus%20sollicitudin%20eros%5Cn%20%20pharetra%20congue.%20Duis%20ornare%20egestas%20augue%20ut%20luctus.%20Proin%20blandit%20quam%20nec%5Cn%20%20lacus%20varius%20commodo%20et%20a%20urna.%20Ut%20id%20ornare%20felis%2C%20eget%20fermentum%20sapien.%5Cn%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22.positioned%20%7B%5Cn%20%20position%3A%20sticky%3B%5Cn%20%20top%3A%2030px%3B%5Cn%20%20left%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Sticky positioning<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam
  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus
  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus
  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,
  tristique sit amet orci vel, viverra egestas ligula.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>positioned<span>"</span></span><span>></span></span>粘性定位<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada
  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed
  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus
  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus
  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis
  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque
  penatibus et magnis dis parturient montes, nascetur ridiculus mus.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam
  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus
  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus
  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,
  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus
  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat
  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros
  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec
  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code><span>.positioned</span> <span>{</span>
  <span>position</span><span>:</span> sticky<span>;</span>
  <span>top</span><span>:</span> 30px<span>;</span>
  <span>left</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="浮动"> 浮动</h2>
<p>把一个元素“浮动”(float)起来，会改变该元素本身和在正常布局流(normal flow)中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流(normal flow)中移除，这时候其他的周围内容就会在这个被设置浮动(float)的元素周围环绕。</p>
<p><code>float</code> 属性有四个可能的值:</p>
<ul>
<li><code>left</code>: 将元素浮动到左侧。</li>
<li><code>right</code>: 将元素浮动到右侧。</li>
<li><code>none</code>: 默认值, 不浮动。</li>
<li><code>inherit</code>: 继承父元素的浮动属性。</li>
</ul>

          <div
            id="code-demo-6082ea53"
           
  
 data-title="float%20%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E7%AE%80%E5%8D%95%E7%9A%84%20float%20%E6%A1%88%E4%BE%8B%3C%2Fh1%3E%5Cn%5Cn%3Cdiv%20class%3D%5C%22box%5C%22%3E%E6%B5%AE%E5%8A%A8%E5%9D%97%3C%2Fdiv%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20Lorem%20ipsum%20dolor%20sit%20amet%2C%20consectetur%20adipiscing%20elit.%20Nulla%20luctus%20aliquam%5Cn%20%20dolor%2C%20eu%20lacinia%20lorem%20placerat%20vulputate.%20Duis%20felis%20orci%2C%20pulvinar%20id%20metus%5Cn%20%20ut%2C%20rutrum%20luctus%20orci.%20Cras%20porttitor%20imperdiet%20nunc%2C%20at%20ultricies%20tellus%5Cn%20%20laoreet%20sit%20amet.%20Sed%20auctor%20cursus%20massa%20at%20porta.%20Integer%20ligula%20ipsum%2C%5Cn%20%20tristique%20sit%20amet%20orci%20vel%2C%20viverra%20egestas%20ligula.%20Curabitur%20vehicula%20tellus%5Cn%20%20neque%2C%20ac%20ornare%20ex%20malesuada%20et.%20In%20vitae%20convallis%20lacus.%20Aliquam%20erat%5Cn%20%20volutpat.%5Cn%3C%2Fp%3E%5Cn%22%2C%22css%22%3A%22.box%20%7B%5Cn%20%20float%3A%20left%3B%5Cn%20%20width%3A%20150px%3B%5Cn%20%20height%3A%20150px%3B%5Cn%20%20margin-right%3A%2030px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>简单的 float 案例<span><span><span>&lt;/</span>h1</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>浮动块<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam
  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus
  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus
  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,
  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus
  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat
  volutpat.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>width</span><span>:</span> 150px<span>;</span>
  <span>height</span><span>:</span> 150px<span>;</span>
  <span>margin-right</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="多列布局"> 多列布局</h2>
<p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。由于在 web 内容里让您的用户在一个列上通过上下滚动来阅读两篇相关的文本是一种非常低效的方式，那么把内容排列成多列可能是一种有用的技术。</p>
<p>要把一个块转变成多列容器(multicol container)，我们可以使用 <code>column-count</code> 属性来告诉浏览器我们需要多少列，也可以使用 <code>column-width</code> 来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p>

          <div
            id="code-demo-de4aae6a"
           
  
 data-title="%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80"

            data-code="%7B%22html%22%3A%22%3Ch1%3EMulti-column%20layout%3C%2Fh1%3E%5Cn%3Cdiv%20class%3D%5C%22container%5C%22%3E%5Cn%20%20%3Cp%3EParagraph%201.%3C%2Fp%3E%5Cn%20%20%3Cp%3EParagraph%202.%3C%2Fp%3E%5Cn%3C%2Fdiv%3E%5Cn%22%2C%22css%22%3A%22.container%20%7B%5Cn%20%20column-width%3A%20200px%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Multi-column layout<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>Paragraph 1.<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>Paragraph 2.<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>.container</span> <span>{</span>
  <span>column-width</span><span>:</span> 200px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">CSS 布局</title>
    <id>https://list-jiang.github.io/code/website/css/layout/</id>
    <link href="https://list-jiang.github.io/code/website/css/layout/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">布局介绍</a></p>
</li>
<li>
<p><a href="./flow.html">正常流布局</a></p>
</li>
<li>
<p><a href="./flex.html">弹性布局</a></p>
</li>
<li>
<p><a href="./exercise.html">实战练习</a></p>
</li>
<li>
<p><a href="./grid.html">网格布局</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-06T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">CSS</title>
    <id>https://list-jiang.github.io/code/website/css/</id>
    <link href="https://list-jiang.github.io/code/website/css/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)，它负责描述网页元素的具体样式。</p>
<p>CSS3 是最新的 CSS 标准，被拆分为&quot;模块&quot;。模块包括: 选择器、盒模型、背景和边框、文字特效、2D/3D 转换、动画、多列布局、用户界面。</p>
]]></summary>
    <content type="html"><![CDATA[<p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)，它负责描述网页元素的具体样式。</p>
<p>CSS3 是最新的 CSS 标准，被拆分为&quot;模块&quot;。模块包括: 选择器、盒模型、背景和边框、文字特效、2D/3D 转换、动画、多列布局、用户界面。</p>

<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./guide/">快速上手</a></p>
<ul>
<li><a href="./guide/selector.html">CSS 选择器</a></li>
<li><a href="./guide/declaration.html">CSS 声明</a></li>
<li><a href="./guide/import.html">CSS 引入</a></li>
<li><a href="./guide/common.html">CSS 常用属性介绍</a></li>
<li><a href="./guide/media.html">CSS 媒体查询</a></li>
<li><a href="./guide/box.html">CSS 盒模型</a></li>
</ul>
</li>
<li>
<p><a href="./layout/">CSS 布局介绍</a></p>
<ul>
<li><a href="./layout/flex.html">CSS 弹性模型</a></li>
<li><a href="./layout/exercise.html">CSS 布局实战</a></li>
<li><a href="./layout/grid.html">CSS 网格模型</a></li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/CSS%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener noreferrer">CSS 工作原理</a></p>
</li>
</ul>
<h2 id="css-参考"> CSS 参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener noreferrer">MDN 教程</a></li>
</ul>
<h2 id="其他文档"> 其他文档 <i>Not supported content</i></h2>
<ul>
<li>
<p>CSS</p>
<ul>
<li><a href="https://www.w3cschool.cn/css/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
<li><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
</ul>
</li>
<li>
<p>CSS3</p>
<ul>
<li><a href="https://www.w3cschool.cn/css3/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="http://www.w3school.com.cn/css3/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
<li><a href="https://www.runoob.com/css3/css3-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
</ul>
</li>
</ul>
<h2 id="在线练习网址"> 在线练习网址</h2>
<ul>
<li><a href="https://c.runoob.com/front-end/61" target="_blank" rel="noopener noreferrer">菜鸟教程在线工具</a></li>
<li><a href="https://jsfiddle.net/" target="_blank" rel="noopener noreferrer">jsfiddle</a></li>
</ul>
<h2 id="css-的超集"> CSS 的超集</h2>
<ul>
<li>
<p>Stylus</p>
<p>带来更简单的写法，支持变量、函数等功能。</p>
<ul>
<li><a href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener noreferrer">中文文档</a></li>
<li><a href="http://stylus-lang.com/" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
</li>
<li>
<p>Sass</p>
<p>Sass 是世界上最成熟、稳定、强大的专业级 CSS 扩展语言。</p>
<blockquote>
<p>注: 官网说的，不是我说的 😂</p>
</blockquote>
<div><p>提示</p>
<p>SCSS 是 Sass3 版本当中引入的新语法特性,完全兼容 CSS3 的同时继承了 Sass 强大的动态功能。</p>
</div>
<ul>
<li><a href="https://sass.bootcss.com/" target="_blank" rel="noopener noreferrer">中文文档</a></li>
<li><a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="CSS"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">CSS Emmet</title>
    <id>https://list-jiang.github.io/code/website/emmet/css/</id>
    <link href="https://list-jiang.github.io/code/website/emmet/css/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>对于 CSS 语法，Emmet 为属性提供了许多预定义的代码段。</p>
<h2 id="添加属性"> 添加属性</h2>
<p>您可以使用缩写来生成 CSS 属性。如 <code>m</code> 会生成 <code>margin: ;</code>，同时光标会自动置于值处。</p>
<h2 id="同时添加属性与值值"> 同时添加属性与值值</h2>
<p>您可以将值直接输入缩写的后面，如果有多个值，您需要用 <code>-</code> 将它们分开，多余的 <code>-</code> 将会被理解为负值。</p>
<div><p>案例</p>
<ul>
<li><code>m10</code>: <code>margin: 10px;</code></li>
<li><code>m10-20</code>: <code>margin: 10px 20px;</code></li>
<li><code>m-10--20</code>: <code>margin: -10px -20px;</code></li>
</ul>
</div>
<div><p>注意</p>
<p>请只有在必要(不添加会产生歧义)的情况下添加 <code>-</code> 分隔符，否则 Emmet 可能会错误的理解它。</p>
</div>
<h2 id="值的单位"> 值的单位</h2>
<p>使用整数值扩展缩写时，Emmet 会以 px 单位输出: <code>m10</code> → <code>margin: 10px;</code>。</p>
<p>使用浮点值扩展缩写时，会以 em 单位输出: <code>m1.5</code> → <code>margin: 1.5em;</code>。</p>
<p>您也可以在值后面紧跟任何字母字符，来显式提供单位名称: <code>m1.5ex</code> → <code>margin: 1.5ex;</code>，<code>m10foo</code> → <code>margin: 10foo;</code>。</p>
<p>明确定义单位后，不再需要使用连字符来分隔值: <code>m10ex20em</code> → <code>margin: 10ex 20em;</code>，<code>m10ex-5</code> → <code>margin: 10ex -5px;</code>。</p>
<h2 id="值别名"> 值别名</h2>
<p>Emmet 具有一些常用值的别名:</p>
<ul>
<li><code>p</code> → <code>%</code></li>
<li><code>e</code> → <code>em</code></li>
<li><code>x</code> → <code>ex</code></li>
</ul>
<p>您可以使用别名代替完整的单位:</p>
<ul>
<li><code>w100p</code> → <code>width: 100%</code></li>
<li><code>m10p30e5x</code> → <code>margin: 10% 30em 5ex</code></li>
</ul>
<h2 id="颜色值"> 颜色值</h2>
<p>Emmet 支持十六进制颜色值。<code>#</code> 将自动作为分隔符，所以针对颜色变量，将不再需要 <code>-</code>。</p>
<ul>
<li><code>c#3</code> → <code>color: #333;</code></li>
<li><code>bd5#0s</code> → <code>border: 5px #000 solid</code>。(<code>#</code> 符号可将颜色与 <code>5</code> 分隔开，并且 <code>s</code>(别名为 <code>solid</code>)不是十六进制字符，因此省略了 <code>-</code>。</li>
</ul>
<p>颜色变量支持 1-3 位的缩写，表现如下:</p>
<ul>
<li><code>#1</code> → <code>#111111</code></li>
<li><code>#e0</code> → <code>#e0e0e0</code></li>
<li><code>#fc0</code> → <code>#ffcc00</code></li>
</ul>
<h2 id="无单元属性"> 无单元属性</h2>
<p>一些 CSS 属性默认为无单位输出:</p>
<ul>
<li><code>lh2</code>→ <code>line-height: 2;</code></li>
<li><code>fw400</code>→ <code>font-weight: 400</code>。</li>
</ul>
<p>这些值是: <code>z-index</code>，<code>line-height</code>，<code>opacity</code> 和 <code>font-weight</code></p>
<h2 id="重要修饰符"> 重要修饰符</h2>
<p>您可以在任何 CSS 缩写的末尾添加 <code>!</code> 后缀来添加 <code>!important</code></p>
<p><code>p!+m10e!</code>:</p>
<div><pre><code><span>padding</span><span>:</span> <span>!important</span><span>;</span>
<span>margin</span><span>:</span> 10em <span>!important</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="输出多个属性"> 输出多个属性</h2>
<p>正如上方演示，您可以利用 <code>+</code> 同时输出多个 CSS 属性。</p>
<div><p>Snippets</p>
<p>完整的 CSS snippets 请见 <a href="https://github.com/emmetio/emmet/blob/master/snippets/css.json" target="_blank" rel="noopener noreferrer">Emmet Repo</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Emmet"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">HTML Emmet</title>
    <id>https://list-jiang.github.io/code/website/emmet/html/</id>
    <link href="https://list-jiang.github.io/code/website/emmet/html/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="元素创建"> 元素创建</h2>
<ol>
<li>在编辑器中输入元素名称之后按下 tab 即可自动补全生成 HTML 标签，即使不是标准的 HTML 标签。</li>
</ol>
<div><p>创建文档</p>
<p>输入: <code>!</code> 或者 <code>html:5</code> 将创建 HTML 基本结构。</p>
</div>
<h2 id="结构操作"> 结构操作</h2>
<h3 id="子元素"> 子元素</h3>
<p>使用 <code>&gt;</code> 生成子元素</p>
<details><summary>案例</summary>
<p><code>div&gt;ul&gt;li</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></details>
<h3 id="兄弟元素"> 兄弟元素</h3>
<p>使用 <code>+</code> 生成兄弟元素</p>
<details><summary>案例</summary>
<p><code>div+p+bq</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>blockquote</span><span>></span></span><span><span><span>&lt;/</span>blockquote</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<h3 id="上移"> 上移</h3>
<p>使用 <code>^</code> 上移一级</p>
<details><summary>案例</summary>
<p><code>div+div&gt;p&gt;span+em^bq</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>em</span><span>></span></span><span><span><span>&lt;/</span>em</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>blockquote</span><span>></span></span><span><span><span>&lt;/</span>blockquote</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></details>
<h3 id="重复"> 重复</h3>
<p>使用 <code>*</code> 生成多个相同元素。</p>
<details><summary>案例</summary>
<p><code>div&gt;ul&gt;li*5</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></details>
<h3 id="分组"> 分组</h3>
<p>使用 <code>()</code> 将元素分组</p>
<details><summary>案例</summary>
<p><code>+</code> 后面的元素与括号中的第一个元素属于兄弟关系</p>
<p><code>div&gt;(header&gt;ul&gt;li*2)+footer&gt;p</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>header</span><span>></span></span>
    <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>header</span><span>></span></span>
  <span><span><span>&lt;</span>footer</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>
<h2 id="属性操作"> 属性操作</h2>
<h3 id="id-与-class"> ID 与 class</h3>
<p>元素与 <code>id</code> 属性值之间用 <code>#</code> 分隔，与 <code>class</code> 属性值之间用 <code>.</code> 分隔</p>
<details><summary>案例</summary>
<p><code>div#header+div.page+div#footer.class1.class2.class3</code>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>header<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>page<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>footer<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>class1 class2 class3<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<h3 id="自定义属性"> 自定义属性</h3>
<p>在 Emmet 中，使用 <code>[]</code> 标记其他属性。</p>
<p>您无需输入引号，直接使用 <code>[属性1=值1 属性2=值2 ... ]</code> 即可。</p>
<ul>
<li>
<p>您可以在方括号内放置任意数量的属性。</p>
</li>
<li>
<p>您不必指定属性值: <code>td[colspan title]</code> 会生成 <code>&lt;td colspan=&quot;&quot; title=&quot;&quot;&gt;</code>。</p>
<p>接下来您可以通过按下 tab 将光标顺序移动至每个空属性内，这会让您很方便的输入内容。</p>
</li>
<li>
<p>您可以使用单引号或双引号来引用属性值。如果值不包含空格，则无需引用它们。如: <code>td[title=hello colspan=3]</code></p>
</li>
</ul>
<details><summary>案例</summary>
<p><code>td[title=&quot;Hello world!&quot; colspan=3]</code>:</p>
<div><pre><code><span><span><span>&lt;</span>td</span> <span>title</span><span><span>=</span><span>"</span>Hello world!<span>"</span></span> <span>colspan</span><span><span>=</span><span>"</span>3<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>td</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></details>
<h3 id="项目编号"> 项目编号</h3>
<p>用 <code>$</code> 符号实现 <code>1</code> 到 <code>n</code> 的自动编号 (<code>*</code> 实现多个元素)</p>
<details><summary>案例</summary>
<p><code>li.item$*3</code>:</p>
<div><pre><code><span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item1<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item2<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<p>可在 <code>$</code> 后添加 <code>@n</code> 修改编号的起始值为 <code>n</code>。</p>
<details><summary>案例</summary>
<p><code>li.item$@3*3</code>:</p>
<div><pre><code><span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<p>可在 “<code>$</code>” 后添加 “<code>@-</code>” 修改编号的方向。</p>
<details><summary>案例</summary>
<p><code>li.item$@-3*3</code>:</p>
<div><pre><code><span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item5<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item4<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item3<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<p>您可以连续使用多个 <code>$</code> 以零填充数字。</p>
<details><summary>案例</summary>
<p><code>ul&gt;li.item$$$*5</code>:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item001<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item002<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item003<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item004<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item005<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>
<h3 id="文本"> 文本</h3>
<p>使用 <code>{}</code> 添加文本内容</p>
<details><summary>案例</summary>
<p><code>a[href=me.html]{click me}</code>:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>me.html<span>"</span></span><span>></span></span>click me<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></details>
<div><p>注意</p>
<p>请注意，<code>{text}</code> 是作为一个单独的元素使用和解析的。</p>
<p>请理解以下案例:</p>
<div><pre><code><span>&lt;!-- a{click}+b{here} --></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span>click<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;</span>b</span><span>></span></span>here<span><span><span>&lt;/</span>b</span><span>></span></span>

<span>&lt;!-- a>{click}+b{here} --></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span>click<span><span><span>&lt;</span>b</span><span>></span></span>here<span><span><span>&lt;/</span>b</span><span>></span></span><span><span><span>&lt;/</span>a</span><span>></span></span>

<span>&lt;!-- p>{Click }+a{here}+{ to continue} --></span>

<span><span><span>&lt;</span>p</span><span>></span></span>Click <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span>here<span><span><span>&lt;/</span>a</span><span>></span></span> to continue<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></div>
<h2 id="隐式标签名称"> 隐式标签名称</h2>
<p>即使使用功能强大的缩写引擎(可以从短缩写扩展大型 HTML 结构)，编写标签名称也可能非常繁琐。</p>
<p>在许多情况下，您可以跳过键入标签名称的操作，而 Emmet 会自动为您生成一个。例如，您可以简单地将 <code>div.content</code> 写为 <code>.content</code>，Emmet 将自动扩展为 <code>&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</code>。</p>
<h3 id="工作原理"> 工作原理</h3>
<p>扩展缩写词时，Emmet 会尝试在其内部扩展缩写词的地方获取上下文进行推断。如果成功捕获了上下文，Emmet 将使用其名称来解析隐式名称。</p>
<details><summary>案例</summary>
<table>
<thead>
<tr>
<th>Emmet 缩写</th>
<th>Emmet 实际输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.wrap&gt;.content</code></td>
<td><code>div.wrap&gt;div.content</code></td>
</tr>
<tr>
<td><code>em&gt;.info</code></td>
<td><code>em&gt;span.info</code></td>
</tr>
<tr>
<td><code>ul&gt;.item*3</code></td>
<td><code>ul&gt;li.item*3</code></td>
</tr>
<tr>
<td><code>table&gt;#row$*4&gt;[colspan=2]</code></td>
<td><code>table&gt;tr#row$*4&gt;td[colspan=2]</code></td>
</tr>
</tbody>
</table>
</details>
<h2 id="lorem-ipsum-生成"> Lorem Ipsum 生成</h2>
<p><code>lorem</code> 是一个示例词的生成器，您可以很方便的生成一些预设文字查看效果。它会自动根据标签调整文字数量，并在重复时轮换输出。</p>
<details><summary>案例</summary>
<p><code>p*4&gt;lorem</code>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui dicta minus
  molestiae vel beatae natus eveniet ratione temporibus aperiam harum alias
  officiis assumenda officia quibusdam deleniti eos cupiditate dolore doloribus!
<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>
  Ad dolore dignissimos asperiores dicta facere optio quod commodi nam tempore
  recusandae. Rerum sed nulla eum vero expedita ex delectus voluptates rem at
  neque quos facere sequi unde optio aliquam!
<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>
  Tenetur quod quidem in voluptatem corporis dolorum dicta sit pariatur porro
  quaerat autem ipsam odit quam beatae tempora quibusdam illum! Modi velit odio
  nam nulla unde amet odit pariatur at!
<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>
  Consequatur rerum amet fuga expedita sunt et tempora saepe? Iusto nihil
  explicabo perferendis quos provident delectus ducimus necessitatibus
  reiciendis optio tempora unde earum doloremque commodi laudantium ad nulla vel
  odio?
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><code>ul.generic-list&gt;lorem10.item*4</code>:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>generic-list<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>
    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nam vero.
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>
    Laboriosam quaerat sapiente minima nam minus similique illum architecto et!
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>
    Incidunt vitae quae facere ducimus nostrum aliquid dolorum veritatis dicta!
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>
    Tenetur laborum quod cum excepturi recusandae porro sint quas soluta!
  <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></details>
<h2 id="其他内容"> 其他内容</h2>
<p>某些元素(例如 a 或)img 会转换为具有预定义属性的元素: <code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code> 和 <code>&lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;</code>。</p>
<p>同时 emmet 还包含了一些常用缩写，如 <code>bq</code> 会输出 <code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>。</p>
<p>这些功能是通过预置的 snippets 实现的。</p>
<div><p>相关信息</p>
<p>部分 snippets 内容:</p>
<div><pre><code>...
<span>{</span>
  <span>"a"</span><span>:</span> <span>"a[href]"</span><span>,</span>
  <span>"img"</span><span>:</span> <span>"img[src alt]/"</span><span>,</span>
  <span>"bq"</span><span>:</span> <span>"blockquote"</span><span>,</span>
  <span>"fig"</span><span>:</span> <span>"figure"</span><span>,</span>
  <span>"cap"</span><span>:</span> <span>"caption"</span><span>,</span>
  <span>"pic"</span><span>:</span> <span>"picture"</span><span>,</span>
  <span>"mn"</span><span>:</span> <span>"main"</span><span>,</span>
  <span>"!!!"</span><span>:</span> <span>"{&lt;!DOCTYPE html>}"</span><span>,</span>
  <span>"doc"</span><span>:</span> <span>"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body"</span><span>,</span>
  <span>"!|html:5"</span><span>:</span> <span>"!!!+doc"</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>完整的 HTML snippets 请见 <a href="https://github.com/emmetio/emmet/blob/master/snippets/html.json" target="_blank" rel="noopener noreferrer">Emmet Repo</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Emmet"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Emmet 语法</title>
    <id>https://list-jiang.github.io/code/website/emmet/</id>
    <link href="https://list-jiang.github.io/code/website/emmet/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>简介</p>
<p>所有操作按下 “tab” 键即可瞬间完成</p>
</div>
<p>Emmet 是一个快速创建 HTML 和 CSS 的方式，如果您想要成为一个高级 Web 开发者，为了工作效率，您应该掌握 Emmet 语法。</p>
]]></summary>
    <content type="html"><![CDATA[<div><p>简介</p>
<p>所有操作按下 “tab” 键即可瞬间完成</p>
</div>
<p>Emmet 是一个快速创建 HTML 和 CSS 的方式，如果您想要成为一个高级 Web 开发者，为了工作效率，您应该掌握 Emmet 语法。</p>

<h2 id="html"> HTML</h2>
<ul>
<li><a href="./html.html">HTML Emmet 语法</a></li>
</ul>
<h2 id="css"> CSS</h2>
<ul>
<li><a href="./CSS.html">CSS Emmet 语法</a></li>
</ul>
<h2 id="其他功能"> 其他功能</h2>
<p>Emmet 还提供了很多内置功能，在 VS Code 中，您可以按下 <code>F1</code> 并输入 <code>emmet</code> 来查看功能列表。详细的功能列表说明请见 <a href="https://docs.emmet.io/actions/" target="_blank" rel="noopener noreferrer">Emmet 文档</a></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Emmet"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">MIME type</title>
    <id>https://list-jiang.github.io/code/website/html/definition/mime/</id>
    <link href="https://list-jiang.github.io/code/website/html/definition/mime/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>MIME type，即媒体类型(media type) (有时是“内容类型(content type)”) 是指示文件类型的字符串，与文件一起发送。</p>
<p>例如，一个声音文件可能被标记为 <code>audio/ogg</code> ，一个图像文件可能是 <code>image/png</code>。</p>
<p>它与传统 Windows 上的文件扩展名有相同目的。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">定义</title>
    <id>https://list-jiang.github.io/code/website/html/definition/</id>
    <link href="https://list-jiang.github.io/code/website/html/definition/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="定义列表"> 定义列表</h2>
<ul>
<li>
<p><a href="./uri.html">URI 统一资源标识符</a></p>
</li>
<li>
<p><a href="./url.html">URL 统一资源定位符</a></p>
</li>
<li>
<p><a href="./seo.html">SEO 搜索引擎优化</a></p>
</li>
<li>
<p><a href="./mime.html">MIME Type 媒体类型</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">SEO</title>
    <id>https://list-jiang.github.io/code/website/html/definition/seo/</id>
    <link href="https://list-jiang.github.io/code/website/html/definition/seo/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>搜索引擎优化 (<strong>S</strong>earch <strong>E</strong>ngine <strong>O</strong>ptimization)，是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望透过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。</p>
<p>所谓“针对搜索引擎作最优化的处理”，是指为了要让网站更容易被搜索引擎接受。搜索引擎会将网站彼此间的内容做一些相关性的资料比对，然后再由浏览器将这些内容以最快速且接近最完整的方式，呈现给搜索者。搜索引擎优化就是通过搜索引擎的规则进行优化，为用户打造更好的用户体验，最终的目的就是做好用户体验。</p>
<h2 id="相关文档"> 相关文档</h2>
<ul>
<li>
<p><a href="https://schema.org/" target="_blank" rel="noopener noreferrer">Schema Org</a></p>
<ul>
<li>
<p><a href="https://schema.org/docs/gs.html" target="_blank" rel="noopener noreferrer">快速上手</a></p>
</li>
<li>
<p><a href="https://schema.org/docs/full.html" target="_blank" rel="noopener noreferrer">全部的 Schema 列表</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://ogp.me/" target="_blank" rel="noopener noreferrer">开放内容协议 OGP</a> (<strong>O</strong>pen <strong>G</strong>raph <strong>Pr</strong>otocal)</p>
</li>
<li>
<p><a href="https://developers.google.com/search/docs/" target="_blank" rel="noopener noreferrer">Google 搜索指南</a></p>
<ul>
<li><a href="https://developers.google.com/search/docs/guides/get-started" target="_blank" rel="noopener noreferrer">快速上手</a></li>
</ul>
</li>
</ul>
<h2 id="相关工具"> 相关工具</h2>
<ul>
<li>
<p><a href="https://developers.google.com/search" target="_blank" rel="noopener noreferrer">Google 搜索中心</a></p>
</li>
<li>
<p><a href="https://search.google.com/search-console/" target="_blank" rel="noopener noreferrer">Google Search Console</a></p>
<p>Search Console 是 Google 推出的一款免费工具，可帮助开发者、网站所有者和搜索引擎优化专家了解其网站在 Google 搜索上的表现。</p>
</li>
<li>
<p><a href="https://search.google.com/test/rich-results" target="_blank" rel="noopener noreferrer">Google 富媒体测试工具</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">URI</title>
    <id>https://list-jiang.github.io/code/website/html/definition/uri/</id>
    <link href="https://list-jiang.github.io/code/website/html/definition/uri/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p><strong>统一资源标识符</strong>(英语: Uniform Resource Identifier，缩写: URI)在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p>
<p>该种标识允许用户对网络中(一般指万维网)的资源通过特定的协议进行交互操作。URI 的最常见的形式是统一资源定位符(URL)，经常指定为非正式的网址。更罕见的用法是统一资源名称(URN)，其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。</p>
<h2 id="与-url-和-urn-的关系"> 与 URL 和 URN 的关系</h2>
<h3 id="urn"> URN</h3>
<p><strong>统一资源名称</strong>(英语: Uniform Resource Name，缩写: URN)是统一资源标识(URI)的历史名字，它使用 <code>urn:</code> 作为 URI scheme。</p>
<div><p>相关信息</p>
<p>更多详情请见 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D" target="_blank" rel="noopener noreferrer">维基百科</a></p>
</div>
<h3 id="url"> URL</h3>
<p><strong>统一资源定位符</strong>(英语: Uniform Resource Locator，缩写: URL；或称统一资源定位器、定位地址、URL 地址，俗称网页地址或简称网址)是因特网上标准的资源的地址(Address)，如同在网络上的门牌。</p>
<div><p>相关信息</p>
<p>更多详情请见 <a href="./url.html">URL</a></p>
</div>
<h3 id="关系"> 关系</h3>
<p><img src="./assets/uri.png" alt="URL方案分类图" loading="lazy"></p>
<p>URL(定位符)和 URN(名称)方案属于 URI 的子类，URI 可以为 URL 或 URN 两者之一或同时是 URI 和 URN。技术上讲，URL 和 URN 属于资源 ID；但是，人们往往无法将某种方案归类于两者中的某一个: 所有的 URI 都可被作为名称看待，而某些方案同时体现了两者中的不同部分。
URI 可被视为定位符(URL)，名称(URN)或两者兼备。统一资源名(URN)如同一个人的名称，而统一资源定位符(URL)代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。</p>
<div><p>例子</p>
<p>用于标识唯一书目的 ISBN 系统是一个典型的 URN 使用范例。例如，ISBN <code>0-486-27557-4</code> 无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个 URL 地址。在类 Unix 操作系统中，一个典型的 URL 地址可能是一个文件目录，例如 <code>file:///home/username/RomeoAndJuliet.pdf</code>。该 URL 标识出存储于本地硬盘中的电子书文件。因此，URL 和 URN 有着互补的作用。</p>
</div>
<h3 id="技术观点"> 技术观点</h3>
<p>URL 是一种 URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述，也可能通过网络“位置”进行标识。例如，<a href="http://www.wikipedia.org/" target="_blank" rel="noopener noreferrer">http://www.wikipedia.org/</a> 这个 URL，标识一个特定资源(首页)并表示该资源的某种形式(例如以编码字符表示的，首页的 HTML 代码)是可以通过 HTTP 协议从 <code>www.wikipedia.org</code> 这个网络主机获得的。URN 是基于某名字空间通过名称指定资源的 URI。人们可以通过 URN 来指出某个资源，而无需指出其位置和获得方式。资源无需是基于互联网的。例如，URN <code>urn:ISBN 0-395-36341-1</code> 指定标识系统(即国际标准书号 ISBN)和某资源在该系统中的唯一表示的 URI。它可以允许人们在不指出其位置和获得方式的情况下谈论这本书。</p>
<p>技术刊物，特别是 IETF 和 W3C 发布的标准中，通常不再使用“URL”这一术语，因为很少需要区别 URL 和 URI。但是，在非技术文献和万维网软件中，URL 这一术语仍被广泛使用。此外，术语“网址”(没有正式定义)在非技术文献中时常作为 URL 或 URI 的同义词出现，虽然往往其指代的只是“http”和“https”协议。</p>
<h2 id="文法格式"> 文法格式</h2>
<div><pre><code>                    hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&amp;amp;key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment

  urn:example:mammal:monotreme:echidna
  └┬┘ └──────────────┬───────────────┘
scheme              path
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">URL</title>
    <id>https://list-jiang.github.io/code/website/html/definition/url/</id>
    <link href="https://list-jiang.github.io/code/website/html/definition/url/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p><strong>统一资源定位符</strong>(英语: Uniform Resource Locator，缩写: URL；或称统一资源定位器、定位地址、URL 地址，俗称网页地址或简称网址)是因特网上标准的资源的地址(Address)，如同在网络上的门牌。</p>
<p>统一资源定位符的标准格式如下:</p>
<div><pre><code>[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]
</code></pre>
<div><span>1</span><br></div></div><p>统一资源定位符的完整格式如下:</p>
<div><pre><code>[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]
</code></pre>
<div><span>1</span><br></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener noreferrer">维基百科</a></p>
</div>
<h2 id="绝对-url-和相对-url"> 绝对 URL 和相对 URL</h2>
<p>您可能会在网络上遇到两个术语，绝对 URL 和相对 URL(或者称为，绝对链接和相对链接):</p>
<h3 id="绝对-url"> 绝对 URL</h3>
<p>指向由其在 Web 上的绝对位置定义的位置，包括 protocol(协议) 和 domain name(域名)。</p>
<div><p>例子</p>
<p>如果 index.html 页面上传到 projects 这一个目录。并且 projects 目录位于 web 服务站点的根目录，web 站点的域名为 <code>http://www.example.com</code>，那么这个页面就可以通过 <code>http://www.example.com/projects/index.html</code> 访问(或者通过 <code>http://www.example.com/projects/</code> 来访问，因为在没有指定特定的 URL 的情况下，大多数 web 服务会默认访问加载 <code>index.html</code> 这类页面)</p>
</div>
<p>不管绝对 URL 在哪里使用，它总是指向确定的相同位置。</p>
<h3 id="相对-url"> 相对 URL</h3>
<p>指向与您链接的文件相关的位置，更像我们在前面一节中所看到的位置。例如，如果我们想从示例文件链接 <code>http://www.example.com/projects/index.html</code> 转到相同目录下的一个 PDF 文件，URL 就是文件名 URL(如: <code>project-brief.pdf</code>)。如果 PDF 文件能够在 projects 的子目录 pdfs 中访问到，相对路径就是 <code>pdfs/project-brief.pdf</code>(对应的绝对 URL 是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code>)</p>
<p>一个相对 URL 将指向不同的位置，这取决于它所在的文件所在的位置——例如，如果我们把 index.html 文件从 projects 目录移动到 Web 站点的根目录(最高级别，而不是任何目录中)，里面的 <code>pdfs/project-brief.pdf</code> 相对 URL 将会指向 <code>http://www.example.com/pdfs/project-brief.pdf</code>，而不是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code></p>
<p>当然，project-brief.pdf 文件和 pdfs 文件夹的位置不会因为您移动了 <code>index.html</code> 文件而突然发生变化——这将使您的链接指向错误的位置，因此如果单击它，它将无法工作。您得小心点!</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">快速上手</title>
    <id>https://list-jiang.github.io/code/website/html/guide/</id>
    <link href="https://list-jiang.github.io/code/website/html/guide/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章能让您快速了解 HTML 并学会编写它。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章能让您快速了解 HTML 并学会编写它。</p>

<h2 id="html-简介"> HTML 简介</h2>
<p>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage。它是一种用来结构化 Web 网页及其内容的标记语言。</p>
<p>HTML 不是一门编程语言，而是一种用于定义内容结构的<strong>标记语言</strong> (markup language)。HTML 由一系列的元素(elements)组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。<strong>标记标签</strong> (markup tag) 是 HTML 的基本语法。一对标签( tags)可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。</p>
<div><p>特点</p>
<ul>
<li>HTML 使用标记标签来<strong>描述</strong>网页。</li>
<li>HTML 文档包含了 <strong>HTML 标签</strong>及<strong>文本</strong>内容。</li>
<li>HTML 文档也叫做 <strong>Web 页面</strong>。</li>
</ul>
</div>
<h3 id="例子"> 例子</h3>
<p>对于一段文字</p>
<div><pre><code>Mr.Hope is handsome.
</code></pre>
<div><span>1</span><br></div></div><p>HTML 可以将这行文字封装成一个段落(<strong>p</strong>aragraph)元素来使其在单独一行呈现:</p>

          <div
            id="code-demo-67e4f5e1"
           
  
 data-title="HTML%20%E6%AE%B5%E8%90%BD"

            data-code="%7B%22html%22%3A%22%3Cp%3EMr.Hope%20is%20handsome.%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Mr.Hope is handsome.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>深入理解</p>
<p>HTML 中，除了<strong>语义</strong>，其他什么都没有。</p>
<p>HTML 是一个纯文本文件，用一些标签来描述文字的语义，这些标签在浏览器里面是看不到的，所以称为“超文本”，所以就是“超文本标记语言”了。</p>
<p>比如，面试的时候问您，<code>h1</code> 标签有什么作用?</p>
<ul>
<li>
<p>给文本增加主标题的语义。✔️</p>
</li>
<li>
<p>给文字加粗、加黑、变大。❌</p>
</li>
</ul>
</div>
<h2 id="html-元素语法"> HTML 元素语法</h2>
<p>一个元素是:</p>
<div><pre><code><span><span><span>&lt;</span>标签名称</span> <span>属性1</span><span><span>=</span><span>"</span>值1<span>"</span></span> <span>属性2</span><span><span>=</span><span>"</span>值2<span>"</span></span><span>...</span><span>></span></span>内容<span><span><span>&lt;/</span>标签名称</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>An element is:</p>
<div><pre><code><span><span><span>&lt;</span>tagname</span> <span>attribution1</span><span><span>=</span><span>"</span>value1<span>"</span></span> <span>attribution2</span><span><span>=</span><span>"</span>value2<span>"</span></span><span>></span></span>content<span><span><span>&lt;/</span>tagname</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
          <div
            id="code-demo-67e4f5e1"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cp%3EMr.Hope%20is%20handsome.%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Mr.Hope is handsome.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>元素的主要部分有:</p>
<ul>
<li>
<p><strong>开始标签</strong>(Opening tag): 包含元素的名称(本例为 p)，被 <code>&lt;</code>、<code>&gt;</code> 所包围。表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。</p>
</li>
<li>
<p><strong>结束标签</strong>(Closing tag): 与开始标签相似，只是其在元素名之前包含了一个 <code>/</code>。这表示着元素的结尾 —— 在本例中即段落在此结束。</p>
<div><p>注意</p>
<p>忘记包含结束标签可能会产生一些奇怪的结果。</p>
</div>
</li>
<li>
<p><strong>内容</strong>(Content): 元素的内容，本例中就是所输入的文本本身。</p>
</li>
<li>
<p><strong>元素</strong>(Element): 开始标签、结束标签与内容相结合，便是一个完整的元素。</p>
</li>
</ul>
<h3 id="标签"> 标签</h3>
<p><code>&lt;tagname ...&gt;</code> 是开始标签，<code>&lt;/tagname&gt;</code> 是结束标签。</p>
<p>案例中起始标签为 <code>&lt;p&gt;</code> 内容为 <code>Mr.Hope is handsome.</code> 闭合标签为 <code>&lt;/p&gt;</code>。</p>
<p>开始标签常被称为 <strong>起始标签(Opening tag)</strong>，结束标签常称为 <strong>闭合标签(Closing tag)</strong></p>
<h3 id="自闭合标签"> 自闭合标签</h3>
<p>如果标签内部没有内容，可以直接使用一个特殊的写法完成自身的闭合，即为自闭合标签。</p>
<p>格式:</p>
<div><pre><code><span><span><span>&lt;</span>tagname</span> <span>attribution1</span><span><span>=</span><span>"</span>value1<span>"</span></span> <span>attribution2</span><span><span>=</span><span>"</span>value2<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>即:</p>
<div><pre><code><span><span><span>&lt;</span>标签名称</span> <span>属性1</span><span><span>=</span><span>"</span>值1<span>"</span></span> <span>属性2</span><span><span>=</span><span>"</span>值2<span>"</span></span><span>...</span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>例子:</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>/></span></span>
<span>&lt;!--  属性="值"  --></span>

<span><span><span>&lt;</span>div</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>height</span><span>:</span>100px</span><span>"</span></span></span> <span>/></span></span>
<span>&lt;!--这里空的 div 用于占位置，“撑起”一块空间--></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>空标签</p>
<p>由于历史原因，一些 HTML 标签在设计时就不包含内容(例如: 图片 <code>&lt;img&gt;</code>，折行 <code>&lt;br&gt;</code>，分割线 <code>&lt;hr&gt;</code>，输入框 <code>&lt;input&gt;</code> 等)，这些标签被称为空标签。</p>
<p>在空标签内部添加内容是没有任何作用的，同时，空标签在初始时没有结束标签，以自身结束。</p>
<p>常见的空标签有 <code>br</code>、<code>hr</code>、<code>img</code>，不过还是建议写作 <code>&lt;br /&gt;</code>、<code>&lt;hr /&gt;</code>、<code>&lt;img /&gt;</code>。</p>
</div>
<h3 id="标签的嵌套"> 标签的嵌套</h3>
<p>除了并列放置标签以外，标签的内容也可以放置其他标签，这就构成了标签的嵌套。比如您想强调 Mr.Hope 的帅:</p>

          <div
            id="code-demo-3fadd1dd"
           
  
 data-title="%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B5%8C%E5%A5%97"

            data-code="%7B%22html%22%3A%22%3Cp%3EMr.Hope%20is%20%3Cstrong%3Every%3C%2Fstrong%3E%20handsome.%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Mr.Hope is <span><span><span>&lt;</span>strong</span><span>></span></span>very<span><span><span>&lt;/</span>strong</span><span>></span></span> handsome.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>总结</p>
<ul>
<li>HTML 元素以 <strong>开始标签</strong> 起始</li>
<li>HTML 元素以 <strong>结束标签</strong> 终止</li>
<li><strong>元素的内容</strong> 是开始标签与结束标签之间的内容</li>
<li>某些 HTML 元素具有 <strong>空内容 (empty content)</strong></li>
<li>空元素 <strong>在开始标签中进行关闭</strong> (以开始标签的结束使用 <code>/</code> 而结束)</li>
<li>大多数 HTML 元素可拥有<strong>属性</strong></li>
</ul>
</div>
<h2 id="html-属性"> HTML 属性</h2>
<p>属性包含元素的额外信息，这些信息不会出现在实际的内容中。</p>
<p>一个属性必须包含如下内容:</p>
<ol>
<li>在属性与元素名称(或上一个属性，如果有超过一个属性的话)之间的空格符</li>
<li>属性名称，后面跟着一个等于号。</li>
<li>一个属性值，由一对引号 <code>&quot; &quot;</code> 引起来。</li>
</ol>
<p>比如 <code>&lt;img src=&quot;/logo.png&quot; /&gt;</code>，<code>attribute</code> 为 <code>src</code>，<code>value</code> 是 <code>/logo.png</code></p>
<p>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。</p>
<p>在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如: <code>name='John &quot;ShotGun&quot; Nelson'</code></p>
<div><p>提示</p>
<p>尽管不包含 ASCII 空格(以及 <code>&quot;</code> <code>'</code> <code>`</code> <code>=</code> <code>&lt;</code> <code>&gt;</code> )的简单属性值可以不使用引号，但是建议将所有属性值用双引号(除必须使用单引号的情况)括起来，这样的代码一致性更佳，更易于阅读。</p>
</div>
<h3 id="适用于大多数-html-元素的属性"> 适用于大多数 HTML 元素的属性</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>为 HTML 元素定义一个或多个类名 (classname)</td>
</tr>
<tr>
<td>id</td>
<td>定义元素的唯一 id</td>
</tr>
<tr>
<td>style</td>
<td>规定元素的行内样式 (inline style)</td>
</tr>
<tr>
<td>title</td>
<td>描述了元素的额外信息</td>
</tr>
</tbody>
</table>
<h3 id="布尔属性"> 布尔属性</h3>
<p>有时您会看到没有值的属性，它是合法的。这些属性被称为布尔属性，他们只能有跟它的属性名一样的属性值。例如 <code>disabled</code> 属性，他们可以标记表单输入使之变为不可用(变灰色)，此时用户不能向他们输入任何数据。</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>disabled</span><span><span>=</span><span>"</span>disabled<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>方便起见，我们完全可以将其写成以下形式:</p>
<div><pre><code><span>&lt;!-- 使用disabled属性来防止终端用户输入文本到输入框中 --></span>
<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>disabled</span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="后缀名"> 后缀名</h2>
<p>HTML 文档的后缀名是 <code>.html</code>。</p>
<div><p>新手误区</p>
<p>文件名应该为 <code>xx.html</code>，不应该是 <code>html</code>。</p>
<p><code>html</code> 是一个没有后缀名称，文件名字叫做 <code>html</code> 的文件。</p>
<p>更多详情，请见 <a href="./../../../basic/file-extension.html">基础 → 文件后缀名</a>。</p>
</div>
<h2 id="html-结构"> HTML 结构</h2>
<p>一个符合最新标准的 HTML 文件，应该满足如下结构:</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span><span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>其中:</p>
<p><code>&lt;!DOCTYPE html&gt;</code> 是在 HTML5 标准下要求的，必须放在每个 HTML 文件的首行。对文档类型的声明。</p>
<blockquote>
<p><code>DOCTYPE</code> 可小写，此处无特殊要求。</p>
</blockquote>
<p>每个网页应该在 HTML 里包含一个唯一的 <code>&lt;html&gt;</code> 标签。在 <code>&lt;html&gt;</code> 标签中，应该按照顺序包含 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</p>
<p><code>&lt;head&gt;</code> 标签中，应该包含 <code>&lt;title&gt;</code> 标签注明文档的标题。</p>
<div><p>提示</p>
<p><code>&lt;head&gt;</code> 元素是一个容器，它包含了所有您想包含在 HTML 页面中但不想在 HTML 页面中显示的内容。这些内容包括您想在搜索结果中出现的关键字和页面描述，CSS 样式，字符集声明等等。</p>
<p><code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code> 元素设置文档使用 utf-8 字符集编码，utf-8 字符集包含了人类大部分的文字。基本上他能识别您放上去的所有文本内容。毫无疑问要使用它，并且它能在以后避免很多其他问题。所以建议任何 HTML 文件都包含此标签。</p>
<p>更多详情，请见 <a href="./../intro/head.html">介绍 → head 标签</a>。</p>
</div>
<p><code>&lt;body&gt;</code> 标签包含了您访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。</p>
<h2 id="html-空白"> HTML 空白</h2>
<p>您可能已经注意到了在代码中包含了很多的空格——这是没有必要的。</p>

          <div
            id="code-demo-6718c0b6"
           
  
 data-title="%E4%B8%A4%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%AD%89%E4%BB%B7%E7%9A%84%E6%AE%B5%E8%90%BD"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E7%8B%97%20%20%20%20%E7%8B%97%5Cn%E5%BE%88%20%E5%91%86%20%E8%90%8C%E3%80%82%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%E7%8B%97%20%E7%8B%97%20%E5%BE%88%20%E5%91%86%20%E8%90%8C%E3%80%82%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>狗    狗
很 呆 萌。<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>狗 狗 很 呆 萌。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>无论您在 HTML 元素的内容中使用多少空格(包括空白字符，包括换行)，当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。</p>
<p>那么为什么我们会在 HTML 元素的嵌套中使用那么多的空白呢? 答案就是为了可读性 —— 如果您的代码被很好地进行格式化，那么就很容易理解您的代码是怎么回事，反之就只有聚做一团的混乱。在 HTML 代码中，通常让每一个嵌套的元素以两个空格缩进。</p>
<h2 id="特殊字符"> 特殊字符</h2>
<p>在 HTML 中，字符 <code>&lt;</code>, <code>&gt;</code>,<code>&quot;</code>,<code>'</code> 和 <code>&amp;</code> 是特殊字符. 它们是 HTML 语法自身的一部分, 那么您如何将这些字符包含进您的文本中呢, 比如说如果您真的想要在文本中使用符号 <code>&amp;</code> 或者 <code>&lt;</code> 号, 而不想让它们被浏览器视为代码并被解释?</p>
<p>我们必须使用字符引用 —— 表示字符的特殊编码, 它们可以在那些情况下使用. 每个字符引用以符号 <code>&amp;</code> 开始, 以分号 (<code>;</code>) 结束。</p>
<table>
<thead>
<tr>
<th>原义字符</th>
<th>等价字符引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>&amp;lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt;</td>
</tr>
<tr>
<td>&quot;</td>
<td>&amp;quot;</td>
</tr>
<tr>
<td>'</td>
<td>&amp;apos;</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;amp;</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">常见标签</title>
    <id>https://list-jiang.github.io/code/website/html/guide/tag/</id>
    <link href="https://list-jiang.github.io/code/website/html/guide/tag/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="html-标题"> HTML 标题</h2>
<p>HTML 标题 (Heading) 是通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签来定义的。</p>

          <div
            id="code-demo-adb93076"
           
  
 data-title="HTML%20%E6%A0%87%E9%A2%98"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98%3C%2Fh1%3E%5Cn%3Ch2%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98%3C%2Fh2%3E%5Cn%3Ch3%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98%3C%2Fh3%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>这是一个标题<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>h2</span><span>></span></span>这是一个标题<span><span><span>&lt;/</span>h2</span><span>></span></span>
<span><span><span>&lt;</span>h3</span><span>></span></span>这是一个标题<span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="html-段落"> HTML 段落</h2>
<p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的。</p>

          <div
            id="code-demo-4d77d9a6"
           
  
 data-title="HTML%20%E6%AE%B5%E8%90%BD"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%E3%80%82%3C%2Fp%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%E3%80%82%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是另外一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="html-列表"> HTML 列表</h2>
<p>文档许多内容都是列表，HTML 有一些特别的列表元素。标记列表通常包括至少两个元素。最常用的列表类型为:</p>
<ul>
<li>无序列表 (Unordered List) 中项目的顺序不重要，比如购物清单。用一个 <code>&lt;ul&gt;</code> 元素包围。</li>
<li>有序列表 (Ordered List) 中项目的顺序很重要，比如使用指南。用一个 <code>&lt;ol&gt;</code> 元素包围。</li>
</ul>
<p>列表的每个项目用一个列表项目 (List Item) 元素 <code>&lt;li&gt;</code> 包围。</p>

          <div
            id="code-demo-6fc9a639"
           
  
 data-title="HTML%20%E5%88%97%E8%A1%A8"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E8%B4%AD%E7%89%A9%E6%B8%85%E5%8D%95%3C%2Fp%3E%5Cn%3Cul%3E%5Cn%20%20%3Cli%3E%E7%89%9B%E5%A5%B6%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E9%B8%A1%E8%9B%8B%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E9%9D%A2%E7%B2%89%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%5Cn%3Cp%3E%E6%8A%8A%E5%A4%A7%E8%B1%A1%E6%94%BE%E8%BF%9B%E5%86%B0%E7%AE%B1%3C%2Fp%3E%5Cn%3Col%3E%5Cn%20%20%3Cli%3E%E6%89%93%E5%BC%80%E5%86%B0%E7%AE%B1%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E5%A1%9E%E5%85%A5%E5%A4%A7%E8%B1%A1%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E5%85%B3%E4%B8%8A%E5%86%B0%E7%AE%B1%3C%2Fli%3E%5Cn%3C%2Fol%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>购物清单<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>牛奶<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>鸡蛋<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>面粉<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>把大象放进冰箱<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>打开冰箱<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>塞入大象<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>关上冰箱<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="html-链接"> HTML 链接</h2>
<p>HTML 链接是通过标签 <code>&lt;a&gt;</code> 来定义的。</p>

          <div
            id="code-demo-462b0041"
           
  
 data-title="HTML%20%E9%93%BE%E6%8E%A5"

            data-code="%7B%22html%22%3A%22%3Ca%20href%3D%5C%22https%3A%2F%2Fmrhope.site%5C%22%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%93%BE%E6%8E%A5%3C%2Fa%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://mrhope.site<span>"</span></span><span>></span></span>这是一个链接<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>提示</p>
<p>href 属性指定链接的地址。</p>
</div>
<h2 id="html-图像"> HTML 图像</h2>
<p>HTML 图像是通过标签 <code>&lt;img&gt;</code> 来定义的。</p>

          <div
            id="code-demo-73d3e31e"
           
  
 data-title="HTML%20%E5%9B%BE%E5%83%8F"

            data-code="%7B%22html%22%3A%22%3Cimg%20src%3D%5C%22%2Flogo.png%5C%22%20width%3D%5C%2260%5C%22%20height%3D%5C%2260%5C%22%20%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>/logo.png<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>60<span>"</span></span> <span>height</span><span><span>=</span><span>"</span>60<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="html-水平线"> HTML 水平线</h2>
<p><code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线。</p>
<p><code>hr</code> 元素可用于分隔内容。</p>

          <div
            id="code-demo-6f1d8bbc"
           
  
 data-title="HTML%20%E6%B0%B4%E5%B9%B3%E7%BA%BF"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%E3%80%82%3C%2Fp%3E%5Cn%3Chr%20%2F%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%E3%80%82%3C%2Fp%3E%5Cn%3Chr%20%2F%3E%5Cn%3Cp%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%E3%80%82%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>hr</span> <span>/></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>hr</span> <span>/></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>这是一个段落。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="html-注释"> HTML 注释</h2>
<p>如同大部分的编程语言一样，在 HTML 中可以添加注释。</p>
<p>注释是被浏览器忽略的，而且是对用户不可见的，它们的目的是允许您描述您的代码是如何工作的和不同部分的代码做了什么等等。</p>
<p>注释写法如下:</p>
<div><pre><code><span>&lt;!-- 这是一个注释 --></span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>开始括号之后(左边的括号)需要紧跟一个叹号，结束括号之前(右边的括号)不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。</p>
</div>
<h2 id="html-折行"> HTML 折行</h2>
<p>如果您希望在不产生一个新段落的情况下进行换行(新行)，请使用 <code>&lt;br&gt;</code> 标签:</p>

          <div
            id="code-demo-7073d171"
           
  
 data-title="HTML%20%E6%8A%98%E8%A1%8C"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E8%BF%99%E4%B8%AA%3Cbr%20%2F%3E%E6%AE%B5%E8%90%BD%3Cbr%20%2F%3E%E6%BC%94%E7%A4%BA%E4%BA%86%E5%88%86%E8%A1%8C%E7%9A%84%E6%95%88%E6%9E%9C%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>这个<span><span><span>&lt;</span>br</span> <span>/></span></span>段落<span><span><span>&lt;</span>br</span> <span>/></span></span>演示了分行的效果<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>&lt;br /&gt;</code> 元素是一个空的 HTML 元素。所以推荐写成自闭合标签的形式。</p>
<h2 id="html-块"> HTML 块</h2>
<p>在开发中，最常用的就是块标签(<code>&lt;div /&gt;</code>)。</p>

          <div
            id="code-demo-4e08d972"
           
  
 data-title="HTML%20%E5%9D%97"

            data-code="%7B%22html%22%3A%22%3Cdiv%3E%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%9D%97%3C%2Fdiv%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>这是一个没有任何样式的块<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="其他标签"> 其他标签</h2>
<p>更多 HTML 标签如 <code>&lt;form&gt;</code> <code>&lt;button&gt;</code> 等，请见: <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener noreferrer">MDN 文档</a>。</p>
<div><p>提示</p>
<p>请注意，不要使用弃用的元素，如 <code>&lt;center&gt;</code> <code>&lt;font&gt;</code> 等。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">基础内容</title>
    <id>https://list-jiang.github.io/code/website/html/intro/basic/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/basic/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章是最常见的的 HTML 标签介绍。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章是最常见的的 HTML 标签介绍。</p>

<h2 id="标题和段落"> 标题和段落</h2>
<p>大部分的文本结构由标题和段落组成。不管是小说、报刊、教科书还是杂志等。</p>
<p>内容结构化会使读者的阅读体验更轻松，更愉快。</p>
<p>在 HTML 中，每个段落是通过 <code>&lt;p&gt;</code> 元素标签进行定义的, 比如下面这样:</p>

          <div
            id="code-demo-6dfc57e5"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%90%BD%EF%BC%8C%E5%8D%83%E7%9C%9F%E4%B8%87%E7%A1%AE%E3%80%82%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>我是一个段落，千真万确。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>每个标题(Heading)是通过“标题标签”进行定义的:</p>

          <div
            id="code-demo-517b28b2"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%A0%87%E9%A2%98"

            data-code="%7B%22html%22%3A%22%3Ch1%3E%E6%88%91%E6%98%AF%E6%96%87%E7%AB%A0%E7%9A%84%E6%A0%87%E9%A2%98%3C%2Fh1%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>我是文章的标题<span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>这里有六个标题元素标签 —— <code>&lt;h1&gt;</code>、<code>&lt;h2&gt;</code>、<code>&lt;h3&gt;</code>、<code>&lt;h4&gt;</code>、<code>&lt;h5&gt;</code>、<code>&lt;h6&gt;</code>。每个元素代表文档中不同级别的内容; <code>&lt;h1&gt;</code> 表示主标题(the main heading)，<code>&lt;h2&gt;</code> 表示二级子标题(subheadings)，<code>&lt;h3&gt;</code> 表示三级子标题(sub-subheadings)，等等。</p>
<div><p>最佳实践</p>
<ul>
<li>
<p>您应该最好只对每个页面使用一次 <code>&lt;h1&gt;</code> — 这是顶级标题，所有其他标题位于层次结构中的下方。</p>
</li>
<li>
<p>请确保在层次结构中以正确的顺序使用标题。不要使用 <code>&lt;h3&gt;</code> 来表示副标题，后面跟 <code>&lt;h2&gt;</code> 来表示副副标题 - 这是没有意义的，会导致奇怪的结果。</p>
</li>
<li>
<p>在可用的六个标题级别中，您应该旨在每页使用不超过三个，除非您认为有必要使用更多。具有许多级别的文档(即，较深的标题层次结构)变得难以操作并且难以导航。在这种情况下，如果可能，建议将内容分散在多个页面上。</p>
</li>
</ul>
</div>
<div><p>为什么需要结构化</p>
<p>这是因为没有元素给内容结构，所以浏览器不知道什么是标题，什么是段落。此外:</p>
<ul>
<li>用户在阅读网页时，往往会快速浏览以查找相关内容，经常只是阅读开头的标题(我们通常在一个网页上会花费很少的时间)。如果用户不能在几秒内看到一些有用的内容，他们很可能会感到沮丧并离开。</li>
<li>对您的网页建立索引的搜索引擎将标题的内容视为影响网页搜索排名的重要关键字。没有标题，您的网页在 SEO(搜索引擎优化)方面效果不佳。</li>
<li>严重视力障碍者通常不会阅读网页；他们用听力来代替。完成这项工作的软件叫做屏幕阅读器(screen reader)。该软件提供了快速访问给定文本内容的方法。在使用的各种技术中，它们通过朗读标题来提供文档的概述，让用户能快速找到他们需要的信息。如果标题不可用，用户将被迫听到整个文档的大声朗读。</li>
<li>使用 CSS 样式化内容，或者使用 JavaScript 做一些有趣的事情，您需要包含相关内容的元素，所以 CSS / JavaScript 可以有效地定位它。</li>
</ul>
</div>
<div><p>为什么需要语义</p>
<p>在我们身边的任何地方都要依赖语义学。我们依靠以前的经验就知道日常事物都代表什么；当我们看到什么，我们就会知道它代表什么。举个例子, 我们知道红色交通灯表示“停止”，绿色交通灯表示”通行“。</p>
<p>同样的道理，我们需要确保使用了正确的元素来给予内容正确的意思、作用以及外形。在这里，<code>&lt;h1&gt;</code> 元素也是一个语义元素，它给出了包裹在您的页面上用来表示顶级标题的角色(或意义)的文本。</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>这是一个顶级标题<span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>一般来说，浏览器会给它一个更大的字形来让它看上去像个标题。虽然您可以使用 CSS 让它变成任何您想要的样式。更重要的是，它的语义值将以多种方式被使用，比如通过搜索引擎和屏幕阅读器(上文提到过的)。</p>
<p>在另一方面，您可以让任一元素看起来像一个顶级标题，如下:</p>

          <div
            id="code-demo-ab86c496"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E5%83%8F%E9%A1%B6%E7%BA%A7%E6%A0%87%E9%A2%98%E7%9A%84%20span"

            data-code="%7B%22html%22%3A%22%3Cspan%20style%3D%5C%22font-size%3A%2032px%3B%20margin%3A%2021px%200%3B%5C%22%3E%E8%BF%99%E6%98%AF%E9%A1%B6%E7%BA%A7%E6%A0%87%E9%A2%98%E5%90%97%3F%20%3C%2Fspan%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>span</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 32px<span>;</span> <span>margin</span><span>:</span> 21px 0<span>;</span></span><span>"</span></span></span><span>></span></span>这是顶级标题吗? <span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>这是一个 <code>&lt;span&gt;</code> 元素，它没有语义。当您想要对它用 CSS(或者 JS)时，您可以用它包裹内容，且不需要附加任何额外的意义。我们已经对它使用了 CSS 来让它看起来像一个顶级标题。然而，由于它没有语义值，所以它不会有任何上文提到的帮助。最好的方法是使用相关的 HTML 元素来标记这个项目。</p>
</div>
<h2 id="列表"> 列表</h2>
<p>列表在生活中随处可见，一共有三种不同类型的列表。</p>
<h3 id="无序-unordered"> 无序 Unordered</h3>
<p>无序的列表被用来标记每个项目。在这里，项目的顺序并不重要。</p>
<div><pre><code>豆浆
油条
豆汁
焦圈
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>每份无序的清单从 <code>&lt;ul&gt;</code> 元素开始，它包裹所有列表项目，下一步就是用 <code>&lt;li&gt;</code> 元素把每个列出的项目分别包裹起来:</p>

          <div
            id="code-demo-220663d2"
           
  
 data-title="%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8"

            data-code="%7B%22html%22%3A%22%3Cul%3E%5Cn%20%20%3Cli%3E%E8%B1%86%E6%B5%86%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E6%B2%B9%E6%9D%A1%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E8%B1%86%E6%B1%81%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E7%84%A6%E5%9C%88%3C%2Fli%3E%5Cn%3C%2Ful%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>豆浆<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>油条<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>豆汁<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>焦圈<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="有序-ordered"> 有序 Ordered</h3>
<p>有序的列表是根据项目的顺序列出来的——让我们以一组方向为例:</p>
<div><pre><code>沿着条路走到头
右转
直行穿过第一个十字路口
在第三个十字路口处左转
继续走 300 米，学校就在您的右手边
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个标记的结构和无序列表一样，唯一不同的是您需要用 <code>&lt;ol&gt;</code> 元素将所有项目包裹, 而不是用 <code>&lt;ul&gt;</code>:</p>

          <div
            id="code-demo-c65d6006"
           
  
 data-title="%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8"

            data-code="%7B%22html%22%3A%22%3Col%3E%5Cn%20%20%3Cli%3E%E6%B2%BF%E7%9D%80%E6%9D%A1%E8%B7%AF%E8%B5%B0%E5%88%B0%E5%A4%B4%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E5%8F%B3%E8%BD%AC%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E7%9B%B4%E8%A1%8C%E7%A9%BF%E8%BF%87%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E5%9C%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E5%A4%84%E5%B7%A6%E8%BD%AC%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E7%BB%A7%E7%BB%AD%E8%B5%B0%20300%20%E7%B1%B3%EF%BC%8C%E5%AD%A6%E6%A0%A1%E5%B0%B1%E5%9C%A8%E6%82%A8%E7%9A%84%E5%8F%B3%E6%89%8B%E8%BE%B9%3C%2Fli%3E%5Cn%3C%2Fol%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>沿着条路走到头<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>右转<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>直行穿过第一个十字路口<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>在第三个十字路口处左转<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>继续走 300 米，学校就在您的右手边<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="描述列表"> 描述列表</h3>
<p>详情请见 <a href="./format.html#描述列表">格式化 → 描述列表</a></p>
<h3 id="嵌套列表-nesting-lists"> 嵌套列表 Nesting lists</h3>
<p>请务必注意正确嵌套列表，不要忘记父元素 <code>&lt;ul&gt;</code></p>

          <div
            id="code-demo-12e4655d"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8"

            data-code="%7B%22html%22%3A%22%3Col%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E5%85%88%E7%94%A8%E8%9B%8B%E7%99%BD%E4%B8%80%E4%B8%AA%E3%80%81%E7%9B%90%E5%8D%8A%E8%8C%B6%E5%8C%99%E5%8F%8A%E6%B7%80%E7%B2%89%E4%B8%A4%E5%A4%A7%E5%8C%99%E6%90%85%E6%8B%8C%E5%9D%87%E5%8C%80%EF%BC%8C%E8%B0%83%E6%88%90%E2%80%9C%E8%85%8C%E6%96%99%E2%80%9D%EF%BC%8C%E9%B8%A1%E8%83%B8%E8%82%89%E5%88%87%E6%88%90%E7%BA%A6%E4%B8%80%E5%8E%98%E7%B1%B3%E8%A7%81%E6%96%B9%E7%9A%84%E7%A2%8E%E4%B8%81%E5%B9%B6%E7%94%A8%E2%80%9C%E8%85%8C%E6%96%99%E2%80%9D%E6%90%85%E6%8B%8C%E5%9D%87%E5%8C%80%EF%BC%8C%E8%85%8C%E6%B8%8D%E5%8D%8A%E5%B0%8F%E6%97%B6%E3%80%82%5Cn%20%20%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E7%94%A8%E9%85%B1%E6%B2%B9%E4%B8%80%E5%A4%A7%E5%8C%99%E3%80%81%E6%B7%80%E7%B2%89%E6%B0%B4%E4%B8%80%E5%A4%A7%E5%8C%99%E3%80%81%E7%B3%96%E5%8D%8A%E8%8C%B6%E5%8C%99%E3%80%81%E7%9B%90%E5%9B%9B%E5%88%86%E4%B9%8B%E4%B8%80%E8%8C%B6%E5%8C%99%E3%80%81%E7%99%BD%E9%86%8B%E4%B8%80%E8%8C%B6%E5%8C%99%E3%80%81%E8%92%9C%E6%9C%AB%E5%8D%8A%E8%8C%B6%E5%8C%99%E8%B0%83%E6%8B%8C%E5%9D%87%E5%8C%80%EF%BC%8C%E8%B0%83%E6%88%90%E2%80%9C%E7%BB%BC%E5%90%88%E8%B0%83%E5%91%B3%E6%96%99%E2%80%9D%E3%80%82%5Cn%20%20%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E9%B8%A1%E4%B8%81%E8%85%8C%E5%A5%BD%E4%BB%A5%E5%90%8E%EF%BC%8C%E8%89%B2%E6%8B%89%E6%B2%B9%E4%B8%8B%E9%94%85%E7%83%A7%E7%83%AD%EF%BC%8C%E5%85%88%E5%B0%86%E9%B8%A1%E4%B8%81%E5%80%92%E5%85%A5%E9%94%85%E5%86%85%EF%BC%8C%E7%94%A8%E5%A4%A7%E7%81%AB%E5%BF%AB%E7%82%B8%E5%8D%8A%E5%88%86%E9%92%9F%EF%BC%8C%E7%82%B8%E5%88%B0%E5%8F%98%E8%89%B2%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8D%9E%E5%87%BA%E6%9D%A5%E6%B2%A5%E5%B9%B2%E6%B2%B9%E6%B1%81%E5%A4%87%E7%94%A8%E3%80%82%5Cn%20%20%3C%2Fli%3E%5Cn%20%20%3Cli%3E%5Cn%20%20%20%20%E5%9C%A8%E9%94%85%E9%87%8C%E7%95%99%E4%B8%8B%E7%BA%A6%E4%B8%A4%E5%A4%A7%E5%8C%99%E6%B2%B9%EF%BC%8C%E7%83%A7%E7%83%AD%E5%90%8E%E5%B0%86%E5%88%87%E5%A5%BD%E7%9A%84%E5%B9%B2%E8%BE%A3%E6%A4%92%E4%B8%8B%E9%94%85%EF%BC%8C%E7%94%A8%E5%B0%8F%E7%81%AB%E7%82%92%E9%A6%99%E5%90%8E%EF%BC%8C%E5%86%8D%E6%94%BE%E5%85%A5%E8%8A%B1%E6%A4%92%E7%B2%92%E5%92%8C%E8%91%B1%E6%AE%B5%E4%B8%80%E8%B5%B7%E7%88%86%E9%A6%99%E3%80%82%E9%9A%8F%E5%90%8E%E9%B8%A1%E4%B8%81%E9%87%8D%E6%96%B0%E4%B8%8B%E9%94%85%EF%BC%8C%E7%94%A8%E5%A4%A7%E7%81%AB%E5%BF%AB%E7%82%92%E7%89%87%E5%88%BB%E5%90%8E%EF%BC%8C%E5%86%8D%E5%80%92%E5%85%A5%E2%80%9C%E7%BB%BC%E5%90%88%E8%B0%83%E5%91%B3%E6%96%99%E2%80%9D%E7%BB%A7%E7%BB%AD%E5%BF%AB%E7%82%92%E3%80%82%5Cn%20%20%20%20%3Cul%3E%5Cn%20%20%20%20%20%20%3Cli%3E%5Cn%20%20%20%20%20%20%20%20%E5%A6%82%E6%9E%9C%E6%82%A8%E9%87%87%E7%94%A8%E6%AD%A3%E5%AE%97%E5%B7%9D%E8%8F%9C%E5%81%9A%E6%B3%95%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%AA%E9%9C%80%E5%8A%A0%E5%85%A5%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%8C%E7%82%92%E6%8B%8C%E5%87%A0%E4%B8%8B%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%B5%B7%E9%94%85%E4%BA%86%E3%80%82%5Cn%20%20%20%20%20%20%3C%2Fli%3E%5Cn%20%20%20%20%20%20%3Cli%3E%E5%A6%82%E6%9E%9C%E6%82%A8%E5%9C%A8%E5%8C%97%E6%96%B9%EF%BC%8C%E5%8F%AF%E5%8A%A0%E5%85%A5%E9%BB%84%E7%93%9C%E4%B8%81%E3%80%81%E8%83%A1%E8%90%9D%E5%8D%9C%E4%B8%81%E5%92%8C%E8%8A%B1%E7%94%9F%E7%B1%B3%EF%BC%8C%E7%BF%BB%E7%82%92%E5%90%8E%E8%B5%B7%E9%94%85%E3%80%82%3C%2Fli%3E%5Cn%20%20%20%20%3C%2Ful%3E%5Cn%20%20%3C%2Fli%3E%5Cn%3C%2Fol%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    先用蛋白一个、盐半茶匙及淀粉两大匙搅拌均匀，调成“腌料”，鸡胸肉切成约一厘米见方的碎丁并用“腌料”搅拌均匀，腌渍半小时。
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    用酱油一大匙、淀粉水一大匙、糖半茶匙、盐四分之一茶匙、白醋一茶匙、蒜末半茶匙调拌均匀，调成“综合调味料”。
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    鸡丁腌好以后，色拉油下锅烧热，先将鸡丁倒入锅内，用大火快炸半分钟，炸到变色之后，捞出来沥干油汁备用。
  <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>
    在锅里留下约两大匙油，烧热后将切好的干辣椒下锅，用小火炒香后，再放入花椒粒和葱段一起爆香。随后鸡丁重新下锅，用大火快炒片刻后，再倒入“综合调味料”继续快炒。
    <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>
        如果您采用正宗川菜做法，最后只需加入花生米，炒拌几下就可以起锅了。
      <span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span>如果您在北方，可加入黄瓜丁、胡萝卜丁和花生米，翻炒后起锅。<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="重点强调"> 重点强调</h2>
<p>在人类语言中，为了突出一句话的意思，我们通常强调某些词，并且我们通常想要标记某些词作为重点或者在某种程度上的不同。HTML 提供了许多语义化的元素，并且允许我们通过这些元素的意义标记正文内容，在这个章节中，我们将看到最常见的一小部分元素。</p>
<h3 id="强调"> 强调</h3>
<p>当我们想要在口语中添加强调，我们重读某些词，以便隐含的说出我们想要说的意思。类似的，在写作中，我们通过将文字写成斜体来强调它。比如，接下来的两个句子就有不同的含义.</p>
<p>I am glad you weren’t late.</p>
<p>I am <em>glad</em> you weren’t <em>late</em>.</p>
<p>第一句话听起来真的像松了一口气因为没有迟到。相反，第二句话听起来具有讽刺性而且有隐含的攻击性，表达对一个人迟到的恼怒。</p>
<p>在 HTML 中我们用 <code>&lt;em&gt;</code>(emphasis)元素来标记这样的情况。这样做既可以让文档读起来更有趣，也可以被屏幕阅读器识别出来，并以不同的语调发出。浏览器默认风格为斜体，但您不应该纯粹使用这个标签来获得斜体风格，为了获得斜体风格，您应该使用 <code>&lt;span&gt;</code> 元素和一些 CSS，或者是 <code>&lt;i&gt;</code> 元素(见下文)。</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>I am <span><span><span>&lt;</span>em</span><span>></span></span>glad<span><span><span>&lt;/</span>em</span><span>></span></span> you weren't <span><span><span>&lt;</span>em</span><span>></span></span>late<span><span><span>&lt;/</span>em</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="非常重要"> 非常重要</h3>
<p>为了强调重要的词，在口语方面我们往往用重音强调，在文字方面则是用粗体字来达到强调的效果。</p>
<p>在 HTML 中我们用 <code>&lt;strong&gt;</code> (strong importance) 元素来标记这样的请况。这样做既可以让文档更加地有用，也可以被屏幕阅读器识别出来，并以不同的语调发出。浏览器默认风格为粗体，但您不应该纯粹使用这个标签来获得粗体风格，为了获得粗体风格，您应该使用 <code>&lt;span&gt;</code> 元素和一些 CSS，或者是 <code>&lt;b&gt;</code> 元素 (见下文)。</p>

          <div
            id="code-demo-6e20e3ca"
           
  
 data-title="%E5%BC%BA%E8%B0%83"

            data-code="%7B%22html%22%3A%22%3Cp%3EThis%20liquid%20is%20%3Cstrong%3Ehighly%20toxic%3C%2Fstrong%3E.%3C%2Fp%3E%5Cn%5Cn%3Cp%3EI%20am%20counting%20on%20you.%20%3Cstrong%3EDo%20not%3C%2Fstrong%3E%20be%20late!%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>This liquid is <span><span><span>&lt;</span>strong</span><span>></span></span>highly toxic<span><span><span>&lt;/</span>strong</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>I am counting on you. <span><span><span>&lt;</span>strong</span><span>></span></span>Do not<span><span><span>&lt;/</span>strong</span><span>></span></span> be late!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>如有需要您可以将 strong 元素和 em 元素嵌套在其他的标签中:</p>

          <div
            id="code-demo-fed5685e"
           
  
 data-title="%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B5%8C%E5%A5%97"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20This%20liquid%20is%20%3Cstrong%3Ehighly%20toxic%3C%2Fstrong%3E%20%E2%80%94%20if%20you%20drink%20it%2C%5Cn%20%20%3Cstrong%3Eyou%20may%20%3Cem%3Edie%3C%2Fem%3E%3C%2Fstrong%5Cn%20%20%3E.%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  This liquid is <span><span><span>&lt;</span>strong</span><span>></span></span>highly toxic<span><span><span>&lt;/</span>strong</span><span>></span></span> — if you drink it,
  <span><span><span>&lt;</span>strong</span><span>></span></span>you may <span><span><span>&lt;</span>em</span><span>></span></span>die<span><span><span>&lt;/</span>em</span><span>></span></span><span><span><span>&lt;/</span>strong</span>
  <span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="斜体字、粗体字、下划线"> 斜体字、粗体字、下划线</h3>
<p>迄今为止我们已经讨论的元素都是意义清楚的语义元素。<code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, 和 <code>&lt;u&gt;</code> 的情况却有点复杂。它们出现于人们要在文本中使用粗体、斜体、下划线但 CSS 仍然不被完全支持的时期。像这样的元素，仅仅影响表象而且没有语义，被称为表象元素(presentational elements)并且不应该再被使用。因为正如我们在之前看到的，语义对可访问性，SEO(搜索引擎优化)等非常重要。</p>
<p>HTML5 用新的语义规则重新定义了 <code>&lt;b&gt;</code>,<code>&lt;i&gt;</code> 和 <code>&lt;u&gt;</code>,稍微有点混乱。</p>
<p>这里是最好的经验法则: 使用 <code>&lt;b&gt;</code>,<code>&lt;i&gt;</code>,<code>&lt;u&gt;</code> 来传达传统意义上的粗体，斜体或下划线是合适的，没有其他元素更适合这样用了。然而，始终拥有可访问性的思维模式是至关重要的。斜体的概念对人们使用屏幕阅读器是没有帮助的，对使用其他书写系统而不是拉丁文书写系统的人们也是没有帮助的。</p>
<ul>
<li><code>&lt;i&gt;</code> 被用来传达传统上用斜体表达的意义: 外国文字，分类名称，技术术语，一种思想……</li>
<li><code>&lt;b&gt;</code> 被用来传达传统上用粗体表达的意义: 关键字，产品名称，引导句……</li>
<li><code>&lt;u&gt;</code> 被用来传达传统上用下划线表达的意义: 专有名词，拼写错误……</li>
</ul>

          <div
            id="code-demo-4e208604"
           
  
 data-title="%E6%96%9C%E4%BD%93%E5%AD%97%E3%80%81%E7%B2%97%E4%BD%93%E5%AD%97%E3%80%81%E4%B8%8B%E5%88%92%E7%BA%BF"

            data-code="%7B%22html%22%3A%22%3C!--%20%E5%AD%A6%E5%90%8D%20--%3E%5Cn%3Cp%3E%E7%BA%A2%E5%96%89%E5%8C%97%E8%9C%82%E9%B8%9F(%E5%AD%A6%E5%90%8D%3A%20%3Ci%3EArchilocus%20colubris%3C%2Fi%3E)%20%E6%98%AF%E5%8C%97%E7%BE%8E%E4%B8%9C%E9%83%A8%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E8%9C%82%E9%B8%9F%E5%93%81%E7%A7%8D%E3%80%82%3C%2Fp%3E%5Cn%5Cn%3C!--%20%E8%88%B6%E6%9D%A5%E8%AF%8D%20--%3E%5Cn%3Cp%3E%5Cn%20%20%E8%8F%9C%E5%8D%95%E4%B8%8A%E6%9C%89%E5%A5%BD%E5%A4%9A%E8%88%B6%E6%9D%A5%E8%AF%8D%E6%B1%87%EF%BC%8C%E6%AF%94%E5%A6%82%20%3Ci%20lang%3D%5C%22uk-latn%5C%22%3Evatrushka%3C%2Fi%3E(%E4%B8%9C%E6%AC%A7%E4%B9%B3%E9%85%AA%E9%9D%A2%E5%8C%85)%2C%5Cn%20%20%3Ci%20lang%3D%5C%22id%5C%22%3Enasi%20goreng%3C%2Fi%3E(%E5%8D%B0%E5%B0%BC%E7%82%92%E9%A5%AD)%E4%BB%A5%E5%8F%8A%3Ci%20lang%3D%5C%22fr%5C%22%3Esoupe%20%C3%A0%20l'oignon%3C%2Fi%5Cn%20%20%3E(%E6%B3%95%E5%BC%8F%E6%B4%8B%E8%91%B1%E6%B1%A4)%E3%80%82%5Cn%3C%2Fp%3E%5Cn%5Cn%3C!--%20%E5%B7%B2%E7%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF%E4%B9%A6%E5%86%99%20--%3E%5Cn%3Cp%3E%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E6%88%91%E4%BC%9A%E6%94%B9%E6%8E%89%E5%86%99%3Cu%3E%E6%8E%AA%E5%AD%97%3C%2Fu%3E%E7%9A%84%E6%AF%9B%E7%97%85%E3%80%82%3C%2Fp%3E%5Cn%5Cn%3C!--%20%E7%B3%BB%E5%88%97%E8%AF%B4%E6%98%8E%E6%96%87%E5%AD%97%E4%B8%AD%E9%9C%80%E8%A6%81%E7%AA%81%E5%87%BA%E7%9A%84%E6%96%87%E5%AD%97%20--%3E%5Cn%3Col%3E%5Cn%20%20%3Cli%3E%3Cb%3E%E5%88%87%3C%2Fb%3E%E4%B8%8B%E4%B8%A4%E7%89%87%E9%9D%A2%E5%8C%85%EF%BC%8C%3C%2Fli%3E%5Cn%20%20%3Cli%3E%E5%9C%A8%E4%B8%A4%E7%89%87%E9%9D%A2%E5%8C%85%E4%B8%AD%E9%97%B4%3Cb%3E%E5%A4%B9%E5%85%A5%3C%2Fb%3E%E4%B8%80%E7%89%87%E8%A5%BF%E7%BA%A2%E6%9F%BF%E5%92%8C%E4%B8%80%E7%89%87%E7%94%9F%E8%8F%9C%E5%8F%B6%E3%80%82%3C%2Fli%3E%5Cn%3C%2Fol%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span>&lt;!-- 学名 --></span>
<span><span><span>&lt;</span>p</span><span>></span></span>红喉北蜂鸟(学名: <span><span><span>&lt;</span>i</span><span>></span></span>Archilocus colubris<span><span><span>&lt;/</span>i</span><span>></span></span>) 是北美东部最常见的蜂鸟品种。<span><span><span>&lt;/</span>p</span><span>></span></span>

<span>&lt;!-- 舶来词 --></span>
<span><span><span>&lt;</span>p</span><span>></span></span>
  菜单上有好多舶来词汇，比如 <span><span><span>&lt;</span>i</span> <span>lang</span><span><span>=</span><span>"</span>uk-latn<span>"</span></span><span>></span></span>vatrushka<span><span><span>&lt;/</span>i</span><span>></span></span>(东欧乳酪面包),
  <span><span><span>&lt;</span>i</span> <span>lang</span><span><span>=</span><span>"</span>id<span>"</span></span><span>></span></span>nasi goreng<span><span><span>&lt;/</span>i</span><span>></span></span>(印尼炒饭)以及<span><span><span>&lt;</span>i</span> <span>lang</span><span><span>=</span><span>"</span>fr<span>"</span></span><span>></span></span>soupe à l'oignon<span><span><span>&lt;/</span>i</span>
  <span>></span></span>(法式洋葱汤)。
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span>&lt;!-- 已知的错误书写 --></span>
<span><span><span>&lt;</span>p</span><span>></span></span>总有一天我会改掉写<span><span><span>&lt;</span>u</span><span>></span></span>措字<span><span><span>&lt;/</span>u</span><span>></span></span>的毛病。<span><span><span>&lt;/</span>p</span><span>></span></span>

<span>&lt;!-- 系列说明文字中需要突出的文字 --></span>
<span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>b</span><span>></span></span>切<span><span><span>&lt;/</span>b</span><span>></span></span>下两片面包，<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>在两片面包中间<span><span><span>&lt;</span>b</span><span>></span></span>夹入<span><span><span>&lt;/</span>b</span><span>></span></span>一片西红柿和一片生菜叶。<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">嵌入</title>
    <id>https://list-jiang.github.io/code/website/html/intro/embed/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/embed/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iframe"> Iframe</h2>
<p><code>&lt;iframe&gt;</code> 元素旨在允许您将其他 Web 文档嵌入到当前文档中。这很适合将第三方内容嵌入您的网站，您可能无法直接控制，也不希望实现自己的版本 - 例如来自在线视频提供商的视频，Disqus 等评论系统，在线地图提供商，广告横幅等。</p>
<div><p>案例</p>
<div><pre><code><span><span><span>&lt;</span>iframe</span>
  <span>src</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Glossary<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>500<span>"</span></span>
  <span>frameborder</span><span><span>=</span><span>"</span>0<span>"</span></span>
  <span>allowfullscreen</span>
  <span>sandbox</span>
<span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Glossary<span>"</span></span><span>></span></span>
      Fallback link for browsers that don't support iframes
    <span><span><span>&lt;/</span>a</span><span>></span></span>
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>iframe</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></div>
<ul>
<li>
<p>allowfullscreen</p>
<p>如果设置，<code>&lt;iframe&gt;</code> 则可以通过全屏 API 设置为全屏模式(稍微超出本文的范围)。</p>
</li>
<li>
<p>frameborder</p>
<p>如果设置为 1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0 删除边框。不推荐这样设置，因为在 CSS 中可以更好地实现相同的效果。border: none;</p>
</li>
<li>
<p>src</p>
<p>该属性与 <code>&lt;video&gt;/&lt;img&gt;</code> 一样包含指向要嵌入文档的 URL 路径。</p>
</li>
<li>
<p>width 和 height</p>
<p>这些属性指定您想要的 iframe 的宽度和高度。</p>
</li>
<li>
<p>备选内容
与 <code>&lt;video&gt;</code> 等其他类似元素相同，您可以在 <code>&lt;iframe&gt;&lt;/iframe&gt;</code> 标签之间包含备选内容，如果浏览器不支持 <code>&lt;iframe&gt;</code>，将会显示备选内容，这种情况下，我们已经添加了一个到该页面的链接。</p>
<div><p>提示</p>
<p>2020 年几乎不可能遇到不支持 <code>&lt;iframe&gt;</code> 的浏览器。</p>
</div>
</li>
<li>
<p>sandbox</p>
<p>该属性需要在已经支持其他 <code>&lt;iframe&gt;</code> 功能(例如 IE 10 及更高版本)但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置。</p>
</li>
</ul>
<h3 id="安全隐患"> 安全隐患</h3>
<p>如果黑客试图恶意修改您的网页或欺骗人们进行不想做的事情时常把 iframe 作为共同的攻击目标(官方术语: 攻击向量)，例如显示用户名和密码等敏感信息。因此，规范工程师和浏览器开发人员已经开发了各种安全机制，使 <code>&lt;iframe&gt;</code> 更加安全。</p>
<div><p>提示</p>
<p>单击劫持是一种常见的 iframe 攻击，黑客将隐藏的 iframe 嵌入到您的文档中(或将您的文档嵌入到他们自己的恶意网站)，并使用它来捕获用户的交互。这是误导用户或窃取敏感数据的常见方式。</p>
</div>
<h4 id="只有在必要时嵌入"> 只有在必要时嵌入</h4>
<p>有时嵌入第三方内容(例如 YouTube 视频和地图)是有意义的，但如果您只在完全需要时嵌入第三方内容，您可以省去很多麻烦。网络安全的一个很好的经验法则是“您怎么谨慎都不为过，如果您决定要做这件事，多检查一遍；如果是别人做的，在被证明是安全的之前，都假设这是危险的。”</p>
<p>除了安全问题，您还应该意识到知识产权问题。无论在线内容还是离线内容，绝大部分内容都是有版权的，甚至是一些您没想到有版权的内容(例如，Wikimedia Commons 上的大多数图片)。不要在网页上展示一些不属于您的内容，除非您是所有者或所有者给了您明确的、书面的许可。对于侵犯版权的惩罚是严厉的。再说一次，您再小心也不为过。</p>
<p>如果内容获得许可，您必须遵守许可条款。例如，MDN 上的内容是在 CC-BY-SA 下许可的，这意味着，如果您要引用我们的内容，就必须用适当的方式注明来源，即使您对内容做了实质性的修改。</p>
<h4 id="使用-https"> 使用 HTTPS</h4>
<p>HTTPS 是 HTTP 的加密版本。您应该尽可能用 HTTPS 为您的网站提供服务:</p>
<ul>
<li>HTTPS 减少了远程内容在传输过程中被篡改的机会，</li>
<li>HTTPS 防止嵌入式内容访问您的父文档中的内容，反之亦然。</li>
</ul>
<p>由于 HTTPS 的第二个好处，无论成本如何，您绝对不能使用 HTTP 嵌入第三方内容(在最好的情况下，您的用户的 Web 浏览器会给他们一个可怕的警告)。</p>
<h4 id="始终使用-sandbox-属性"> 始终使用 sandbox 属性</h4>
<p>您应该给嵌入的内容仅能完成自己工作的权限，当然这也适用于您自己的内容。</p>
<p>一个允许包含在其里的代码以适当的方式执行或者用于测试，但不能对其他代码库(意外或恶意)造成任何损害的容器称为沙盒。</p>
<p>未沙盒化 (Unsandboxed) 内容可以做得太多，如执行 JavaScript，提交表单，弹出窗口等。默认情况下，您应该使用没有参数的 <code>sandbox</code> 属性来强制执行所有可用的限制，如我们前面的示例所示。如果真的需要关闭某些限制，您可以逐个添加权限(在 <code>sandbox=&quot;&quot;</code> 属性值内)。</p>
<div><p>警告</p>
<p>您永远不应该同时添加 <code>allow-scripts</code> 和 <code>allow-same-origin</code> 到您的 sandbox 属性中-在这种情况下，嵌入式内容可以绕过阻止站点执行脚本的同源安全策略，并使用 JavaScript 完全关闭沙盒。</p>
</div>
<div><p>注意</p>
<p>如果攻击者可以欺骗人们直接访问恶意内容(在 iframe 之外)，则沙盒无法提供保护。如果某些内容可能是恶意的(例如，用户生成的内容)，请保证其是从不同的域向您的主站点提供的。</p>
</div>
<div><p>相关信息</p>
<p>更多沙盒相关详情，请见 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox" target="_blank" rel="noopener noreferrer">MDN sandbox</a></p>
</div>
<h4 id="配置-csp-指令"> 配置 CSP 指令</h4>
<p>CSP 代表内容安全策略，它提供一组 HTTP 标头(由 web 服务器发送时与元数据一起发送的元数据)，旨在提高 HTML 文档的安全性。在 <code>&lt;iframe&gt;</code> 安全性方面，您可以将服务器配置为发送适当的 <code>X-Frame-Options</code> 标题。这样做可以防止其他网站在其网页中嵌入您的内容(这将导致点击和一系列其他攻击)。</p>
<h2 id="embed-和-object"> <code>&lt;embed&gt;</code> 和 <code>&lt;object&gt;</code></h2>
<p><code>&lt;embed&gt;</code> 和 <code>&lt;object&gt;</code> 元素的功能不同于 <code>&lt;iframe&gt;</code>。这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像 Java 小程序，PDF 这样的插件技术，甚至像视频，SVG 和图像的内容。</p>
<div><p>注意</p>
<p>目前浏览器对视频，SVG，图像的支持已经很好，而且网站应该使用 JavaScript 编写，所以不建议使用这两个元素。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">格式化</title>
    <id>https://list-jiang.github.io/code/website/html/intro/format/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/format/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>HTML 中有许多其他元素可以用于格式化文本。本文介绍标记引文、描述列表、计算机代码和其他相关文本、下标和上标、联系信息等。</p>
]]></summary>
    <content type="html"><![CDATA[<p>HTML 中有许多其他元素可以用于格式化文本。本文介绍标记引文、描述列表、计算机代码和其他相关文本、下标和上标、联系信息等。</p>

<h2 id="描述列表"> 描述列表</h2>
<p>在 HTML 基础部分，我们说 HTML 有三种列表。第三种类型的列表叫<strong>描述列表</strong> (description list)。这种列表的目的是标记一组项目及其相关描述，例如术语和定义，或者是问题和答案等。让我们看一组术语和定义的示例:</p>
<div><pre><code>内心独白
戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。
语言独白
戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。
旁白
戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>描述列表使用与其他列表类型不同的闭合标签 <code>&lt;dl&gt;</code>; 此外，每一项都用 <code>&lt;dt&gt;</code> (description term) 元素闭合。每个描述都用 <code>&lt;dd&gt;</code> (description description) 元素闭合.</p>

          <div
            id="code-demo-a121736e"
           
  
 data-title="%E6%8F%8F%E8%BF%B0%E5%88%97%E8%A1%A8"

            data-code="%7B%22html%22%3A%22%3Cdl%3E%5Cn%20%20%3Cdt%3E%E5%86%85%E5%BF%83%E7%8B%AC%E7%99%BD%3C%2Fdt%3E%5Cn%20%20%3Cdd%3E%5Cn%20%20%20%20%E6%88%8F%E5%89%A7%E4%B8%AD%EF%BC%8C%E6%9F%90%E4%B8%AA%E8%A7%92%E8%89%B2%E5%AF%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%BF%83%E6%B4%BB%E5%8A%A8%E6%88%96%E6%84%9F%E5%8F%97%E8%BF%9B%E8%A1%8C%E5%BF%B5%E7%99%BD%E8%A1%A8%E6%BC%94%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%8F%B0%E8%AF%8D%E5%8F%AA%E9%9D%A2%E5%90%91%E8%A7%82%E4%BC%97%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E8%A7%92%E8%89%B2%E4%B8%8D%E4%BC%9A%E5%90%AC%E5%88%B0%E3%80%82%5Cn%20%20%3C%2Fdd%3E%5Cn%20%20%3Cdt%3E%E8%AF%AD%E8%A8%80%E7%8B%AC%E7%99%BD%3C%2Fdt%3E%5Cn%20%20%3Cdd%3E%5Cn%20%20%20%20%E6%88%8F%E5%89%A7%E4%B8%AD%EF%BC%8C%E6%9F%90%E4%B8%AA%E8%A7%92%E8%89%B2%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E6%83%B3%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%BF%B5%E7%99%BD%E8%A1%A8%E6%BC%94%EF%BC%8C%E8%A7%82%E4%BC%97%E5%92%8C%E5%85%B6%E4%BB%96%E8%A7%92%E8%89%B2%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%90%AC%E5%88%B0%E3%80%82%5Cn%20%20%3C%2Fdd%3E%5Cn%20%20%3Cdt%3E%E6%97%81%E7%99%BD%3C%2Fdt%3E%5Cn%20%20%3Cdd%3E%5Cn%20%20%20%20%E6%88%8F%E5%89%A7%E4%B8%AD%EF%BC%8C%E4%B8%BA%E6%B8%B2%E6%9F%93%E5%B9%BD%E9%BB%98%E6%88%96%E6%88%8F%E5%89%A7%E6%80%A7%E6%95%88%E6%9E%9C%E8%80%8C%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E8%A1%A5%E5%85%85%E6%B3%A8%E9%87%8A%E5%BF%B5%E7%99%BD%EF%BC%8C%E5%8F%AA%E9%9D%A2%E5%90%91%E8%A7%82%E4%BC%97%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E8%A7%92%E8%89%B2%E7%9A%84%E6%84%9F%E5%8F%97%E3%80%81%E6%83%B3%E6%B3%95%E3%80%81%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF%E7%AD%89%E3%80%82%5Cn%20%20%3C%2Fdd%3E%5Cn%3C%2Fdl%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>dl</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>内心独白<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>
    戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。
  <span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>语言独白<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>
    戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。
  <span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>旁白<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>
    戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。
  <span><span><span>&lt;/</span>dd</span><span>></span></span>
<span><span><span>&lt;/</span>dl</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>浏览器的默认样式会在描述列表的<strong>描述部分</strong>(description description)和<strong>描述术语</strong>(description terms)之间产生缩进。MDN 非常严密地遵循这一惯例，同时也鼓励关于术语的其他更多的定义。</p>
<div><p>提示</p>
<p>一个术语 <code>&lt;dt&gt;</code> 可以同时有多个描述 <code>&lt;dd&gt;</code>。</p>
</div>
<h2 id="引用"> 引用</h2>
<p>HTML 也有用于标记引用的特性，至于使用哪个元素标记，取决于您引用的是一块还是一行。</p>
<h3 id="块引用"> 块引用</h3>
<p>如果一个块级内容(一个段落、多个段落、一个列表等)从其他地方被引用，您应该把它用 <code>&lt;blockquote&gt;</code> 元素包裹起来表示，并且在 <code>cite</code> 属性里用 URL 来指向引用的资源。</p>
<h3 id="行内引用"> 行内引用</h3>
<p>行内元素需要使用 <code>&lt;q&gt;</code> 元素。浏览器默认将其作为普通文本放入引号内表示引用</p>
<h3 id="引文"> 引文</h3>
<p><code>cite</code> 属性内容不会被浏览器显示、屏幕阅读器阅读，需使用 JavaScript 或 CSS，浏览器才会显示 <code>cite</code> 的内容。如果您想要确保引用的来源在页面上是可显示的，最好使用 <code>&lt;cite&gt;</code> 元素。</p>

          <div
            id="code-demo-825c187e"
           
  
 data-title="%E5%BC%95%E6%96%87%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20According%20to%20the%5Cn%20%20%3Ca%5Cn%20%20%20%20href%3D%5C%22https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FElement%2Fblockquote%5C%22%5Cn%20%20%3E%5Cn%20%20%20%20%3Ccite%3EMDN%20blockquote%20page%3C%2Fcite%3E%3C%2Fa%5Cn%20%20%3E%3A%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cblockquote%5Cn%20%20cite%3D%5C%22https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FElement%2Fblockquote%5C%22%5Cn%3E%5Cn%20%20%3Cp%3E%5Cn%20%20%20%20The%20%3Cstrong%3EHTML%20%3Ccode%3E%26lt%3Bblockquote%26gt%3B%3C%2Fcode%3E%20Element%3C%2Fstrong%3E%20(or%5Cn%20%20%20%20%3Cem%3EHTML%20Block%20Quotation%20Element%3C%2Fem%3E)%20indicates%20that%20the%20enclosed%20text%20is%5Cn%20%20%20%20an%20extended%20quotation.%5Cn%20%20%3C%2Fp%3E%5Cn%3C%2Fblockquote%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20The%20quote%20element%20%E2%80%94%20%3Ccode%3E%26lt%3Bq%26gt%3B%3C%2Fcode%3E%20%E2%80%94%20is%5Cn%20%20%3Cq%20cite%3D%5C%22https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FElement%2Fq%5C%22%5Cn%20%20%20%20%3Eintended%20for%20short%20quotations%20that%20don't%20require%20paragraph%20breaks.%3C%2Fq%5Cn%20%20%3E%5Cn%20%20--%5Cn%20%20%3Ca%20href%3D%5C%22https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FElement%2Fq%5C%22%3E%5Cn%20%20%20%20%3Ccite%3EMDN%20q%20page%3C%2Fcite%3E%3C%2Fa%5Cn%20%20%3E.%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  According to the
  <span><span><span>&lt;</span>a</span>
    <span>href</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote<span>"</span></span>
  <span>></span></span>
    <span><span><span>&lt;</span>cite</span><span>></span></span>MDN blockquote page<span><span><span>&lt;/</span>cite</span><span>></span></span><span><span><span>&lt;/</span>a</span>
  <span>></span></span>:
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>blockquote</span>
  <span>cite</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote<span>"</span></span>
<span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    The <span><span><span>&lt;</span>strong</span><span>></span></span>HTML <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>blockquote<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span> Element<span><span><span>&lt;/</span>strong</span><span>></span></span> (or
    <span><span><span>&lt;</span>em</span><span>></span></span>HTML Block Quotation Element<span><span><span>&lt;/</span>em</span><span>></span></span>) indicates that the enclosed text is
    an extended quotation.
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>blockquote</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  The quote element — <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>q<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span> — is
  <span><span><span>&lt;</span>q</span> <span>cite</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q<span>"</span></span>
    <span>></span></span>intended for short quotations that don't require paragraph breaks.<span><span><span>&lt;/</span>q</span>
  <span>></span></span>
  --
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>cite</span><span>></span></span>MDN q page<span><span><span>&lt;/</span>cite</span><span>></span></span><span><span><span>&lt;/</span>a</span>
  <span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="缩略语"> 缩略语</h2>
<p><code>&lt;abbr&gt;</code> 用来包裹一个缩略语或缩写，并且提供缩写的解释(包含在 <code>title</code> 属性中)。</p>

          <div
            id="code-demo-1e8f5553"
           
  
 data-title="%E7%BC%A9%E7%95%A5%E8%AF%AD"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%5Cn%20%20%3Cabbr%20title%3D%5C%22%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80(Hypertext%20Markup%20Language)%5C%22%3EHTML%3C%2Fabbr%3E%5Cn%20%20%E6%9D%A5%E7%BB%84%E7%BB%87%E7%BD%91%E9%A1%B5%E6%96%87%E6%A1%A3%E3%80%82%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20%E7%AC%AC%2033%20%E5%B1%8A%20%3Cabbr%20title%3D%5C%22%E5%A4%8F%E5%AD%A3%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E8%BF%90%E5%8A%A8%E4%BC%9A%5C%22%3E%E5%A5%A5%E8%BF%90%E4%BC%9A%3C%2Fabbr%3E%20%E5%B0%86%E4%BA%8E%202024%20%E5%B9%B4%208%5Cn%20%20%E6%9C%88%E5%9C%A8%E6%B3%95%E5%9B%BD%E5%B7%B4%E9%BB%8E%E4%B8%BE%E8%A1%8C%E3%80%82%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  我们使用
  <span><span><span>&lt;</span>abbr</span> <span>title</span><span><span>=</span><span>"</span>超文本标记语言(Hypertext Markup Language)<span>"</span></span><span>></span></span>HTML<span><span><span>&lt;/</span>abbr</span><span>></span></span>
  来组织网页文档。
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  第 33 届 <span><span><span>&lt;</span>abbr</span> <span>title</span><span><span>=</span><span>"</span>夏季奥林匹克运动会<span>"</span></span><span>></span></span>奥运会<span><span><span>&lt;/</span>abbr</span><span>></span></span> 将于 2024 年 8
  月在法国巴黎举行。
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="标记联系方式"> 标记联系方式</h2>
<p><code>&lt;address&gt;</code> 用于标记联系方式，它仅仅包含您的联系方式。</p>

          <div
            id="code-demo-2db07a3a"
           
  
 data-title="%E6%A0%87%E8%AE%B0%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F"

            data-code="%7B%22html%22%3A%22%3Caddress%3E%5Cn%20%20%3Cp%3EChris%20Mills%2C%20Manchester%2C%20The%20Grim%20North%2C%20UK%3C%2Fp%3E%5Cn%3C%2Faddress%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>address</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>Chris Mills, Manchester, The Grim North, UK<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>address</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<div><p>注意</p>
<p><code>&lt;address&gt;</code> 元素是为了标记编写 HTML 文档的人的联系方式，而不是任何其他的内容。</p>
</div>
<h2 id="上标和下标"> 上标和下标</h2>
<p>当您使用日期、化学方程式、和数学方程式时会偶尔使用上标和下标。<code>&lt;sup&gt;</code> 和 <code>&lt;sub&gt;</code> 元素可以解决这样的问题。</p>

          <div
            id="code-demo-f543577e"
           
  
 data-title="%E4%B8%8A%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E5%92%96%E5%95%A1%E5%9B%A0%E7%9A%84%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F%E6%98%AF%20C%3Csub%3E8%3C%2Fsub%3EH%3Csub%3E10%3C%2Fsub%3EN%3Csub%3E4%3C%2Fsub%3EO%3Csub%3E2%3C%2Fsub%3E%E3%80%82%5Cn%3C%2Fp%3E%5Cn%3Cp%3E%E5%A6%82%E6%9E%9C%20x%3Csup%3E2%3C%2Fsup%3E%20%E7%9A%84%E5%80%BC%E4%B8%BA%209%EF%BC%8C%E9%82%A3%E4%B9%88%20x%20%E7%9A%84%E5%80%BC%E5%BF%85%E4%B8%BA%203%20%E6%88%96%20-3%E3%80%82%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  咖啡因的化学方程式是 C<span><span><span>&lt;</span>sub</span><span>></span></span>8<span><span><span>&lt;/</span>sub</span><span>></span></span>H<span><span><span>&lt;</span>sub</span><span>></span></span>10<span><span><span>&lt;/</span>sub</span><span>></span></span>N<span><span><span>&lt;</span>sub</span><span>></span></span>4<span><span><span>&lt;/</span>sub</span><span>></span></span>O<span><span><span>&lt;</span>sub</span><span>></span></span>2<span><span><span>&lt;/</span>sub</span><span>></span></span>。
<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>如果 x<span><span><span>&lt;</span>sup</span><span>></span></span>2<span><span><span>&lt;/</span>sup</span><span>></span></span> 的值为 9，那么 x 的值必为 3 或 -3。<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="展示计算机代码"> 展示计算机代码</h2>
<p>有大量的 HTML 元素可以来标记计算机代码:</p>
<ul>
<li><code>&lt;code&gt;</code>: 用于标记计算机通用代码。</li>
<li><code>&lt;pre&gt;</code>: 用于保留空白字符(通常用于代码块)——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本- 包含在 <code>&lt;pre&gt;&lt;/pre&gt;</code> 标签中，那么空白将会以与您在文本编辑器中看到的相同的方式渲染出来。</li>
<li><code>&lt;var&gt;</code>: 用于标记具体变量名。</li>
<li><code>&lt;kbd&gt;</code>: 用于标记输入电脑的键盘(或其他类型)输入。</li>
<li><code>&lt;samp&gt;</code>: 用于标记计算机程序的输出。</li>
</ul>
<h2 id="标记时间和日期"> 标记时间和日期</h2>
<p>HTML 还支持将时间和日期标记为可供机器识别的格式的 <code>&lt;time&gt;</code> 元素。例如:</p>
<div><pre><code><span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-01-20<span>"</span></span><span>></span></span>2016年1月20日<span><span><span>&lt;/</span>time</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>为什么需要这样做? 因为世界上有许多种书写日期的格式，上边的日期可能被写成:</p>
<ul>
<li>20 January 2016</li>
<li>20th January 2016</li>
<li>Jan 20 2016</li>
<li>20/06/16</li>
<li>06/20/16</li>
<li>The 20th of next month</li>
<li>20e Janvier 2016</li>
<li>2016 年 1 月 20 日</li>
</ul>
<p>但是这些不同的格式不容易被电脑识别 — 假如您想自动抓取页面上所有事件的日期并将它们插入到日历中，<code>&lt;time&gt;</code> 元素允许您附上清晰的、可被机器识别的 时间/日期来实现这种需求。</p>
<p>上述基本的例子仅仅提供了一种简单的可被机器识别的日期格式，这里还有许多其他支持的格式。</p>

          <div
            id="code-demo-002a5049"
           
  
 data-title="%E6%A0%87%E8%AE%B0%E6%97%B6%E9%97%B4"

            data-code="%7B%22html%22%3A%22%3C!--%20%E6%A0%87%E5%87%86%E7%AE%80%E5%8D%95%E6%97%A5%E6%9C%9F%20--%3E%5Cn%3Ctime%20datetime%3D%5C%222016-01-20%5C%22%3E20%20January%202016%3C%2Ftime%3E%5Cn%3C!--%20%E5%8F%AA%E5%8C%85%E5%90%AB%E5%B9%B4%E4%BB%BD%E5%92%8C%E6%9C%88%E4%BB%BD--%3E%5Cn%3Ctime%20datetime%3D%5C%222016-01%5C%22%3EJanuary%202016%3C%2Ftime%3E%5Cn%3C!--%20%E5%8F%AA%E5%8C%85%E5%90%AB%E6%9C%88%E4%BB%BD%E5%92%8C%E6%97%A5%E6%9C%9F%20--%3E%5Cn%3Ctime%20datetime%3D%5C%2201-20%5C%22%3E20%20January%3C%2Ftime%3E%5Cn%3C!--%20%E5%8F%AA%E5%8C%85%E5%90%AB%E6%97%B6%E9%97%B4%EF%BC%8C%E5%B0%8F%E6%97%B6%E5%92%8C%E5%88%86%E9%92%9F%E6%95%B0%20--%3E%5Cn%3Ctime%20datetime%3D%5C%2219%3A30%5C%22%3E19%3A30%3C%2Ftime%3E%5Cn%3C!--%20%E8%BF%98%E5%8F%AF%E5%8C%85%E5%90%AB%E7%A7%92%E5%92%8C%E6%AF%AB%E7%A7%92%20--%3E%5Cn%3Ctime%20datetime%3D%5C%2219%3A30%3A01.856%5C%22%3E19%3A30%3A01.856%3C%2Ftime%3E%5Cn%3C!--%20%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%20--%3E%5Cn%3Ctime%20datetime%3D%5C%222016-01-20T19%3A30%5C%22%3E7.30pm%2C%2020%20January%202016%3C%2Ftime%3E%5Cn%3C!--%20%E5%90%AB%E6%9C%89%E6%97%B6%E5%8C%BA%E5%81%8F%E7%A7%BB%E5%80%BC%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%20--%3E%5Cn%3Ctime%20datetime%3D%5C%222016-01-20T19%3A30%2B01%3A00%5C%22%5Cn%20%20%3E7.30pm%2C%2020%20January%202016%20is%208.30pm%20in%20France%3C%2Ftime%5Cn%3E%5Cn%3C!--%20%E8%B0%83%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%91%A8%20--%3E%5Cn%3Ctime%20datetime%3D%5C%222016-W04%5C%22%3EThe%20fourth%20week%20of%202016%3C%2Ftime%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span>&lt;!-- 标准简单日期 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-01-20<span>"</span></span><span>></span></span>20 January 2016<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 只包含年份和月份--></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-01<span>"</span></span><span>></span></span>January 2016<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 只包含月份和日期 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>01-20<span>"</span></span><span>></span></span>20 January<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 只包含时间，小时和分钟数 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>19:30<span>"</span></span><span>></span></span>19:30<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 还可包含秒和毫秒 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>19:30:01.856<span>"</span></span><span>></span></span>19:30:01.856<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 日期和时间 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-01-20T19:30<span>"</span></span><span>></span></span>7.30pm, 20 January 2016<span><span><span>&lt;/</span>time</span><span>></span></span>
<span>&lt;!-- 含有时区偏移值的日期时间 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-01-20T19:30+01:00<span>"</span></span>
  <span>></span></span>7.30pm, 20 January 2016 is 8.30pm in France<span><span><span>&lt;/</span>time</span>
<span>></span></span>
<span>&lt;!-- 调用特定的周 --></span>
<span><span><span>&lt;</span>time</span> <span>datetime</span><span><span>=</span><span>"</span>2016-W04<span>"</span></span><span>></span></span>The fourth week of 2016<span><span><span>&lt;/</span>time</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">head 标签</title>
    <id>https://list-jiang.github.io/code/website/html/intro/head/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/head/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在页面加载完成的时候，标签 <code>&lt;head&gt;</code> 里的内容，是不会在页面中显示出来的。</p>
<p><code>&lt;head&gt;</code> 包含了像页面的 <code>&lt;title&gt;</code>(标题) ,CSS (如果您选择用 CSS 来为 HTML 内容添加样式)，指向自定义图标的链接和其他的元数据 (描述 HTML 的数据，比如，作者，和描述文档的重要关键词)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在页面加载完成的时候，标签 <code>&lt;head&gt;</code> 里的内容，是不会在页面中显示出来的。</p>
<p><code>&lt;head&gt;</code> 包含了像页面的 <code>&lt;title&gt;</code>(标题) ,CSS (如果您选择用 CSS 来为 HTML 内容添加样式)，指向自定义图标的链接和其他的元数据 (描述 HTML 的数据，比如，作者，和描述文档的重要关键词)。</p>

<h2 id="html-头部"> HTML 头部</h2>
<p>HTML 头部是包含在 <code>&lt;head&gt;</code> 元素里面的内容。不像 <code>&lt;body&gt;</code> 元素的内容会显示在浏览器中，head 里面的内容不会在浏览器中显示，它的作用是包含一些页面的元数据。在下面的例子中，head 的内容很少。</p>
<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>utf-8<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>My test page<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当然，在大型的页面中，head 会包含很多的元数据。您可以用 <a href="./../../../../software/Chrome.html#开发者工具">开发者工具</a> 去查看您喜欢的网页的 head 的内容。这里只会列出要包含在 head 里的主要元素。</p>
<h2 id="title-元素"> <code>&lt;title&gt;</code> 元素</h2>
<p><code>&lt;title&gt;</code> 可以用来给 HTML 文档添加一个标题。您可能会将它和给 body 添加标题的 <code>&lt;h1&gt;</code> 元素混淆，有些时候 <code>&lt;h1&gt;</code> 也会被称作网页标题。但是它们是不同的。</p>
<ul>
<li>当被加载到浏览器中的时候，元素 <code>&lt;h1&gt;</code> 会出现在页面中 —— 通常它应该在一个页面中只被使用一次，它被用来标记您的页面内容的标题(故事的标题，新闻标题或者任何适当的方式)。</li>
<li>元素 <code>&lt;title&gt;</code> 是用来表示整个 HTML 文档标题的元数据(不是文档的内容)。</li>
</ul>
<p>直白点说，<code>&lt;h1&gt;</code> 会出现在页面上，而 <code>&lt;title&gt;</code> 会出现在选项卡或书签中。</p>
<h2 id="meta-元素"> <code>&lt;meta&gt;</code> 元素</h2>
<p>元数据就是描述数据的数据，有很多不同种类的 <code>&lt;meta&gt;</code> 元素可以被包含进您的页面的 <code>&lt;head&gt;</code> 元素，下面仅为最常用的。</p>
<h3 id="指定编码"> 指定编码</h3>
<div><pre><code><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>utf-8<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>这个元素简单的指定了文档的字符编码 —— 在这个文档中被允许使用的字符集。</p>
<div><p>相关信息</p>
<p>字符集的详情，请见 <a href="./../../../basic/encoding.html">基础知识 → 字符集</a></p>
</div>
<div><p>注意</p>
<p>如果您指定了错误的编码，则整个网页都会乱码。</p>
</div>
<h3 id="添加作者和描述"> 添加作者和描述</h3>
<p>许多 <code>&lt;meta&gt;</code> 元素包含了 <code>name</code> 和 <code>content</code> 特性:</p>
<ul>
<li><code>name</code> 指定了 meta 元素的类型； 说明该元素包含了什么类型的信息。</li>
<li><code>content</code> 指定了实际的元数据内容。</li>
</ul>
<p>这两个 meta 元素用于定义页面作者与提供页面简要描述。</p>
<div><p>案例</p>
<div><pre><code><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>author<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>Mr.Hope<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>description<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>Introduction about &lt;head> tags<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<p>指定作者在某些情况下是很有用的: 如果您需要联系页面的作者，问一些关于页面内容的问题。一些内容管理系统能够自动获取页面作者的信息，然后用于某些用途。</p>
<p>指定包含关于页面内容的关键字的页面内容的描述是很有用的，因为它可能或让您的页面在搜索引擎的相关的搜索出现得更多 (这些行为术语上被称为 Search Engine Optimization，简称 SEO.)</p>
<div><p>相关信息</p>
<p>关于 SEO 详情，请见 <a href="./../definition/seo.html">定义 → SEO</a></p>
</div>
<h3 id="自定义图标"> 自定义图标</h3>
<p>您可以在元数据中添加对自定义图标的引用。现代浏览器在各种场合使用 favicons，如打开的页面标签页和书签面板中的书签页面。</p>
<p>这个不起眼的图标已经存在很多很多年了，16 x 16 像素是这种图标的第一种类型。</p>
<p>页面添加图标的方式有:</p>
<ol>
<li>
<p>将其保存在与网站的索引页面相同的目录中，以 <code>.ico</code> 格式保存(大多数浏览器将支持更通用的格式，如 .gif 或.png，但使用 ICO 格式将确保它能在如 IE6 一样久远的浏览器显示)</p>
</li>
<li>
<p>将以下行添加到 HTML <code>&lt;head&gt;</code> 中以引用它</p>
<div><pre><code><span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>shortcut icon<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>favicon.ico<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>image/x-icon<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<div><p>相关信息</p>
<p>更多元数据详情，请见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta" target="_blank" rel="noopener noreferrer">MDN Meta 标签</a>)</p>
</div>
<h2 id="为文档设定主语言"> 为文档设定主语言</h2>
<p>您应该添加 <code>lang</code> 属性到 HTML 开始标签中来为您的站点设定语言。</p>
<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>zh-CN<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>html</span><span>></span></span>

<span>&lt;!-- or --></span>

<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en-US<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果您的 HTML 文档的语言设置好了，那么您的 HTML 文档就会被搜索引擎更有效地索引 (保证它在特定于语言的结果中正确显示)。同时，这对于那些使用屏幕阅读器的视障人士也很有用(比如，法语和英语中都有“six”这个单词，但是发音却完全不同)。</p>
<p>您还可以将文档的片段设置为不同的语言:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Chinese example: <span><span><span>&lt;</span>span</span> <span>lang</span><span><span>=</span><span>"</span>zh-CN<span>"</span></span><span>></span></span>春眠不觉晓<span><span><span>&lt;/</span>span</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">HTML 历史</title>
    <id>https://list-jiang.github.io/code/website/html/intro/history/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/history/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>1990 年，由于对 Web 未来发展的远见，Tim Berners-Lee 提出了 超文本 的概念，并在第二年在 SGML 的基础上将其正式定义为一个标记语言。IETF 于 1993 年正式开始制定 HTML 规范，并在经历了几个版本的草案后于 1995 年发布了 HTML 2.0 版本。1994 年，Berners-Lee 为了 Web 发展而成立了 W3C。1996 年，W3C 接管了 HTML 的标准化工作，并在 1 年后发布了 HTML 3.2 推荐标准。1999 年，HTML 4.0 发布，并在 2000 年成为 ISO 标准。</p>
<p>自那以后，W3C 几乎放弃了 HTML 而转向 XHTML，并于 2004 年成立了另一个独立的小组 WHATWG。幸运的是，WHATWG 后来又转回来参与了 HTML5 标准的制定，两个组织(译注: 即 W3C 和 WHATWG)在 2008 年发布了第一份草案，并在 2014 年发布了 HTML5 标准的最终版。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">图片</title>
    <id>https://list-jiang.github.io/code/website/html/intro/image/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/image/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="插入图片"> 插入图片</h2>
<p>我们可以用 <code>&lt;img&gt;</code> 元素来把图片放到网页上。它是一个空元素(也就是无法包含内容，可以省略闭合标签)，最少只需要一个 <code>src</code> (一般读作其全称 source)来使其生效。<code>src</code> 属性包含了指向我们想要引入的图片的路径，可以是相对路径或绝对 URL，就像 <code>&lt;a&gt;</code> 元素的 <code>href</code> 属性一样。</p>
<p>如果您有一幅文件名为 dinosaur.jpg 的图片，且它与您的 HTML 页面存放在相同路径下，那么您可以这样嵌入它:</p>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>dinosaur.jpg<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>如果这张图片存储在和 HTML 页面同路径的 images 文件夹下(这也是 Google 推荐的做法，利于 SEO/索引)，那么您可以采用如下形式:</p>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>images/dinosaur.jpg<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>搜索引擎也读取图像的文件名并把它们计入 SEO。因此您应该给您的图片取一个描述性的文件名: dinosaur.jpg 比 img835.png 要好。</p>
</div>
<p>您也可以像下面这样使用绝对路径:</p>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>https://www.example.com/images/dinosaur.jpg<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>但是这种方式是不被推荐的，这样做只会使浏览器做更多的工作，例如重新通过 DNS 再去寻找 IP 地址。通常我们都会把图片和 HTML 放在同一个服务器上。</p>
<div><p>警告</p>
<p>大多数图片是有版权的。不要在您的网页上使用一张图片，除非:</p>
<ul>
<li>您是图片版权所有者</li>
<li>您有图片版权所有者明确的、书面上的使用授权</li>
<li>您有充分的证据证明这张图片是公共领域内的</li>
</ul>
<p>侵犯版权是违法并且不道德的。此外，在得到授权之前永远不要把您的 <code>src</code> 属性指向其他人网站上的图片。这被称为&quot;盗链(hotlinking)&quot;。同样，盗取其他人的带宽也是违法的。而且这会降低您的页面的加载速度，而且图片可能会在不受您控制的情况下被移走或用别的令人尴尬的东西替换掉。</p>
</div>
<div><p>相关信息</p>
<p>像 <code>&lt;img&gt;</code> 和 <code>&lt;video&gt;</code> 这样的元素有时被称之为替换元素，因为这样的元素的内容和尺寸由外部资源(像是一个图片或视频文件)所定义，而不是元素自身。</p>
</div>
<h2 id="备选文本"> 备选文本</h2>
<p><code>alt</code> 的值应该是对图片的文字描述，用于在图片无法显示或不能被看到的情况。</p>

          <div
            id="code-demo-6d9c7716"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Cimg%5Cn%20%20src%3D%5C%22http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fdinosaur_small.jpg%5C%22%5Cn%20%20alt%3D%5C%22The%20head%20and%20torso%20of%20a%20dinosaur%20skeleton%3B%20it%20has%20a%20large%20head%20with%20long%20sharp%20teeth%5C%22%5Cn%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>src</span><span><span>=</span><span>"</span>http://mrhope.site/assets/img/dinosaur_small.jpg<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>The head and torso of a dinosaur skeleton; it has a large head with long sharp teeth<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>测试 <code>alt</code> 属性最简单的方式就是故意拼错图片文件名，这样浏览器就无法找到该图片从而显示备选的文本。</p>
<p>设置备选文本的原因有很多:</p>
<ul>
<li>用户有视力障碍，通过屏幕阅读器来浏览网页 。事实上，给图片一个备选的描述文本对大多数用户都是很有用的。</li>
<li>就像上面所说的，您也许会把图片的路径或文件名拼错。</li>
<li>浏览器不支持该图片类型。</li>
<li>您会想提供一些文字描述来给搜索引擎使用，例如搜索引擎可能会将图片的文字描述和查询条件进行匹配。</li>
<li>用户关闭的图片显示以减少数据的传输，这之前在手机上是十分普遍的，并且在一些国家带宽有限且昂贵。</li>
</ul>
<p><code>alt</code> 中的内容取决于图片的作用:</p>
<ul>
<li>
<p>装饰:</p>
<p>如果图片只是用于装饰，而不是内容的一部分，可以写一个空的 <code>alt=&quot;&quot;</code>。例如，屏幕阅读器不会浪费时间对用户读出不是核心需要的内容。实际上装饰性图片就不应该放在 HTML 文件里， <a href="./../../css/background-and-border.html#背景图片">CSS 背景图片</a> 才应该用于插入装饰图片，但如果这种情况无法避免， <code>alt=&quot;&quot;</code> 会是最佳处理方案。</p>
</li>
<li>
<p>内容:</p>
<p>如果您的图片提供了重要的信息，就要在 <code>alt</code> 文本中简要的提供相同的信息，甚至更近一步，把这些信息写在主要的文本内容里，这样所有人都能看见。不要写冗余的备选文本，如果在主要文本中已经对图片进行了充分的描述，写 <code>alt=&quot;&quot;</code> 就好。</p>
</li>
<li>
<p>链接:</p>
<p>如果您把图片嵌套在 <code>&lt;a&gt;</code> 标签里，来把图片变成链接，那您还必须提供无障碍的链接文本。在这种情况下，您可以写在同一个 <code>&lt;a&gt;</code> 元素里，或者写在图片的 <code>alt</code> 属性里，随您喜欢。</p>
</li>
<li>
<p>文本:</p>
<p>您不应该将文本放到图像里。例如，如果您的主标题需要有阴影，您可以用 CSS 来达到这个目的，而不是把文本放到图片里。如果真的必须这么做，那就把文本也放到 <code>alt</code> 里。</p>
</li>
</ul>
<p>本质上，关键在于在图片无法被看见时也提供一个可用的体验，这确保了所有人都不会错失一部分内容。</p>
<h2 id="宽度和高度"> 宽度和高度</h2>
<p>您可以用宽度和高度属性来指定您的图片的高度和宽度。</p>

          <div
            id="code-demo-ba12f6de"
           
  
 data-title="%E8%AE%BE%E7%BD%AE%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6"

            data-code="%7B%22html%22%3A%22%3Cimg%5Cn%20%20src%3D%5C%22http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fdinosaur_small.jpg%5C%22%5Cn%20%20alt%3D%5C%22%E4%B8%80%E5%8F%AA%E6%81%90%E9%BE%99%E5%A4%B4%E9%83%A8%E5%92%8C%E8%BA%AF%E5%B9%B2%E7%9A%84%E9%AA%A8%E6%9E%B6%EF%BC%8C%E5%AE%83%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%A4%A7%E7%9A%84%E5%A4%B4%EF%BC%8C%E9%95%BF%E7%9D%80%E9%94%8B%E5%88%A9%E7%9A%84%E7%89%99%E9%BD%BF%E3%80%82%5C%22%5Cn%20%20width%3D%5C%22400%5C%22%5Cn%20%20height%3D%5C%22341%5C%22%5Cn%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>src</span><span><span>=</span><span>"</span>http://mrhope.site/assets/img/dinosaur_small.jpg<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>400<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>341<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>在正常的情况下，这不会对显示产生很大的影响， 但是如果图片没有显示(例如用户刚刚开始浏览网页，但是图片还没有加载完成)，您会注意到浏览器会为要显示的图片留下一定的空间。这会使得页面加载更令人愉悦，而不是被跳动的内容布局所困扰。</p>
<div><p>注意</p>
<p>不应使用 HTML 属性来改变图片的大小。</p>
<ul>
<li>如果您把尺寸设定的太大，最终图片看起来会模糊；</li>
<li>如果太小，会在下载远远大于您需要的图片时浪费带宽；</li>
<li>如果您没有保持正确的宽高比，图片可能看起来会扭曲。</li>
</ul>
<p>在把图片放到您的网站页面之前，您应该使用图形编辑器使图片的尺寸正确。</p>
</div>
<h2 id="图片标题"> 图片标题</h2>
<p>类似于超链接，您可以给图片增加 <code>title</code> 属性来提供需要更进一步的支持信息。</p>

          <div
            id="code-demo-6b468ffb"
           
  
 data-title="%E5%9B%BE%E7%89%87%E6%A0%87%E9%A2%98"

            data-code="%7B%22html%22%3A%22%3Cimg%5Cn%20%20src%3D%5C%22http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fdinosaur_small.jpg%5C%22%5Cn%20%20alt%3D%5C%22%E4%B8%80%E5%8F%AA%E6%81%90%E9%BE%99%E5%A4%B4%E9%83%A8%E5%92%8C%E8%BA%AF%E5%B9%B2%E7%9A%84%E9%AA%A8%E6%9E%B6%EF%BC%8C%E5%AE%83%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%A4%A7%E7%9A%84%E5%A4%B4%EF%BC%8C%E9%95%BF%E7%9D%80%E9%94%8B%E5%88%A9%E7%9A%84%E7%89%99%E9%BD%BF%E3%80%82%5C%22%5Cn%20%20width%3D%5C%22400%5C%22%5Cn%20%20height%3D%5C%22341%5C%22%5Cn%20%20title%3D%5C%22A%20T-Rex%20on%20display%20in%20the%20Manchester%20University%20Museum%5C%22%5Cn%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>src</span><span><span>=</span><span>"</span>http://mrhope.site/assets/img/dinosaur_small.jpg<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>400<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>341<span>"</span></span>
  <span>title</span><span><span>=</span><span>"</span>A T-Rex on display in the Manchester University Museum<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>这会给我们一个鼠标悬停提示，看起来就像链接标题。</p>
<p>图片标题并不必须要包含有意义的信息，通常来说，将这样的支持信息放到主要文本中而不是附着于图片会更好。不过，在当没有空间显示提示时这样做更有用，比如在一个图库样式的照片流中。</p>
<p>然而并不建议使用 <code>title</code>。<code>title</code> 会带来易访问性的问题，屏幕阅读器的支持是不可预测的，而且大多数浏览器在鼠标悬停外都不会显示它。</p>
<div><p>提示</p>
<p>您可以使用 <a href="https://github.com/kazzkiq/balloon.css" target="_blank" rel="noopener noreferrer">balloon-css</a> 库很好的解决这个问题</p>
</div>
<h2 id="搭配说明文字"> 搭配说明文字</h2>
<p>HTML5 的 <code>&lt;figure&gt;</code> 和 <code>&lt;figcaption&gt;</code> 元素为图片提供一个语义容器，在标题和图片之间建立清晰的关联。</p>

          <div
            id="code-demo-20baef66"
           
  
 data-title="HTML5%20%E8%AF%AD%E4%B9%89%E5%AE%B9%E5%99%A8"

            data-code="%7B%22html%22%3A%22%3Cfigure%3E%5Cn%20%20%3Cimg%5Cn%20%20%20%20src%3D%5C%22http%3A%2F%2Fmrhope.site%2Fassets%2Fimg%2Fdinosaur_small.jpg%5C%22%5Cn%20%20%20%20alt%3D%5C%22%E4%B8%80%E5%8F%AA%E6%81%90%E9%BE%99%E5%A4%B4%E9%83%A8%E5%92%8C%E8%BA%AF%E5%B9%B2%E7%9A%84%E9%AA%A8%E6%9E%B6%EF%BC%8C%E5%AE%83%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%A4%A7%E7%9A%84%E5%A4%B4%EF%BC%8C%E9%95%BF%E7%9D%80%E9%94%8B%E5%88%A9%E7%9A%84%E7%89%99%E9%BD%BF%E3%80%82%5C%22%5Cn%20%20%20%20width%3D%5C%22400%5C%22%5Cn%20%20%20%20height%3D%5C%22341%5C%22%5Cn%20%20%2F%3E%5Cn%20%20%3Cfigcaption%3E%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E5%A4%A7%E5%AD%A6%E5%8D%9A%E7%89%A9%E9%A6%86%E5%B1%95%E5%87%BA%E7%9A%84%E4%B8%80%E5%8F%AA%E9%9C%B8%E7%8E%8B%E9%BE%99%E7%9A%84%E5%8C%96%E7%9F%B3%3C%2Ffigcaption%3E%5Cn%3C%2Ffigure%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>figure</span><span>></span></span>
  <span><span><span>&lt;</span>img</span>
    <span>src</span><span><span>=</span><span>"</span>http://mrhope.site/assets/img/dinosaur_small.jpg<span>"</span></span>
    <span>alt</span><span><span>=</span><span>"</span>一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。<span>"</span></span>
    <span>width</span><span><span>=</span><span>"</span>400<span>"</span></span>
    <span>height</span><span><span>=</span><span>"</span>341<span>"</span></span>
  <span>/></span></span>
  <span><span><span>&lt;</span>figcaption</span><span>></span></span>曼彻斯特大学博物馆展出的一只霸王龙的化石<span><span><span>&lt;/</span>figcaption</span><span>></span></span>
<span><span><span>&lt;/</span>figure</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>这个 <code>&lt;figcaption&gt;</code> 元素 告诉浏览器和其他辅助的技术工具这段说明文字描述了 <code>&lt;figure&gt;</code> 元素的内容。</p>
<div><p>注意</p>
<p>从无障碍的角度来说，说明文字和 alt 文本扮演着不同的角色。看得见图片的人们同样可以受益于说明文字，而 alt 文字只有在图片无法显示时才这样。</p>
</div>
<div><p>figure 的使用</p>
<p><code>&lt;figure&gt;</code> 里不一定要是一张图片，只要是一个这样的独立内容单元:</p>
<ul>
<li>用简洁、易懂的方式表达意图。</li>
<li>可以置于页面线性流的某处。</li>
<li>为主要内容提供重要的补充说明。</li>
</ul>
<p><code>&lt;figure&gt;</code> 可以是几张图片、一段代码、音视频、方程、表格或别的。</p>
</div>
<h2 id="自适应的图片"> 自适应的图片</h2>
<p>在这一部分中，我们将看看上面说明的两个问题，并且展示怎样用 HTML 的响应式图片来解决这些问题。</p>
<h3 id="分辨率切换"> 分辨率切换</h3>
<p>我们想要显示相同的图片内容，仅仅依据设备来显示更大或更小的图片。标准的 <code>&lt;img&gt;</code> 元素传统上仅仅让您给浏览器指定唯一的资源文件。</p>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>elva-fairy-800w.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>Elva dressed as a fairy<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>但是 <code>srcset</code> 和 <code>sizes</code> 可以提供更多额外的资源图像和提示，帮助浏览器选择正确的一个资源。</p>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>srcset</span><span><span>=</span><span>"</span>
    elva-fairy-320w.jpg 320w,
    elva-fairy-480w.jpg 480w,
    elva-fairy-800w.jpg 800w
  <span>"</span></span>
  <span>sizes</span><span><span>=</span><span>"</span>(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px<span>"</span></span>
  <span>src</span><span><span>=</span><span>"</span>elva-fairy-800w.jpg<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>Elva dressed as a fairy<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>srcset</code> 和 <code>sizes</code> 属性看起来很复杂，但是他们并不难理解。每个值都包含逗号分隔的列表。</p>
<p><code>srcset</code> 定义了我们允许浏览器选择的图像集，以及每个图像的大小。在每个逗号之前，我们写:</p>
<ol>
<li>一个文件名 (elva-fairy-480w.jpg.)</li>
<li>一个空格</li>
<li>图像的固有宽度(以像素为单位)(480w)</li>
</ol>
<div><p>注意</p>
<p>注意使用 <code>w</code> 单位，而不是您预计的 <code>px</code>。这是图像的真实大小。</p>
</div>
<p><code>sizes</code> 定义了一组媒体条件(例如屏幕宽度)并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择—我们在之前已经讨论了一些提示。在这种情况下，在每个逗号之前，我们写:</p>
<ol>
<li>一个媒体条件((max-width:480px))——您会在 CSS topic 中学到更多的。但是现在我们仅仅讨论的是媒体条件描述了屏幕可能处于的状态。在这里，我们说“当可视窗口的宽度是 480 像素或更少”。</li>
<li>一个空格</li>
<li>当媒体条件为真时，图像将填充的槽的宽度(440px)</li>
</ol>
<div><p>提示</p>
<p>您也许会提供宽度一个固定值 (px, em) 或者是一个相对于视口的长度(vw)。最后一个槽的宽度是没有媒体条件的，它是默认的，当没有任何一个媒体条件为真时，它就会生效。当浏览器成功匹配第一个媒体条件的时候，剩下所有的东西都会被忽略，所以要注意媒体条件的顺序。</p>
</div>
<p>所以，有了这些属性，浏览器会:</p>
<ol>
<li>查看设备宽度</li>
<li>检查 sizes 列表中哪个媒体条件是第一个为真</li>
<li>查看给予该媒体查询的槽大小</li>
<li>加载 srcset 列表中引用的最接近所选的槽大小的图像</li>
</ol>
<p>老旧的浏览器不支持这些特性，它会忽略这些特征。并继续正常加载 <code>src</code> 属性引用的图像文件。</p>
<div><p>提示</p>
<p>在本博客 HTML 文件中的 <code>&lt;head&gt;</code> 标签里，您将会找到这一行代码 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>。这行代码会强制地让手机浏览器采用它们真实可视窗口的宽度来加载网页。</p>
<p>有些手机浏览器会提供不真实的可视窗口宽度, 然后加载比浏览器真实可视窗口的宽度大的宽度的网页，然后再缩小加载的页面，这样的做法对响应式图片或其他设计，没有任何帮助。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">网站布局</title>
    <id>https://list-jiang.github.io/code/website/html/intro/layout/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/layout/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>HTML 不仅能够定义网页的单独部分 (例如“段落”或“图片”)，还可以使用块级元素 (例如“标题栏”、“导航菜单”、“主内容列”) 来定义网站中的复合区域。本文将探讨如何规划基本的网站结构，并根据规划的结构来编写 HTML。</p>
]]></summary>
    <content type="html"><![CDATA[<p>HTML 不仅能够定义网页的单独部分 (例如“段落”或“图片”)，还可以使用块级元素 (例如“标题栏”、“导航菜单”、“主内容列”) 来定义网站中的复合区域。本文将探讨如何规划基本的网站结构，并根据规划的结构来编写 HTML。</p>

<h2 id="文档的基本组成部分"> 文档的基本组成部分</h2>
<p>网页的外观多种多样，但是除了全屏视频或游戏，或艺术作品页面，或只是结构不当的页面以外，都倾向于使用类似的标准组件:</p>
<h3 id="页眉"> 页眉</h3>
<p>通常横跨于整个页面顶部有一个大标题或一个 LOGO。这是网站的主要一般信息，通常存在于所有网页。</p>
<h3 id="导航栏"> 导航栏</h3>
<p>指向网站各个主要区段的超链接。通常用菜单按钮、链接或标签页表示。类似于标题栏，导航栏通常应在所有网页之间保持一致，否则会让用户感到疑惑，甚至无所适从。许多 web 设计人员认为导航栏是标题栏的一部分，而不是独立的组件，但这并非绝对，两者独立可以提供更好的无障碍访问特性，因为屏幕阅读器可以更清晰地分辨二者。</p>
<h3 id="主内容"> 主内容</h3>
<p>中心的大部分区域是当前网页大多数的独有内容，例如视频、文章、地图、新闻等。这些内容是网站的一部分，且会因页面而异。</p>
<h3 id="侧边栏"> 侧边栏</h3>
<p>一些外围信息、链接、引用、广告等。通常与主内容相关(例如一个新闻页面上，侧边栏可能包含作者信息或相关文章链接)，还可能存在其他的重复元素，如辅助导航系统。</p>
<h3 id="页脚"> 页脚</h3>
<p>横跨页面底部的狭长区域。和标题一样，页脚是放置公共信息(比如版权声明或联系方式)的，一般使用较小字体，且通常为次要内容。还可以通过提供快速访问链接来进行 SEO。</p>
<h2 id="用于构建内容的-html"> 用于构建内容的 HTML</h2>
<p>视觉效果并不是一切。我们可以修改最重要内容(例如导航菜单和相关链接)的颜色、字体大小来吸引用户的注意，但是这对视障人士是无效的，“粉红色”和“大字体”对他们并不奏效。</p>
<div><p>提示</p>
<p>注: 全球色盲患者比例为 4%，换句话说，每 12 名男性就有一位色盲，每 200 名女性就有一位色盲。全盲和视障人士约占世界人口(约 70 亿)的 13%(2015 年 全球约有 9.4 亿人口存在视力问题)。</p>
</div>
<p>HTML 代码中可根据功能来为区段添加标记。可使用元素来无歧义地表示上文所讲的内容区段，屏幕阅读器等辅助技术可以识别这些元素，并帮助执行“找到主导航 “或”找到主内容“等任务。参见前文所讲的 页面中元素结构和语义不佳所带来的后果。</p>
<p>为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如:</p>
<ul>
<li><code>&lt;header&gt;</code>: 页眉。</li>
<li><code>&lt;nav&gt;</code>: 导航栏。</li>
<li><code>&lt;main&gt;</code>: 主内容。主内容中还可以有各种子内容区段，可用 <code>&lt;article&gt;</code>、<code>&lt;section&gt;</code> 和 <code>&lt;div&gt;</code> 等元素表示。</li>
<li><code>&lt;aside&gt;</code>: 侧边栏，经常嵌套在 <code>&lt;main&gt;</code> 中。</li>
<li><code>&lt;footer&gt;</code>: 页脚。</li>
</ul>
<h3 id="案例"> 案例</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>utf-8<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>二次元俱乐部<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span>
      <span>href</span><span><span>=</span><span>"</span>https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One<span>"</span></span>
      <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span>
    <span>/></span></span>
    <span><span><span>&lt;</span>link</span>
      <span>href</span><span><span>=</span><span>"</span>https://fonts.googleapis.com/css?family=ZCOOL+KuaiLe<span>"</span></span>
      <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span>
    <span>/></span></span>
    <span><span><span>&lt;</span>link</span> <span>href</span><span><span>=</span><span>"</span>style.css<span>"</span></span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>

  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>header</span><span>></span></span>
      <span>&lt;!-- 本站所有网页的统一主标题 --></span>
      <span><span><span>&lt;</span>h1</span><span>></span></span>聆听电子天籁之音<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>header</span><span>></span></span>

    <span><span><span>&lt;</span>nav</span><span>></span></span>
      <span>&lt;!-- 本站统一的导航栏 --></span>
      <span><span><span>&lt;</span>ul</span><span>></span></span>
        <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>主页<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
        <span>&lt;!-- 共n个导航栏项目，省略…… --></span>
      <span><span><span>&lt;/</span>ul</span><span>></span></span>

      <span><span><span>&lt;</span>form</span><span>></span></span>
        <span>&lt;!-- 搜索栏是站点内导航的一个非线性的方式。--></span>
        <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>search<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>q<span>"</span></span> <span>placeholder</span><span><span>=</span><span>"</span>要搜索的内容<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>submit<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>搜索<span>"</span></span> <span>/></span></span>
      <span><span><span>&lt;/</span>form</span><span>></span></span>
    <span><span><span>&lt;/</span>nav</span><span>></span></span>

    <span><span><span>&lt;</span>main</span><span>></span></span>
      <span>&lt;!-- 网页主体内容 --></span>
      <span><span><span>&lt;</span>article</span><span>></span></span>
        <span>&lt;!-- 此处包含一个 article(一篇文章)，内容略…… --></span>
      <span><span><span>&lt;/</span>article</span><span>></span></span>

      <span><span><span>&lt;</span>aside</span><span>></span></span>
        <span>&lt;!-- 侧边栏在主内容右侧 --></span>
        <span><span><span>&lt;</span>h2</span><span>></span></span>相关链接<span><span><span>&lt;/</span>h2</span><span>></span></span>
        <span><span><span>&lt;</span>ul</span><span>></span></span>
          <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>这是一个超链接<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
          <span>&lt;!-- 侧边栏有n个超链接，略略略…… --></span>
        <span><span><span>&lt;/</span>ul</span><span>></span></span>
      <span><span><span>&lt;/</span>aside</span><span>></span></span>
    <span><span><span>&lt;/</span>main</span><span>></span></span>

    <span><span><span>&lt;</span>footer</span><span>></span></span>
      <span>&lt;!-- 本站所有网页的统一页脚 --></span>
      <span><span><span>&lt;</span>p</span><span>></span></span>© 2050 某某保留所有权利<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>footer</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="html-布局元素细节"> HTML 布局元素细节</h2>
<p>理解所有 HTML 区段元素具体含义是很有益处的，以下列出了常见元素:</p>
<ul>
<li>
<p><code>&lt;main&gt;</code></p>
<p>存放每个页面独有的内容。每个页面上只能用一次 <code>&lt;main&gt;</code>，且直接位于 <code>&lt;body&gt;</code> 中。最好不要把它嵌套进其它元素。</p>
</li>
<li>
<p><code>&lt;article</code>&gt;</p>
<p>一篇文章，与页面其它部分无关(比如一篇博文)。</p>
</li>
<li>
<p><code>&lt;section&gt;</code></p>
<p>与 <code>&lt;article&gt;</code> 类似，但 <code>&lt;section&gt;</code> 更适用于组织页面使其按功能 (比如迷您地图、一组文章标题和摘要) 分块。</p>
<p>一般的最佳用法是以标题作为开头。也可以把一篇 <code>&lt;article&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;section&gt;</code> 中，也可以把一个区段 <code>&lt;section&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;article&gt;</code> 中，取决于上下文。</p>
</li>
<li>
<p><code>&lt;aside&gt;</code> 包含一些间接信息(术语条目、作者简介、相关链接，等等)。</p>
</li>
<li>
<p><code>&lt;header&gt;</code> 是简介形式的内容。如果它是 <code>&lt;body&gt;</code> 的子元素，那么就是网站的全局页眉。如果它是 <code>&lt;article&gt;</code> 或 <code>&lt;section&gt;</code> 的子元素，那么它是这些部分特有的页眉(此 <code>&lt;header&gt;</code> 非彼 标题)。</p>
</li>
<li>
<p><code>&lt;nav&gt;</code> 包含页面主导航功能。其中不应包含二级链接等内容。</p>
</li>
<li>
<p><code>&lt;footer&gt;</code> 包含了页面的页脚部分。</p>
</li>
</ul>
<h3 id="无语义元素"> 无语义元素</h3>
<p>有时您会发现，对于一些要组织的项目或要包装的内容，现有的语义元素均不能很好对应。有时候您可能只想将一组元素作为一个单独的实体来修饰来响应单一的用 CSS 或 JavaScript。为了应对这种情况，HTML 提供了 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 元素。应配合使用 class 属性提供一些标签，使这些元素能易于查询。</p>
<p><code>&lt;span&gt;</code> 是一个内联的 (inline) 无语义元素，最好只用于无法找到更好的语义元素来包含内容时，或者不想增加特定的含义时。</p>

          <div
            id="code-demo-3a4201d5"
           
  
 data-title="%E6%97%A0%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0%20span"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E5%9B%BD%E7%8E%8B%E5%96%9D%E5%BE%97%E9%85%A9%E9%85%8A%E5%A4%A7%E9%86%89%EF%BC%8C%E5%9C%A8%E5%87%8C%E6%99%A8%201%20%E7%82%B9%E6%97%B6%E6%89%8D%E5%9B%9E%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%88%BF%E9%97%B4%EF%BC%8C%E8%B8%89%E8%B7%84%E5%9C%B0%E8%B5%B0%E8%BF%87%E9%97%A8%E5%8F%A3%E3%80%82%3Cspan%5Cn%20%20%20%20class%3D%5C%22editor-note%5C%22%5Cn%20%20%20%20%3E%5B%E7%BC%96%E8%BE%91%E6%89%B9%E6%B3%A8%3A%20%E6%AD%A4%E5%88%BB%E8%88%9E%E5%8F%B0%E7%81%AF%E5%85%89%E5%BA%94%E5%8F%98%E6%9A%97%5D%3C%2Fspan%5Cn%20%20%3E.%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  国王喝得酩酊大醉，在凌晨 1 点时才回到自己的房间，踉跄地走过门口。<span><span><span>&lt;</span>span</span>
    <span>class</span><span><span>=</span><span>"</span>editor-note<span>"</span></span>
    <span>></span></span>[编辑批注: 此刻舞台灯光应变暗]<span><span><span>&lt;/</span>span</span>
  <span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这里，“编辑批注”仅仅是对舞台剧导演提供额外指引；没有具体语义。对于视力正常的用户，CSS 应将批注内容与主内容稍微隔开一些。</p>

            </div>
          </div>
          
        </div>
<p><code>&lt;div&gt;</code> 是一个块级无语义元素，应仅用于找不到更好的块级元素时，或者不想增加特定的意义时。例如，一个电子商务网站页面上有一个一直显示的购物车组件。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>shopping-cart<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h2</span><span>></span></span>购物车<span><span><span>&lt;/</span>h2</span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>p</span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span><span><span><span>&lt;</span>strong</span><span>></span></span>银耳环<span><span><span>&lt;/</span>strong</span><span>></span></span><span><span><span>&lt;/</span>a</span>
        <span>></span></span>: $99.95.
      <span><span><span>&lt;/</span>p</span><span>></span></span>
      <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>../products/3333-0985/<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>Silver earrings<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span>...<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>售价: $237.89<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这里不应使用 <code>&lt;aside&gt;</code>，因为它和主内容并没有必要的联系(您想在任何地方都能看到它)。甚至不能用 <code>&lt;section&gt;</code> ，因为它也不是页面上主内容的一部分。所以在这种情况下就应使用 <code>&lt;div&gt;</code>，为满足无障碍使用特征，还应为购物车的标题设置一个可读标签。</p>
<div><p>提示</p>
<p><code>&lt;div&gt;</code> 非常便利但容易被滥用。由于它们没有语义值，会使 HTML 代码变得混乱。要小心使用，只有在没有更好的语义方案时才选择它，而且要尽可能少用， 否则文档的语义化升级和维护工作会非常困难。</p>
</div>
<h3 id="换行与水平分割线"> 换行与水平分割线</h3>
<p><code>&lt;br&gt;</code> 可在段落中进行换行；<code>&lt;br&gt;</code> 是唯一能够生成多个短行结构(例如邮寄地址或诗歌)的元素。比如:</p>

          <div
            id="code-demo-a2ce3f9e"
           
  
 data-title="%E6%8D%A2%E8%A1%8C"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E4%BB%8E%E5%89%8D%E6%9C%89%E4%B8%AA%E4%BA%BA%E5%8F%AB%E5%B0%8F%E9%AB%98%3Cbr%20%2F%3E%5Cn%20%20%E4%BB%96%E8%AF%B4%E5%86%99%20HTML%20%E6%84%9F%E8%A7%89%E6%9C%80%E5%A5%BD%3Cbr%20%2F%3E%5Cn%20%20%E4%BD%86%E4%BB%96%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%AD%E4%B9%89%E4%B8%80%E5%9B%A2%E7%B3%9F%3Cbr%20%2F%3E%5Cn%20%20%E4%BB%96%E5%86%99%E7%9A%84%E6%A0%87%E7%AD%BE%E8%B0%81%E4%B9%9F%E6%87%82%E4%B8%8D%E4%BA%86%E3%80%82%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  从前有个人叫小高<span><span><span>&lt;</span>br</span> <span>/></span></span>
  他说写 HTML 感觉最好<span><span><span>&lt;</span>br</span> <span>/></span></span>
  但他写的代码结构语义一团糟<span><span><span>&lt;</span>br</span> <span>/></span></span>
  他写的标签谁也懂不了。
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><code>&lt;hr&gt;</code> 元素在文档中生成一条水平分割线，表示文本中主题的变化(例如话题或场景的改变)。一般就是一条水平的直线。例如:</p>

          <div
            id="code-demo-2f66ddb2"
           
  
 data-title="%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2%E7%BA%BF"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E5%8E%9F%E6%9D%A5%E8%BF%99%E5%94%90%E5%83%A7%E6%98%AF%E4%B8%AA%E6%85%88%E6%82%AF%E7%9A%84%E5%9C%A3%E5%83%A7%E3%80%82%E4%BB%96%E8%A7%81%E8%A1%8C%E8%80%85%E5%93%80%E5%91%8A%EF%BC%8C%E5%8D%B4%E4%B9%9F%E5%9B%9E%E5%BF%83%E8%BD%AC%E6%84%8F%E9%81%93%3A%5Cn%20%20%E2%80%9C%E6%97%A2%E5%A6%82%E6%AD%A4%E8%AF%B4%EF%BC%8C%E4%B8%94%E9%A5%B6%E6%82%A8%E8%BF%99%E4%B8%80%E6%AC%A1%E3%80%82%E5%86%8D%E4%BC%91%E6%97%A0%E7%A4%BC%E3%80%82%E5%A6%82%E8%8B%A5%E4%BB%8D%E5%89%8D%E4%BD%9C%E6%81%B6%EF%BC%8C%E8%BF%99%E5%92%92%E8%AF%AD%E9%A2%A0%E5%80%92%E5%B0%B1%E5%BF%B5%E4%BA%8C%E5%8D%81%E9%81%8D!%5Cn%20%20%E2%80%9D%E8%A1%8C%E8%80%85%E9%81%93%3A%5Cn%20%20%E2%80%9C%E4%B8%89%E5%8D%81%E9%81%8D%E4%B9%9F%E7%94%B1%E6%82%A8%EF%BC%8C%E5%8F%AA%E6%98%AF%E6%88%91%E4%B8%8D%E6%89%93%E4%BA%BA%E4%BA%86%E3%80%82%E2%80%9D%E5%8D%B4%E6%89%8D%E4%BC%8F%E4%BE%8D%E5%94%90%E5%83%A7%E4%B8%8A%E9%A9%AC%EF%BC%8C%E5%8F%88%E5%B0%86%E6%91%98%E6%9D%A5%E6%A1%83%E5%AD%90%E5%A5%89%E4%B8%8A%E3%80%82%E5%94%90%E5%83%A7%E5%9C%A8%E9%A9%AC%E4%B8%8A%E4%B9%9F%E5%90%83%E4%BA%86%E5%87%A0%E4%B8%AA%EF%BC%8C%E6%9D%83%E4%B8%94%E5%85%85%E9%A5%A5%E3%80%82%5Cn%3C%2Fp%3E%5Cn%3Chr%20%2F%3E%5Cn%3Cp%3E%5Cn%20%20%E5%8D%B4%E8%AF%B4%E9%82%A3%E5%A6%96%E7%B2%BE%EF%BC%8C%E8%84%B1%E5%91%BD%E5%8D%87%E7%A9%BA%E3%80%82%E5%8E%9F%E6%9D%A5%E8%A1%8C%E8%80%85%E9%82%A3%E4%B8%80%E6%A3%92%E4%B8%8D%E6%9B%BE%E6%89%93%E6%9D%80%E5%A6%96%E7%B2%BE%EF%BC%8C%E5%A6%96%E7%B2%BE%E5%87%BA%E7%A5%9E%E5%8E%BB%E4%BA%86%E3%80%82%E4%BB%96%E5%9C%A8%E9%82%A3%E4%BA%91%E7%AB%AF%E9%87%8C%EF%BC%8C%E5%92%AC%E7%89%99%E5%88%87%E9%BD%BF%EF%BC%8C%E6%9A%97%E6%81%A8%E8%A1%8C%E8%80%85%E9%81%93%3A%5Cn%20%20%E2%80%9C%E5%87%A0%E5%B9%B4%E5%8F%AA%E9%97%BB%E5%BE%97%E8%AE%B2%E4%BB%96%E6%89%8B%E6%AE%B5%EF%BC%8C%E4%BB%8A%E6%97%A5%E6%9E%9C%E7%84%B6%E8%AF%9D%E4%B8%8D%E8%99%9A%E4%BC%A0%E3%80%82%E9%82%A3%E5%94%90%E5%83%A7%E5%B7%B2%E6%AD%A4%E4%B8%8D%E8%AE%A4%E5%BE%97%E6%88%91%EF%BC%8C%E5%B0%86%E8%A6%81%E5%90%83%E9%A5%AD%E3%80%82%E8%8B%A5%E4%BD%8E%E5%A4%B4%E9%97%BB%E4%B8%80%E9%97%BB%E5%84%BF%EF%BC%8C%E6%88%91%E5%B0%B1%E4%B8%80%E6%8A%8A%E6%8D%9E%E4%BD%8F%EF%BC%8C%E5%8D%B4%E4%B8%8D%E6%98%AF%E6%88%91%E7%9A%84%E4%BA%BA%E4%BA%86%E3%80%82%E4%B8%8D%E6%9C%9F%E8%A2%AB%E4%BB%96%E8%B5%B0%E6%9D%A5%EF%BC%8C%E5%BC%84%E7%A0%B4%E6%88%91%E8%BF%99%E5%8B%BE%E5%BD%93%EF%BC%8C%E5%8F%88%E5%87%A0%E4%B9%8E%E8%A2%AB%E4%BB%96%E6%89%93%E4%BA%86%E4%B8%80%E6%A3%92%E3%80%82%E8%8B%A5%E9%A5%B6%E4%BA%86%E8%BF%99%E4%B8%AA%E5%92%8C%E5%B0%9A%EF%BC%8C%E8%AF%9A%E7%84%B6%E6%98%AF%E5%8A%B3%E8%80%8C%E6%97%A0%E5%8A%9F%E4%B9%9F%E3%80%82%E6%88%91%E8%BF%98%E4%B8%8B%E5%8E%BB%E6%88%8F%E4%BB%96%E4%B8%80%E6%88%8F%E3%80%82%E2%80%9D%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  原来这唐僧是个慈悯的圣僧。他见行者哀告，却也回心转意道:
  “既如此说，且饶您这一次。再休无礼。如若仍前作恶，这咒语颠倒就念二十遍!
  ”行者道:
  “三十遍也由您，只是我不打人了。”却才伏侍唐僧上马，又将摘来桃子奉上。唐僧在马上也吃了几个，权且充饥。
<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>hr</span> <span>/></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>
  却说那妖精，脱命升空。原来行者那一棒不曾打杀妖精，妖精出神去了。他在那云端里，咬牙切齿，暗恨行者道:
  “几年只闻得讲他手段，今日果然话不虚传。那唐僧已此不认得我，将要吃饭。若低头闻一闻儿，我就一把捞住，却不是我的人了。不期被他走来，弄破我这勾当，又几乎被他打了一棒。若饶了这个和尚，诚然是劳而无功也。我还下去戏他一戏。”
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">超链接</title>
    <id>https://list-jiang.github.io/code/website/html/intro/link/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/link/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>超链接是互联网提供的最令人兴奋的创新之一，它们从一开始就一直是互联网的一个特性，使互联网成为互联的网络。超链接使我们能够将我们的文档链接到任何其他文档(或其他资源)，也可以链接到文档的指定部分，我们可以在一个简单的网址上提供应用程序(与必须先安装的本地应用程序或其他东西相比)。几乎任何网络内容都可以转换为链接，点击(或激活)超链接将使网络浏览器转到另一个网址(URL)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>超链接是互联网提供的最令人兴奋的创新之一，它们从一开始就一直是互联网的一个特性，使互联网成为互联的网络。超链接使我们能够将我们的文档链接到任何其他文档(或其他资源)，也可以链接到文档的指定部分，我们可以在一个简单的网址上提供应用程序(与必须先安装的本地应用程序或其他东西相比)。几乎任何网络内容都可以转换为链接，点击(或激活)超链接将使网络浏览器转到另一个网址(URL)。</p>

<div><p>URL</p>
<p>URL 可以指向 HTML 文件、文本文件、图像、文本文档、视频和音频文件以及可以在网络上保存的任何其他内容。如果浏览器不知道如何显示或处理文件，它会询问您是否要打开文件(需要选择合适的本地应用来打开或处理文件)或下载文件(以后处理它)</p>
<p>更多 URL 相关，请见 <a href="./../definition/url.html">定义 → URL</a>。</p>
</div>
<h2 id="链接的解析"> 链接的解析</h2>
<p>通过将文本(或其他内容，见块级链接)转换为 <code>&lt;a&gt;</code> 元素内的链接来创建基本链接， 给它一个 <code>href</code> 属性(也称为目标)，它将包含您希望链接指向的网址。</p>

          <div
            id="code-demo-25849e01"
           
  
 data-title="%E9%93%BE%E6%8E%A5%20Demo"

            data-code="%7B%22html%22%3A%22%3Cp%3E%E6%88%91%E6%AD%A3%E5%9C%A8%E5%88%9B%E5%BB%BA%3Ca%20href%3D%5C%22https%3A%2F%2Fbaidu.com%5C%22%3E%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E7%99%BE%E5%BA%A6%E4%B8%BB%E9%A1%B5%E7%9A%84%E9%93%BE%E6%8E%A5%3C%2Fa%3E.%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>我正在创建<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://baidu.com<span>"</span></span><span>></span></span>一个指向百度主页的链接<span><span><span>&lt;/</span>a</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="使用-title-属性"> 使用 title 属性</h2>
<p>title 属性旨在包含关于链接的补充有用信息，例如页面包含什么样的信息或需要注意的事情。</p>

          <div
            id="code-demo-46258e6d"
           
  
 data-title="Title%20%E5%B1%9E%E6%80%A7"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E6%88%91%E6%AD%A3%E5%9C%A8%E5%88%9B%E5%BB%BA%3Ca%20href%3D%5C%22https%3A%2F%2Fbaidu.com%5C%22%20title%3D%5C%22%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%AD%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%5C%22%5Cn%20%20%20%20%3E%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E7%99%BE%E5%BA%A6%E4%B8%BB%E9%A1%B5%E7%9A%84%E9%93%BE%E6%8E%A5%3C%2Fa%5Cn%20%20%3E.%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  我正在创建<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://baidu.com<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>最大的中文搜索引擎<span>"</span></span>
    <span>></span></span>一个指向百度主页的链接<span><span><span>&lt;/</span>a</span>
  <span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>当鼠标指针悬停在链接上时，标题将作为提示信息出现。</p>
<div><p>提示</p>
<p>链接的标题仅当鼠标悬停在其上时才会显示，这意味着使用键盘来导航网页的人很难获取到标题信息。如果标题信息对于页面非常重要，您应该使用所有用户能都方便获取的方式来呈现，例如放在常规文本中。</p>
</div>
<h2 id="块级链接"> 块级链接</h2>
<p>您可以将一些内容转换为链接，甚至是块级元素。例如您想要将一个图像转换为链接，您只需把图像元素放到 <code>&lt;a&gt;&lt;/a&gt;</code> 标签中。</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://www.mozilla.org/en-US/<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>img</span>
    <span>src</span><span><span>=</span><span>"</span>mozilla-image.png<span>"</span></span>
    <span>alt</span><span><span>=</span><span>"</span>mozilla logo that links to the mozilla homepage<span>"</span></span>
  <span>/></span></span>
<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="统一资源定位符-url"> 统一资源定位符 (URL)</h2>
<p>统一资源定位符(英文: Uniform Resource Locator，简写: URL)是一个定义了在网络上的位置的一个文本字符串。例如我的博客主页定位在 <code>https://mrhope.site</code>.</p>
<p>URL 使用路径查找文件。路径指定文件系统中您感兴趣的文件所在的位置。</p>
<div><p>相关信息</p>
<p>更多详情，请见<a href="./../definition/url.html">定义 → URL</a>。</p>
</div>
<p><img src="./assets/simple-directory.png" alt="目录结构图" loading="lazy"></p>
<p>此目录结构的根目录称为 <code>creation-hyperlinks</code>。当在网站上工作时， 您会有一个包含整个网站的目录。在根目录，我们有一个 <code>index.html</code> 和一个 <code>contacts.html</code> 文件。在真实的网站上，<code>index.html</code> 将会成为我们的主页或登录页面。</p>
<p>我们的根目录还有两个目录—— <code>pdfs</code> 和 <code>projects</code>，它们分别包含一个 PDF (project-brief.pdf) 文件和一个 <code>index.html</code> 文件。请注意您可以有两个 <code>index.html</code> 文件，前提是他们在不同的目录下，许多网站就是如此。第二个 <code>index.html</code> 或许是项目相关信息的主登录界面。</p>
<ul>
<li>
<p>指向当前目录:</p>
<p>如果 <code>index.html</code>(目录顶层的 <code>index.html</code>)想要包含一个超链接指向 <code>contacts.html</code>，您只需要指定想要链接的文件名，因为它与当前文件是在同一个目录的. 所以您应该使用的 URL 是 <code>contacts.html</code>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  Want to contact a specific staff member? Find details on our
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>contacts.html<span>"</span></span><span>></span></span>contacts page<span><span><span>&lt;/</span>a</span><span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>指向子目录:</p>
<p>如果 <code>index.html</code> (目录顶层 <code>index.html</code>)想要包含一个超链接指向 <code>projects/index.html</code>，您需要先进入 <code>projects/</code> 项目目录，然后指明要链接到的文件 <code>index.html</code>。通过指定目录的名称，然后是正斜杠，然后是文件的名称。因此您要使用的 URL 是 <code>projects/index.html</code>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Visit my <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>projects/index.html<span>"</span></span><span>></span></span>project homepage<span><span><span>&lt;/</span>a</span><span>></span></span>.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>指向上级目录:</p>
<p>如果您想在 <code>projects/index.html</code> 中包含一个指向 <code>pdfs/project-brief.pdf</code> 的超链接，您必须先返回上级目录，然后再回到 pdf 目录。“返回上一个目录级”使用两个英文点号表示 — <code>..</code> — 所以您应该使用的 URL 是 <code>../pdfs/project-brief.pdf</code>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>A link to my <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>../pdfs/project-brief.pdf<span>"</span></span><span>></span></span>project brief<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="文档片段"> 文档片段</h2>
<p>超链接除了可以链接到文档外，也可以链接到 HTML 文档的特定部分(被称为文档片段)。要做到这一点，您必须首先给要链接到的元素分配一个 id 属性。例如，如果您想链接到一个特定的标题，可以这样做:</p>
<div><pre><code><span><span><span>&lt;</span>h2</span> <span>id</span><span><span>=</span><span>"</span>Mailing_address<span>"</span></span><span>></span></span>Mailing address<span><span><span>&lt;/</span>h2</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>然后链接到那个特定的 id，您可以在 URL 的结尾使用一个 <code>#</code> 号指向它，例如:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  Want to write us a letter? Use our
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>contacts.html#Mailing_address<span>"</span></span><span>></span></span>mailing address<span><span><span>&lt;/</span>a</span><span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>您甚至可以在同一份文档下，通过链接文档片段，来链接到同一份文档的另一部分:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  The <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#Mailing_address<span>"</span></span><span>></span></span>company mailing address<span><span><span>&lt;/</span>a</span><span>></span></span> can be found at the
  bottom of this page.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="链接最佳实践"> 链接最佳实践</h2>
<p>在写链接时有一些最好的做法。现在让我们看看这些。</p>
<h3 id="用清晰的链接措辞"> 用清晰的链接措辞</h3>
<p>把链接放在您的页面上很容易。这还不够。我们需要让所有的读者都可以使用链接，不管他们当前的环境和哪些工具。例如:</p>
<ul>
<li>使用屏幕阅读器的用户喜欢从页面上的一个链接跳到另一个链接，并且脱离上下文来阅读链接。</li>
<li>搜索引擎使用链接文本来索引目标文件，所以在链接文本中包含关键词是一个很好的主意，以有效地描述与之相关的信息。</li>
<li>读者往往会浏览页面而不是阅读每一个字，他们的眼睛会被页面的特征所吸引，比如链接。他们会找到描述性的链接。</li>
</ul>

          <div
            id="code-demo-108b72de"
           
  
 data-title="%E6%B8%85%E6%99%B0%E7%9A%84%E9%93%BE%E6%8E%A5"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%E5%A5%BD%E7%9A%84%E9%93%BE%E6%8E%A5%E6%96%87%E6%9C%AC%3A%5Cn%20%20%3Ca%20href%3D%5C%22https%3A%2F%2Ffirefox.com%2F%5C%22%3E%20%E4%B8%8B%E8%BD%BDFirefox%20%3C%2Fa%3E%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20%E4%B8%8D%E5%A5%BD%E7%9A%84%E9%93%BE%E6%8E%A5%E6%96%87%E6%9C%AC%3A%5Cn%20%20%3Ca%20href%3D%5C%22https%3A%2F%2Ffirefox.com%2F%5C%22%3E%20%E7%82%B9%E5%87%BB%E8%BF%99%E9%87%8C%20%3C%2Fa%3E%5Cn%20%20%E4%B8%8B%E8%BD%BDFirefox%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  好的链接文本:
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://firefox.com/<span>"</span></span><span>></span></span> 下载Firefox <span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  不好的链接文本:
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://firefox.com/<span>"</span></span><span>></span></span> 点击这里 <span><span><span>&lt;/</span>a</span><span>></span></span>
  下载Firefox
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>其他提示:</p>
<ul>
<li>不要重复 URL 作为链接文本的一部分 ——URL 看起来很丑，当屏幕朗读器一个字母一个字母的读出来的时候听起来就更丑了。</li>
<li>不要在链接文本中说“链接”或“链接到”——它只是噪音。屏幕阅读器告诉人们有一个链接。可视化用户也会知道有一个链接，因为链接通常是用不同的颜色设计的，并且存在下划线。</li>
<li>保持您的链接标签尽可能短。长链接尤其惹恼屏幕阅读器用户。</li>
</ul>
<h3 id="尽可能使用相对链接"> 尽可能使用相对链接</h3>
<p>从上面的描述中，您可能认为始终使用绝对链接是一个好主意；毕竟，当页面像相对链接那样移动时，它们不会中断。但是，当链接到同一网站的其他位置时，您应该使用相对链接 (当链接到另一个网站时，您需要使用绝对链接):</p>
<ul>
<li>首先，检查代码要容易得多——相对 URL 通常比绝对 URL 短得多，这使得阅读代码更容易。</li>
<li>其次，在可能的情况下使用相对 URL 更有效。当使用绝对 URL 时，浏览器首先通过 DNS 查找服务器的真实位置，然后再转到该服务器并查找所请求的文件。另一方面，相对 URL，浏览器只在同一服务器上查找被请求的文件。因此，如果您使用绝对 URL 而不是相对 URL，您就会不断地让您的浏览器做额外的工作，这意味着它的效率会降低。</li>
</ul>
<h3 id="链接到非-html-资源-留下清晰的指示"> 链接到非 HTML 资源 ——留下清晰的指示</h3>
<p>当链接到一个需要下载的资源 (如 PDF 或 Word 文档) 或流媒体 (如视频或音频) 或有另一个潜在的意想不到的效果(打开一个弹出窗口，或加载 Flash 电影)，您应该添加明确的措辞，以减少任何混乱。如下的例子会让人反感:</p>
<ul>
<li>如果您是在低带宽连接，点击一个链接，然后就开始下载大文件。</li>
<li>如果您没有安装 Flash 播放器，点击一个链接，然后突然被带到一个需要 Flash 的页面。</li>
</ul>

          <div
            id="code-demo-54eeffc1"
           
  
 data-title="%E4%B8%BA%E9%93%BE%E6%8E%A5%E7%95%99%E4%B8%8B%E6%8F%90%E7%A4%BA"

            data-code="%7B%22html%22%3A%22%3Cp%3E%5Cn%20%20%3Ca%20href%3D%5C%22http%3A%2F%2Fwww.example.com%2Flarge-report.pdf%5C%22%3E%5Cn%20%20%20%20%E4%B8%8B%E8%BD%BD%E9%94%80%E5%94%AE%E6%8A%A5%E5%91%8A(PDF%2C%2010MB)%5Cn%20%20%3C%2Fa%3E%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20%3Ca%20href%3D%5C%22http%3A%2F%2Fwww.example.com%2Fvideo-stream%2F%5C%22%3E%5Cn%20%20%20%20%E8%A7%82%E7%9C%8B%E8%A7%86%E9%A2%91(%E5%B0%86%E5%9C%A8%E6%96%B0%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B8%AD%E6%92%AD%E6%94%BE%2C%20HD%E7%94%BB%E8%B4%A8)%5Cn%20%20%3C%2Fa%3E%5Cn%3C%2Fp%3E%5Cn%5Cn%3Cp%3E%5Cn%20%20%3Ca%20href%3D%5C%22http%3A%2F%2Fwww.example.com%2Fcar-game%5C%22%3E%20%E8%BF%9B%E5%85%A5%E6%B1%BD%E8%BD%A6%E6%B8%B8%E6%88%8F%20%3C%2Fa%3E%5Cn%3C%2Fp%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.example.com/large-report.pdf<span>"</span></span><span>></span></span>
    下载销售报告(PDF, 10MB)
  <span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.example.com/video-stream/<span>"</span></span><span>></span></span>
    观看视频(将在新标签页中播放, HD画质)
  <span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.example.com/car-game<span>"</span></span><span>></span></span> 进入汽车游戏 <span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<h3 id="在下载链接时使用-download-属性"> 在下载链接时使用 download 属性</h3>
<p>当您链接到要下载的资源而不是在浏览器中打开时，您可以使用 <code>download</code> 属性来提供一个默认的保存文件名 (此属性仅适用于同源 URL)。下面是一个下载链接到 Firefox 的 Windows 最新版本的示例:</p>

          <div
            id="code-demo-618e357c"
           
  
 data-title="download%20%E5%B1%9E%E6%80%A7"

            data-code="%7B%22html%22%3A%22%3Ca%5Cn%20%20href%3D%5C%22https%3A%2F%2Fdownload.mozilla.org%2F%3Fproduct%3Dfirefox-latest-ssl%26os%3Dwin64%26lang%3Den-US%5C%22%5Cn%20%20download%3D%5C%22firefox-latest-64bit-installer.exe%5C%22%5Cn%3E%5Cn%20%20%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84%20Windows%20%E7%89%88%20Firefox%20(64-bit)%20(English%2C%20US)%5Cn%3C%2Fa%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span>https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=en-US<span>"</span></span>
  <span>download</span><span><span>=</span><span>"</span>firefox-latest-64bit-installer.exe<span>"</span></span>
<span>></span></span>
  下载最新的 Windows 版 Firefox (64-bit) (English, US)
<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="电子邮件链接"> 电子邮件链接</h2>
<p>当点击一个链接或按钮时，打开一个新的电子邮件发送信息而不是连接到一个资源或页面，这种情况是可能做到的。这样做是使用 <code>&lt;a&gt;</code> 元素和 <code>mailto:</code> URL 的方案。其最基本和最常用的使用形式为一个 <code>mailto:link</code>，链接简单说明收件人的电子邮件地址。</p>

          <div
            id="code-demo-3cacf8e1"
           
  
 data-title="%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5"

            data-code="%7B%22html%22%3A%22%3Ca%20href%3D%5C%22mailto%3Anowhere%40mozilla.org%5C%22%3ESend%20email%20to%20nowhere%3C%2Fa%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>mailto:nowhere@mozilla.org<span>"</span></span><span>></span></span>Send email to nowhere<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>网站页脚的邮箱也是类似的链接</p>

            </div>
          </div>
          
        </div>
<p>实际上，邮件地址甚至是可选的。如果您忘记了(也就是说，您的 <code>href</code> 仅仅只是简单的 <code>mailto:</code>)，一个新的发送电子邮件的窗口也会被用户的邮件客户端打开，只是没有收件人的地址信息，这通常在“分享”链接是很有用的，用户可以发送给他们选择的地址邮件</p>
<h3 id="具体细节"> 具体细节</h3>
<p>除了电子邮件地址，您还可以提供其他信息。事实上，任何标准的邮件头字段可以被添加到您提供的邮件 URL。其中最常用的是主题(subject)、抄送(cc)和主体(body) (这不是一个真正的头字段，但允许您为新邮件指定一个短内容消息)。每个字段及其值被指定为查询项。</p>

          <div
            id="code-demo-a9e1da0e"
           
  
 data-title="%E5%9C%A8%E9%93%BE%E6%8E%A5%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BF%A1%E6%81%AF"

            data-code="%7B%22html%22%3A%22%3Ca%5Cn%20%20href%3D%5C%22mailto%3Anowhere%40mozilla.org%3Fcc%3Dname2%40rapidtables.com%26bcc%3Dname3%40rapidtables.com%26subject%3DThe%2520subject%2520of%2520the%2520email%26body%3DThe%2520body%2520of%2520the%2520email%5C%22%5Cn%20%20%3E%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%3C%2Fa%5Cn%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span>mailto:nowhere@mozilla.org?cc=name2@rapidtables.com&amp;bcc=name3@rapidtables.com&amp;subject=The%20subject%20of%20the%20email&amp;body=The%20body%20of%20the%20email<span>"</span></span>
  <span>></span></span>发送邮件<span><span><span>&lt;/</span>a</span>
<span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>
            </div>
          </div>
          
        </div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">视频和音频</title>
    <id>https://list-jiang.github.io/code/website/html/intro/media/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/media/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>HTML5 标准推出了 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 标签，以及一些 JavaScript 和 APIs 用于对其进行控制。</p>
<h2 id="video-元素"> <code>&lt;video&gt;</code> 元素</h2>
<p><code>&lt;video&gt;</code> 允许您轻松地嵌入一段视频。</p>
<div><p>案例</p>
<div><pre><code><span><span><span>&lt;</span>video</span> <span>src</span><span><span>=</span><span>"</span>rabbit320.webm<span>"</span></span> <span>controls</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    您的浏览器不支持 HTML5 视频。可点击<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>rabbit320.mp4<span>"</span></span><span>></span></span>此链接<span><span><span>&lt;/</span>a</span><span>></span></span>观看
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>video</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<p>案例属性解释:</p>
<ul>
<li>
<p>src</p>
<p>同 <code>&lt;img&gt;</code> 标签使用方式相同，<code>src</code> 属性指向您想要嵌入网页当中的视频资源，他们的使用方式完全相同。</p>
</li>
<li>
<p>controls</p>
<p>用户必须能够控制视频和音频的回放功能。您可以使用 <code>controls</code> 来包含浏览器提供的控件界面，同时您也可以使用合适的 JavaScript API 创建自己的界面。界面中至少要包含开始、停止以及调整音量的功能。</p>
</li>
<li>
<p><code>&lt;video&gt;</code> 标签内的内容</p>
<p>此内容叫后备内容。当浏览器不支持 <code>&lt;video&gt;</code> 标签的时候，就会显示这段内容，这使得我们能够对旧的浏览器提供回退内容。您可以添加任何后备内容，在这个例子中我们提供了一个指向这个视频文件的链接，从而使用户至少可以访问到这个文件，而不会局限于浏览器的支持。</p>
</li>
</ul>
<h3 id="兼容性"> 兼容性</h3>
<p>如果您使用 Safari 或者 IE 来访问上面的链接，视频并不会播放，这是因为不同的浏览器对视频格式的支持不同。</p>
<p>所以 <code>&lt;video&gt;</code> 标签的最佳实践是使用多个播放源以提高兼容性。</p>
<div><p>媒体文件的内容</p>
<p>像 MP3、MP4、WebM 这些术语叫做容器格式。他们定义了构成媒体文件的音频轨道和视频轨道的储存结构，其中还包含描述这个媒体文件的元数据，以及用于编码的编码译码器等等。</p>
<p>一个格式为 WebM 的电影包含视频轨道，音频轨道和文本轨道，其中视频轨道包含一个主视频轨道和一个可选的 Angle 轨道。</p>
<p>为了编解码器(codec)编码媒体，容器中的音频和视频轨道以适合的格式保存。音频轨道和视频轨道使用不同的格式。每个音频轨道都使用音频编解码器进行编码，而视频轨道则使用视频编解码器进行编码。如前所述，不同的浏览器支持不同的视频和音频格式，以及不同的容器格式(如 MP3、MP4 和 WebM，这些格式又可以包含不同类型的视频和音频)。</p>
<p>例如:</p>
<ul>
<li>WebM 容器通常包括了 Opus 或 Vorbis 音频和 VP8/VP9 视频。这在所有的现代浏览器中都支持，除了他们的老版本。</li>
<li>MP4 容器通常包括 AAC 以及 MP3 音频和 H.264 视频。这在所有的现代浏览器中都支持，还有 Internet Explorer。</li>
<li>老式的 Ogg 容器往往支持 Ogg Vorbis 音频和 Ogg Theora 视频。主要在 Firefox 和 Chrome 当中支持，不过这个容器已经被更强大的 WebM 容器所取代。</li>
</ul>
<p>有一些特殊情况。例如，对于某些类型的音频，通常编解码器的数据存储没有容器或简化容器。其中一个例子就是 FLAC 编解码器，它通常存储在 FLAC 文件中，FLAC 文件只是 FLAC 的原始轨迹。</p>
<p>另一种情况是一直流行的 MP3 文件。“MP3 文件”实际上是存储在 MPEG 或 MPEG-2 容器中的 MPEG-1 音频层 III(MPEG-1 Audio Layer III ，MP3)音频轨道。这一点特别有趣，因为尽管大多数浏览器不支持在 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素中使用 MPEG 媒体，但由于 MP3 的流行，它们可能仍然支持 MP3。</p>
<p>音频播放器将会直接播放音频文件，例如 MP3 和 Ogg 文件。这些不需要容器。</p>
</div>
<p>不同的媒体格式主要用于将音频和视频压缩成可管理的文件(原始的音频和视频文件非常大)。浏览器包含了不同的 Codecs,，如 Vorbis 和 H.264，它们用来将已压缩的音频和视频转化成二进制数字。不同的编码器和不同的容器都有各自的优缺点，在您更了解它们后，您可以自己选择使用哪个编码器和容器。</p>
<p>浏览器并不全支持相同的 codecs，所以您得使用几个不同格式的文件来兼容不同的浏览器。如果您使用的格式都得不到浏览器的支持，那么媒体文件将不会播放。另外同一款浏览器，移动版可能比桌面版支持的格式可能会有不同。</p>
<div><pre><code><span><span><span>&lt;</span>video</span> <span>controls</span><span>></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>rabbit320.mp4<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/mp4<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>rabbit320.webm<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/webm<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    您的浏览器不支持 HTML5 视频。可点击<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>rabbit320.mp4<span>"</span></span><span>></span></span>此链接<span><span><span>&lt;/</span>a</span><span>></span></span>观看
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>video</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>您需要将 <code>src</code> 属性从 <code>&lt;video&gt;</code> 标签中移除，转而将它放在几个单独的标签 <code>&lt;source&gt;</code> 当中。浏览器将会检查 <code>&lt;source&gt;</code> 标签，并且播放第一个与其自身 codec 相匹配的媒体。</p>
<div><p>提示</p>
<p>您的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。</p>
</div>
<p>每个 <code>&lt;source&gt;</code> 标签页含有一个 <code>type</code> 属性，这个属性是可选的，但是建议您添加上这个属性 — 它包含了视频文件的 <a href="./../definition/mime.html">MIME types</a> ，同时浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。如果您没有添加 <code>type</code> 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这样会消耗掉大量的时间和资源。</p>
<h3 id="其他属性"> 其他属性</h3>
<p>这里有许多您可以用在 HTML5 <code>&lt;video&gt;</code> 上的特性。</p>
<div><pre><code><span><span><span>&lt;</span>video</span>
  <span>controls</span>
  <span>width</span><span><span>=</span><span>"</span>400<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>400<span>"</span></span>
  <span>autoplay</span>
  <span>loop</span>
  <span>muted</span>
  <span>poster</span><span><span>=</span><span>"</span>poster.png<span>"</span></span>
<span>></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>rabbit320.mp4<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/mp4<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>rabbit320.webm<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/webm<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    您的浏览器不支持 HTML5 视频。可点击<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>rabbit320.mp4<span>"</span></span><span>></span></span>此链接<span><span><span>&lt;/</span>a</span><span>></span></span>观看
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>video</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li>
<p>width 和 height</p>
<p>您可以用属性控制视频的尺寸，也可以用 CSS 来控制视频尺寸。 无论使用哪种方式，视频都会保持它原始的长宽比 — 也叫做纵横比。如果您设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。</p>
</li>
<li>
<p>autoplay</p>
<p>这个属性会使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。建议不要应用这个属性在您的网站上，因为用户们会比较反感自动播放的媒体文件。</p>
</li>
<li>
<p>loop</p>
<p>这个属性可以让音频或者视频文件循环播放。同样不建议使用，除非有必要。</p>
</li>
<li>
<p>muted</p>
<p>这个属性会导致媒体播放时，默认关闭声音。</p>
</li>
<li>
<p>poster</p>
<p>这个属性指向了一个图像的 URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。</p>
</li>
<li>
<p>preload
这个属性被用来缓冲较大的文件，有 3 个值可选:</p>
<ul>
<li><code>none</code>: 不缓冲</li>
<li><code>auto</code>: 页面加载后缓存媒体文件</li>
<li><code>metadata</code>: 仅缓冲文件的元数据</li>
</ul>
</li>
</ul>
<h2 id="audio-标签"> <code>&lt;audio&gt;</code> 标签</h2>
<p><code>&lt;audio&gt;</code> 标签与 <code>&lt;video&gt;</code> 标签的使用方式几乎完全相同，有一些细微的差别。</p>
<div><pre><code><span><span><span>&lt;</span>audio</span> <span>controls</span><span>></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>viper.mp3<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>audio/mp3<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>viper.ogg<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>audio/ogg<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>您的浏览器不支持 HTML5 音频，可点击<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>viper.mp3<span>"</span></span><span>></span></span>此链接<span><span><span>&lt;/</span>a</span><span>></span></span>收听。<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>audio</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>音频播放器所占用的空间比视频播放器要小，由于它没有视觉部件 — 您只需要显示出能控制音频播放的控件。一些与 HTML5 <code>&lt;video&gt;</code> 的差异如下:</p>
<ul>
<li><code>&lt;audio&gt;</code> 标签不支持 <code>width/height</code> 属性 — 由于其并没有视觉部件，也就没有可以设置 <code>width/height</code> 的内容。</li>
<li>同时也不支持 <code>poster</code> 属性 — 同样，没有视觉部件。</li>
</ul>
<p>除此之外，<code>&lt;audio&gt;</code> 标签支持所有 <code>&lt;video&gt;</code> 标签拥有的特性。</p>
<h2 id="显示音轨文本"> 显示音轨文本</h2>
<p>文本轨道会使您的网站更容易被搜索引擎抓取到 (SEO)， 由于搜索引擎的文本抓取能力非常强大，使用文本轨道甚至可以让搜索引擎通过视频的内容直接链接。</p>
<div><p>WebVTT</p>
<p>WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在视频中显示的时间，甚至可以用来描述这些字符串的样式以及定位信息。这些字符串叫做 <strong>cues</strong>，您可以根据不同的需求来显示不同的样式，最常见的如下:</p>
<ul>
<li>
<p>subtitles</p>
<p>通过添加翻译字幕，来帮助那些听不懂外国语言的人们理解音频当中的内容。</p>
</li>
<li>
<p>captions</p>
<p>同步翻译对白，或是描述一些有重要信息的声音，来帮助那些不能听音频的人们理解音频中的内容。</p>
</li>
<li>
<p>timed descriptions</p>
<p>将文字转换为音频，用于服务那些有视觉障碍的人。</p>
</li>
</ul>
<p>一个典型的 WebVTT 文件如下:</p>
<div><pre><code>WEBVTT

1
00:00:22.230 --&gt; 00:00:24.606
第一段字幕

2
00:00:30.739 --&gt; 00:00:34.074
第二段

...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></div>
<p>有了 WebVTT 格式，您可以使用 <code>&lt;track&gt;</code> 标签。</p>
<p>让其与 HTML 媒体一起显示，您需要做如下工作:</p>
<ol>
<li>以 <code>.vtt</code> 后缀名保存文件。</li>
<li>用 <code>&lt;track&gt;</code> 标签链接 <code>.vtt</code> 文件， <code>&lt;track&gt;</code> 标签需放在 <code>&lt;audio&gt;</code> 或 <code>&lt;video&gt;</code> 标签当中，同时需要放在所有 <code>&lt;source&gt;</code> 标签之后。使用 <code>kind</code> 属性来指明是哪一种类型，如 <code>subtitles</code> 、 <code>captions</code> 、 <code>descriptions</code>。然后，使用 <code>srclang</code> 来告诉浏览器您是用什么语言来编写的 subtitles。</li>
</ol>
<div><p>案例</p>
<div><pre><code><span><span><span>&lt;</span>video</span> <span>controls</span><span>></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>example.mp4<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/mp4<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>source</span> <span>src</span><span><span>=</span><span>"</span>example.webm<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>video/webm<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>track</span> <span>kind</span><span><span>=</span><span>"</span>subtitles<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>subtitles_en.vtt<span>"</span></span> <span>srclang</span><span><span>=</span><span>"</span>en<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>video</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">HTML 介绍</title>
    <id>https://list-jiang.github.io/code/website/html/intro/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="html-介绍"> HTML 介绍</h2>
<ul>
<li>
<p><a href="./history.html">历史</a></p>
</li>
<li>
<p><a href="./head.html">Head 标签</a></p>
</li>
<li>
<p><a href="./basic.html">基本标签</a></p>
</li>
<li>
<p><a href="./link.html">链接</a></p>
</li>
<li>
<p><a href="./image.html">图片</a></p>
</li>
<li>
<p><a href="./svg.html">矢量图形</a></p>
</li>
<li>
<p><a href="./media.html">视频与音频</a></p>
</li>
<li>
<p><a href="./table.html">表格</a></p>
</li>
<li>
<p><a href="./embed.html">嵌入</a></p>
</li>
<li>
<p><a href="./format.html">格式化文档</a></p>
</li>
<li>
<p><a href="./layout.html">网站布局</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">SVG</title>
    <id>https://list-jiang.github.io/code/website/html/intro/svg/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/svg/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="矢量图形"> 矢量图形</h2>
<p>在网上，您会和两种类型的图片打交道 — 位图和矢量图:</p>
<ul>
<li>
<p>位图使用像素网格来定义。</p>
<p>一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.)</p>
</li>
<li>
<p>矢量图使用算法来定义。</p>
<p>一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG 格式可以让我们创造用于 Web 的精彩的矢量图形。</p>
</li>
</ul>
<div><p>提示</p>
<p>矢量图形相较于同样的位图，通常拥有更小的体积，因为它们仅需储存少量的算法，而不是逐个储存每个像素的信息。</p>
</div>
<h2 id="简介"> 简介</h2>
<p>SVG 是用于描述矢量图像的 XML 语言。它基本上是像 HTML 一样的标记，只是您有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。 SVG 用于标记图形，而不是内容。您可以使用一些元素来创建简单图形，如 <code>&lt;circle&gt;</code> 和 <code>&lt;rect&gt;</code>。更高级的 SVG 功能包括 <code>&lt;feColorMatrix&gt;</code>(使用变换矩阵转换颜色)<code>&lt;animate&gt;</code> (矢量图形的动画部分)和 <code>&lt;mask&gt;</code>(在图像顶部应用模板)。</p>

          <div
            id="code-demo-34e39ec0"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%20SVG"

            data-code="%7B%22html%22%3A%22%3Csvg%5Cn%20%20version%3D%5C%221.1%5C%22%5Cn%20%20baseProfile%3D%5C%22full%5C%22%5Cn%20%20width%3D%5C%22300%5C%22%5Cn%20%20height%3D%5C%22200%5C%22%5Cn%20%20xmlns%3D%5C%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%5C%22%5Cn%3E%5Cn%20%20%3Crect%20width%3D%5C%22100%25%5C%22%20height%3D%5C%22100%25%5C%22%20fill%3D%5C%22black%5C%22%20%2F%3E%5Cn%20%20%3Ccircle%20cx%3D%5C%22150%5C%22%20cy%3D%5C%22100%5C%22%20r%3D%5C%2290%5C%22%20fill%3D%5C%22blue%5C%22%20%2F%3E%5Cn%3C%2Fsvg%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>svg</span>
  <span>version</span><span><span>=</span><span>"</span>1.1<span>"</span></span>
  <span>baseProfile</span><span><span>=</span><span>"</span>full<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>300<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>200<span>"</span></span>
  <span>xmlns</span><span><span>=</span><span>"</span>http://www.w3.org/2000/svg<span>"</span></span>
<span>></span></span>
  <span><span><span>&lt;</span>rect</span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>height</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>fill</span><span><span>=</span><span>"</span>black<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>circle</span> <span>cx</span><span><span>=</span><span>"</span>150<span>"</span></span> <span>cy</span><span><span>=</span><span>"</span>100<span>"</span></span> <span>r</span><span><span>=</span><span>"</span>90<span>"</span></span> <span>fill</span><span><span>=</span><span>"</span>blue<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>svg</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>从上面的例子可以看出，SVG 很容易人工编码。您可以在文本编辑器中手动编写简单的 SVG，但是对于复杂的图像，这就变得非常困难。</p>
<p>为了创建 SVG 图像，大多数人使用矢量图形编辑器，如 Inkscape 或 Illustrator。这些软件包允许您使用各种图形工具创建各种插图，并创建照片的近似值(例如 Inkscape 的跟踪位图功能)。</p>
<p>SVG 除了迄今为止所描述的以外还有其他优点:</p>
<ul>
<li>矢量图像中的文本仍然可访问(这也有利于 SEO)。</li>
<li>SVG 可以很好地适应样式/脚本，因为图像的每个组件都是可以通过 CSS 或通过 JavaScript 编写的样式的元素。</li>
</ul>
<p>SVG 也确实有一些缺点:</p>
<ul>
<li>SVG 非常容易变得复杂，这意味着文件大小会增加; 复杂的 SVG 也会在浏览器中占用很长的处理时间。</li>
<li>SVG 可能比栅格图像更难创建，具体取决于您尝试创建哪种图像。</li>
<li>旧版浏览器不支持 SVG，(非主要的原因，IE 8 及更低版本，Android 2.3 及更低版本)。</li>
</ul>
<p>由于上述原因，光栅图形更适合照片那样复杂精密的图像。</p>
<h2 id="添加到页面"> 添加到页面</h2>
<h3 id="img"> <code>&lt;img&gt;</code></h3>
<p>要通过 <code>&lt;img&gt;</code> 元素嵌入 SVG，您只需要按照预期的方式在 <code>src</code> 属性中引用它。您将需要一个 <code>height</code> 或 <code>width</code> 属性。</p>

          <div
            id="code-demo-f10c681e"
           
  
 data-title="%E4%BD%BF%E7%94%A8%20img%20%E6%8F%92%E5%85%A5%20SVG"

            data-code="%7B%22html%22%3A%22%3Cimg%5Cn%20%20src%3D%5C%22%2Fassets%2Fimg%2Fvuepress-hope-logo.svg%5C%22%5Cn%20%20alt%3D%5C%22vuepress-theme-hope%5C%22%5Cn%20%20height%3D%5C%2287px%5C%22%5Cn%20%20width%3D%5C%22100px%5C%22%5Cn%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>src</span><span><span>=</span><span>"</span>/assets/img/vuepress-hope-logo.svg<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>vuepress-theme-hope<span>"</span></span>
  <span>height</span><span><span>=</span><span>"</span>87px<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>100px<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><strong>优点</strong>:</p>
<ul>
<li>快速，熟悉的图像语法与 <code>alt</code> 属性中提供的内置文本等效。</li>
<li>可以通过在 <code>&lt;a&gt;</code> 元素嵌套 <code>&lt;img&gt;</code>，使图像轻松地成为超链接。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>无法使用 JavaScript 操作图像。</li>
<li>如果要使用 CSS 控制 SVG 内容，则必须在 SVG 代码中包含内联 CSS 样式。 (从 SVG 文件调用的外部样式表不起作用)</li>
<li>不能用 CSS 伪类来重设图像样式 (如 <code>:focus</code>)。</li>
</ul>
<h3 id="兼容"> 兼容</h3>
<p>对于不支持 SVG (IE 8 及更低版本，Android 2.3 及更低版本) 的浏览器，您可以从 <code>src</code> 属性引用 PNG 或 JPG，并使用 <code>srcset</code> 属性来引用 SVG。 在这种情况下，支持的浏览器将加载 SVG，而较旧的浏览器将加载 PNG:</p>

          <div
            id="code-demo-66750e05"
           
  
 data-title="%E5%85%BC%E5%AE%B9%E4%B8%8A%E5%8F%A4%E6%B5%8F%E8%A7%88%E5%99%A8"

            data-code="%7B%22html%22%3A%22%3Cimg%5Cn%20%20src%3D%5C%22%2Fassets%2Fimg%2Fvuepress-hope-logo.png%5C%22%5Cn%20%20alt%3D%5C%22vuepress-theme-hope%5C%22%5Cn%20%20srcset%3D%5C%22%2Fassets%2Fimg%2Fvuepress-hope-logo.svg%5C%22%5Cn%20%20width%3D%5C%22100px%5C%22%5Cn%2F%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>img</span>
  <span>src</span><span><span>=</span><span>"</span>/assets/img/vuepress-hope-logo.png<span>"</span></span>
  <span>alt</span><span><span>=</span><span>"</span>vuepress-theme-hope<span>"</span></span>
  <span>srcset</span><span><span>=</span><span>"</span>/assets/img/vuepress-hope-logo.svg<span>"</span></span>
  <span>width</span><span><span>=</span><span>"</span>100px<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>您还可以使用 SVG 作为 CSS 背景图像，如下所示。 在下面的代码中，旧版浏览器会坚持他们理解的 PNG，而较新的浏览器将加载 SVG:</p>
<div><pre><code> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"fallback.png"</span><span>)</span></span> no-repeat center<span>;</span>
  <span>background-image</span><span>:</span> <span><span>url</span><span>(</span><span>"image.svg"</span><span>)</span></span><span>;</span>
  <span>background-size</span><span>:</span> contain<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>像上面描述的 <code>&lt;img&gt;</code> 方法一样，使用 CSS 背景图像插入 SVG 意味着它不能被 JavaScript 操作，并且也受到相同的 CSS 限制。</p>
<h3 id="html"> HTML</h3>
<p>您可以直接将 SVG 代码插入 HTML 文档中，这称为内联 SVG。确保您的 SVG 代码在 <code>&lt;svg&gt;&lt;/svg&gt;</code> 标签中(不要在外面添加任何内容)。</p>

          <div
            id="code-demo-ae68a5b6"
           
  
 data-title="%E6%A1%88%E4%BE%8B"

            data-code="%7B%22html%22%3A%22%3Csvg%20width%3D%5C%22300%5C%22%20height%3D%5C%22200%5C%22%3E%5Cn%20%20%3Crect%20width%3D%5C%22100%25%5C%22%20height%3D%5C%22100%25%5C%22%20fill%3D%5C%22green%5C%22%20%2F%3E%5Cn%3C%2Fsvg%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>svg</span> <span>width</span><span><span>=</span><span>"</span>300<span>"</span></span> <span>height</span><span><span>=</span><span>"</span>200<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>rect</span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>height</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>fill</span><span><span>=</span><span>"</span>green<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>svg</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<p><strong>优点</strong>:</p>
<ul>
<li>将 SVG 内联减少 HTTP 请求，可以减少加载时间。</li>
<li>您可以为 SVG 元素分配 class 和 id，并使用 CSS 修改样式，无论是在 SVG 中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 SVG 外观属性 作为 CSS 属性。</li>
<li>内联 SVG 是唯一可以让您在 SVG 图像上使用 CSS 交互(如 <code>:focus</code>)和 CSS 动画的方法(即使在常规样式表中)。</li>
<li>您可以通过将 SVG 标记包在 <code>&lt;a&gt;</code> 元素中，使其成为超链接。</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>这种方法只适用于在一个地方使用的 SVG。多次使用会导致资源密集型维护(resource-intensive maintenance)。</li>
<li>额外的 SVG 代码会增加 HTML 文件的大小。</li>
<li>浏览器不能像缓存普通图片一样缓存内联 SVG。</li>
<li>您可能会在 <code>&lt;foreignObject&gt;</code> 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。您需要考虑仅仅为支持过时的浏览器，而增加额外开销是否真的值得。</li>
</ul>
<div><p>总结</p>
<p>在 2020 年，显然内联 SVG 更加适合。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">表格</title>
    <id>https://list-jiang.github.io/code/website/html/intro/table/</id>
    <link href="https://list-jiang.github.io/code/website/html/intro/table/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>表格是由行和列组成的结构化数据集(表格数据)，它能够使您简捷迅速地查找某个表示不同类型数据之间的某种关系的值。</p>
<p>表格的一个特点就是严格. 通过在行和列的标题之间进行视觉关联的方法，就可以让信息能够很简单地被解读出来。</p>
<h2 id="常见误区"> 常见误区</h2>
<p>HTML 表格应该用于表格数据 ，这正是 HTML 表格设计出来的用途。请不要用它来进行布局。</p>
<p>使用表格而不是 CSS 布局的缺点:</p>
<ol>
<li>
<p>表格布局减少了视觉受损的用户的可访问性:</p>
<p>屏幕阅读器, 被盲人所使用, 解析存在于 HTML 页面上的标签，然后为用户读出其中的内容。因为对于布局来说，表格不是一个正确的工具，使用的标记比使用 CSS 布局技术更复杂, 所以屏幕阅读器的输出会让他们的用户感到困惑。</p>
</li>
<li>
<p>表格会产生很多标签:</p>
<p>正如刚才提到的, 表格布局通常会比正确的布局技术涉及更复杂的标签结构，这会导致代码变得更难于编写、维护、调试.</p>
</li>
<li>
<p>表格不能自动响应:</p>
<p>当您使用正确的布局容器 (比如 <code>&lt;header&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, 或是 <code>&lt;div&gt;</code>), 它们的默认宽度是父元素的 <code>100%</code>. 而表格的的默认大小是根据其内容而定的。因此，需要采取额外的措施来获取表格布局样式，以便有效地在各种设备上工作。</p>
</li>
</ol>
<h2 id="使用表格"> 使用表格</h2>
<ul>
<li>使用 <code>&lt;table&gt;&lt;/table&gt;</code> 构建表格。</li>
<li>在表格中，最小的内容容器是单元格, 是通过 <code>&lt;td&gt;</code> 元素创建的 (td 代表 table data)，同时使用 <code>&lt;th&gt;</code> 元素 (th 代表 table header) 描述表格标题，它是一个特殊的单元格。</li>
<li>使用 <code>&lt;tr&gt;</code> 元素 (tr 代表 table row) 描述一行表格</li>
</ul>
<h2 id="合并单元格"> 合并单元格</h2>
<p>表格中的标题和单元格有 <code>colspan</code> 和 <code>rowspan</code> 属性，这两个属性可以帮助我们实现这些效果。这两个属性接受一个没有单位的数字值，数字决定了它们的宽度或高度是几个单元格。比如 <code>colspan=&quot;2&quot;</code> 使一个单元格的宽度是两个单元格。</p>
<div><p>规则</p>
<p>当单元格额外占据其他单元格位置时。表格会在渲染时自动跳过他们放置其他单元格。</p>
</div>
<h2 id="为列提供共同的样式"> 为列提供共同的样式</h2>
<p>HTML 有一种方法可以定义整列数据的样式信息: 就是 <code>&lt;col&gt;</code> 和 <code>&lt;colgroup&gt;</code> 元素。</p>
<p>如果您想让一列中的每个数据的样式都一样，那么您就要为每个数据都添加一个样式，这样的做法是令人厌烦和低效的。您通常需要在列中的每个 <code>&lt;td&gt;</code> 或 <code>&lt;th&gt;</code> 上定义样式，或者使用一个复杂的选择器，比如 <code>:nth-child()</code>。为了舍弃这种做法，我们可以只定义一次，在 <code>&lt;col&gt;</code> 元素中。<code>&lt;col&gt;</code> 元素被规定包含在 <code>&lt;colgroup&gt;</code> 容器中，而 <code>&lt;colgroup&gt;</code> 就在 <code>&lt;table&gt;</code> 标签的下方。</p>

          <div
            id="code-demo-c1938a7e"
           
  
 data-title="%E6%A0%B7%E5%BC%8F%E5%8C%96%E8%A1%A8%E6%A0%BC"

            data-code="%7B%22html%22%3A%22%3Ctable%3E%5Cn%20%20%3Ccolgroup%3E%5Cn%20%20%20%20%3Ccol%20%2F%3E%5Cn%20%20%20%20%3Ccol%20style%3D%5C%22background-color%3A%20yellow%5C%22%20%2F%3E%5Cn%20%20%3C%2Fcolgroup%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Cth%3EData%201%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3EData%202%3C%2Fth%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Ctd%3ECalcutta%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EOrange%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Ctd%3ERobots%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EJazz%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%3C%2Ftable%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
  <span><span><span>&lt;</span>colgroup</span><span>></span></span>
    <span><span><span>&lt;</span>col</span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>background-color</span><span>:</span> yellow</span><span>"</span></span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>colgroup</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Data 1<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Data 2<span><span><span>&lt;/</span>th</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Calcutta<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Orange<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Robots<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Jazz<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>
            </div>
          </div>
          
        </div>
<p>我们使用了两个 <code>&lt;col&gt;</code> 来定义“列的样式”，每一个 <code>&lt;col&gt;</code> 都会制定每列的样式，对于第一列，我们没有采取任何样式，但是我们仍然需要添加一个空的 <code>&lt;col&gt;</code> 元素，如果不这样做，那么我们的样式就会应用到第一列上，这和我们预想的不一样。</p>
<p>如果您想把这种样式信息应用到每一列，我们可以只使用一个 <code>&lt;col&gt;</code> 元素，不过需要包含 <code>span</code> 属性，像这样:</p>
<div><pre><code><span><span><span>&lt;</span>colgroup</span><span>></span></span>
  <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>background-color</span><span>:</span> yellow</span><span>"</span></span></span> <span>span</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>colgroup</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>rowspan</code> 就像 <code>colspan</code>, <code>span</code> 需要一个无单位的数字值，用来制定您想要让这个样式应用到表格中多少列</p>

          <div
            id="code-demo-756aa64e"
           
  
 data-title="%E6%A0%B7%E5%BC%8F%E5%8C%96%E8%A1%A8%E6%A0%BC"

            data-code="%7B%22html%22%3A%22%3Ctable%3E%5Cn%20%20%3Ccolgroup%3E%5Cn%20%20%20%20%3Ccol%20span%3D%5C%222%5C%22%20%2F%3E%5Cn%20%20%20%20%3Ccol%20style%3D%5C%22background-color%3A%2397DB9A%3B%5C%22%20%2F%3E%5Cn%20%20%20%20%3Ccol%20style%3D%5C%22width%3A42px%3B%5C%22%20%2F%3E%5Cn%20%20%20%20%3Ccol%20style%3D%5C%22background-color%3A%2397DB9A%3B%5C%22%20%2F%3E%5Cn%20%20%20%20%3Ccol%20style%3D%5C%22background-color%3A%23DCC48E%3B%20border%3A4px%20solid%20%23C1437A%3B%5C%22%20%2F%3E%5Cn%20%20%20%20%3Ccol%20span%3D%5C%222%5C%22%20style%3D%5C%22width%3A42px%3B%5C%22%20%2F%3E%5Cn%20%20%3C%2Fcolgroup%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Cth%3EMon%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3ETues%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3EWed%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3EThurs%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3EFri%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3ESat%3C%2Fth%3E%5Cn%20%20%20%20%3Cth%3ESun%3C%2Fth%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Cth%3E1st%20period%3C%2Fth%3E%5Cn%20%20%20%20%3Ctd%3EEnglish%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EGerman%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EDutch%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Cth%3E2nd%20period%3C%2Fth%3E%5Cn%20%20%20%20%3Ctd%3EEnglish%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EEnglish%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EGerman%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EDutch%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Cth%3E3rd%20period%3C%2Fth%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EGerman%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EGerman%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EDutch%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%20%20%3Ctr%3E%5Cn%20%20%20%20%3Cth%3E4th%20period%3C%2Fth%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EEnglish%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EEnglish%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3EDutch%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%20%20%3Ctd%3E%26nbsp%3B%3C%2Ftd%3E%5Cn%20%20%3C%2Ftr%3E%5Cn%3C%2Ftable%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
  <span><span><span>&lt;</span>colgroup</span><span>></span></span>
    <span><span><span>&lt;</span>col</span> <span>span</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>background-color</span><span>:</span>#97DB9A<span>;</span></span><span>"</span></span></span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>width</span><span>:</span>42px<span>;</span></span><span>"</span></span></span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>background-color</span><span>:</span>#97DB9A<span>;</span></span><span>"</span></span></span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>background-color</span><span>:</span>#DCC48E<span>;</span> <span>border</span><span>:</span>4px solid #C1437A<span>;</span></span><span>"</span></span></span> <span>/></span></span>
    <span><span><span>&lt;</span>col</span> <span>span</span><span><span>=</span><span>"</span>2<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>width</span><span>:</span>42px<span>;</span></span><span>"</span></span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>colgroup</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Mon<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Tues<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Wed<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Thurs<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Fri<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Sat<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>Sun<span><span><span>&lt;/</span>th</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>1st period<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>English<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>German<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Dutch<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>2nd period<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>English<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>English<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>German<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Dutch<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>3rd period<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>German<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>German<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Dutch<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span><span>></span></span>4th period<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>English<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>English<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>Dutch<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span><span title="&nbsp;">&amp;nbsp;</span><span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div>
            </div>
          </div>
          
        </div>
<h2 id="添加标题-caption"> 添加标题 <code>&lt;caption&gt;</code></h2>
<p>您可以通过 <code>&lt;caption&gt;</code> 元素为您的表格增加一个标题。</p>
<p>您应该把 <code>&lt;caption&gt;</code> 元素放入 <code>&lt;table&gt;</code> 元素中，<code>&lt;table&gt;</code> 标签的下面。</p>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
  <span><span><span>&lt;</span>caption</span><span>></span></span>
    Dinosaurs in the Jurassic period
  <span><span><span>&lt;/</span>caption</span><span>></span></span>

  ...
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>标题意味着包含对于表格内容的描述，这对那些希望可以快速浏览网页中的表格对他们是否有帮助的读者们来说，是非常好的功能。特别是盲人用户，不需要让屏幕阅读设备读出很多单元格的内容，来让用户了解这张表格讲的是什么，而是可以依靠标题的内容，来决定是否需要了解更详细的内容。</p>
<h2 id="结构化"> 结构化</h2>
<p>使用 <code>&lt;thead&gt;</code>, <code>&lt;tfoot&gt;</code>,和 <code>&lt;tbody&gt;</code> 可以结构化表格。这些元素允许您把表格中的部分标记为表头、页脚、正文部分。</p>
<p>在长表格的情况下，您可以在每个打印页面上使表格页眉和页脚重复，您也可以让表格的正文部分显示在一个单独的页面上，并通过上下滚动来获得内容。</p>
<ul>
<li><code>&lt;thead&gt;</code> 需要嵌套在 table 元素中，放置在头部的位置，因为它通常代表第一行，第一行中往往都是每列的标题，但是不是每种情况都是这样的。如果您使用了 <code>&lt;col&gt;/&lt;colgroup&gt;</code> 元素，那么 <code>&lt;thead&gt;</code> 元素就需要放在它们的下面。</li>
<li><code>&lt;tfoot&gt;</code> 需要嵌套在 table 元素中，放置在底部 (页脚)的位置，一般是最后一行，往往是对前面所有行的总结，比如，您可以按照预想的方式将 <code>&lt;tfoot&gt;</code> 放在表格的底部，或者就放在 <code>&lt;thead&gt;</code> 的下面。(浏览器仍将它呈现在表格的底部)</li>
<li><code>&lt;tbody&gt;</code> 需要嵌套在 table 元素中，放置在 <code>&lt;thead&gt;</code> 的下面或者是 <code>&lt;tfoot&gt;</code> 的下面，这取决于您如何设计您的结构。(<code>&lt;tfoot&gt;</code> 放在 <code>&lt;thead&gt;</code> 下面也可以生效.)</li>
</ul>
<div><p>注意</p>
<p><code>&lt;tbody&gt;</code> 总是包含在每个表中，如果您没有在代码中指定它，那就是隐式的。可以来验证一下，打开一个没有包含 <code>&lt;tbody&gt;</code> 的网页，然后在开发者工具中查看代码，您会看到浏览器为您添加了这个标签。它可以让您更好地控制表格结构和样式。</p>
</div>
<h2 id="嵌套表格"> 嵌套表格</h2>
<p>在一个单元格中可以嵌套里另一个表格，但是这会让用户 (尤其是使用阅读器的盲人) 非常困惑，您更应该用锚点与引用的方式去避免嵌套表格。</p>
<h2 id="屏幕阅读增强"> 屏幕阅读增强</h2>
<p>视力受损的用户经常使用一个屏幕阅读设备来为他们读出网页上的信息。对于盲人来说，阅读简单的文字没有什么问题，但是要理解一张表格的内容，这就有一些难度了。虽然，使用正确的标记，我们可以用程序化来代替视觉关联。</p>
<h3 id="使用列和行的标题"> 使用列和行的标题</h3>
<p>屏幕阅读设备会识别所有的标题，然后在它们和它们所关联的单元格之间产生编程关联。列和行标题的组合将标识和解释每个单元格中的数据，以便屏幕阅读器用户可以类似于视力正常的用户的操作来理解表格。</p>
<h3 id="scope-属性"> scope 属性</h3>
<p>scope 属性可以添加在 <code>&lt;th&gt;</code> 元素中，用来帮助屏幕阅读设备更好地理解那些标题单元格，这个标题单元格到底是列标题呢，还是行标题。</p>
<div><p>案例</p>
<p>一个表头:</p>
<div><pre><code><span><span><span>&lt;</span>thead</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>col<span>"</span></span><span>></span></span>Purchase<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>col<span>"</span></span><span>></span></span>Location<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>col<span>"</span></span><span>></span></span>Date<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>col<span>"</span></span><span>></span></span>Evaluation<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>col<span>"</span></span><span>></span></span>Cost (€)<span><span><span>&lt;/</span>th</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>thead</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>一个有行标题的行:</p>
<div><pre><code><span><span><span>&lt;</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>th</span> <span>scope</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>Haircut<span><span><span>&lt;/</span>th</span><span>></span></span>
  <span><span><span>&lt;</span>td</span><span>></span></span>Hairdresser<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;</span>td</span><span>></span></span>12/09<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;</span>td</span><span>></span></span>Great idea<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;</span>td</span><span>></span></span>30<span><span><span>&lt;/</span>td</span><span>></span></span>
<span><span><span>&lt;/</span>tr</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></div>
<p>scope 还有两个可选的值 <code>colgroup</code> 和 <code>rowgroup</code>。这些用于位于多个列或行的顶部的标题，以配合 <code>colspan</code> 和 <code>rowspan</code>。</p>
<h3 id="id-和标题属性"> id 和标题属性</h3>
<p>如果要替代 scope 属性，可以使用 id 和 headers 属性来创造标题与单元格之间的联系。使用方法如下:</p>
<ul>
<li>为每个 <code>&lt;th&gt;</code> 元素添加一个唯一的 id 。</li>
<li>为每个 <code>&lt;td&gt;</code> 元素添加一个 <code>headers</code> 属性。每个单元格的 <code>headers</code> 属性需要包含它从属于的所有标题的 id，之间用空格分隔开。</li>
</ul>
<p>这会给您的 HTML 表格中每个单元格的位置一个明确的定义。像一个电子表格一样，通过 headers 属性来定义属于哪些行或列。为了让它工作良好，表格同时需要列和行标题。</p>
<div><pre><code><span><span><span>&lt;</span>thead</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>purchase<span>"</span></span><span>></span></span>Purchase<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>location<span>"</span></span><span>></span></span>Location<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>date<span>"</span></span><span>></span></span>Date<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>evaluation<span>"</span></span><span>></span></span>Evaluation<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>cost<span>"</span></span><span>></span></span>Cost (€)<span><span><span>&lt;/</span>th</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>thead</span><span>></span></span>
<span><span><span>&lt;</span>tbody</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>th</span> <span>id</span><span><span>=</span><span>"</span>haircut<span>"</span></span><span>></span></span>Haircut<span><span><span>&lt;/</span>th</span><span>></span></span>
    <span><span><span>&lt;</span>td</span> <span>headers</span><span><span>=</span><span>"</span>location haircut<span>"</span></span><span>></span></span>Hairdresser<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span> <span>headers</span><span><span>=</span><span>"</span>date haircut<span>"</span></span><span>></span></span>12/09<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span> <span>headers</span><span><span>=</span><span>"</span>evaluation haircut<span>"</span></span><span>></span></span>Great idea<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;</span>td</span> <span>headers</span><span><span>=</span><span>"</span>cost haircut<span>"</span></span><span>></span></span>30<span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>

  ...
<span><span><span>&lt;/</span>tbody</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">HTML</title>
    <id>https://list-jiang.github.io/code/website/html/</id>
    <link href="https://list-jiang.github.io/code/website/html/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标记语言 (markup language)，它使用标记标签来描述网页。HTML5 是 HTML 最新的修订版本。</p>
]]></summary>
    <content type="html"><![CDATA[<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标记语言 (markup language)，它使用标记标签来描述网页。HTML5 是 HTML 最新的修订版本。</p>

<div><p>提示</p>
<p>在网页的前端开发中，它描绘了了视图层的具体结构。</p>
</div>
<h2 id="初学者教程"> 初学者教程</h2>
<ul>
<li><a href="./guide/">HTML 快速入门</a></li>
<li><a href="./guide/tag.html">HTML 常用标签</a></li>
</ul>
<h2 id="html-教程"> HTML 教程</h2>
<ul>
<li><a href="./intro/history.html">历史</a></li>
<li><a href="./intro/head.html">Head 标签</a></li>
<li><a href="./intro/basic.html">基本标签</a></li>
<li><a href="./intro/link.html">链接</a></li>
<li><a href="./intro/image.html">图片</a></li>
<li><a href="./intro/svg.html">矢量图形</a></li>
<li><a href="./intro/media.html">视频与音频</a></li>
<li><a href="./intro/table.html">表格</a></li>
<li><a href="./intro/embed.html">嵌入</a></li>
<li><a href="./intro/format.html">格式化文档</a></li>
<li><a href="./intro/layout.html">网站布局</a></li>
</ul>
<h2 id="定义列表"> 定义列表</h2>
<ul>
<li><a href="./definition/uri.html">URI 统一资源标识符</a></li>
<li><a href="./definition/url.html">URL 统一资源定位符</a></li>
<li><a href="./definition/seo.html">SEO 搜索引擎优化</a></li>
<li><a href="./definition/mime.html">MIME Type 媒体类型</a></li>
</ul>
<h2 id="html-参考"> HTML 参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML" target="_blank" rel="noopener noreferrer">MDN 教程</a></li>
</ul>
<h2 id="html5"> HTML5</h2>
<p>HTML5 是 HTML 现行的最新修订版本，主要的新特性包括:</p>
<ul>
<li>用于绘画的 <code>&lt;canvas /&gt;</code> 元素</li>
<li>用于媒体播放的 <code>&lt;video /&gt;</code> 和 <code>&lt;audio /&gt;</code> 元素</li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，比如 <code>&lt;article /&gt;</code>、<code>&lt;footer /&gt;</code>、<code>&lt;header /&gt;</code>、<code>&lt;nav /&gt;</code>、<code>&lt;section /&gt;</code></li>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
<h2 id="其他文档"> 其他文档 <i>Not supported content</i></h2>
<ul>
<li>
<p>HTML</p>
<ul>
<li><a href="https://www.w3cschool.cn/html/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
</ul>
</li>
<li>
<p>HTML5</p>
<ul>
<li><a href="https://www.w3cschool.cn/html5/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="https://www.runoob.com/html/html5-intro.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="HTML"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Http 与 Https 介绍</title>
    <id>https://list-jiang.github.io/code/website/https/</id>
    <link href="https://list-jiang.github.io/code/website/https/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是-http-协议"> 什么是 HTTP 协议</h2>
<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>
<p><img src="./assets/http1.jpg" alt="Http 漫画" loading="lazy"></p>
<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>
<p><img src="./assets/http2.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>
<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p><img src="./assets/http3.jpg" alt="Http 漫画" loading="lazy"></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>
<p><img src="./assets/http4.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http5.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http6.jpg" alt="Http 漫画" loading="lazy"></p>
<p>如何进行加密呢?</p>
<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="./assets/http7.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http8.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这样做是不是就绝对安全了呢? 并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p><img src="./assets/http9.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>
<p><img src="./assets/http10.jpg" alt="Http 漫画" loading="lazy"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>
<p><img src="./assets/http11.jpg" alt="Http 漫画" loading="lazy"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>
<p><img src="./assets/http12.jpg" alt="Http 漫画" loading="lazy"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>
<p><img src="./assets/http13.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http14.jpg" alt="Http 漫画" loading="lazy"></p>
<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>
<p><img src="./assets/http15.jpg" alt="Http 漫画" loading="lazy"></p>
<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>
<p><img src="./assets/http16.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>
<p><img src="./assets/http17.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http18.jpg" alt="Http 漫画" loading="lazy"></p>
<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>
<p>到底什么是证书呢? 证书包含如下信息:</p>
<p><img src="./assets/http19.jpg" alt="Http 漫画" loading="lazy"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下:</p>
<ol>
<li>
<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p><img src="./assets/http20.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p><img src="./assets/http21.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="./assets/http22.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>
<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>
<p><img src="./assets/http23.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>
<p><img src="./assets/http24.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>
<p><img src="./assets/http25.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
</ol>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>
<p><img src="./assets/http26.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http27.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http28.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http29.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http30.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http31.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="./assets/http32.jpg" alt="Http 漫画" loading="lazy"></p>
<div><p>相关信息</p>
<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>
</div>
]]></content>
    <author>
      <name>小灰</name>
    </author>
    <contributor>
      <name>小灰</name>
    </contributor>
    <published>2019-11-03T00:00:00.000Z</published>
    <rights>本文转载自&lt;a href="https://zhuanlan.zhihu.com/p/57142784"&gt;小灰的知乎专栏&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">动画</title>
    <id>https://list-jiang.github.io/code/website/jQuery/animation/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/animation/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>章节过时</p>
<p>大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。</p>
<p>2020 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>章节过时</p>
<p>大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。</p>
<p>2020 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。</p>
</div>

<p>用 JavaScript 实现动画，原理非常简单: 我们只需要以固定的时间间隔(例如，0.1 秒)，每次把 DOM 元素的 CSS 样式修改一点(例如，高宽各增加 10%)，看起来就像动画了。</p>
<p>但是要用 JavaScript 手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用 jQuery 实现动画，代码已经简单得不能再简化了: 只需要一行代码!</p>
<p>让我们先来看看 jQuery 内置的几种动画样式:</p>
<h2 id="show-hide"> show / hide</h2>
<p>直接以无参数形式调用 <code>show()</code> 和 <code>hide()</code>，会显示和隐藏 DOM 元素。但是，只要传递一个时间参数进去，就变成了动画:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-show-hide"</span><span>)</span><span>;</span>

div<span>.</span><span>hide</span><span>(</span><span>3000</span><span>)</span><span>;</span> <span>// 在3秒钟内逐渐消失</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>时间以毫秒为单位，但也可以是 <code>'slow'</code>，<code>'fast'</code> 这些字符串:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-show-hide"</span><span>)</span><span>;</span>

div<span>.</span><span>show</span><span>(</span><span>"slow"</span><span>)</span><span>;</span> <span>// 在0.6秒钟内逐渐显示</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>toggle()</code> 方法则根据当前状态决定是 <code>show()</code> 还是 <code>hide()</code>。</p>
<h2 id="slideup-slidedown"> slideUp / slideDown</h2>
<p>您可能已经看出来了，<code>show()</code> 和 <code>hide()</code> 是从左上角逐渐展开或收缩的，而 <code>slideUp()</code> 和 <code>slideDown()</code> 则是在垂直方向逐渐展开或收缩的。</p>
<p><code>slideUp()</code> 把一个可见的 DOM 元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code> 相反，而 <code>slideToggle()</code> 则根据元素是否可见来决定下一步动作:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-slide"</span><span>)</span><span>;</span>

div<span>.</span><span>slideUp</span><span>(</span><span>3000</span><span>)</span><span>;</span> <span>// 在3秒钟内逐渐向上消失</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="fadein-fadeout"> fadeIn / fadeOut</h2>
<p><code>fadeIn()</code> 和 <code>fadeOut()</code> 的动画效果是淡入淡出，也就是通过不断设置 DOM 元素的 <code>opacity</code> 属性来实现，而 <code>fadeToggle()</code> 则根据元素是否可见来决定下一步动作:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>'#test-fade'</span><span>)</span><span>;</span>

div<span>.</span><span>fadeOut</span><span>(</span><span>'slow'</span><span>)</span><span>;</span> <span>// 在 0.6 秒内淡出</span>
<span>fadeOut</span><span>(</span><span>'slow'</span><span>)</span>  <span>fadeIn</span><span>(</span><span>'slow'</span><span>)</span>  <span>fadeToggle</span><span>(</span><span>'slow'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="自定义动画"> 自定义动画</h2>
<p>如果上述动画效果还不能满足您的要求，那就祭出最后大招: <code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是 DOM 元素最终的 CSS 状态和时间，jQuery 在时间段内不断调整 CSS 直到达到我们设定的值:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-animate"</span><span>)</span><span>;</span>

div<span>.</span><span>animate</span><span>(</span>
  <span>{</span>
    opacity<span>:</span> <span>0.25</span><span>,</span>
    width<span>:</span> <span>"256px"</span><span>,</span>
    height<span>:</span> <span>"256px"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>3000</span>
<span>)</span><span>;</span> <span>// 在 3 秒钟内 CSS 过渡到设定值</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>animate()</code> 还可以再传入一个函数，当动画结束时，该函数将被调用:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-animate"</span><span>)</span><span>;</span>

div<span>.</span><span>animate</span><span>(</span>
  <span>{</span>
    opacity<span>:</span> <span>0.25</span><span>,</span>
    width<span>:</span> <span>"256px"</span><span>,</span>
    height<span>:</span> <span>"256px"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>3000</span><span>,</span>
  <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"动画已结束"</span><span>)</span><span>;</span>
    <span>// 恢复至初始状态:</span>
    <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"opacity"</span><span>,</span> <span>"1.0"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"width"</span><span>,</span> <span>"128px"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"height"</span><span>,</span> <span>"128px"</span><span>)</span><span>;</span>
  <span>}</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<p>有了 <code>animate()</code>，您就可以实现各种自定义动画效果了:</p>
<h2 id="串行动画"> 串行动画</h2>
<p>jQuery 的动画效果还可以串行执行，通过 <code>delay()</code> 方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>'#test-animates'</span><span>)</span><span>;</span>

<span>// 动画效果: slideDown - 暂停 - 放大 - 暂停 - 缩小</span>
div<span>.</span><span>slideDown</span><span>(</span><span>2000</span><span>)</span>
   <span>.</span><span>delay</span><span>(</span><span>1000</span><span>)</span>
   <span>.</span><span>animate</span><span>(</span><span>{</span>
       width<span>:</span> <span>'256px'</span><span>,</span>
       height<span>:</span> <span>'256px'</span>
   <span>}</span><span>,</span> <span>2000</span><span>)</span>
   <span>.</span><span>delay</span><span>(</span><span>1000</span><span>)</span>
   <span>.</span><span>animate</span><span>(</span><span>{</span>
       width<span>:</span> <span>'128px'</span><span>,</span>
       height<span>:</span> <span>'128px'</span>
   <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>因为动画需要执行一段时间，所以 jQuery 必须不断返回新的 Promise 对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<h2 id="为什么有的动画没有效果"> 为什么有的动画没有效果</h2>
<p>您可能会遇到，有的动画如 <code>slideUp()</code> 根本没有效果。这是因为 jQuery 动画的原理是逐渐改变 CSS 的值，如 <code>height</code> 从 <code>100px</code> 逐渐变为 <code>0</code>。但是很多不是 block 性质的 DOM 元素，对它们设置 <code>height</code> 根本就不起作用，所以动画也就没有效果。</p>
<p>此外，jQuery 也没有实现对 <code>background-color</code> 的动画效果，用 <code>animate()</code> 设置 <code>background-color</code> 也没有效果。这种情况下可以使用 CSS3 的 <code>transition</code> 实现动画效果。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-04T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">AJAX</title>
    <id>https://list-jiang.github.io/code/website/jQuery/AJAX/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/AJAX/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>章节过时</p>
<p>目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node.js 中，我们使用 <a href="/code/node-js/package/axois.html">axios</a> 来进行请求。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>章节过时</p>
<p>目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node.js 中，我们使用 <a href="./../../node-js/package/axois.html">axios</a> 来进行请求。</p>
</div>

<p>用 JavaScript 写 Ajax 前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。</p>
<p>用 jQuery 的相关对象来处理 AJAX，不但不需要考虑浏览器问题，代码也能大大简化。</p>
<h2 id="ajax"> Ajax</h2>
<p>jQuery 在全局对象 jQuery (也就是 <code>$</code>) 绑定了 <code>ajax()</code> 函数，可以处理 Ajax 请求。<code>ajax(url, settings)</code> 函数需要接收一个 URL 和一个可选的 settings 对象，常用的选项如下:</p>
<ul>
<li>
<p>async: 是否异步执行 Ajax 请求，默认为 <code>true</code>；</p>
</li>
<li>
<p>method: 发送的 Method，缺省为 <code>'GET'</code>，可指定为 <code>'POST'</code> 、<code>'PUT'</code> 等；</p>
</li>
<li>
<p>contentType: 发送 POST 请求的格式，默认值为 <code>'application/x-www-form-urlencoded; charset=UTF-8'</code>，也可以指定为 <code>text/plain</code>、<code>application/json</code>；</p>
</li>
<li>
<p>data: 发送的数据，可以是字符串、数组或 object。如果是 <code>GET</code> 请求，data 将被转换成 <code>query</code> 附加到 URL 上，如果是 <code>POST</code> 请求，根据 <code>contentType</code> 把 <code>data</code> 序列化成合适的格式；</p>
</li>
<li>
<p>headers: 发送的额外的 HTTP 头，必须是一个 object；</p>
</li>
<li>
<p>dataType: 接收的数据格式，可以指定为 <code>'html'</code>、<code>'xml'</code>、<code>'json'</code>、<code>'text'</code> 等，缺省情况下根据响应的 <code>Content-Type</code> 猜测。</p>
</li>
</ul>
<p>下面的例子发送一个 <code>GET</code> 请求，并返回一个 JSON 格式的数据:</p>
<div><pre><code><span>const</span> jqxhr <span>=</span> $<span>.</span><span>ajax</span><span>(</span><span>"/api/categories"</span><span>,</span> <span>{</span>
  dataType<span>:</span> <span>"json"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// 请求已经发送了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不过，如何用回调函数处理返回的数据和出错时的响应呢?</p>
<p>还记得 Promise 对象吗? jQuery 的 <code>jqXHR</code> 对象类似一个 Promise 对象，我们可以用链式写法来处理各种回调:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>function</span> <span>ajaxLog</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> txt <span>=</span> <span>$</span><span>(</span><span>"#test-response-text"</span><span>)</span><span>;</span>
  txt<span>.</span><span>val</span><span>(</span>txt<span>.</span><span>val</span><span>(</span><span>)</span> <span>+</span> <span>"\n"</span> <span>+</span> s<span>)</span><span>;</span>
<span>}</span>

<span>$</span><span>(</span><span>"#test-response-text"</span><span>)</span><span>.</span><span>val</span><span>(</span><span>""</span><span>)</span><span>;</span>

<span>const</span> jqxhr <span>=</span> $<span>.</span><span>ajax</span><span>(</span><span>"/api/categories"</span><span>,</span> <span>{</span>
  dataType<span>:</span> <span>"json"</span><span>,</span>
<span>}</span><span>)</span>
  <span>.</span><span>done</span><span>(</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>
    <span>ajaxLog</span><span>(</span><span>"成功, 收到的数据: "</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>fail</span><span>(</span><span>function</span> <span>(</span><span>xhr<span>,</span> status</span><span>)</span> <span>{</span>
    <span>ajaxLog</span><span>(</span><span>"失败: "</span> <span>+</span> xhr<span>.</span>status <span>+</span> <span>", 原因: "</span> <span>+</span> status<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>always</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>ajaxLog</span><span>(</span><span>"请求完成: 无论成功或失败都会调用"</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="get"> get</h2>
<p>对常用的 Ajax 操作，jQuery 提供了一些辅助方法。由于 GET 请求最常见，所以 jQuery 提供了 <code>get()</code> 方法，可以这么写:</p>
<div><pre><code><span>const</span> jqxhr <span>=</span> $<span>.</span><span>get</span><span>(</span><span>"/path/to/resource"</span><span>,</span> <span>{</span>
  name<span>:</span> <span>"Bob Lee"</span><span>,</span>
  check<span>:</span> <span>1</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>第二个参数如果是 object，jQuery 自动把它变成 <code>query string</code> 然后加到 URL 后面，实际的 URL 是:</p>
<p><code>/path/to/resource?name=Bob%20Lee&amp;check=1</code></p>
<p>这样我们就不用关心如何用 URL 编码并构造一个 <code>query string</code> 了。</p>
<h2 id="post"> post</h2>
<p><code>post()</code> 和 <code>get()</code> 类似，但是传入的第二个参数默认被序列化为 <code>application/x-www-form-urlencoded</code>:</p>
<div><pre><code><span>const</span> jqxhr <span>=</span> $<span>.</span><span>post</span><span>(</span><span>"/path/to/resource"</span><span>,</span> <span>{</span>
  name<span>:</span> <span>"Bob Lee"</span><span>,</span>
  check<span>:</span> <span>1</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>实际构造的数据 <code>name=Bob%20Lee&amp;check=1</code> 作为 POST 的 body 被发送。</p>
<h2 id="getjson"> getJSON</h2>
<p>由于 JSON 用得越来越普遍，所以 jQuery 也提供了 <code>getJSON()</code> 方法来快速通过 GET 获取一个 JSON 对象:</p>
<div><pre><code><span>const</span> jqxhr <span>=</span> $<span>.</span><span>getJSON</span><span>(</span><span>"/path/to/resource"</span><span>,</span> <span>{</span>
  name<span>:</span> <span>"Bob Lee"</span><span>,</span>
  check<span>:</span> <span>1</span><span>,</span>
<span>}</span><span>)</span><span>.</span><span>done</span><span>(</span><span>function</span> <span>(</span><span>data</span><span>)</span> <span>{</span>
  <span>// data已经被解析为JSON对象了</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="安全限制"> 安全限制</h2>
<p>jQuery 的 Ajax 完全封装的是 JavaScript 的 Ajax 操作，所以它的安全限制和前面讲的用 JavaScript 写 Ajax 完全一样。</p>
<p>如果需要使用 JSONP，可以在 <code>ajax()</code> 中设置 <code>jsonp: 'callback'</code>，让 jQuery 实现 JSONP 跨域加载数据。</p>
<p>关于跨域的设置请参考浏览器 Ajax 一节中 CORS 的设置。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">事件</title>
    <id>https://list-jiang.github.io/code/website/jQuery/event/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/event/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>章节过时</p>
<p>由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>章节过时</p>
<p>由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。</p>
</div>

<p>因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用 jQuery 来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用 jQuery 这样绑定一个 <code>click</code> 事件:</p>
<div><pre><code><span>/* HTML:
 *
 * &lt;a id="test-link" href="#0">点我试试&lt;/a>
 *
 */</span>

<span>// 获取超链接的jQuery对象:</span>
<span>const</span> a <span>=</span> <span>$</span><span>(</span><span>"#test-link"</span><span>)</span><span>;</span>

a<span>.</span><span>on</span><span>(</span><span>"click"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello!"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>on</code> 方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>
<p>另一种更简化的写法是直接调用 <code>click()</code> 方法:</p>
<div><pre><code>a<span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello!"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>两者完全等价。我们通常用后面的写法。</p>
<p>jQuery 能够绑定的事件主要包括:</p>
<h2 id="鼠标事件"> 鼠标事件</h2>
<ul>
<li><code>click</code>: 鼠标单击时触发；</li>
<li><code>dblclick</code>: 鼠标双击时触发；</li>
<li><code>mouseenter</code>: 鼠标进入时触发；</li>
<li><code>mouseleave</code>: 鼠标移出时触发；</li>
<li><code>mousemove</code>: 鼠标在 DOM 内部移动时触发；</li>
<li><code>hover</code>: 鼠标进入和退出时触发两个函数，相当于 <code>mouseenter</code> 加上 <code>mouseleave</code>。</li>
</ul>
<h2 id="键盘事件"> 键盘事件</h2>
<p>键盘事件仅作用在当前焦点的 DOM 上，通常是 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p>
<ul>
<li><code>keydown</code>: 键盘按下时触发；</li>
<li><code>keyup</code>: 键盘松开时触发；</li>
<li><code>keypress</code>: 按一次键后触发。</li>
</ul>
<h2 id="其他事件"> 其他事件</h2>
<ul>
<li><code>focus</code>: 当 DOM 获得焦点时触发；</li>
<li><code>blur</code>: 当 DOM 失去焦点时触发；</li>
<li><code>change</code>: 当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发；</li>
<li><code>submit</code>: 当 <code>&lt;form&gt;</code> 提交时触发；</li>
<li><code>ready</code>: 当页面被载入并且 DOM 树完成初始化后触发。</li>
</ul>
<p>其中，<code>ready</code> 仅作用于 document 对象。由于 ready 事件在 DOM 完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个 <code>&lt;form&gt;</code> 表单绑定 submit 事件，下面的代码没有预期的效果:</p>
<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
      <span>// 代码有误:</span>
      <span>$</span><span>(</span><span>'#testForm).on('</span>submit'<span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
          <span>alert</span><span>(</span><span>'submit!'</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>form</span> <span>id</span><span><span>=</span><span>"</span>testForm<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>form</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>因为 JavaScript 在此执行的时候，<code>&lt;form&gt;</code> 尚未载入浏览器，所以 <code>$('#testForm)</code> 返回 <code>[]</code>，并没有绑定事件到任何 DOM 上。</p>
<p>所以我们自己的初始化代码必须放到 document 对象的 <code>ready</code> 事件中，保证 DOM 已完成初始化:</p>
<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
      <span>$</span><span>(</span>document<span>)</span><span>.</span><span>on</span><span>(</span><span>'ready'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
          <span>$</span><span>(</span><span>'#testForm).on('</span>submit'<span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
              <span>alert</span><span>(</span><span>'submit!'</span><span>)</span><span>;</span>
          <span>}</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>form</span> <span>id</span><span><span>=</span><span>"</span>testForm<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>form</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这样写就没有问题了。因为相关代码会在 DOM 树初始化后再执行。</p>
<p>由于 <code>ready</code> 事件使用非常普遍，所以可以这样简化:</p>
<div><pre><code><span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// on('submit', function)也可以简化:</span>
    <span>$</span><span>(</span>'#testForm<span>)</span><span>.</span><span>submit</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>'submit!'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>甚至还可以再简化为:</p>
<div><pre><code><span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// init...</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的这种写法最为常见。如果您遇到 <code>$(function () {...})</code> 的形式，牢记这是 document 对象的 <code>ready</code> 事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行:</p>
<div><pre><code><span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"init A..."</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"init B..."</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"init C..."</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="事件参数"> 事件参数</h2>
<p>有些事件，如 <code>mousemove</code> 和 <code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入 Event 对象作为参数，可以从 Event 对象上获取到更多的信息:</p>
<div><pre><code><span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>$</span><span>(</span><span>"#testMouseMoveDiv"</span><span>)</span><span>.</span><span>mousemove</span><span>(</span><span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
    <span>$</span><span>(</span><span>"#testMouseMoveSpan"</span><span>)</span><span>.</span><span>text</span><span>(</span><span>"pageX = "</span> <span>+</span> e<span>.</span>pageX <span>+</span> <span>", pageY = "</span> <span>+</span> e<span>.</span>pageY<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="取消绑定"> 取消绑定</h2>
<p>一个已被绑定的事件可以解除绑定，通过 <code>off('click', function)</code> 实现:</p>
<div><pre><code><span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>'hello!'</span><span>)</span><span>;</span>
<span>}</span>

a<span>.</span><span>click</span><span>(</span>hello<span>)</span><span>;</span> <span>// 绑定事件</span>

<span>// 10秒钟后解除绑定:</span>
<span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    a<span>.</span><span>off</span><span>(</span><span>'click'</span><span>,</span> hello<span>)</span><span>;</span>
<span>}</span><span>,</span> <span>10000</span><span>)</span><span>;</span>
需要特别注意的是，下面这种写法是无效的<span>:</span>

<span>// 绑定事件:</span>
a<span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>'hello!'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 解除绑定:</span>
a<span>.</span><span>off</span><span>(</span><span>'click'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>alert</span><span>(</span><span>'hello!'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，<code>off('click', function () {...})</code> 无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用 <code>off('click')</code> 一次性移除已绑定的 click 事件的所有处理函数。</p>
<p>同理，无参数调用 <code>off()</code> 一次性移除已绑定的所有类型的事件处理函数。</p>
<h2 id="事件触发条件"> 事件触发条件</h2>
<p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动:</p>
<div><pre><code><span>const</span> input <span>=</span> <span>$</span><span>(</span><span>"#test-input"</span><span>)</span><span>;</span>

input<span>.</span><span>change</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"changed..."</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当用户在文本框中输入时，就会触发 <code>change</code> 事件。但是，如果用 JavaScript 代码去改动文本框的值，将不会触发 <code>change</code> 事件:</p>
<div><pre><code><span>const</span> input <span>=</span> <span>$</span><span>(</span><span>"#test-input"</span><span>)</span><span>;</span>

input<span>.</span><span>val</span><span>(</span><span>"change it!"</span><span>)</span><span>;</span> <span>// 无法触发change事件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有些时候，我们希望用代码触发 <code>change</code> 事件，可以直接调用无参数的 <code>change()</code> 方法来触发该事件:</p>
<div><pre><code><span>const</span> input <span>=</span> <span>$</span><span>(</span><span>"#test-input"</span><span>)</span><span>;</span>

input<span>.</span><span>val</span><span>(</span><span>"change it!"</span><span>)</span><span>;</span>
input<span>.</span><span>change</span><span>(</span><span>)</span><span>;</span> <span>// 触发change事件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>input.change()</code> 相当于 <code>input.trigger('change')</code>，它是 <code>trigger()</code> 方法的简写。</p>
<p>为什么我们希望手动触发一个事件呢? 如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>
<h2 id="浏览器安全限制"> 浏览器安全限制</h2>
<p>在浏览器中，有些 JavaScript 代码只有在用户触发下才能执行，例如，<code>window.open()</code> 函数:</p>
<div><pre><code><span>// 无法弹出新窗口，将被浏览器屏蔽:</span>
<span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  window<span>.</span><span>open</span><span>(</span><span>"/"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这些 “敏感代码” 只能由用户操作来触发:</p>
<div><pre><code><span>const</span> button1 <span>=</span> <span>$</span><span>(</span><span>"#testPopupButton1"</span><span>)</span><span>;</span>
<span>const</span> button2 <span>=</span> <span>$</span><span>(</span><span>"#testPopupButton2"</span><span>)</span><span>;</span>

<span>function</span> <span>popupTestWindow</span><span>(</span><span>)</span> <span>{</span>
  window<span>.</span><span>open</span><span>(</span><span>"/"</span><span>)</span><span>;</span>
<span>}</span>

button1<span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>popupTestWindow</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

button2<span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 不立刻执行 popupTestWindow()，100 毫秒后执行:</span>
  <span>setTimeout</span><span>(</span>popupTestWindow<span>,</span> <span>100</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>当用户点击 button1 时，<code>click</code> 事件被触发，由于 <code>popupTestWindow()</code> 在 <code>click</code> 事件处理函数内执行，这是浏览器允许的，而 button2 的 <code>click</code> 事件并未立刻执行 <code>popupTestWindow()</code>，延迟执行的 <code>popupTestWindow()</code> 将被浏览器拦截。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-04T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">扩展</title>
    <id>https://list-jiang.github.io/code/website/jQuery/extend/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/extend/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>当我们使用 jQuery 对象的方法时，由于 jQuery 对象可以操作一组 DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>但是 jQuery 内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些 DOM 元素，用 jQuery 可以这么实现:</p>
<div><pre><code><span>$</span><span>(</span><span>"span.hl"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"backgroundColor"</span><span>,</span> <span>"#fffceb"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>"#d85030"</span><span>)</span><span>;</span>

<span>$</span><span>(</span><span>"p a.hl"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"backgroundColor"</span><span>,</span> <span>"#fffceb"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>"#d85030"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个 <code>highlight()</code> 方法?</p>
<div><pre><code><span>$</span><span>(</span><span>"span.hl"</span><span>)</span><span>.</span><span>highlight</span><span>(</span><span>)</span><span>;</span>

<span>$</span><span>(</span><span>"p a.hl"</span><span>)</span><span>.</span><span>highlight</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>答案是肯定的。我们可以扩展 jQuery 来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写 jQuery 插件。</p>
<h2 id="编写-jquery-插件"> 编写 jQuery 插件</h2>
<p>给 jQuery 对象绑定一个新方法是通过扩展 <code>$.fn</code> 对象实现的。让我们来编写第一个扩展—— <code>highlight1()</code>:</p>
<div><pre><code>$<span>.</span>fn<span>.</span><span>highlight1</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// this已绑定为当前jQuery对象:</span>
  <span>this</span><span>.</span><span>css</span><span>(</span><span>"backgroundColor"</span><span>,</span> <span>"#fffceb"</span><span>)</span><span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>"#d85030"</span><span>)</span><span>;</span>
  <span>return</span> <span>this</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意到函数内部的 <code>this</code> 在调用时被绑定为 jQuery 对象，所以函数内部代码可以正常调用所有 jQuery 对象的方法。</p>
<p>对于如下的 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>test-highlight1<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>什么是<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span>是目前最流行的<span><span><span>&lt;</span>span</span><span>></span></span>JavaScript<span><span><span>&lt;/</span>span</span><span>></span></span>库。<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>来测试一下 <code>highlight1()</code> 的效果:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>$</span><span>(</span><span>"#test-highlight1 span"</span><span>)</span><span>.</span><span>highlight1</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>细心的您可能发现了，为什么最后要 <code>return this</code> ;? 因为 jQuery 对象支持链式操作，我们自己写的扩展方法也要能继续链式下去:</p>
<div><pre><code><span>$</span><span>(</span><span>"span.hl"</span><span>)</span><span>.</span><span>highlight1</span><span>(</span><span>)</span><span>.</span><span>slideDown</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>
<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办?</p>
<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的 <code>highlight2()</code>:</p>
<div><pre><code>$<span>.</span>fn<span>.</span><span>highlight2</span> <span>=</span> <span>function</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>// 要考虑到各种情况:</span>
  <span>// options为undefined</span>
  <span>// options只有部分key</span>
  <span>const</span> bgcolor <span>=</span> <span>(</span>options <span>&amp;&amp;</span> options<span>.</span>backgroundColor<span>)</span> <span>||</span> <span>"#fffceb"</span><span>;</span>
  <span>const</span> color <span>=</span> <span>(</span>options <span>&amp;&amp;</span> options<span>.</span>color<span>)</span> <span>||</span> <span>"#d85030"</span><span>;</span>
  <span>this</span><span>.</span><span>css</span><span>(</span><span>"backgroundColor"</span><span>,</span> bgcolor<span>)</span><span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> color<span>)</span><span>;</span>
  <span>return</span> <span>this</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>对于如下 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>test-highlight2<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>什么是<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span> <span><span><span>&lt;</span>span</span><span>></span></span>Plugin<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    编写<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span>
    <span><span><span>&lt;</span>span</span><span>></span></span>Plugin<span><span><span>&lt;/</span>span</span><span>></span></span>可以用来扩展<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span>的功能。
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>来实测一下带参数的 <code>highlight2()</code>:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>$</span><span>(</span><span>"#test-highlight2 span"</span><span>)</span><span>.</span><span>highlight2</span><span>(</span><span>{</span>
  backgroundColor<span>:</span> <span>"#00a8e6"</span><span>,</span>
  color<span>:</span> <span>"#ffffff"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对于默认值的处理，我们用了一个简单的 <code>&amp;&amp;</code> 和 <code>||</code> 短路操作符，总能得到一个有效的值。</p>
<p>另一种方法是使用 jQuery 提供的辅助方法 <code>$.extend(target, obj1, obj2, ...)</code>，它把多个 object 对象的属性合并到第一个 target 对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高:</p>
<div><pre><code><span>// 把默认值和用户传入的options合并到对象{}中并返回:</span>
<span>const</span> opts <span>=</span> $<span>.</span><span>extend</span><span>(</span>
  <span>{</span><span>}</span><span>,</span>
  <span>{</span>
    backgroundColor<span>:</span> <span>"#00a8e6"</span><span>,</span>
    color<span>:</span> <span>"#ffffff"</span><span>,</span>
  <span>}</span><span>,</span>
  options
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>紧接着用户对 <code>highlight2()</code> 提出了意见: 每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的 <code>highlight2()</code>?</p>
<p>也就是说，我们设定的默认值应该能允许用户修改。</p>
<p>那默认值放哪比较合适? 放全局变量肯定不合适，最佳地点是 <code>$.fn.highlight2</code> 这个函数对象本身。</p>
<p>于是最终版的 <code>highlight()</code> 终于诞生了:</p>
<div><pre><code>$<span>.</span>fn<span>.</span><span>highlight</span> <span>=</span> <span>function</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>// 合并默认值和用户设定值:</span>
  <span>const</span> opts <span>=</span> $<span>.</span><span>extend</span><span>(</span><span>{</span><span>}</span><span>,</span> $<span>.</span>fn<span>.</span>highlight<span>.</span>defaults<span>,</span> options<span>)</span><span>;</span>
  <span>this</span><span>.</span><span>css</span><span>(</span><span>"backgroundColor"</span><span>,</span> opts<span>.</span>backgroundColor<span>)</span><span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> opts<span>.</span>color<span>)</span><span>;</span>
  <span>return</span> <span>this</span><span>;</span>
<span>}</span><span>;</span>

<span>// 设定默认值:</span>
$<span>.</span>fn<span>.</span>highlight<span>.</span>defaults <span>=</span> <span>{</span>
  color<span>:</span> <span>"#d85030"</span><span>,</span>
  backgroundColor<span>:</span> <span>"#fff8de"</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这次用户终于满意了。用户使用时，只需一次性设定默认值:</p>
<div><pre><code>$<span>.</span>fn<span>.</span>highlight<span>.</span>defaults<span>.</span>color <span>=</span> <span>"#fff"</span><span>;</span>
$<span>.</span>fn<span>.</span>highlight<span>.</span>defaults<span>.</span>backgroundColor <span>=</span> <span>"#000"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后就可以非常简单地调用 <code>highlight()</code> 了。</p>
<p>对如下的 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>test-highlight<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>如何编写<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span> <span><span><span>&lt;</span>span</span><span>></span></span>Plugin<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    编写<span><span><span>&lt;</span>span</span><span>></span></span>jQuery<span><span><span>&lt;/</span>span</span><span>></span></span>
    <span><span><span>&lt;</span>span</span><span>></span></span>Plugin<span><span><span>&lt;/</span>span</span>
    <span>></span></span>，要设置<span><span><span>&lt;</span>span</span><span>></span></span>默认值<span><span><span>&lt;/</span>span</span><span>></span></span>，并允许用户修改<span><span><span>&lt;</span>span</span><span>></span></span>默认值<span><span><span>&lt;/</span>span</span><span>></span></span>，或者运行时传入<span><span><span>&lt;</span>span</span><span>></span></span>其他值<span><span><span>&lt;/</span>span</span><span>></span></span>。
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>实测一下修改默认值的效果:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

$<span>.</span>fn<span>.</span>highlight<span>.</span>defaults<span>.</span>color <span>=</span> <span>"#659f13"</span><span>;</span>
$<span>.</span>fn<span>.</span>highlight<span>.</span>defaults<span>.</span>backgroundColor <span>=</span> <span>"#f2fae3"</span><span>;</span>

<span>$</span><span>(</span><span>"#test-highlight p:first-child span"</span><span>)</span><span>.</span><span>highlight</span><span>(</span><span>)</span><span>;</span>

<span>$</span><span>(</span><span>"#test-highlight p:last-child span"</span><span>)</span><span>.</span><span>highlight</span><span>(</span><span>{</span>
  color<span>:</span> <span>"#dd1144"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>最终，我们得出编写一个 jQuery 插件的原则:</p>
<ul>
<li>给 <code>$.fn</code> 绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要 <code>return this</code> ;以支持链式调用；</li>
<li>插件函数要有默认值，绑定在 <code>$.fn.&lt;pluginName&gt;.defaults</code> 上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ul>
<h2 id="针对特定元素的扩展"> 针对特定元素的扩展</h2>
<p>我们知道 jQuery 对象的有些方法只能作用在特定 DOM 元素上，比如 <code>submit()</code> 方法只能针对 form。如果我们编写的扩展只能针对某些类型的 DOM 元素，应该怎么写?</p>
<p>还记得 jQuery 的选择器支持 <code>filter()</code> 方法来过滤吗? 我们可以借助这个方法来实现针对特定元素的扩展。</p>
<p>举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做?</p>
<p>先写出用户调用的代码:</p>
<div><pre><code><span>$</span><span>(</span><span>"#main a"</span><span>)</span><span>.</span><span>external</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后按照上面的方法编写一个 <code>external</code> 扩展:</p>
<div><pre><code>$<span>.</span>fn<span>.</span><span>external</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// return返回的each()返回结果，支持链式调用:</span>
  <span>return</span> <span>this</span><span>.</span><span>filter</span><span>(</span><span>"a"</span><span>)</span><span>.</span><span>each</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 注意: each()内部的回调函数的this绑定为DOM本身!</span>
    <span>const</span> a <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>const</span> url <span>=</span> a<span>.</span><span>attr</span><span>(</span><span>"href"</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>
      url <span>&amp;&amp;</span>
      <span>(</span>url<span>.</span><span>indexOf</span><span>(</span><span>"http://"</span><span>)</span> <span>===</span> <span>0</span> <span>||</span> url<span>.</span><span>indexOf</span><span>(</span><span>"https://"</span><span>)</span> <span>===</span> <span>0</span><span>)</span>
    <span>)</span> <span>{</span>
      a<span>.</span><span>attr</span><span>(</span><span>"href"</span><span>,</span> <span>"#0"</span><span>)</span>
        <span>.</span><span>removeAttr</span><span>(</span><span>"target"</span><span>)</span>
        <span>.</span><span>append</span><span>(</span><span>' &lt;i>&lt;/i>'</span><span>)</span>
        <span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span><span>confirm</span><span>(</span><span>"您确定要前往"</span> <span>+</span> url <span>+</span> <span>"? "</span><span>)</span><span>)</span> <span>{</span>
            window<span>.</span><span>open</span><span>(</span>url<span>)</span><span>;</span>
          <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>对如下的 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>test-external<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>如何学习<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://jquery.com<span>"</span></span><span>></span></span>jQuery<span><span><span>&lt;/</span>a</span><span>></span></span>?<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>
    首先，您要学习<span><span><span>&lt;</span>a</span>
      <span>href</span><span><span>=</span><span>"</span>/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000<span>"</span></span>
      <span>></span></span>JavaScript<span><span><span>&lt;/</span>a</span>
    <span>></span></span>，并了解基本的<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>https://developer.mozilla.org/en-US/docs/Web/HTML<span>"</span></span>
      <span>></span></span>HTML<span><span><span>&lt;/</span>a</span>
    <span>></span></span>。
  <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>实测外链效果:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>$</span><span>(</span><span>"#test-external a"</span><span>)</span><span>.</span><span>external</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="小结"> 小结</h2>
<p>扩展 jQuery 对象的功能十分简单，但是我们要遵循 jQuery 的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和 jQuery 本身的方法没有什么区别。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-05T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">jQuery 介绍</title>
    <id>https://list-jiang.github.io/code/website/jQuery/intro/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。</p>
<p>jQuery 能帮我们干这些事情:</p>
<ul>
<li>消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 Ajax 等代码；</li>
<li>简洁的操作 DOM 的方法: 写 <code>$('#test')</code> 肯定比 <code>document.getElementById('test')</code> 来得简洁；</li>
<li>轻松实现动画、修改 CSS 等各种操作。</li>
<li>jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作!</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<p>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。</p>
<p>jQuery 能帮我们干这些事情:</p>
<ul>
<li>消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 Ajax 等代码；</li>
<li>简洁的操作 DOM 的方法: 写 <code>$('#test')</code> 肯定比 <code>document.getElementById('test')</code> 来得简洁；</li>
<li>轻松实现动画、修改 CSS 等各种操作。</li>
<li>jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作!</li>
</ul>

<h2 id="jquery-版本"> jQuery 版本</h2>
<div><p>提示</p>
<p>jQuery 的 <code>1.x</code> 版本 兼容 ie678，<code>2.x</code> 为了精简代码体积移除了 ie678 的兼容。<code>3.x</code> 只兼容最新的一批浏览器，是官方还在更新维护的把呢不能</p>
<p>由于已经 2020 年了，直接选用 jQuery<code>3.x</code> 版本即可。</p>
</div>
<p>从 jQuery 官网可以下载最新版本。jQuery 只是一个 jquery-xxx.js 文件，但您会看到有 compressed(已压缩)和 uncompressed(未压缩)两种版本，使用时完全一样，但如果您想深入研究 jQuery 源码，那就用 uncompressed 版本。</p>
<h2 id="使用-jquery"> 使用 jQuery</h2>
<p>使用 jQuery 只需要在页面的 <code>&lt;head&gt;</code> 引入 jQuery 文件即可:</p>
<div><pre><code><span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>//code.jquery.com/jquery-3.4.1.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
    ...
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    ...
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="符号"> $ 符号</h2>
<p><code>$</code> 是著名的 jQuery 符号。实际上，jQuery 把所有功能全部封装在一个全局变量 jQuery 中，而 <code>$</code> 也是一个合法的变量名，它是变量 jQuery 的别名:</p>
<div><pre><code>window<span>.</span>jQuery<span>;</span> <span>// jQuery(selector, context)</span>
window<span>.</span>$<span>;</span> <span>// jQuery(selector, context)</span>
$ <span>===</span> jQuery<span>;</span> <span>// true</span>
<span>typeof</span> $<span>;</span> <span>// 'function'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>$</code> 本质上就是一个函数，但是函数也是对象，于是 <code>$</code> 除了可以直接调用外，也可以有很多其他属性。</p>
<p>注意，您看到的 <code>$</code> 函数名可能不是 <code>jQuery(selector, context)</code>，因为很多 JavaScript 压缩工具可以对函数名和参数改名，所以压缩过的 jQuery 源码 <code>$</code> 函数可能变成 <code>a(b, c)</code>。</p>
<p>绝大多数时候，我们都直接用 <code>$</code> (因为写起来更简单嘛)。但是，如果 <code>$</code> 这个变量不幸地被占用了，而且还不能改，那我们就只能让 jQuery 把 <code>$</code> 变量交出来，然后就只能使用 <code>jQuery</code> 这个变量:</p>
<div><pre><code>$<span>;</span> <span>// jQuery(selector, context)</span>
jQuery<span>.</span><span>noConflict</span><span>(</span><span>)</span><span>;</span>
$<span>;</span> <span>// undefined</span>
jQuery<span>;</span> <span>// jQuery(selector, context)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这种黑魔法的原理是 jQuery 在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用 <code>jQuery.noConflict()</code> 时会把原来保存的变量还原。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">修改 DOM 结构</title>
    <id>https://list-jiang.github.io/code/website/jQuery/modifyDOM/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/modifyDOM/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>章节过时</p>
<p>而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>章节过时</p>
<p>而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。</p>
</div>

<p>直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>
<p>有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了。</p>
<h2 id="添加-dom"> 添加 DOM</h2>
<p>要添加新的 DOM 节点，除了通过 jQuery 的 <code>html()</code> 这种暴力方法外，还可以用 <code>append()</code> 方法，例如:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>test-div<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>JavaScript<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Python<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Swift<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如何向列表新增一个语言? 首先要拿到 <code>&lt;ul&gt;</code> 节点:</p>
<div><pre><code><span>const</span> ul <span>=</span> <span>$</span><span>(</span><span>"#test-div>ul"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后，调用 <code>append()</code> 传入 HTML 片段:</p>
<div><pre><code>ul<span>.</span><span>append</span><span>(</span><span>"&lt;li>&lt;span>Haskell&lt;/span>&lt;/li>"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>除了接受字符串，<code>append()</code> 还可以传入原始的 DOM 对象，jQuery 对象和函数对象:</p>
<div><pre><code><span>// 创建DOM对象:</span>
<span>const</span> ps <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>"li"</span><span>)</span><span>;</span>
ps<span>.</span>innerHTML <span>=</span> <span>"&lt;span>Pascal&lt;/span>"</span><span>;</span>
<span>// 添加DOM对象:</span>
ul<span>.</span><span>append</span><span>(</span>ps<span>)</span><span>;</span>

<span>// 添加jQuery对象:</span>
ul<span>.</span><span>append</span><span>(</span><span>$</span><span>(</span><span>"#scheme"</span><span>)</span><span>)</span><span>;</span>

<span>// 添加函数对象:</span>
ul<span>.</span><span>append</span><span>(</span><span>function</span> <span>(</span><span>index<span>,</span> html</span><span>)</span> <span>{</span>
  <span>return</span> <span>"&lt;li>&lt;span>Language - "</span> <span>+</span> index <span>+</span> <span>"&lt;/span>&lt;/li>"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>传入函数时，要求返回一个字符串、DOM 对象或者 jQuery 对象。因为 jQuery 的 <code>append()</code> 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。</p>
<p><code>append()</code> 把 DOM 添加到最后，<code>prepend()</code> 则把 DOM 添加到最前。</p>
<p>另外注意，如果要添加的 DOM 节点已经存在于 HTML 文档中，它会首先从文档移除，然后再添加，也就是说，用 <code>append()</code>，您可以移动一个 DOM 节点。</p>
<p>如果要把新节点插入到指定位置，例如，JavaScript 和 Python 之间，那么，可以先定位到 JavaScript，然后用 <code>after()</code> 方法:</p>
<div><pre><code><span>const</span> js <span>=</span> <span>$</span><span>(</span><span>"#test-div>ul>li:first-child"</span><span>)</span><span>;</span>
js<span>.</span><span>after</span><span>(</span><span>"&lt;li>&lt;span>Lua&lt;/span>&lt;/li>"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>也就是说，同级节点可以用 <code>after()</code> 或者 <code>before()</code> 方法。</p>
<h2 id="删除节点"> 删除节点</h2>
<p>要删除 DOM 节点，拿到 jQuery 对象后直接调用 <code>remove()</code> 方法就可以了。如果 jQuery 对象包含若干 DOM 节点，实际上可以一次删除多个 DOM 节点:</p>
<div><pre><code><span>const</span> li <span>=</span> <span>$</span><span>(</span><span>"#test-div>ul>li"</span><span>)</span><span>;</span>
li<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span> <span>// 所有&lt;li>全被删除</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">操作 DOM</title>
    <id>https://list-jiang.github.io/code/website/jQuery/operateDOM/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/operateDOM/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<div><p>章节过时</p>
<p>目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<div><p>章节过时</p>
<p>目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。</p>
</div>

<p>jQuery 的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了 jQuery 对象，到底要干什么?</p>
<p>答案当然是操作对应的 DOM 节点啦!</p>
<p>回顾一下修改 DOM 的 CSS、文本、设置 HTML 有多么麻烦，而且有的浏览器只有 innerHTML，有的浏览器支持 innerText，有了 jQuery 对象，不需要考虑浏览器差异了，全部统一操作!</p>
<h2 id="修改-text-和-html"> 修改 Text 和 HTML</h2>
<p>jQuery 对象的 <code>text()</code> 和 <code>html()</code> 方法分别获取节点的文本和原始 HTML 文本，例如，如下的 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>ul</span> <span>id</span><span><span>=</span><span>"</span>test-ul<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>js<span>"</span></span><span>></span></span>JavaScript<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>name</span><span><span>=</span><span>"</span>book<span>"</span></span><span>></span></span>Java <span title="&amp;">&amp;amp;</span> JavaScript<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>分别获取文本和 HTML:</p>
<div><pre><code><span>$</span><span>(</span><span>"#test-ul li[name=book]"</span><span>)</span><span>.</span><span>text</span><span>(</span><span>)</span><span>;</span> <span>// 'Java &amp; JavaScript'</span>
<span>$</span><span>(</span><span>"#test-ul li[name=book]"</span><span>)</span><span>.</span><span>html</span><span>(</span><span>)</span><span>;</span> <span>// 'Java &amp;amp; JavaScript'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如何设置文本或 HTML ? jQuery 的 API 设计非常巧妙: 无参数调用 <code>text()</code> 是获取文本，传入参数就变成设置文本，HTML 也是类似操作，自己动手试试:</p>
<div><pre><code><span>"use strict"</span><span>;</span>
<span>const</span> j1 <span>=</span> <span>$</span><span>(</span><span>"#test-ul li.js"</span><span>)</span><span>;</span>
<span>const</span> j2 <span>=</span> <span>$</span><span>(</span><span>"#test-ul li[name=book]"</span><span>)</span><span>;</span>

j1<span>.</span><span>html</span><span>(</span><span>'&lt;span style="color: red">JavaScript&lt;/span>'</span><span>)</span><span>;</span>
j2<span>.</span><span>text</span><span>(</span><span>"JavaScript &amp; ECMAScript"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>JavaScript
Java &amp; JavaScript
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一个 jQuery 对象可以包含 0 个或任意个 DOM 对象，它的方法实际上会作用在对应的每个 DOM 节点上。在上面的例子中试试:</p>
<div><pre><code><span>$</span><span>(</span><span>"#test-ul li"</span><span>)</span><span>.</span><span>text</span><span>(</span><span>"JS"</span><span>)</span><span>;</span> <span>// 是不是两个节点都变成了JS?</span>
</code></pre>
<div><span>1</span><br></div></div><p>所以 jQuery 对象的另一个好处是我们可以执行一个操作，作用在对应的一组 DOM 节点上。即使选择器没有返回任何 DOM 节点，调用 jQuery 对象的方法仍然不会报错:</p>
<div><pre><code><span>// 如果不存在 id 为 not-exist 的节点:</span>
<span>$</span><span>(</span><span>"#not-exist"</span><span>)</span><span>.</span><span>text</span><span>(</span><span>"Hello"</span><span>)</span><span>;</span> <span>// 代码不报错，没有节点被设置为'Hello'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这意味着 jQuery 帮您免去了许多 if 语句。</p>
<h2 id="修改-css"> 修改 CSS</h2>
<p>jQuery 对象有“批量操作”的特点，这用于修改 CSS 实在是太方便了。考虑下面的 HTML 结构:</p>
<div><pre><code><span>&lt;!-- HTML 结构 --></span>
<span><span><span>&lt;</span>ul</span> <span>id</span><span><span>=</span><span>"</span>test-css<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang dy<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>JavaScript<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Java<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang dy<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Python<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Swift<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang dy<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span>Scheme<span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要高亮显示动态语言，调用 jQuery 对象的 <code>css('name', 'value')</code> 方法，我们用一行语句实现:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>$</span><span>(</span><span>"#test-css li.dy>span"</span><span>)</span>
  <span>.</span><span>css</span><span>(</span><span>"background-color"</span><span>,</span> <span>"#ffd351"</span><span>)</span>
  <span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>"red"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>JavaScript
Java
Python
Swift
Scheme
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，jQuery 对象的所有方法都返回一个 jQuery 对象(可能是新的也可能是自身)，这样我们可以进行链式调用，非常方便。</p>
<p>jQuery 对象的 <code>css()</code> 方法可以这么用:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-div"</span><span>)</span><span>;</span>
div<span>.</span><span>css</span><span>(</span><span>"color"</span><span>)</span><span>;</span> <span>// '#000033', 获取CSS属性</span>
div<span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>"#336699"</span><span>)</span><span>;</span> <span>// 设置CSS属性</span>
div<span>.</span><span>css</span><span>(</span><span>"color"</span><span>,</span> <span>""</span><span>)</span><span>;</span> <span>// 清除CSS属性</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了和 JavaScript 保持一致，CSS 属性可以用 <code>'background-color'</code> 和 <code>'backgroundColor'</code> 两种格式。</p>
<p><code>css()</code> 方法将作用于 DOM 节点的 style 属性，具有最高优先级。如果要修改 class 属性，可以用 jQuery 提供的下列方法:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-div"</span><span>)</span><span>;</span>
div<span>.</span><span>hasClass</span><span>(</span><span>"highlight"</span><span>)</span><span>;</span> <span>// false， class是否包含highlight</span>
div<span>.</span><span>addClass</span><span>(</span><span>"highlight"</span><span>)</span><span>;</span> <span>// 添加highlight这个class</span>
div<span>.</span><span>removeClass</span><span>(</span><span>"highlight"</span><span>)</span><span>;</span> <span>// 删除highlight这个class</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="显示和隐藏-dom"> 显示和隐藏 DOM</h2>
<p>要隐藏一个 DOM，我们可以设置 CSS 的 <code>display</code> 属性为 <code>none</code>，利用 <code>css()</code> 方法就可以实现。不过，要显示这个 DOM 就需要恢复原有的 <code>display</code> 属性，这就得先记下来原有的 <code>display</code> 属性到底是 <code>block</code> 还是 <code>inline</code> 还是别的值。</p>
<p>考虑到显示和隐藏 DOM 元素使用非常普遍，jQuery 直接提供 <code>show()</code> 和 <code>hide()</code> 方法，我们不用关心它是如何修改 display 属性的，总之它能正常工作:</p>
<div><pre><code><span>const</span> a <span>=</span> <span>$</span><span>(</span><span>"a[target=_blank]"</span><span>)</span><span>;</span>
a<span>.</span><span>hide</span><span>(</span><span>)</span><span>;</span> <span>// 隐藏</span>
a<span>.</span><span>show</span><span>(</span><span>)</span><span>;</span> <span>// 显示</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，隐藏 DOM 节点并未改变 DOM 树的结构，它只影响 DOM 节点的显示。这和删除 DOM 节点是不同的。</p>
<h2 id="获取-dom-信息"> 获取 DOM 信息</h2>
<p>利用 jQuery 对象的若干方法，我们直接可以获取 DOM 的高宽等信息，而无需针对不同浏览器编写特定代码:</p>
<div><pre><code><span>// 浏览器可视窗口大小:</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>width</span><span>(</span><span>)</span><span>;</span> <span>// 800</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>height</span><span>(</span><span>)</span><span>;</span> <span>// 600</span>

<span>// HTML 文档大小:</span>
<span>$</span><span>(</span>document<span>)</span><span>.</span><span>width</span><span>(</span><span>)</span><span>;</span> <span>// 800</span>
<span>$</span><span>(</span>document<span>)</span><span>.</span><span>height</span><span>(</span><span>)</span><span>;</span> <span>// 3500</span>

<span>// 某个 div 的大小:</span>
<span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-div"</span><span>)</span><span>;</span>
div<span>.</span><span>width</span><span>(</span><span>)</span><span>;</span> <span>// 600</span>
div<span>.</span><span>height</span><span>(</span><span>)</span><span>;</span> <span>// 300</span>
div<span>.</span><span>width</span><span>(</span><span>400</span><span>)</span><span>;</span> <span>// 设置 CSS 属性 width: 400px，是否生效要看 CSS 是否有效</span>
div<span>.</span><span>height</span><span>(</span><span>"200px"</span><span>)</span><span>;</span> <span>// 设置 CSS 属性 height: 200px，是否生效要看 CSS 是否有效</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>attr()</code> 和 <code>removeAttr()</code> 方法用于操作 DOM 节点的属性:</p>
<div><pre><code><span>// &lt;div id="test-div" name="Test" start="1">...&lt;/div></span>
<span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#test-div"</span><span>)</span><span>;</span>
div<span>.</span><span>attr</span><span>(</span><span>"data"</span><span>)</span><span>;</span> <span>// undefined, 属性不存在</span>
div<span>.</span><span>attr</span><span>(</span><span>"name"</span><span>)</span><span>;</span> <span>// 'Test'</span>
div<span>.</span><span>attr</span><span>(</span><span>"name"</span><span>,</span> <span>"Hello"</span><span>)</span><span>;</span> <span>// div 的 name 属性变为 'Hello'</span>
div<span>.</span><span>removeAttr</span><span>(</span><span>"name"</span><span>)</span><span>;</span> <span>// 删除 name 属性</span>
div<span>.</span><span>attr</span><span>(</span><span>"name"</span><span>)</span><span>;</span> <span>// undefined</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>prop()</code> 方法和 <code>attr()</code> 类似，但是 HTML5 规定有一种属性在 DOM 节点中可以没有值，只有出现与不出现两种，例如:</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>id</span><span><span>=</span><span>"</span>test-radio<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>radio<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>test<span>"</span></span> <span>checked</span> <span>value</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>等价于:</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>id</span><span><span>=</span><span>"</span>test-radio<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>radio<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>test<span>"</span></span> <span>checked</span><span><span>=</span><span>"</span>checked<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><code>attr()</code> 和 <code>prop()</code> 对于属性 <code>checked</code> 处理有所不同:</p>
<div><pre><code><span>const</span> radio <span>=</span> <span>$</span><span>(</span><span>"#test-radio"</span><span>)</span><span>;</span>
radio<span>.</span><span>attr</span><span>(</span><span>"checked"</span><span>)</span><span>;</span> <span>// 'checked'</span>
radio<span>.</span><span>prop</span><span>(</span><span>"checked"</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>prop()</code> 返回值更合理一些。不过，用 <code>is()</code> 方法判断更好:</p>
<div><pre><code><span>const</span> radio <span>=</span> <span>$</span><span>(</span><span>"#test-radio"</span><span>)</span><span>;</span>
radio<span>.</span><span>is</span><span>(</span><span>":checked"</span><span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>类似的属性还有 <code>selected</code>，处理时最好用 <code>is(':selected')</code>。</p>
<h2 id="操作表单"> 操作表单</h2>
<p>对于表单元素，jQuery 对象统一提供 <code>val()</code> 方法获取和设置对应的 <code>value</code> 属性:</p>
<div><pre><code><span>/*
    &lt;input id="test-input" name="email" value="">
    &lt;select id="test-select" name="city">
        &lt;option value="BJ" selected>Beijing&lt;/option>
        &lt;option value="SH">Shanghai&lt;/option>
        &lt;option value="SZ">Shenzhen&lt;/option>
    &lt;/select>
    &lt;textarea id="test-textarea">Hello&lt;/textarea>
*/</span>
<span>const</span> input <span>=</span> <span>$</span><span>(</span><span>"#test-input"</span><span>)</span><span>,</span>
  select <span>=</span> <span>$</span><span>(</span><span>"#test-select"</span><span>)</span><span>,</span>
  textarea <span>=</span> <span>$</span><span>(</span><span>"#test-textarea"</span><span>)</span><span>;</span>

input<span>.</span><span>val</span><span>(</span><span>)</span><span>;</span> <span>// 'test'</span>
input<span>.</span><span>val</span><span>(</span><span>"abc@example.com"</span><span>)</span><span>;</span> <span>// 文本框的内容已变为 abc@example.com</span>

select<span>.</span><span>val</span><span>(</span><span>)</span><span>;</span> <span>// 'BJ'</span>
select<span>.</span><span>val</span><span>(</span><span>"SH"</span><span>)</span><span>;</span> <span>// 选择框已变为 Shanghai</span>

textarea<span>.</span><span>val</span><span>(</span><span>)</span><span>;</span> <span>// 'Hello'</span>
textarea<span>.</span><span>val</span><span>(</span><span>"Hi"</span><span>)</span><span>;</span> <span>// 文本区域已更新为 'Hi'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>可见，一个 <code>val()</code> 就统一了各种输入框的取值和赋值的问题。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">jQuery</title>
    <id>https://list-jiang.github.io/code/website/jQuery/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/"/>
    <updated>2022-01-19T09:48:59.000Z</updated>
    <summary type="html"><![CDATA[<p>jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。</p>
<div><p>提示</p>
<p>由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2020 年，<strong>jQuery 已经过时了</strong>!</p>
<p>不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。</p>
<p>所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 <a href="/code/node-js/">跳过本章节</a>。</p>
<p>本章节应以理解写法与思路为主，无需刻意记忆。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<p>jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。</p>
<div><p>提示</p>
<p>由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2020 年，<strong>jQuery 已经过时了</strong>!</p>
<p>不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。</p>
<p>所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 <a href="./../../node-js/">跳过本章节</a>。</p>
<p>本章节应以理解写法与思路为主，无需刻意记忆。</p>
</div>

<h2 id="教程目录"> 教程目录</h2>
<ul>
<li>
<p><a href="./intro.html">jQuery 简介</a></p>
</li>
<li>
<p><a href="./selector.html">选择器</a></p>
</li>
<li>
<p><a href="./operateDOM.html">操作 DOM</a></p>
</li>
<li>
<p><a href="./modifyDOM.html">修改 DOM 结构</a></p>
</li>
<li>
<p><a href="./event.html">事件</a></p>
</li>
<li>
<p><a href="./animation.html">动画</a></p>
</li>
<li>
<p><a href="./AJAX.html">Ajax</a></p>
</li>
<li>
<p><a href="./extend.html">扩展</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-02T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">选择器</title>
    <id>https://list-jiang.github.io/code/website/jQuery/selector/</id>
    <link href="https://list-jiang.github.io/code/website/jQuery/selector/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>选择器是 jQuery 的核心。一个选择器写出来类似 <code>$('#dom-id')</code>。</p>
]]></summary>
    <content type="html"><![CDATA[<p>选择器是 jQuery 的核心。一个选择器写出来类似 <code>$('#dom-id')</code>。</p>

<p>为什么 jQuery 要发明选择器? 回顾一下 DOM 操作中我们经常使用的代码:</p>
<div><pre><code><span>// 按ID查找:</span>
<span>const</span> a <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'dom-id'</span><span>)</span><span>;</span>

<span>// 按tag查找:</span>
<span>const</span> divs <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'div'</span><span>)</span><span>;</span>

<span>// 查找&lt;p>:</span>
<span>const</span> ps <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'p'</span><span>)</span><span>;</span>
<span>// 过滤出class="red":</span>
<span>// TODO:</span>

<span>// 查找&lt;table>里面的所有&lt;tr>:</span>
<span>const</span> table <span>=</span> <span>...</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> table<span>.</span>children<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>// TODO: 过滤出&lt;tr></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找 <code>&lt;table class=&quot;green&quot;&gt;</code> 里面的所有 <code>&lt;tr&gt;</code>，一层循环实际上是错的，因为 <code>&lt;table&gt;</code> 的标准写法是:</p>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
  <span><span><span>&lt;</span>tbody</span><span>></span></span>
    <span><span><span>&lt;</span>tr</span><span>></span></span>
      ...
    <span><span><span>&lt;/</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>tr</span><span>></span></span>
      ...
    <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;/</span>tbody</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>很多时候，需要递归查找所有子节点。</p>
<p>jQuery 的选择器就是帮助我们快速定位到一个或多个 DOM 节点。</p>
<h2 id="简单选择器"> 简单选择器</h2>
<div><p>提示</p>
<p>jQuery 的选择器特别像 CSS 的选择器</p>
</div>
<h3 id="按-id-查找"> 按 ID 查找</h3>
<p>如果某个 DOM 节点有 id 属性，利用 jQuery 查找如下:</p>
<div><pre><code><span>// 查找&lt;div id="abc">:</span>
<span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#abc"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，<code>#abc</code> 以 <code>#</code> 开头。返回的对象是 jQuery 对象。</p>
<p>什么是 jQuery 对象? jQuery 对象类似数组，它的每个元素都是一个引用了 DOM 节点的对象。</p>
<p>以上面的查找为例，如果 id 为 <code>abc</code> 的 <code>&lt;div&gt;</code> 存在，返回的 jQuery 对象如下:</p>
<div><pre><code>[
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>abc<span>"</span></span><span>></span></span>...<span><span><span>&lt;/</span>div</span><span>></span></span>
]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果 id 为 abc 的 <code>&lt;div&gt;</code> 不存在，返回的 jQuery 对象如下:</p>
<p><code>[]</code></p>
<p>总之 jQuery 的选择器不会返回 <code>undefined</code> 或者 <code>null</code>，这样的好处是您不必在下一行判断 <code>if (div === undefined)</code>。</p>
<p>jQuery 对象和 DOM 对象之间可以互相转化:</p>
<div><pre><code><span>const</span> div <span>=</span> <span>$</span><span>(</span><span>"#abc"</span><span>)</span><span>;</span> <span>// jQuery对象</span>
<span>const</span> divDom <span>=</span> div<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// 假设存在div，获取第1个DOM元素</span>
<span>const</span> another <span>=</span> <span>$</span><span>(</span>divDom<span>)</span><span>;</span> <span>// 重新把DOM包装为jQuery对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>通常情况下您不需要获取 DOM 对象，直接使用 jQuery 对象更加方便。如果您拿到了一个 DOM 对象，那可以简单地调用 <code>$(aDomObject)</code> 把它变成 jQuery 对象，这样就可以方便地使用 jQuery 的 API 了。</p>
<h3 id="按-tag-查找"> 按 tag 查找</h3>
<p>按 tag 查找只需要写上 tag 名称就可以了:</p>
<div><pre><code><span>const</span> ps <span>=</span> <span>$</span><span>(</span><span>"p"</span><span>)</span><span>;</span> <span>// 返回所有 &lt;p> 节点</span>
ps<span>.</span>length<span>;</span> <span>// 数一数页面有多少个 &lt;p> 节点</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="按-class-查找"> 按 class 查找</h3>
<p>按 class 查找注意在 class 名称前加一个 <code>.</code>:</p>
<div><pre><code><span>const</span> a <span>=</span> <span>$</span><span>(</span><span>".red"</span><span>)</span><span>;</span> <span>// 所有节点包含 `class="red"` 都将返回</span>
<span>// 例如:</span>
<span>// &lt;div>...&lt;/div></span>
<span>// &lt;p>...&lt;/p></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通常很多节点有多个 <strong>class</strong>，我们可以查找同时包含 <code>red</code> 和 <code>green</code> 的节点:</p>
<div><pre><code><span>const</span> a <span>=</span> <span>$</span><span>(</span><span>".red.green"</span><span>)</span><span>;</span> <span>// 注意没有空格!</span>
<span>// 符合条件的节点:</span>
<span>// &lt;div>...&lt;/div></span>
<span>// &lt;div>...&lt;/div></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="按属性查找"> 按属性查找</h3>
<p>一个 DOM 节点除了 id 和 class 外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找:</p>
<div><pre><code><span>const</span> email <span>=</span> <span>$</span><span>(</span><span>"[name=email]"</span><span>)</span><span>;</span> <span>// 找出 `&lt;??? name="email">`</span>
<span>const</span> passwordInput <span>=</span> <span>$</span><span>(</span><span>"[type=password]"</span><span>)</span><span>;</span> <span>// 找出 `&lt;??? type="password">`</span>
<span>const</span> a <span>=</span> <span>$</span><span>(</span><span>'[items="A B"]'</span><span>)</span><span>;</span> <span>// 找出 `&lt;??? items="A B">`</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用前缀查找或者后缀查找:</p>
<div><pre><code><span>const</span> icons <span>=</span> <span>$</span><span>(</span><span>"[name^=icon]"</span><span>)</span><span>;</span> <span>// 找出所有name属性值以icon开头的DOM</span>
<span>// 例如: name="icon-1", name="icon-2"</span>
<span>const</span> names <span>=</span> <span>$</span><span>(</span><span>"[name$=with]"</span><span>)</span><span>;</span> <span>// 找出所有 name 属性值以 with 结尾的 DOM</span>
<span>// 例如: name="startswith", name="endswith"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个方法尤其适合通过 class 属性查找，且不受 class 包含多个名称的影响:</p>
<div><pre><code><span>const</span> icons <span>=</span> <span>$</span><span>(</span><span>'[class^="icon-"]'</span><span>)</span><span>;</span> <span>// 找出所有 class 包含至少一个以 `icon-` 开头的DOM</span>
<span>// 例如:,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="组合查找"> 组合查找</h3>
<p>组合查找就是把上述简单选择器组合起来使用。如果我们查找 <code>$('[name=email]')</code>，很可能把表单外的 <code>&lt;div name=&quot;email&quot;&gt;</code> 也找出来，但我们只希望查找 <code>&lt;input&gt;</code>，就可以这么写:</p>
<div><pre><code><span>const</span> emailInput <span>=</span> <span>$</span><span>(</span><span>"input[name=email]"</span><span>)</span><span>;</span> <span>// 不会找出 &lt;div name="email"></span>
</code></pre>
<div><span>1</span><br></div></div><p>同样的，根据 tag 和 class 来组合查找也很常见:</p>
<div><pre><code><span>const</span> tr <span>=</span> <span>$</span><span>(</span><span>"tr.red"</span><span>)</span><span>;</span> <span>// 找出 &lt;tr>...&lt;/tr></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="多项选择器"> 多项选择器</h2>
<p>多项选择器就是把多个选择器用，组合起来一块选:</p>
<div><pre><code><span>$</span><span>(</span><span>"p,div"</span><span>)</span><span>;</span> <span>// 把 &lt;p> 和 &lt;div> 选出来</span>
<span>$</span><span>(</span><span>"p.red,p.green"</span><span>)</span><span>;</span> <span>// 把 &lt;p> 和 &lt;p> 都选出来</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>要注意的是，选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class=&quot;red green&quot;&gt;</code> 不会被上面的 <code>$('p.red,p.green')</code> 选择两次。</p>
<h2 id="层级选择器"> 层级选择器</h2>
<p>除了基本的选择器外，jQuery 的层级选择器更加灵活，也更强大。</p>
<p>因为 DOM 的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h3 id="层级选择器-descendant-selector"> 层级选择器 (Descendant Selector)</h3>
<p>如果两个 DOM 元素具有层级关系，就可以用 <code>$('ancestor descendant')</code> 来选择，层级之间用空格隔开。例如:</p>
<div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>testing<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>lang<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang-javascript<span>"</span></span><span>></span></span>JavaScript<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang-python<span>"</span></span><span>></span></span>Python<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>lang-lua<span>"</span></span><span>></span></span>Lua<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要选出 JavaScript，可以用层级选择器:</p>
<div><pre><code><span>$</span><span>(</span><span>"ul.lang li.lang-javascript"</span><span>)</span><span>;</span> <span>// [&lt;li>JavaScript&lt;/li>]</span>
<span>$</span><span>(</span><span>"div.testing li.lang-javascript"</span><span>)</span><span>;</span> <span>// [&lt;li>JavaScript&lt;/li>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为 <code>&lt;div&gt;</code> 和 <code>&lt;ul&gt;</code> 都是 <code>&lt;li&gt;</code> 的祖先节点，所以上面两种方式都可以选出相应的 <code>&lt;li&gt;</code> 节点。</p>
<p>要选择所有的 <code>&lt;li&gt;</code> 节点，用:</p>
<div><pre><code><span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p>
<p>例如:</p>
<div><pre><code><span>$</span><span>(</span><span>"form[name=upload] input"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>就把选择范围限定在 <code>name</code> 属性为 <code>upload</code> 的表单里。如果页面有很多表单，其他表单的 <code>&lt;input&gt;</code> 不会被选择。</p>
<p>多层选择也是允许的:</p>
<div><pre><code><span>$</span><span>(</span><span>"form.test p input"</span><span>)</span><span>;</span> <span>// 在 form 表单选择被 &lt;p> 包含的 &lt;input></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="子选择器-child-selector"> 子选择器(Child Selector)</h2>
<p>子选择器 <code>$('parent&gt;child')</code> 类似层级选择器，但是限定了层级关系必须是父子关系，就是 <code>&lt;child&gt;</code> 节点必须是 <code>&lt;parent&gt;</code> 节点的直属子节点。还是以上面的例子:</p>
<div><pre><code><span>$</span><span>(</span><span>"ul.lang>li.lang-javascript"</span><span>)</span><span>;</span> <span>// 可以选出 [&lt;li>JavaScript&lt;/li>]</span>
<span>$</span><span>(</span><span>"div.testing>li.lang-javascript"</span><span>)</span><span>;</span> <span>// [], 无法选出，因为 &lt;div> 和 &lt;li> 不构成父子关系</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="过滤器-filter"> 过滤器(Filter)</h2>
<p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果:</p>
<div><pre><code><span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span> <span>// 选出JavaScript、Python和Lua 3个节点</span>

<span>$</span><span>(</span><span>"ul.lang li:first-child"</span><span>)</span><span>;</span> <span>// 仅选出JavaScript</span>
<span>$</span><span>(</span><span>"ul.lang li:last-child"</span><span>)</span><span>;</span> <span>// 仅选出Lua</span>
<span>$</span><span>(</span><span>"ul.lang li:nth-child(2)"</span><span>)</span><span>;</span> <span>// 选出第N个元素，N从1开始</span>
<span>$</span><span>(</span><span>"ul.lang li:nth-child(even)"</span><span>)</span><span>;</span> <span>// 选出序号为偶数的元素</span>
<span>$</span><span>(</span><span>"ul.lang li:nth-child(odd)"</span><span>)</span><span>;</span> <span>// 选出序号为奇数的元素</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="表单相关"> 表单相关</h2>
<p>针对表单元素，jQuery 还有一组特殊的选择器:</p>
<ul>
<li>
<p><code>:input</code>: 可以选择 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code>；</p>
</li>
<li>
<p><code>:file</code>: 可以选择 <code>&lt;input type=&quot;file&quot;&gt;</code>，和 <code>input[type=file]</code> 一样；</p>
</li>
<li>
<p><code>:checkbox</code>: 可以选择复选框，和 <code>input[type=checkbox]</code> 一样；</p>
</li>
<li>
<p><code>:radio</code>: 可以选择单选框，和 <code>input[type=radio]</code> 一样；</p>
</li>
<li>
<p><code>:focus</code>: 可以选择当前输入焦点的元素，例如把光标放到一个 <code>&lt;input&gt;</code> 上，用<code>$('input:focus')</code> 就可以选出；</p>
</li>
<li>
<p><code>:checked</code>: 选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$('input[type=radio]:checked')</code>；</p>
</li>
<li>
<p><code>:enabled</code>: 可以选择可以正常输入的 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 等，也就是没有灰掉的输入；</p>
</li>
<li>
<p><code>:disabled</code>: 和 <code>:enabled</code> 正好相反，选择那些不能输入的。</p>
</li>
</ul>
<p>此外，jQuery 还有很多有用的选择器，例如，选出可见的或隐藏的元素:</p>
<div><pre><code><span>$</span><span>(</span><span>"div:visible"</span><span>)</span><span>;</span> <span>// 所有可见的 div</span>
<span>$</span><span>(</span><span>"div:hidden"</span><span>)</span><span>;</span> <span>// 所有隐藏的 div</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="查找和过滤"> 查找和过滤</h2>
<p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个 jQuery 对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<h3 id="查找"> 查找</h3>
<p>最常见的查找是在某个节点的所有子节点中查找，使用 <code>find()</code> 方法，它本身又接收一个任意的选择器。例如如下的 HTML 结构:</p>
<div><pre><code>JavaScript
Python
Swift
Scheme
Haskell
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>&lt;!-- HTML结构 --></span>
<span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>lang<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>js dy<span>"</span></span><span>></span></span>JavaScript<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>dy<span>"</span></span><span>></span></span>Python<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>id</span><span><span>=</span><span>"</span>swift<span>"</span></span><span>></span></span>Swift<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>dy<span>"</span></span><span>></span></span>Scheme<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span>name</span><span><span>=</span><span>"</span>haskell<span>"</span></span><span>></span></span>Haskell<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>用 <code>find()</code> 查找:</p>
<div><pre><code><span>const</span> ul <span>=</span> <span>$</span><span>(</span><span>"ul.lang"</span><span>)</span><span>;</span> <span>// 获得 &lt;ul></span>
<span>const</span> dy <span>=</span> ul<span>.</span><span>find</span><span>(</span><span>".dy"</span><span>)</span><span>;</span> <span>// 获得 JavaScript, Python, Scheme</span>
<span>const</span> swf <span>=</span> ul<span>.</span><span>find</span><span>(</span><span>"#swift"</span><span>)</span><span>;</span> <span>// 获得 Swift</span>
<span>const</span> hsk <span>=</span> ul<span>.</span><span>find</span><span>(</span><span>"[name=haskell]"</span><span>)</span><span>;</span> <span>// 获得 Haskell</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果要从当前节点开始向上查找，使用 <code>parent()</code> 方法:</p>
<div><pre><code><span>const</span> swf <span>=</span> <span>$</span><span>(</span><span>"#swift"</span><span>)</span><span>;</span> <span>// 获得 Swift</span>
<span>const</span> parent <span>=</span> swf<span>.</span><span>parent</span><span>(</span><span>)</span><span>;</span> <span>// 获得 Swift 的上层节点 &lt;ul></span>
<span>const</span> a <span>=</span> swf<span>.</span><span>parent</span><span>(</span><span>".red"</span><span>)</span><span>;</span> <span>// 获得 Swift 的上层节点 &lt;ul>，同时传入过滤条件。如果 ul 不符合条件，返回空 jQuery 对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>对于位于同一层级的节点，可以通过 <code>next()</code> 和 <code>prev()</code> 方法，例如:</p>
<p>当我们已经拿到 Swift 节点后:</p>
<div><pre><code><span>const</span> swift <span>=</span> <span>$</span><span>(</span><span>"#swift"</span><span>)</span><span>;</span>

swift<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span> <span>// Scheme</span>
swift<span>.</span><span>next</span><span>(</span><span>"[name=haskell]"</span><span>)</span><span>;</span> <span>// 空的 jQuery 对象，因为 Swift 的下一个元素 Scheme 不符合条件 [name=haskell]</span>

swift<span>.</span><span>prev</span><span>(</span><span>)</span><span>;</span> <span>// Python</span>
swift<span>.</span><span>prev</span><span>(</span><span>".dy"</span><span>)</span><span>;</span> <span>// Python，因为 Python 同时符合过滤器条件 .dy</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="过滤"> 过滤</h3>
<p>和函数式编程的 <code>map</code>、<code>filter</code> 类似，jQuery 对象也有类似的方法。</p>
<p><code>filter()</code> 方法可以过滤掉不符合选择器条件的节点:</p>
<div><pre><code><span>const</span> langs <span>=</span> <span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span> <span>// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span>
<span>const</span> a <span>=</span> langs<span>.</span><span>filter</span><span>(</span><span>".dy"</span><span>)</span><span>;</span> <span>// 拿到 JavaScript, Python, Scheme</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者传入一个函数，要特别注意函数内部的 <code>this</code> 被绑定为 DOM 对象，不是 jQuery 对象:</p>
<div><pre><code><span>const</span> langs <span>=</span> <span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span> <span>// 拿到JavaScript, Python, Swift, Scheme和Haskell</span>
langs<span>.</span><span>filter</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>innerHTML<span>.</span><span>indexOf</span><span>(</span><span>"S"</span><span>)</span> <span>===</span> <span>0</span><span>;</span> <span>// 返回 S 开头的节点</span>
<span>}</span><span>)</span><span>;</span> <span>// 拿到 Swift, Scheme</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>map()</code> 方法把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象:</p>
<div><pre><code><span>const</span> langs <span>=</span> <span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span> <span>// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span>
<span>const</span> arr <span>=</span> langs
  <span>.</span><span>map</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>innerHTML<span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>get</span><span>(</span><span>)</span><span>;</span> <span>// 用 get() 拿到包含 string 的 Array: ['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>此外，一个 jQuery 对象如果包含了不止一个 DOM 节点，<code>first()</code>、<code>last()</code> 和 <code>slice()</code> 方法可以返回一个新的 jQuery 对象，把不需要的 DOM 节点去掉:</p>
<div><pre><code><span>const</span> langs <span>=</span> <span>$</span><span>(</span><span>"ul.lang li"</span><span>)</span><span>;</span> <span>// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span>
<span>const</span> js <span>=</span> langs<span>.</span><span>first</span><span>(</span><span>)</span><span>;</span> <span>// JavaScript，相当于 $('ul.lang li:first-child')</span>
<span>const</span> haskell <span>=</span> langs<span>.</span><span>last</span><span>(</span><span>)</span><span>;</span> <span>// Haskell, 相当于 $('ul.lang li:last-child')</span>
<span>const</span> sub <span>=</span> langs<span>.</span><span>slice</span><span>(</span><span>2</span><span>,</span> <span>4</span><span>)</span><span>;</span> <span>// Swift, Scheme, 参数和数组的 slice() 方法一致</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="jQuery"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-03T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">JavaScript 教程</title>
    <id>https://list-jiang.github.io/code/website/js/</id>
    <link href="https://list-jiang.github.io/code/website/js/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="初学者教程"> 初学者教程</h2>
<ul>
<li><a href="./../language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册"> JavaScript 手册</h3>
<ul>
<li><a href="./../language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程"> 在线教程</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="es6"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="./../language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="./../language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="./../language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="JavaScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">环境变量的添加</title>
    <id>https://list-jiang.github.io/code/windows/add-path/</id>
    <link href="https://list-jiang.github.io/code/windows/add-path/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>以 Windows 10 系统为例，直接在左下角搜索栏中输入“系统变量”</p>
<p><img src="./assets/pathSearch.png" alt="搜索" loading="lazy"></p>
<p>在弹出的框中点击环境变量</p>
<p><img src="./assets/path.png" alt="系统变量" loading="lazy"></p>
<p>在弹出的新窗口中找到 path，选中并点击编辑</p>
<p><img src="./assets/pathDetail.png" alt="系统变量" loading="lazy"></p>
<p>点击添加输入想要添加到 path 的路径或者执行文件名即可</p>
<p><img src="./assets/pathAdd.png" alt="系统变量" loading="lazy"></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-08T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">网页入门</title>
    <id>https://list-jiang.github.io/code/website/</id>
    <link href="https://list-jiang.github.io/code/website/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>
]]></summary>
    <content type="html"><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>

<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="./html/">HTML 教程</a></li>
</ul>
<h2 id="css"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="./css/">CSS 教程</a></li>
</ul>
<h2 id="emmet"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="./emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="./js.html">JS 教程</a></li>
</ul>
<h3 id="typescript"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="./../language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="./../node-js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架"> 历史前端框架</h2>
<h3 id="jquery"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="./jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架"> 现代前端框架</h2>
<h3 id="vue"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="./../vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react"> React</h3>
<ul>
<li><a href="./../react/">React 教程</a></li>
</ul>
<h3 id="angular"> Angular</h3>
<ul>
<li><a href="./../angular/">Angular 教程</a></li>
</ul>
<h2 id="其他文档"> 其他文档</h2>
<ul>
<li><a href="./https.html">HTTPS 介绍</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-01T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">打开命令行</title>
    <id>https://list-jiang.github.io/code/windows/cmd/</id>
    <link href="https://list-jiang.github.io/code/windows/cmd/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>
]]></summary>
    <content type="html"><![CDATA[<p>打开命令行 (命令提示符) 有多种方式。</p>
<ol>
<li>运行 - cmd: <code>Win + R</code> 打开运行，然后敲入 <code>cmd</code> 后回车。</li>
<li>搜索 - cmd: 点击左下角搜索，输入 cmd，然后单击命令提示符。</li>
<li>开始菜单 - Windows 系统 - 命令提示符。</li>
</ol>
<p>如果想要快速打开特定路径的 cmd，请打开对应的文件夹，在地址栏直接输入 <code>cmd</code> 并回车。</p>

<p><img src="./assets/cmd.png" alt="示意图" loading="lazy"></p>
<p>这样就会快速打开一个路径为当前文件夹的命令提示符窗口。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-08T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">显示文件后缀名与隐藏文件</title>
    <id>https://list-jiang.github.io/code/windows/hidden-file/</id>
    <link href="https://list-jiang.github.io/code/windows/hidden-file/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>显示文件后缀名与隐藏文件</p>
<p><img src="./assets/hidden-file.png" alt="如何显示隐藏的文件与文件夹" loading="lazy"></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-09-15T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">记事本的遗留问题</title>
    <id>https://list-jiang.github.io/code/windows/notepad/</id>
    <link href="https://list-jiang.github.io/code/windows/notepad/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在编写代码的时候，临时的软件选择需要注意。</p>
<p>请注意，绝对不能用 Word 和写字板。Word 和写字板保存的不是纯文本文件。</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<p>原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了几个特殊字符(UTF-8 BOM，即 0xefbbbf)，您会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。</p>
<p>这个弱智行为从 Windows XP 影响到 Windows 10，在最新的 Windows 10 版本(20H2) 中，才得到解决。</p>
<div><p>提示</p>
<p>如果实在是临时急用，需要用记事本替代改一下代码，也要一定注意，保存文件时使用 ANSI 编码，并且暂时不要输入(包含)中文。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Windows 基础</title>
    <id>https://list-jiang.github.io/code/windows/</id>
    <link href="https://list-jiang.github.io/code/windows/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <summary type="html"><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>
]]></summary>
    <content type="html"><![CDATA[<p>以下是有关于 Windows 10 系统的一些基础知识。</p>

<ul>
<li>
<p><a href="./add-path.html">添加到 path</a></p>
</li>
<li>
<p><a href="./shortcut-key.html">Windows 快捷键</a></p>
</li>
<li>
<p><a href="./hidden-file.html">显示文件后缀名与隐藏文件</a></p>
</li>
<li>
<p><a href="./cmd.html">快速打开 CMD</a></p>
</li>
<li>
<p><a href="./notepad.html">记事本的遗留问题</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">常用快捷键</title>
    <id>https://list-jiang.github.io/code/windows/shortcut-key/</id>
    <link href="https://list-jiang.github.io/code/windows/shortcut-key/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>
]]></summary>
    <content type="html"><![CDATA[<p>熟练掌握各种 Windows 快捷键，能够更加高效的使用 Windows。</p>

<h2 id="最常用且最有用的"> 最常用且最有用的</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="通用键"> 通用键</h2>
<ul>
<li><code>F1</code>: 显示帮助；</li>
<li><code>F2</code>: 重命名文件；</li>
<li><code>F5</code>: 刷新；</li>
<li><code>F11</code>: 全屏；</li>
<li><code>Shift</code> + <code>F10</code>: 打开当前活动项目的快捷菜单(相当于鼠标右键)；</li>
<li><code>ALT</code> 激活当前程序的菜单栏(使用对应字母选择)；</li>
<li><code>Backspace</code>: 退格——删除前一个字符、文件视图下——返回上一级；</li>
<li><code>Enter</code>: 执行或进入；</li>
<li><code>Win</code> 或 <code>CTRL</code> + <code>ESC</code>: 打开开始菜单；</li>
<li><code>DELETE</code>: 删除被选中的项目，如果是文件，将被放入回收站；</li>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
</ul>
<h2 id="程序窗口"> 程序窗口</h2>
<ul>
<li><code>Win</code> + <code>Tab</code>: 最近任务和多桌面视图；</li>
<li><code>ALT</code> + <code>TAB</code> 切换当前程序(加 Shift 反向)；</li>
<li><code>ALT</code> + <code>F4</code>: 关闭当前应用程序；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>Alt</code> + <code>加下划线的字母</code> 执行与该字母匹配的命令(或选择选项)；</li>
<li><code>Win</code> + <code>↑</code>: 显示最小化的窗口 → 最大化窗口；</li>
<li><code>Win</code> + <code>←</code>: 将窗口最大化到屏幕的左侧；</li>
<li><code>Win</code> + <code>→</code>: 将窗口最大化到屏幕的右侧；</li>
<li><code>Win</code> + <code>↓</code>: 缩小窗口 → 最小化窗口；</li>
<li><code>Win</code> + <code>Home</code>: 最小化除活动窗口之外的所有窗口；</li>
<li><code>ALT</code> + <code>SPACEBAR</code>: 打开程序最左上角的菜单；</li>
<li><code>Win</code> + <code>Shift</code> + <code>↑</code>: 将窗口拉伸到屏幕的顶部和底部；</li>
<li><code>Win</code> + <code>Shift</code> + <code>←</code> 或 <code>Win</code> + <code>Shift</code> + <code>→</code>: 将窗口从一个监视器移动到另一个监视器；</li>
</ul>
<h2 id="文件浏览"> 文件浏览</h2>
<ul>
<li><code>F2</code>: 重命名文件；</li>
<li><code>Shift</code> + <code>DELETE</code>: 删除被选中的项目，如果是文件，将被直接删除而不是放入回收站；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Shift</code> + <code>N</code>: 新建文件夹或窗口</li>
</ul>
<h2 id="编辑模式"> 编辑模式</h2>
<ul>
<li><code>CTRL</code> + <code>O</code>: 打开文件；</li>
<li><code>CTRL</code> + <code>S</code>: 保存；</li>
<li><code>CTRL</code> + <code>方向键</code>: 滚动屏幕；</li>
<li><code>CTRL</code> + <code>A</code>: 全选；</li>
<li><code>CTRL</code> + <code>X</code>: 剪切；</li>
<li><code>CTRL</code> + <code>C</code>: 复制；</li>
<li><code>CTRL</code> + <code>V</code>: 粘贴；</li>
<li><code>CTRL</code> + <code>Z</code>: 撤销；</li>
<li><code>CTRL</code> + <code>Y</code>: 重做；</li>
<li><code>Ctrl</code> + <code>F</code>: 查找；</li>
<li><code>Ctrl</code> + <code>H</code>: 替换。</li>
<li><code>CTRL</code> + <code>E</code>: 搜索/助理；</li>
<li><code>Ctrl</code> + <code>Tab</code>: 在选项卡上向后移动(加 Shift 反向)；</li>
<li><code>CTRL</code> + <code>F4</code> 或 <code>CTRL</code> + <code>W</code>: 关闭当前选项卡；</li>
<li><code>CTRL</code> + <code>P</code>: 打印；</li>
</ul>
<div><p>提示</p>
<p>单击鼠标左键选择光标位置，按住 <code>Shift</code> 再次在另一处单击鼠标左键，即可选中两光标间的所有文字。鼠标左键单击拖动选中内容即可移动选中内容在文档中的位置。</p>
</div>
<h2 id="系统"> 系统</h2>
<ul>
<li><code>CTRL</code> + <code>Shift</code> + <code>ESC</code>: 打开任务管理器;</li>
<li><code>CTRL</code> + <code>ALT</code> + <code>DELETE</code>: 进入安全选项；</li>
<li><code>Win</code> + <code>D</code>: 显示桌面；</li>
<li><code>Win</code> + <code>E</code>: 打开资源管理器；</li>
<li><code>Win</code> + <code>L</code>: 锁定计算机或切换用户；</li>
<li><code>Win</code> + <code>M</code>: 最小化所有窗口(和显示桌面不同，自行感受)；</li>
<li><code>Win</code> + <code>Shift</code> + <code>M</code>: 将最小化的窗口还原到桌面；</li>
<li><code>Win</code> + <code>R</code>: 打开“运行”对话框；</li>
<li><code>Win</code> + <code>A</code>: 打开通知中心；</li>
<li><code>Win</code> + <code>I</code>: 打开系统设置；</li>
<li><code>Win</code> + <code>X</code>: 打开 Windows 主选项菜单；</li>
<li><code>Win</code> + <code>P</code>: 选择投影模式；</li>
<li><code>Win</code> + <code>数字</code>: 启动任务栏上快捷启动项数字位置处的程序；</li>
<li><code>Win</code> + <code>B</code> 选中桌面右下方工具栏；</li>
<li><code>Win</code> + <code>BREAK</code>: 打开“系统属性”对话框</li>
<li><code>Win</code> + <code>T</code>: 循环切换任务栏上的程序；</li>
<li><code>Shift</code> + <code>Win</code> + <code>数字</code>: 打开任务栏上快捷启动项数字位置处程序的新实例；</li>
<li><code>Alt</code> + <code>Win</code> + <code>数字</code>: 显示任务栏上快捷启动项数字位置处程序的跳转列表；</li>
<li><code>ALT</code> + <code>ESC</code>: 保留程序的显示状态切换当前程序(最小化状态将被保留)(加 Shift 反向)；</li>
</ul>
<h2 id="输入法"> 输入法</h2>
<ul>
<li><code>CTRL</code> + <code>Space</code>: 切换中英文输入法；</li>
<li><code>Win</code> + <code>Space</code>: 切换输入法；</li>
</ul>
<h2 id="屏幕截图"> 屏幕截图</h2>
<ul>
<li><code>PRINT SCREEN</code>: 将当前屏幕截图拷贝到剪贴板；</li>
<li><code>Win</code> + <code>PRINT SCREEN</code>: 将当前屏幕截图保存在图片文件夹中；</li>
<li><code>ALT</code> + <code>PRINT SCREEN</code>: 将当前活动程序窗口以图像方式拷贝到剪贴板；</li>
<li><code>Windows</code> + <code>Shift</code> + <code>S</code>: 打开截图工具；(仅在 Windows10 1809 及以上系统可用)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-09-07T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Mr.Hope Intro</title>
    <id>https://list-jiang.github.io/en/about/</id>
    <link href="https://list-jiang.github.io/en/about/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<i>Not supported content</i>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Code Note</title>
    <id>https://list-jiang.github.io/en/code/</id>
    <link href="https://list-jiang.github.io/en/code/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<div><p>相关信息</p>
<p>Code notes only contains <strong>Chinese</strong> version.</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">About site</title>
    <id>https://list-jiang.github.io/en/about/site/</id>
    <link href="https://list-jiang.github.io/en/about/site/"/>
    <updated>2021-12-07T13:14:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="about-site"> About site</h1>
<div><p>building</p>
<p>This site is built with <a href="https://v1.vuepress.vuejs.org/guide/" target="_blank" rel="noopener noreferrer">VuePress</a>.</p>
</div>
<h2 id="repository-link"> Repository Link</h2>
<ul>
<li><a href="https://github.com/List-Jiang/list-jiang.github.io.git" target="_blank" rel="noopener noreferrer"><strong>Mr.Hope’s Personal Blog</strong></a></li>
</ul>
<h2 id="disclamer"> Disclamer</h2>
<p>This blog contains books &amp; blogs from <a href="https://github.com/ruanyf" target="_blank" rel="noopener noreferrer">ruanyf</a> and <a href="https://weibo.com/liaoxuefeng" target="_blank" rel="noopener noreferrer">廖雪峰</a>.</p>
<p>Great thanks to them.</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>https://list-jiang.github.io/en/</id>
    <link href="https://list-jiang.github.io/en/"/>
    <updated>2021-12-07T13:06:21.000Z</updated>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Mr.Hope&amp;apos;s essay</title>
    <id>https://list-jiang.github.io/en/note/</id>
    <link href="https://list-jiang.github.io/en/note/"/>
    <updated>2021-12-07T13:06:21.000Z</updated>
    <content type="html"><![CDATA[<div><p>提示</p>
<p>Note, all the essay only contains <strong>Chinese</strong> version.</p>
</div>
<h2 id="seasons"> Seasons</h2>
<div><p>Introduction</p>
<p>This is a collection of prose poems I wrote in Senior 1, originally published in the qzone dairy.</p>
<p>Later I also wrote some poems to add in, among which &quot;Autumn Thought&quot; has most poems.</p>
<p>Recently, I moved it as a teenager’s memory in my blog.</p>
</div>
<ul>
<li>
<p><a href="./fall/catalog.html">Autumn Thought</a></p>
</li>
<li>
<p><a href="./winter/note.html">Winter Words</a></p>
</li>
<li>
<p><a href="./spring/1.html">Spring Poetry</a></p>
</li>
<li>
<p><a href="./summer/1.html">Summer Songs</a></p>
</li>
</ul>
<div><p>提示</p>
<p>Also check <a href="https://user.qzone.qq.com/2754005464" target="_blank" rel="noopener noreferrer">Qzone Album</a></p>
</div>
<h2 id="life-discussion"> Life Discussion</h2>
<div><p>Introduction</p>
<p>This is the sentiment of life I wrote in Senior 1, originally published in the qzone dairy.</p>
<p>Recently, I moved it as a teenager’s memory in my blog.</p>
</div>
<ul>
<li><a href="./life/">Details</a></li>
</ul>
<h2 id="whisper"> Whisper</h2>
<div><p>Introduction</p>
<p>This is some small prose poems I wrote in Senior 1, originally published in the qzone dairy.</p>
<p>Recently, I moved it as a teenager’s memory in my blog.</p>
</div>
<ul>
<li><a href="./poem/">Details</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Nginx</title>
    <id>https://list-jiang.github.io/en/software/nginx/</id>
    <link href="https://list-jiang.github.io/en/software/nginx/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx"> Nginx</h1>
<h2 id="intro"> Intro</h2>
<p>Nginx is a high performance HTTP and reverse proxy server and an IMAP / POP3 / SMTP proxy server. It features low memory, high concurrency, high stability, and Nginx’s friendly and flexible configuration.</p>
<h2 id="starting-stopping-and-reloading-configuration"> Starting, Stopping, and Reloading Configuration</h2>
<p>To start nginx, run the executable file. Once nginx is started, it can be controlled by invoking the executable with the <code>-s</code> parameter. Use the following syntax:</p>
<div><pre><code>nginx -s signal
</code></pre>
<div><span>1</span><br></div></div><p>Where signal may be one of the following:</p>
<ul>
<li>stop — fast shutdown</li>
<li>quit — graceful shutdown</li>
<li>reload — reloading the configuration file</li>
<li>reopen — reopening the log files</li>
</ul>
<h2 id="configuration-file-s-structure"> Configuration File’s Structure</h2>
<p>Nginx consists of modules which are controlled by directives specified in the configuration file. Directives are divided into simple directives and block directives. A simple directive consists of the name and parameters separated by spaces and ends with a semicolon (<code>;</code>). A block directive has the same structure as a simple directive, but instead of the semicolon it ends with a set of additional instructions surrounded by braces (<code>{</code> and <code>}</code>). If a block directive can have other directives inside braces, it is called a context (examples: <code>events</code>, <code>http</code>, <code>server</code>, and <code>location</code>).</p>
<p>Directives placed in the configuration file outside of any contexts are considered to be in the main context. The <code>events</code> and <code>http</code> directives reside in the <code>main</code> context, <code>server</code> in <code>http</code>, and <code>location</code> in <code>server</code>.</p>
<p>The rest of a line after the <code>#</code> sign is considered a comment.</p>
<h2 id="serving-static-content"> Serving Static Content</h2>
<p>An important web server task is serving out files (such as images or static HTML pages). You will implement an example where, depending on the request, files will be served from different local directories: <code>/data/www</code> (which may contain HTML files) and <code>/data/images</code> (containing images). This will require editing of the configuration file and setting up of a server block inside the http block with two location blocks.</p>
<p>First, create the <code>/data/www</code> directory and put an <code>index.html</code> file with any text content into it and create the <code>/data/images</code> directory and place some images in it.</p>
<p>Next, open the configuration file. The default configuration file already includes several examples of the server block, mostly commented out. For now comment out all such blocks and start a new server block:</p>
<div><pre><code><span><span>http</span></span> <span>{</span>
    <span><span>server</span></span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Generally, the configuration file may include several server blocks distinguished by ports on which they listen to and by server names. Once nginx decides which server processes a request, it tests the URI specified in the request’s header against the parameters of the location directives defined inside the server block.</p>
<p>Add the following location block to the server block:</p>
<div><pre><code><span><span>location</span> /</span> <span>{</span>
    <span><span>root</span> /data/www</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>This location block specifies the “<code>/</code>” prefix compared with the URI from the request. For matching requests, the URI will be added to the path specified in the root directive, that is, to <code>/data/www</code>, to form the path to the requested file on the local file system. If there are several matching location blocks nginx selects the one with the longest prefix. The location block above provides the shortest prefix, of length one, and so only if all other location blocks fail to provide a match, this block will be used.</p>
<p>Next, add the second location block:</p>
<div><pre><code><span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>It will be a match for requests starting with <code>/images/</code> (location <code>/</code> also matches such requests, but has shorter prefix).</p>
<p>The resulting configuration of the server block should look like this:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
    <span><span>location</span> /</span> <span>{</span>
        <span><span>root</span> /data/www</span><span>;</span>
    <span>}</span>

    <span><span>location</span> /images/</span> <span>{</span>
        <span><span>root</span> /data</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>This is already a working configuration of a server that listens on the standard port <code>80</code> and is accessible on the local machine at <code>http://localhost/</code>. In response to requests with URIs starting with <code>/images/</code>, the server will send files from the <code>/data/images</code> directory. For example, in response to the <code>http://localhost/images/example.png</code> request nginx will send the <code>/data/images/example.png</code> file. If such file does not exist, nginx will send a response indicating the 404 error. Requests with URIs not starting with <code>/images/</code> will be mapped onto the <code>/data/www</code> directory. For example, in response to the <code>http://localhost/some/example.html</code> request nginx will send the <code>/data/www/some/example.html</code> file.</p>
<p>To apply the new configuration, start nginx if it is not yet started or send the <code>reload</code> signal to the nginx’s master process, by executing:</p>
<div><pre><code>nginx -s reload
</code></pre>
<div><span>1</span><br></div></div><p>In case something does not work as expected, you may try to find out the reason in <code>access.log</code> and <code>error.log</code> files in the directory <code>/usr/local/nginx/logs</code> or <code>/var/log/nginx</code>.</p>
<h2 id="setting-up-a-simple-proxy-server"> Setting Up a Simple Proxy Server</h2>
<p>One of the frequent uses of nginx is setting it up as a proxy server, which means a server that receives requests, passes them to the proxied servers, retrieves responses from them, and sends them to the clients.</p>
<p>We will configure a basic proxy server, which serves requests of images with files from the local directory and sends all other requests to a proxied server. In this example, both servers will be defined on a single nginx instance.</p>
<p>First, define the proxied server by adding one more <code>server</code> block to the nginx’s configuration file with the following contents:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
    <span><span>listen</span> <span>8080</span></span><span>;</span>
    <span><span>root</span> /data/up1</span><span>;</span>

    <span><span>location</span> /</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>This will be a simple server that listens on the port <code>8080</code> (previously, the listen directive has not been specified since the standard port <code>80</code> was used) and maps all requests to the <code>/data/up1</code> directory on the local file system. Create this directory and put the <code>index.html</code> file into it. Note that the root directive is placed in the server context. Such root directive is used when the location block selected for serving a request does not include own root directive.</p>
<p>Next, use the server configuration from the previous section and modify it to make it a proxy server configuration. In the first location block, put the <code>proxy_pass</code> directive with the protocol, name and port of the proxied server specified in the parameter (in our case, it is <code>http://localhost:8080</code>):</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
    <span><span>location</span> /</span> <span>{</span>
        <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>
    <span>}</span>

    <span><span>location</span> /images/</span> <span>{</span>
        <span><span>root</span> /data</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>We will modify the second location block, which currently maps requests with the <code>/images/</code> prefix to the files under the <code>/data/images</code> directory, to make it match the requests of images with typical file extensions. The modified location block looks like this:</p>
<div><pre><code><span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>The parameter is a regular expression matching all URIs ending with <code>.gif</code>, <code>.jpg</code>, or <code>.png</code>. A regular expression should be preceded with <code>~</code>. The corresponding requests will be mapped to the <code>/data/images</code> directory.</p>
<p>When nginx selects a <code>location</code> block to serve a request it first checks location directives that specify prefixes, remembering <code>location</code> with the longest prefix, and then checks regular expressions. If there is a match with a regular expression, nginx picks this <code>location</code> or, otherwise, it picks the one remembered earlier.</p>
<p>The resulting configuration of a proxy server will look like this:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
    <span><span>location</span> /</span> <span>{</span>
        <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>
    <span>}</span>

    <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
        <span><span>root</span> /data/images</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>This server will filter requests ending with <code>.gif</code>, <code>.jpg</code>, or <code>.png</code> and map them to the <code>/data/images</code> directory (by adding URI to the root directive’s parameter) and pass all other requests to the proxied server configured above.</p>
<p>To apply new configuration, send the reload signal to nginx as described in the previous sections.</p>
<p>There are many more directives that may be used to further configure a proxy connection.</p>
<h2 id="setting-up-fastcgi-proxying"> Setting Up FastCGI Proxying</h2>
<p>Nginx can be used to route requests to FastCGI servers which run applications built with various frameworks and programming languages such as PHP.</p>
<p>The most basic nginx configuration to work with a FastCGI server includes using the <code>fastcgi_pass</code> directive instead of the <code>proxy_pass</code> directive, and <code>fastcgi_param</code> directives to set parameters passed to a FastCGI server. Suppose the FastCGI server is accessible on <code>localhost:9000</code>. Taking the proxy configuration from the previous section as a basis, replace the <code>proxy_pass</code> directive with the fastcgi_pass directive and change the parameter to <code>localhost:9000</code>. In PHP, the <code>SCRIPT_FILENAME</code> parameter is used for determining the script name, and the <code>QUERY_STRING</code> parameter is used to pass request parameters. The resulting configuration would be:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
    <span><span>location</span> /</span> <span>{</span>
        <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>
        <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
        <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>
    <span>}</span>

    <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
        <span><span>root</span> /data/images</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>This will set up a server that will route all requests except for requests for static images to the proxied server operating on <code>localhost:9000</code> through the FastCGI protocol.</p>
<h2 id="official-docs"> Official Docs</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">Navigate</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Software</title>
    <id>https://list-jiang.github.io/en/software/</id>
    <link href="https://list-jiang.github.io/en/software/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<div><p>相关信息</p>
<p>Most of the software guide only contains <strong>Chinese</strong> version.</p>
</div>
<h2 id="http-server"> Http Server</h2>
<ul>
<li><a href="./nginx.html">Nginx</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">WSL</title>
    <id>https://list-jiang.github.io/linux/WSL/</id>
    <link href="https://list-jiang.github.io/linux/WSL/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <summary type="html"><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>
]]></summary>
    <content type="html"><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre>
<div><span>1</span><br></div></div><h2 id="重启-wsl"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-23T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">归档和备份</title>
    <id>https://list-jiang.github.io/linux/bash/archives/archiving/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/archiving/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="归档和备份"> 归档和备份</h1>
<h2 id="gzip"> gzip</h2>
<p>gzip 程序用来压缩文件，原文件的压缩版(添加 <code>gz</code> 后缀名)会替代原文件。gunzip 程序用来还原压缩版本。</p>
<div><pre><code><span>gzip</span> foo.txt
gunzip foo.txt.gz
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>gzip</code> 的参数如下。</p>
<ul>
<li>-c 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。</li>
<li>-d 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.</li>
<li>-f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。</li>
<li>-h 显示用法信息。也可用--help 选项来指定。</li>
<li>-l 列出每个被压缩文件的压缩数据。也可用--list 选项。</li>
<li>-r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。</li>
<li>-t 测试压缩文件的完整性。也可用--test 选项来指定。</li>
<li>-v 显示压缩过程中的信息。也可用--verbose 选项来指定。</li>
<li>-number 设置压缩指数。number 是一个在 1(最快，最小压缩)到 9(最慢，最大压缩)之间的整数。数值 1 和 9 也可以各自用--fast 和--best 选项来表示。默认值是整数 6。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code><span># 查看解压缩后的内容</span>
$ gunzip -c foo.txt <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zcat</code> 程序等同于带有-c 选项的 gunzip 命令。它可以像 <code>cat</code> 命令那样，用来查看 <code>gzip</code> 压缩文件。</p>
<div><pre><code>zcat foo.txt.gz <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="bzip2"> bzip2</h2>
<p><code>bzip2</code> 程序与 <code>gzip</code> 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 <code>gzip</code>。由 <code>bzip2</code> 压缩的文件，用扩展名 <code>.bz2</code> 表示。</p>
<div><pre><code><span>bzip2</span> foo.txt
bunzip2 foo.txt.bz2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>gzip 程序的所有选项(除了 <code>-r</code>)，bzip2 程序同样也支持。同样有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p>
<h2 id="zip"> zip</h2>
<p><code>zip</code> 程序既是压缩工具，也是一个打包工具，读取和写入.zip 文件。</p>
<div><pre><code><span>zip</span> options zipfile file<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>它的用法如下。</p>
<div><pre><code><span># 将指定目录压缩成zip文件</span>
$ <span>zip</span> -r playground.zip playground
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zip</code> 与 <code>tar</code> 命令有一个相反之处。如果压缩文件已存在，其将被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。</p>
<p>解压使用 <code>unzip</code> 命令。</p>
<div><pre><code><span>unzip</span> <span>..</span>/playground.zip
</code></pre>
<div><span>1</span><br></div></div><p><code>unzip</code> 命令的参数如下。</p>
<ul>
<li><code>-l</code> 列出文件包中的内容而不解压</li>
<li><code>-v</code> 显示冗余信息</li>
<li><code>-p</code> 输出发送到标准输出</li>
</ul>
<div><pre><code><span>unzip</span> -p ls-etc.zip <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="tar"> tar</h2>
<p><code>tar</code> 是 tape archive 的简称，原来是一款制作磁带备份的工具，现在主要用于打包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。</p>
<p><code>tar</code> 程序的语法如下。</p>
<div><pre><code><span>tar</span> mode<span>[</span>options<span>]</span> pathname<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>tar 支持以下模式。</p>
<ul>
<li>c 表示 create，为文件和／或目录列表创建归档文件。</li>
<li>x 抽取归档文件。</li>
<li>r 追加具体的路径到归档文件的末尾。</li>
<li>t 列出归档文件的内容。</li>
</ul>
<p>支持的参数如下。</p>
<ul>
<li>f 表示 file，用来指定生成的文件。</li>
</ul>
<p>模式和参数可以写在一起，而且不需要开头的短横线。注意，必须首先指定模式，然后才是其它的选项。</p>
<div><pre><code><span># 创建子目录的tar包</span>
$ <span>tar</span> cf playground.tar playground

<span># 查看tar包内容</span>
$ <span>tar</span> tf playground.tar

<span># 查看更详细的列表信息</span>
$ <span>tar</span> tvf playground.tar

<span># 还原归档文件</span>
$ <span>tar</span> xf playground.tar

<span># 还原单个文件</span>
$ <span>tar</span> xf archive.tar pathname

<span># 还原文件到指定目录</span>
$ <span>tar</span> xvf archive.tar -C /home/me/

<span># 追加文件</span>
$ <span>tar</span> rf archive.tar file.txt

<span># 验证归档文件内容是否正确</span>
$ <span>tar</span> tvfW archive.tar

<span># 支持通配符</span>
$ <span>tar</span> xf <span>..</span>/playground2.tar --wildcards <span>'home/me/playground/\*.txt'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>注意，<code>tar</code> 命令还原的时候，总是还原为相对路径。如果归档的时候，保存的是绝对路径，那么还原的时候，这个绝对路径会整个变成相对路径。</p>
<p><code>find</code> 命令可以与 <code>tar</code> 命令配合使用。</p>
<div><pre><code><span>find</span> playground -name <span>'file.txt'</span> -exec <span>tar</span> rf playground.tar <span>'{}'</span> <span>'+'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令先用 <code>find</code> 程序找到所有名为 <code>file.txt</code> 的文件，然后使用追加模式(<code>r</code>)的 <code>tar</code> 命令，把匹配的文件添加到归档文件 <code>playground.tar</code> 里面。</p>
<p>这种 <code>tar</code> 和 <code>find</code> 的配合使用，可以创建逐渐增加的目录树或者整个系统的备份。通过 <code>find</code> 命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件。</p>
<p>tar 支持压缩功能。</p>
<div><pre><code><span># 打成gzip压缩包</span>
$ <span>tar</span> czvf assets.tar.gz dist

<span># 打成bz2压缩包</span>
$ <span>tar</span> cvfj assets.tar.bz2 dist

<span># 解压 tar.gz 文件</span>
$ <span>tar</span> xzv archive.tar.gz
$ <span>tar</span> xvf archive.tar.gz

<span># 解压bz2压缩包</span>
$ <span>tar</span> xvf archive.tar.bz2

<span># 显示gzip压缩包内容</span>
$ <span>tar</span> tvf archive.tar.gz

<span># 显示bz2压缩包内容</span>
$ <span>tar</span> tvf archive.tar.bz2

<span># 从gzip压缩包取出单个文件</span>
$ <span>tar</span> zxvf archive.tar.gz file.txt

<span># 从bz2压缩包取出单个文件</span>
$ <span>tar</span> jxvf archive.tar.bz2 file.txt

<span># 按通配符取出文件</span>
$ <span>tar</span> zxvf archive.tar.gz --wildcards <span>'*.php'</span>
$ <span>tar</span> jxvf archive.tar.bz2 --wildcards <span>'*.php'</span>

<span># 追加文件到压缩包</span>
$ <span>tar</span> rvf archive.tar.gz xyz.txt
$ <span>tar</span> rvf archive.tar.bz2 xyz.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="rsync"> rsync</h2>
<p><code>rsync</code> 命令用于在多个目录之间、或者本地与远程目录之间同步。字母 <code>r</code> 表示 <code>remote</code>。</p>
<div><pre><code><span>rsync</span> options <span>source</span> destination
</code></pre>
<div><span>1</span><br></div></div><p>source 和 destination 是下列选项之一:</p>
<ul>
<li>一个本地文件或目录</li>
<li>一个远端文件或目录，以 <code>[user@]host:path</code> 的形式存在</li>
<li>一个远端 rsync 服务器，由 <code>rsync://[user@]host[:port]/path</code> 指定</li>
</ul>
<p>注意 source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制。</p>
<p><code>rsync</code> 命令的参数如下。</p>
<ul>
<li><code>-a</code> 递归和保护文件属性</li>
<li><code>-v</code> 冗余输出</li>
<li><code>--delete</code> 删除可能在备份设备中已经存在但却不再存在于源设备中的文件</li>
<li><code>--rsh=ssh</code> 使用 ssh 程序作为远程 shell，目的地必须标注主机名。</li>
</ul>
<div><pre><code><span># 同步两个本地目录</span>
$ <span>rsync</span> -av playground foo

<span># 删除源设备不存在的文件</span>
$ <span>sudo</span> <span>rsync</span> -av --delete /etc /home /usr/local /media/BigDisk/backup

<span># 远程同步</span>
$ <span>sudo</span> <span>rsync</span> -av --delete --rsh<span>=</span>ssh /etc /home /usr/local remote-sys:/backup

<span># 与远程rsync主机同步</span>
$ <span>rsync</span> -av -delete rsync://rsync.gtlib.gatech.edu/path/to/oss fedora-devel
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">异步任务</title>
    <id>https://list-jiang.github.io/linux/bash/archives/async/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/async/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="异步任务"> 异步任务</h1>
<p>Bash 脚本有时候需要同时执行多个任务。通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办?</p>
<p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程(例如，子脚本)运行结束。</p>
<p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-parent : Asynchronous execution demo (parent)</span>
<span>echo</span> <span>"Parent: starting..."</span>
<span>echo</span> <span>"Parent: launching child script..."</span>
async-child <span>&amp;</span>
<span>pid</span><span>=</span><span>$!</span>
<span>echo</span> <span>"Parent: child (PID= <span>$pid</span>) launched."</span>
<span>echo</span> <span>"Parent: continuing..."</span>
<span>sleep</span> <span>2</span>
<span>echo</span> <span>"Parent: pausing to wait for child to finish..."</span>
<span>wait</span> <span>$pid</span>
<span>echo</span> <span>"Parent: child is finished. Continuing..."</span>
<span>echo</span> <span>"Parent: parent is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>和一个子脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-child : Asynchronous execution demo (child)</span>
<span>echo</span> <span>"Child: child is running..."</span>
<span>sleep</span> <span>5</span>
<span>echo</span> <span>"Child: child is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p>
<p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出， 意味着父脚本结束。</p>
<p>当执行后，父子脚本产生如下输出:</p>
<div><pre><code>$ async-parent
Parent: starting<span>..</span>.
Parent: launching child script<span>..</span>.
Parent: child <span>(</span>PID<span>=</span> <span>6741</span><span>)</span> launched.
Parent: continuing<span>..</span>.
Child: child is running<span>..</span>.
Parent: pausing to <span>wait</span> <span>for</span> child to finish<span>..</span>.
Child: child is done. Exiting.
Parent: child is finished. Continuing<span>..</span>.
Parent: parent is done. Exiting.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Shell 的命令</title>
    <id>https://list-jiang.github.io/linux/bash/archives/command/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/command/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-的命令"> Shell 的命令</h1>
<h2 id="命令的类别"> 命令的类别</h2>
<p>Bash 可以使用的命令分成四类。</p>
<ul>
<li>可执行程序</li>
<li>Shell 提供的命令</li>
<li>Shell 函数</li>
<li>前三类命令的别名</li>
</ul>
<h2 id="type-whatis"> type, whatis</h2>
<p><code>type</code> 命令可以显示命令类型。</p>
<div><pre><code><span>type</span> <span>command</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是几个例子。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>

$ <span>type</span> <span>ls</span>
<span>ls</span> is aliased to `ls --color<span>=</span>tty'

$ <span>type</span> <span>cp</span>
<span>cp</span> is /bin/cp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>whatis</code> 命令显示指定命令的描述。</p>
<div><pre><code>$ whatis <span>ls</span>
<span>ls</span> <span>(</span><span>1</span><span>)</span> - list directory contents
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="apropos"> apropos</h2>
<p><code>apropos</code> 命令返回符合搜索条件的命令列表。</p>
<div><pre><code>$ <span>apropos</span> floppy
create_floppy_devices <span>(</span><span>8</span><span>)</span> - udev callout to create all possible
<span>fdformat</span> <span>(</span><span>8</span><span>)</span> - Low-level formats a floppy disk
floppy <span>(</span><span>8</span><span>)</span> - <span>format</span> floppy disks
gfloppy <span>(</span><span>1</span><span>)</span> - a simple floppy formatter <span>for</span> the GNOME
mbadblocks <span>(</span><span>1</span><span>)</span> - tests a floppy disk, and marks the bad
mformat <span>(</span><span>1</span><span>)</span> - <span>add</span> an MSDOS filesystem to a low-level
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="alias-unalias"> alias, unalias</h2>
<p><code>alias</code> 命令用来为命令起别名。</p>
<div><pre><code>$ <span>alias</span> <span>foo</span><span>=</span><span>'cd /usr; ls; cd -'</span>

$ <span>type</span> foo
foo is aliased to `cd /usr<span>;</span> <span>ls</span> <span>;</span> <span>cd</span> -'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令指定 <code>foo</code> 为三个命令的别名。以后，执行 <code>foo</code> 就相当于一起执行这三条命令。</p>
<p>注意，默认情况下，别名只在当前 Session 有效。当前 Session 结束时，这些别名就会消失。</p>
<p><code>alias</code> 命令不加参数时，显示所有有效的别名。</p>
<div><pre><code>$ <span>alias</span>
<span>alias</span> l.<span>=</span><span>'ls -d .* --color=tty'</span>
<span>alias</span> <span>ll</span><span>=</span><span>'ls -l --color=tty'</span>
<span>alias</span> <span>ls</span><span>=</span><span>'ls --color=tty'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>unalias</code> 命令用来取消别名。</p>
<div><pre><code>$ <span>unalias</span> foo
$ <span>type</span> foo
bash: type: foo: not found
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="which"> which</h2>
<p><code>which</code> 命令显示可执行程序的路径。</p>
<div><pre><code>$ <span>which</span> <span>ls</span>
/bin/ls
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>which</code> 命令用于 Shell 内置命令时(比如 <code>cd</code>)，将没有任何输出。</p>
<h2 id="help-man"> help，man</h2>
<p><code>help</code> 命令用于查看 Shell 内置命令的帮助信息，<code>man</code> 命令用于查看可执行命令的帮助信息。</p>
<div><pre><code><span>help</span> <span>cd</span>
<span>man</span> <span>ls</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>man</code> 里面的文档一共有 8 类，如果同一个命令，匹配多个文档，<code>man</code> 命令总是返回第一个匹配。如果想看指定类型的文档，命令可以采用下面的形式。</p>
<div><pre><code><span>man</span> <span>5</span> <span>passwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="script"> script</h2>
<p><code>script</code> 命令会将输入的命令和它的输出，都保存进一个文件。</p>
<div><pre><code>script <span>[</span>file<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，则所有结果会保存进当前目录下 <code>typescript</code> 文件。结束录制的时候，可以按下 <code>Ctrl + d</code>。</p>
<h2 id="export"> export</h2>
<p><code>export</code> 命令用于将当前进程的变量，输出到所有子进程。</p>
<h2 id="命令的连续执行"> 命令的连续执行</h2>
<p>多个命令可以写在一起。</p>
<p>Bash 提供三种方式，定义它们如何执行。</p>
<div><pre><code><span># 第一个命令执行完，执行第二个命令</span>
command1<span>;</span> command2

<span># 只有第一个命令成功执行完(退出码0)，才会执行第二个命令</span>
command1 <span>&amp;&amp;</span> command2

<span># 只有第一个命令执行失败(退出码非0)，才会执行第二个命令</span>
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种执行方法的退出码，都是最后一条执行的命令的退出码。</p>
<p>bash 允许把命令组合在一起。可以通过两种方式完成；要么用一个 group 命令，要么用一个子 shell。这里是每种方式的语法示例:</p>
<p>组命令:</p>
<div><pre><code><span>{</span> command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span> <span>..</span>.<span>]</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>子 shell</p>
<div><pre><code><span>(</span>command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span><span>..</span>.<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式， 花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。</p>
<p>那么组命令和子 shell 命令对什么有好处呢? 它们都是用来管理重定向的。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>使用一个子 shell 是相似的。</p>
<div><pre><code><span>(</span>ls -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>)</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>组命令和子 shell 真正闪光的地方是与管道线相结合。当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一个流是很有用的。组命令和子 shell 使这种操作变得很简单。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>|</span> <span>lpr</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr 的输入，以便产生一个打印报告。</p>
<p>虽然组命令和子 shell 看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个很重要的不同。然而，一个组命令在当前 shell 中执行它的所有命令，而一个子 shell(顾名思义)在当前 shell 的一个 子副本中执行它的命令。这意味着运行环境被复制给了一个新的 shell 实例。当这个子 shell 退出时，环境副本会消失， 所以在子 shell 环境(包括变量赋值)中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell， 组命令比子 shell 更受欢迎。组命令运行很快并且占用的内存也少。</p>
<p>当我们发现管道线中的一个 read 命令 不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线:</p>
<div><pre><code><span>echo</span> <span>"foo"</span> <span>|</span> <span>read</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>该 REPLY 变量的内容总是为空，是因为这个 read 命令在一个子 shell 中执行，所以它的 REPLY 副本会被毁掉， 当该子 shell 终止的时候。因为管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题。幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式:</p>
<p>一种适用于产生标准输出的进程:</p>
<div><pre><code><span>&lt;</span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>另一种适用于接受标准输入的进程:</p>
<div><pre><code><span>></span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的 list 是一串命令列表:</p>
<p>为了解决我们的 read 命令问题，我们可以雇佣进程替换，像这样。</p>
<div><pre><code><span>read</span> <span>&lt;</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进程替换允许我们把一个子 shell 的输出结果当作一个用于重定向的普通文件。事实上，因为它是一种展开形式，我们可以检验它的真实值:</p>
<div><pre><code><span>[</span>me@linuxbox ~<span>]</span>$ <span>echo</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
/dev/fd/63
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过使用 echo 命令，查看展开结果，我们看到子 shell 的输出结果，由一个名为 /dev/fd/63 的文件提供。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">alias</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/alias/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/alias/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="alias"> alias</h1>
<p><code>alias</code> 命令用于设置别名。通常用于在 Bash 设置文件中，设置别名。</p>
<div><pre><code><span>alias</span> <span>dockerlogin</span><span>=</span><span>'ssh www-data@adnan.local -p2222'</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">awk</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/awk/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/awk/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="awk"> awk</h1>
<p><a href="https://en.wikipedia.org/wiki/AWK" target="_blank" rel="noopener noreferrer"><code>awk</code></a>是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。</p>
<p>它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，<code>awk</code> 可能是最方便的工具。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201811/bg2018110702.jpg" alt="Book" loading="lazy"></p>
<p><code>awk</code> 其实不仅仅是工具软件，还是一种编程语言。不过，这里只介绍它的命令行用法，对于大多数场合，应该足够用了。</p>
<h2 id="基本用法"> 基本用法</h2>
<p><code>awk</code> 的基本用法就是下面的形式。</p>
<div><pre><code><span># 格式</span>
$ <span>awk</span> 动作 文件名

<span># 示例</span>
$ <span>awk</span> <span>'{print $0}'</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面示例中，<code>demo.txt</code> 是 <code>awk</code> 所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作 <code>print $0</code>。其中，<code>print</code> 是打印命令，<code>$0</code> 代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。</p>
<p>下面，我们先用标准输入(stdin)演示上面这个例子。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $0}'</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>print $0</code> 就是把标准输入 <code>this is a test</code>，重新打印了一遍。</p>
<p><code>awk</code> 会根据空格和制表符，将每一行分成若干字段，依次用<code>$1</code>、<code>$2</code>、<code>$3</code> 代表第一个字段、第二个字段、第三个字段等等。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $3}'</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>$3</code> 代表 <code>this is a test</code> 的第三个字段 <code>a</code>。</p>
<p>下面，为了便于举例，我们把<code>/etc/passwd</code> 文件保存成 <code>demo.txt</code>。</p>
<div><pre><code>root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个文件的字段分隔符是冒号(<code>:</code>)，所以要用 <code>-F</code> 参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print $1 }'</span> demo.txt
root
daemon
bin
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="变量"> 变量</h2>
<p>除了<code>$ + 数字</code>表示某个字段，<code>awk</code> 还提供其他一些变量。</p>
<p>变量 <code>NF</code> 表示当前行有多少个字段，因此<code>$NF</code> 就代表最后一个字段。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $NF}'</span>
<span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(NF-1)</code> 代表倒数第二个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print $1, $(NF-1)}'</span> demo.txt
root /root
daemon /usr/sbin
bin /bin
sys /dev
<span>sync</span> /bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p>
<p>变量 <code>NR</code> 表示当前处理的是第几行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print NR ") " $1}'</span> demo.txt
<span>1</span><span>)</span> root
<span>2</span><span>)</span> daemon
<span>3</span><span>)</span> bin
<span>4</span><span>)</span> sys
<span>5</span><span>)</span> <span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面，如果原样输出字符，要放在双引号里面。</p>
<p><code>awk</code> 的其他内置变量如下。</p>
<blockquote>
<ul>
<li><code>FILENAME</code>: 当前文件名</li>
<li><code>FS</code>: 字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>: 行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>: 输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>: 输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>: 数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
</blockquote>
<h2 id="函数"> 函数</h2>
<p><code>awk</code> 还提供了一些内置函数，方便对原始数据的处理。</p>
<p>函数 <code>toupper()</code> 用于将字符转为大写。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print toupper($1) }'</span> demo.txt
ROOT
DAEMON
BIN
SYS
SYNC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，第一个字段输出时都变成了大写。</p>
<p>其他常用函数如下。</p>
<blockquote>
<ul>
<li><code>tolower()</code>: 字符转为小写。</li>
<li><code>length()</code>: 返回字符串长度。</li>
<li><code>substr()</code>: 返回子字符串。</li>
<li><code>sin()</code>: 正弦。</li>
<li><code>cos()</code>: 余弦。</li>
<li><code>sqrt()</code>: 平方根。</li>
<li><code>rand()</code>: 随机数。</li>
</ul>
</blockquote>
<p><code>awk</code> 内置函数的完整列表，可以查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din" target="_blank" rel="noopener noreferrer">手册</a>。</p>
<h2 id="条件"> 条件</h2>
<p><code>awk</code> 允许指定输出条件，只输出符合条件的行。</p>
<p>输出条件要写在动作的前面。</p>
<div><pre><code><span>awk</span> <span>'条件 动作'</span> 文件名
</code></pre>
<div><span>1</span><br></div></div><p>请看下面的例子。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'/usr/ {print $1}'</span> demo.txt
root
daemon
bin
sys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>print</code> 命令前面是一个正则表达式，只输出包含 <code>usr</code> 的行。</p>
<p>下面的例子只输出奇数行，以及输出第三行以后的行。</p>
<div><pre><code><span># 输出奇数行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR % 2 == 1 {print $1}'</span> demo.txt
root
bin
<span>sync</span>

<span># 输出第三行以后的行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR >3 {print $1}'</span> demo.txt
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面的例子输出第一个字段等于指定值的行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'$1 == "root" {print $1}'</span> demo.txt
root

$ <span>awk</span> -F <span>':'</span> <span>'$1 == "root" || $1 == "bin" {print $1}'</span> demo.txt
root
bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="if-语句"> if 语句</h2>
<p><code>awk</code> 提供了 <code>if</code> 结构，用于编写复杂的条件。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if ($1 > "m") print $1}'</span> demo.txt
root
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码输出第一个字段的第一个字符大于 <code>m</code> 的行。</p>
<p><code>if</code> 结构还可以指定 <code>else</code> 部分。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if ($1 > "m") print $1; else print "---"}'</span> demo.txt
root
---
---
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://gregable.com/2010/09/why-you-should-know-just-little-awk.html" target="_blank" rel="noopener noreferrer">An Awk tutorial by Example</a>, Greg Grothaus</li>
<li><a href="https://likegeeks.com/awk-command/" target="_blank" rel="noopener noreferrer">30 Examples for Awk Command in Text Processing</a>, Mokhtar Ebrahim</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">cal</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/cal/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/cal/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cal"> cal</h1>
<p><code>cal</code> 命令显示本月的日历。</p>
<div><pre><code><span>cal</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">cat</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/cat/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/cat/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cat"> cat</h1>
<p><code>cat</code> 命令用于显示一个文本文件的内容。</p>
<p><code>cat - &gt;&gt; filename</code> 用于向一个现有文件的尾部追加内容。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">clear</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/clear/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/clear/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="clear"> clear</h1>
<p><code>clear</code> 命令用来清除当前屏幕的显示，运行后会只留下一个提示符。</p>
<div><pre><code><span>clear</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">cp 命令</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/cp/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/cp/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cp-命令"> cp 命令</h1>
<p><code>cp</code> 命令用于复制文件。</p>
<h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数只复制那些目标目录里面还不存在的文件，以及那些虽然存在、但是比源目录对应文件更陈旧的文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">cut</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/cut/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/cut/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="cut"> cut</h1>
<p><code>cut</code> 命令用于在命令行输出文本文件的指定位置的内容。</p>
<p>它的使用格式如下。</p>
<div><pre><code><span>cut</span> OPTION <span>[</span>FILE<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，将读取标准输入。</p>
<p><code>-b</code> 参数用来指定读取的字节。</p>
<div><pre><code><span># 输出前三个字节</span>
$ <span>cut</span> file1.txt -b1,2,3

<span># 输出前十个字节</span>
$ <span>cut</span> file1.txt -b1-10

<span># 输出从第5个字节开始的所有字节</span>
$ <span>cut</span> file1.txt -b5-

<span># 输出前5个字节</span>
$ <span>cut</span> file1.txt -b-5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>-c</code> 参数用来指定读取的字符，用法与 <code>-b</code> 一样。有的字符是多字节字符，这时候就应该用 <code>-c</code> 代替 <code>-b</code>。</p>
<p><code>-d</code> 参数用来指定分隔符，默认分隔符为制表符。</p>
<p><code>-f</code> 参数用来指定字段。</p>
<div><pre><code><span># 指定每一行的分隔符为逗号，</span>
<span># 输出第一和第三个字段</span>
$ <span>cut</span> file1.txt -d, -f1,3

<span># 输出第一、第二、第四和第五个字段</span>
$ <span>cut</span> -f <span>1</span>-2,4-5 data.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">date</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/date/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/date/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="date"> date</h1>
<p><code>date</code> 命令显示当前的日期和时间。</p>
<div><pre><code><span>date</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">dd</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/dd/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/dd/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="dd"> dd</h1>
<p><code>dd</code> 命令用于复制磁盘或文件系统。</p>
<h2 id="复制磁盘"> 复制磁盘</h2>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示将<code>/dev/sda</code> 磁盘复制到<code>/dev/sdb</code> 设备。参数 <code>if</code> 表示来源地，<code>of</code> 表示目的地。</p>
<p>除了复制，<code>dd</code> 还允许将磁盘做成一个镜像文件。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/home/username/sdadisk.img
</code></pre>
<div><span>1</span><br></div></div><p><code>dd</code> 还可以复制单个分区。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda2 <span>of</span><span>=</span>/home/username/partition2.img <span>bs</span><span>=</span><span>4096</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，参数 <code>bs</code> 表示单次拷贝的字节数(bytes)。</p>
<p>要将镜像文件复原，也很简单。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>sdadisk.img <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><h2 id="清除数据"> 清除数据</h2>
<p><code>dd</code> 也可以用于清除磁盘数据。</p>
<div><pre><code><span># 磁盘数据写满 0</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/zero <span>of</span><span>=</span>/dev/sda1

<span># 磁盘数据写满随机字符</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>of</span><span>=</span>/dev/sda1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="监控进展"> 监控进展</h2>
<p>磁盘的复制通常需要很久，为了监控进展，可以使用 Pipe Viewer 工具软件。如果没有安装这个软件，可以使用下面的命令安装。</p>
<div><pre><code><span>sudo</span> <span>apt</span> <span>install</span> <span>pv</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后，来源地和目的地之间插入广告，就可以看到进展了。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>|</span> <span>pv</span> <span>|</span> <span>dd</span> <span>of</span><span>=</span>/dev/sda1
<span>4</span>,14MB <span>0</span>:00:05 <span>[</span> 98kB/s<span>]</span> <span>[</span>      <span>&lt;=</span><span>></span>                  <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li>David Clinton, <a href="https://opensource.com/article/18/7/how-use-dd-linux" target="_blank" rel="noopener noreferrer">How to use dd in Linux without destroying your disk</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">df</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/df/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/df/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="df"> df</h1>
<p><code>df</code> 命令显示磁盘信息。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">du</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/du/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/du/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="du"> du</h1>
<p><code>du</code> 命令显示某个文件或目录的磁盘使用量。</p>
<div><pre><code><span>du</span> filename
</code></pre>
<div><span>1</span><br></div></div><p><code>-h</code> 参数将返回的大小显示为人类可读的格式，即显示单位为 K、M、G 等。</p>
<p><code>-s</code> 参数表示总结(summarize)。</p>
<p><code>-x</code> 参数表示不显示不在当前分区的目录，通常会忽略<code>/dev</code>、<code>/proc</code>、<code>/sys</code> 等目录。</p>
<p><code>-c</code> 参数表示显示当前目录总共占用的空间大小。</p>
<div><pre><code><span># 显示根目录下各级目录占用的空间大小</span>
$ <span>sudo</span> <span>du</span> -shxc /*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--exclude</code> 参数用于排除某些目录或文件。</p>
<div><pre><code><span>sudo</span> <span>du</span> -shxc /* --exclude<span>=</span>proc
<span>sudo</span> <span>du</span> -sh --exclude<span>=</span>*.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--max-depth</code> 参数用于设定目录大小统计到第几层。如果设为 <code>-–max-depth=0</code>，那么等同于 <code>-s</code> 参数。</p>
<div><pre><code><span>sudo</span> <span>du</span> /home/ -hc --max-depth<span>=</span><span>2</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">export</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/export/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/export/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="export"> export</h1>
<p><code>export</code> 命令用于向子 Shell 输出变量。</p>
<div><pre><code><span>export</span> <span>hotellogs</span><span>=</span><span>"/workspace/hotel-api/storage/logs"</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后执行下面的命令，新建一个子 Shell。</p>
<div><pre><code><span>bash</span>
<span>cd</span> hotellogs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行结果会进入 <code>hotellogs</code> 变量指向的目录。</p>
<p><code>export</code> 命令还可以显示所有环境变量。</p>
<div><pre><code>$ <span>export</span>
<span><span>SHELL</span></span><span>=</span>/bin/zsh
<span>AWS_HOME</span><span>=</span>/Users/adnanadnan/.aws
<span><span>LANG</span></span><span>=</span>en_US.UTF-8
<span>LC_CTYPE</span><span>=</span>en_US.UTF-8
<span>LESS</span><span>=</span>-R
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果想查看单个变量，使用 <code>echo $VARIABLE_NAME</code>。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/usr/bin/zsh
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">egrep</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/egrep/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/egrep/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="egrep"> egrep</h1>
<p><code>egrep</code> 命令用于显示匹配正则模式的行，与 <code>grep -E</code> 命令等价。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
sed diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, sed
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>egrep</code> 命令显示包括 <code>Lorem</code> 或 <code>dolor</code> 的行。</p>
<div><pre><code>$ <span>egrep</span> <span>'(Lorem|dolor)'</span> example.txt
<span># 或者</span>
$ <span>grep</span> -E <span>'(Lorem|dolor)'</span> example.txt
Lorem ipsum
dolor sit amet,
et dolore magna
duo dolores et ea
sanctus est Lorem
ipsum dolor sit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">file</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/file/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/file/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="file"> file</h1>
<p><code>file</code> 命令用来某个文件的类型。</p>
<div><pre><code>$ <span>file</span> index.html
 index.html: HTML document, ASCII text
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>file 工具可以对所给的文件一行简短的介绍，它用文件后缀、头部信息和一些其他的线索来判断文件。您在检查一堆您不熟悉的文件时使用 find 非常方便:</p>
<div><pre><code>$ <span>find</span> -exec <span>file</span> <span>{</span><span>}</span> <span>\</span><span>;</span>
.:            directory
./hanoi:      Perl script, ASCII text executable
./.hanoi.swp: Vim swap file, version <span>7.3</span>
./factorial:  Perl script, ASCII text executable
./bits.c:     C source, ASCII text
./bits:       ELF <span>32</span>-bit LSB executable, Intel <span>80386</span>, version <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">fmt</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/fmt/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/fmt/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="fmt"> fmt</h1>
<p><code>fmt</code> 命令用于对文本指定样式。</p>
<p>下面是 <code>example.txt</code> 的内容，是非常长的一行。</p>
<div><pre><code>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
</code></pre>
<div><span>1</span><br></div></div><p><code>fmt</code> 可以将其输出为每行 80 个字符。</p>
<div><pre><code><span>cat</span> example.txt <span>|</span> <span>fmt</span> -w <span>20</span>
Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">find</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/find/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/find/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="find"> find</h1>
<p><code>find</code> 命令用于寻找文件，会包括当前目录的所有下级目录。</p>
<p>如果不带任何参数，<code>find</code> 文件会列出当前目录的所有文件，甚至还包括相对路径。如果把结果导入 <code>sort</code> 效果更好。</p>
<div><pre><code>$ <span>find</span> <span>|</span> <span>sort</span>
<span>.</span>
./Makefile
./README
./build
./client.c
./client.h
./common.h
./project.c
./server.c
./server.h
./tests
./tests/suite1.pl
./tests/suite2.pl
./tests/suite3.pl
./tests/suite4.pl
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果想要 <code>ls -l</code> 样式的列表，只要在 <code>find</code> 后面加上 <code>-ls</code>。</p>
<div><pre><code><span>find</span> -ls
</code></pre>
<div><span>1</span><br></div></div><p><code>find</code> 有它自己的一套复杂的过滤语句。下面列举的是一些最常用的您可以用以获取某些文件列表的过滤器:</p>
<ul>
<li><code>find -name '*.c'</code> —— 查找符合某 shell 式样式的文件名的文件。用 iname 开启大小写不敏感搜索。</li>
<li><code>find -path '_test_'</code> —— 查找符合某 shell 式样式的路径的文件。用 ipath 开启大小写不敏感搜索。</li>
<li><code>find -mtime -5</code> —— 查找近五天内编辑过的文件。您也可以用 +5 来查找五天之前编辑过的文件。</li>
<li><code>find -newer server.c</code> —— 查找比 server.c 更新的文件。</li>
<li><code>find -type d</code> —— 查找所有文件夹。如果想找出所有文件，那就用 <code>-type f</code>；找符号连接就用 <code>-type l</code>。</li>
</ul>
<p>要注意，上面提到的这些过滤器都是可以组合使用的，例如找出近两天内编辑过的 C 源码:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -mtime -2
</code></pre>
<div><span>1</span><br></div></div><p>默认情况下， find 对搜索结果所采取的动作只是简单地通过标准输出输出一个列表，然而其实还有其他一些有用的后续动作。</p>
<ul>
<li>-ls —— 如前文，提供了一种类 ls -l 式的列表。</li>
<li>-delete —— 删除符合查找条件的文件。</li>
<li>-exec —— 对搜索结果里的每个文件都运行某个命令， <code>{}</code> 会被替换成适当的文件名，并且命令用 <code>\;</code> 终结。</li>
</ul>
<div><pre><code><span>find</span> -name <span>'*.pl'</span> -exec perl -c <span>{</span><span>}</span> <span>\</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以使用 <code>+</code> 作为终止符来对所有结果运行一次命令。我还发现一个我经常使用的小技巧，就是用 <code>find</code> 生成一个文件列表，然后在 Vim 的垂直分窗中编辑:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -exec <span>vim</span> <span>{</span><span>}</span> +
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">grep</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/grep/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/grep/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="grep"> grep</h1>
<p><code>grep</code> 命令用于文件内容的搜索，返回所有匹配的行。</p>
<div><pre><code><span>grep</span> pattern filename
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>grep</span> admin /etc/passwd
_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false
_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false
_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般情况下，应该使用 <code>grep -R</code>，递归地找出当前目录下符合 <code>someVar</code> 的文件。</p>
<div><pre><code><span>grep</span> -FR <span>'someVar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>別忘了大小不敏感的参数，因为 grep 默认搜索是大小写敏感的。</p>
<div><pre><code><span>grep</span> -iR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>也可以用 <code>grep -l</code> 光打印出符合条件的文件名而非文件内容选段。</p>
<div><pre><code><span>grep</span> -lR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果您写的脚本或批处理任务需要上面的输出内容，可以使用 while 和 read 来处理文件名中的空格和其他特殊字符:</p>
<div><pre><code><span>grep</span> -lR someVar <span>|</span> <span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r <span>file</span><span>;</span> <span>do</span>
    <span>head</span> <span>"<span>$file</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您在您的项目里使用了版本控制软件，它通常会在 .svn， .git， .hg 目录下包含一些元数据。您也可以很容易地用 grep -v 把这些目录移出搜索范围，当然得用 grep -F 指定一个恰当且确定的字符串，即要移除的目录名:</p>
<div><pre><code><span>grep</span> -R <span>'someVar'</span> <span>.</span> <span>|</span> <span>grep</span> -vF <span>'.svn'</span>
</code></pre>
<div><span>1</span><br></div></div><p>部分版本的 grep 包含了 --exclude 和 --exclude-dir 选项，这看起来更加易读。</p>
<h2 id="参数"> 参数</h2>
<p><code>-i</code> 参数表示忽略大小写。</p>
<p><code>-r</code> 表示搜索某个目录下面的所有文件。</p>
<div><pre><code><span>grep</span> -r admin /etc/
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 过滤包含某个词的行，即 <code>grep</code> 的逆操作。</p>
<div><pre><code><span># 显示所有包含 vim，但不包含 grep 的行</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vim</span> <span>|</span> <span>grep</span> -v <span>grep</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">gunzip</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/gunzip/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/gunzip/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gunzip"> gunzip</h1>
<p><code>gunzip</code> 命令用于解压 <code>gzip</code> 命令压缩的文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">gzip</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/gzip/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/gzip/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gzip"> gzip</h1>
<p><code>gzip</code> 命令用于压缩文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">gzcat</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/gzcat/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/gzcat/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="gzcat"> gzcat</h1>
<p><code>gzcat</code> 命令用于查看一个 <code>gz</code> 文件，但并不实际解压它。</p>
<div><pre><code>gzcat filename
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">kill</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/kill/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/kill/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="kill"> kill</h1>
<p><code>kill</code> 命令用户终止指定进程。</p>
<div><pre><code><span>kill</span> PID
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">killall</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/killall/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/killall/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="killall"> killall</h1>
<p><code>killall</code> 命令终止给定名字的一系列相关进程。</p>
<div><pre><code><span>killall</span> processname
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">last</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/last/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/last/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="last"> last</h1>
<p><code>last</code> 命令显示用户登录系统的记录。</p>
<div><pre><code>last
</code></pre>
<div><span>1</span><br></div></div><p><code>last</code> 命令后面加上用户名，会显示该用户上次登录的信息。</p>
<div><pre><code>last yourUsername
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">lpq</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/lpq/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/lpq/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="lpq"> lpq</h1>
<p><code>lpq</code> 命令显示打印机队列。</p>
<div><pre><code>$ lpq
Rank    Owner   Job     File<span>(</span>s<span>)</span>                         Total Size
active  adnanad <span>59</span>      demo                            <span>399360</span> bytes
1st     adnanad <span>60</span>      <span>(</span>stdin<span>)</span>                         <span>0</span> bytes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">lpr</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/lpr/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/lpr/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="lpr"> lpr</h1>
<p><code>lpr</code> 命令用于打印文件。</p>
<div><pre><code><span>lpr</span> filename
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">ls</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/ls/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/ls/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ls"> ls</h1>
<p><code>ls</code> 命令用于列出当前目录里面的文件和子目录。</p>
<h2 id="参数"> 参数</h2>
<ul>
<li>a: 列出隐藏文件</li>
<li>l: 以长格式列出文件</li>
<li>t: 按最后编辑日期排序，最新的最先。这在某个大目录里找出最近修改的文件列表时很有用，比如将结果导入( pipe ) head 或者 sed 10q。或许加上 -l 会效果更好。当然如果您想获取最旧的文件列表，只要加 -r 反转列表即可。</li>
<li>X: 按文件类型分类。这在多语言或多后缀的项目中特别方便，比如头文件和源文件分开，或区分开源文件和生成文件或目录。</li>
<li>v: 按照文件名里的版本号排序。</li>
<li>S: 按文件大小排序。</li>
<li>R: 递归地列举文件。这个选项和 -l 组合使用并将结果导出到 less 效果很好。</li>
</ul>
<p>可以把结果导出给类似 vim 的进程。</p>
<div><pre><code><span>ls</span> -XR <span>|</span> <span>vim</span> -
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">nl</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/nl/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/nl/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nl"> nl</h1>
<p><code>nl</code> 命令用于显示行号。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>nl</code> 命令让上面这段文本显示行号。</p>
<div><pre><code>$ <span>nl</span> -s<span>". "</span> example.txt
     <span>1</span>. Lorem ipsum
     <span>2</span>. dolor sit amet,
     <span>3</span>. consetetur
     <span>4</span>. sadipscing elitr,
     <span>5</span>. <span>sed</span> diam nonumy
     <span>6</span>. eirmod tempor
     <span>7</span>. invidunt ut labore
     <span>8</span>. et dolore magna
     <span>9</span>. aliquyam erat, <span>sed</span>
    <span>10</span>. diam voluptua. At
    <span>11</span>. vero eos et
    <span>12</span>. accusam et justo
    <span>13</span>. duo dolores et ea
    <span>14</span>. rebum. Stet clita
    <span>15</span>. kasd gubergren,
    <span>16</span>. no sea takimata
    <span>17</span>. sanctus est Lorem
    <span>18</span>. ipsum dolor sit
    <span>19</span>. amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><code>-s</code> 参数表示行号的后缀。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">ps</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/ps/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/ps/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ps"> ps</h1>
<p><code>ps</code> 命令列出当前正在执行的进程信息。</p>
<p>由于进程很多，所以为了快速找到某个进程，一般与 <code>grep</code> 配合使用。</p>
<div><pre><code><span># 找出正在运行 vim 的进程</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数列出指定用户拥有的进程。</p>
<div><pre><code><span>ps</span> -u yourusername
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">scp</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/scp/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/scp/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="scp"> scp</h1>
<h2 id="基本用法"> 基本用法</h2>
<p><code>scp</code> 是 secure copy 的缩写，用来在两台主机之间加密传送文件。它的底层是 SSH 协议，默认端口是 22。</p>
<p>它主要用于以下三种复制操作。</p>
<ul>
<li>从本地系统到远程系统。</li>
<li>从远程系统到本地系统。</li>
<li>在本地系统的两个远程系统之间。</li>
</ul>
<p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p>
<p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p>
<p>注意，如果传输的文件在本机和远程系统，有相同的名称和位置，<code>scp</code> 会在没有警告的情况下覆盖文件。</p>
<h3 id="本地文件复制到远程系统"> 本地文件复制到远程系统</h3>
<p>复制本机文件到远程系统的基本语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> SourceFile user@host:directory/TargetFile

<span># 示例</span>
$ <span>scp</span> file.txt remote_username@10.10.0.2:/remote/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录。</p>
<div><pre><code><span># 将本机的 documents 目录拷贝到远程主机，</span>
<span># 会在远程主机创建 documents 目录</span>
$ <span>scp</span> -r documents username@server_ip:/path_to_remote_directory

<span># 将本机整个目录拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/

<span># 将本机目录下的所有内容拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="远程文件复制到本地"> 远程文件复制到本地</h3>
<p>从远程主机复制文件到本地的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host:directory/SourceFile TargetFile

<span># 示例</span>
$ <span>scp</span> remote_username@10.10.0.2:/remote/file.txt /local/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录的例子。</p>
<div><pre><code><span># 拷贝一个远程目录到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/

<span># 拷贝远程目录下的所有内容，到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/
$ <span>scp</span> -r user@host:directory/SourceFolder TargetFolder
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="两个远程系统之间的复制"> 两个远程系统之间的复制</h3>
<p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host1:directory/SourceFile user@host2:directory/SourceFile

<span># 示例</span>
$ <span>scp</span> user1@host1.com:/files/file.txt user2@host2.com:/files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>系统将提示您输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p>
<h2 id="参数"> 参数</h2>
<p><code>-P</code> 用来指定远程主机的 SSH 端口。如果远程主机使用非默认端口 22，可以在命令中指定。</p>
<div><pre><code><span>scp</span> -P <span>2222</span> user@host:directory/SourceFile TargetFile
</code></pre>
<div><span>1</span><br></div></div><p><code>-p</code> 参数用来保留修改时间(modification time)、访问时间(access time)、文件状态(mode)等原始文件的信息。</p>
<div><pre><code><span>scp</span> -C -p ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p>
<div><pre><code><span>scp</span> -l <span>80</span> yourusername@yourserver:/home/yourusername/* <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p>
<p><code>-c</code> 参数用来指定加密算法。</p>
<div><pre><code><span>scp</span> -c blowfish some_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p>上面代码指定加密算法为 <code>blowfish</code>。</p>
<p><code>-C</code> 表示是否在传输时压缩文件。</p>
<div><pre><code><span>scp</span> -c blowfish -C local_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p>
<div><pre><code><span>scp</span> -q Label.pdf mrarianto@202.x.x.x:.
</code></pre>
<div><span>1</span><br></div></div><p><code>-F</code> 参数用来指定 ssh_config 文件。</p>
<div><pre><code><span>scp</span> -F /home/pungki/proxy_ssh_config Label.pdf
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 参数用来显示详细的输出。</p>
<div><pre><code><span>scp</span> -v ~/test.txt root@192.168.1.3:/root/help2356.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-i</code> 参数用来指定密钥。</p>
<div><pre><code><span>scp</span> -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-r</code> 参数表示是否以递归方式复制目录。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">sed</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/sed/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/sed/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sed"> sed</h1>
<p><code>sed</code> 命令用于对文本进行过滤和变形处理。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello This is a Test <span>1</span> <span>2</span> <span>3</span> <span>4</span>
replace all spaces with hyphens
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>sed</code> 命令将所有的空格换成连词线 <code>-</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/ /-/g'</span> example.txt
Hello-This-is-a-Test-1-2-3-4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令将数字换成字母 <code>d</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/[0-9]/d/g'</span> example.txt
Hello This is a Test d d d d
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">sort</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/sort/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/sort/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="sort"> sort</h1>
<p><code>sort</code> 命令用于文本文件的排序。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>f
b
c
g
a
e
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行 <code>sort</code> 命令对其进行排序。</p>
<div><pre><code>$ <span>sort</span> example.txt
a
b
c
d
e
f
g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-R</code> 参数表示随机排序。</p>
<div><pre><code><span>sort</span> -R example.txt
b
d
a
c
g
e
f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">tr</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/tr/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/tr/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tr"> tr</h1>
<p><code>tr</code> 命令用于按照给定模式转换文本。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello World Foo Bar Baz<span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>tr</code> 命令可以将所有小写字母转换为大写字母。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>'a-z'</span> <span>'A-Z'</span>
HELLO WORLD FOO BAR BAZ<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>tr</code> 命令还可以将所有空格转为换行符。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>' '</span> <span>'\n'</span>
Hello
World
Foo
Bar
Baz<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">uname</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/uname/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/uname/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uname"> uname</h1>
<p><code>uname</code> 命令用来显示内核信息。</p>
<div><pre><code><span>uname</span> -a
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">uniq</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/uniq/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/uniq/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uniq"> uniq</h1>
<p><code>uniq</code> 用于过滤掉重复的行，该命令只对排序后的文件有效。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>a
a
b
a
b
c
d
c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>对该文件进行排序后，再过滤掉重复的行。</p>
<div><pre><code>$ <span>sort</span> example.txt <span>|</span> <span>uniq</span>
a
b
c
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-c</code> 参数会显示每行一共出现了多少次。</p>
<div><pre><code><span>sort</span> example.txt <span>|</span> <span>uniq</span> -c
    <span>3</span> a
    <span>2</span> b
    <span>2</span> c
    <span>1</span> d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">uptime</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/uptime/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/uptime/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="uptime"> uptime</h1>
<p><code>uptime</code> 命令显示本次开机运行的时间。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">w</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/w/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/w/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="w"> w</h1>
<p><code>w</code> 命令显示当期谁在线。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">wc</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/wc/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/wc/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="wc"> wc</h1>
<p><code>wc</code> 命令返回某个文件的行数、词数和字符数。</p>
<div><pre><code>$ <span>wc</span> demo.txt
<span>7459</span>   <span>15915</span>  <span>398400</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>7459</code> 是行数，<code>15915</code> 是词数，<code>398400</code> 是字符数。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">whereis</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/whereis/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/whereis/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="whereis"> whereis</h1>
<p><code>whereis</code> 用来显示某个命令的位置。如果有多个程序符合条件，会全部列出。</p>
<div><pre><code>$ <span>whereis</span> node
/usr/bin/node /usr/sbin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">which</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/which/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/which/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="which"> which</h1>
<p><code>which</code> 命令根据 <code>PATH</code> 环境变量指定的顺序，返回最早发现某个命令的位置。即不指定路径时，实际执行的命令的完整路径。</p>
<div><pre><code>$ <span>which</span> node
/usr/bin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">who</title>
    <id>https://list-jiang.github.io/linux/bash/archives/commands/who/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/commands/who/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="who"> who</h1>
<p><code>who</code> 命令显示已经登录的用户。</p>
<h2 id="参数"> 参数</h2>
<p><code>-b</code> 参数显示上一次系统启动的时间。</p>
<div><pre><code>$ <span>who</span> -b
system boot  <span>2017</span>-06-20 <span>17</span>:41
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">标准 I/O</title>
    <id>https://list-jiang.github.io/linux/bash/archives/deleted/stdio/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/deleted/stdio/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="标准-i-o"> 标准 I/O</h1>
<h2 id="echo"> echo</h2>
<p><code>echo</code> 命令用于将指定内容输出到显示屏(标准输出)。</p>
<div><pre><code>$ <span>echo</span> this is a <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-e</code> 解释转义字符。</li>
<li><code>-n</code> 不输出行尾的换行符</li>
</ul>
<div><pre><code>$ <span>echo</span> <span>"a<span title="\n">\n</span>b"</span>
a<span>\</span>nb

$ <span>echo</span> -e <span>"a<span title="\n">\n</span>b"</span>
a
b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，如果不加 <code>-e</code> 参数，<code>\n</code> 就会按字面形式输出；加了以后，就被解释成了换行符。</p>
<p>引号之中可以包括多个换行符，即可以输出多行文本。</p>
<div><pre><code><span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="read"> read</h2>
<p><code>read</code> 命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，读取文件中的一行数据。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的 variable 用来存储输入数值的一个或多个变量名。如果没有提供变量名，shell 变量 <code>REPLY</code> 会包含数据行。</p>
<p>基本上，read 会把来自标准输入的字段赋值给具体的变量。</p>
<div><pre><code><span>echo</span> -n <span>"Please enter an integer -> "</span>
<span>read</span> int
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>read</code> 可以给多个变量赋值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-multiple: read multiple values from keyboard</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span> var1 var2 var3 var4 var5
<span>echo</span> <span>"var1 = '<span>$var1</span>'"</span>
<span>echo</span> <span>"var2 = '<span>$var2</span>'"</span>
<span>echo</span> <span>"var3 = '<span>$var3</span>'"</span>
<span>echo</span> <span>"var4 = '<span>$var4</span>'"</span>
<span>echo</span> <span>"var5 = '<span>$var5</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的用法如下。</p>
<div><pre><code>$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e'</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>''</span>
var3 <span>=</span> <span>''</span>
var4 <span>=</span> <span>''</span>
var5 <span>=</span> <span>''</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e f g
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e f g'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果 read 命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入数据则会 被包含到最后一个变量中。</p>
<p>如果 read 命令之后没有列出变量名，则一个 shell 变量 <code>REPLY</code>，将会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的输出结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>read 命令的参数如下。</p>
<ul>
<li><code>-a array</code> 把输入赋值到数组 array 中，从索引号零开始。</li>
<li><code>-d delimiter</code> 用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。</li>
<li><code>-e</code> 使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。</li>
<li><code>-n num</code> 读取 num 个输入字符，而不是整行。</li>
<li><code>-p prompt</code> 为输入显示提示信息，使用字符串 prompt。</li>
<li><code>-r</code> Raw mode. 不把反斜杠字符解释为转义字符。</li>
<li><code>-s</code> Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。</li>
<li><code>-t seconds</code> 超时. 几秒钟后终止输入。read 会返回一个非零退出状态，若输入超时。</li>
<li><code>-u fd</code> 使用文件描述符 fd 中的输入，而不是标准输入。</li>
</ul>
<p><code>-p</code> 的例子。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 和 <code>-s</code> 的例子。</p>
<div><pre><code><span>if</span> <span>read</span> -t <span>10</span> -sp <span>"Enter secret pass phrase > "</span> secret_pass<span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>Secret pass phrase = '<span>$secret_pass</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面这个脚本提示用户输入一个密码，并等待输入 10 秒钟。如果在特定的时间内没有完成输入， 则脚本会退出并返回一个错误。因为包含了一个 -s 选项，所以输入的密码不会出现在屏幕上。</p>
<p>Shell 的内部变量 <code>IFS</code> 可以控制输入字段的分离。例如，这个 /etc/passwd 文件包含的数据行 使用冒号作为字段分隔符。通过把 IFS 的值更改为单个冒号，我们可以使用 read 读取 /etc/passwd 中的内容，并成功地把字段分给不同的变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>
<span>FILE</span><span>=</span>/etc/passwd
<span>read</span> -p <span>"Enter a user name > "</span> user_name
<span>file_info</span><span>=</span><span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>
<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
    <span>echo</span> <span>"User = '<span>$user</span>'"</span>
    <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
    <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
    <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
    <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
    <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
    <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Shell 允许在一个命令之前立即发生一个或多个变量赋值。这些赋值为跟随着的命令更改环境变量。这个赋值的影响是暂时的；只是在命令存在期间改变环境变量。</p>
<p>虽然通常 read 命令接受标准输入，但是您不能这样做:</p>
<div><pre><code><span>echo</span> “foo” <span>|</span> <span>read</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY 变量 总是为空。为什么会这样?</p>
<p>答案与 shell 处理管道线的方式有关系。在 bash(和其它 shells，例如 sh)中，管道线 会创建子 shell。它们是 shell 的副本，且用来执行命令的环境变量在管道线中。上面示例中，read 命令将在子 shell 中执行。</p>
<p>在类 Unix 的系统中，子 shell 执行的时候，会为进程创建父环境的副本。当进程结束 之后，环境副本就会被破坏掉。这意味着一个子 shell 永远不能改变父进程的环境。read 赋值变量， 然后会变为环境的一部分。在上面的例子中，read 在它的子 shell 环境中，把 foo 赋值给变量 REPLY， 但是当命令退出后，子 shell 和它的环境将被破坏掉，这样赋值的影响就会消失。</p>
<p>使用 here 字符串是解决此问题的一种方法。</p>
<p>下面是生成菜单的一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-menu: a menu driven system information program</span>
<span>clear</span>
<span>echo</span> <span>"
Please Select:

    1. Display System Information
    2. Display Disk Space
    3. Display Home Space Utilization
    0. Quit
"</span>
<span>read</span> -p <span>"Enter selection [0-3] > "</span>

<span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>=~</span> ^<span>[</span><span>0</span>-3<span>]</span>$ <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Program terminated."</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Hostname: <span>$HOSTNAME</span>"</span>
        <span>uptime</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>2</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>df</span> -h
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>3</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>if</span> <span>[</span><span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> -eq <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
            <span>echo</span> <span>"Home Space Utilization (All Users)"</span>
            <span>du</span> -sh /home/*
        <span>else</span>
            <span>echo</span> <span>"Home Space Utilization (<span>$USER</span>)"</span>
            <span>du</span> -sh <span>$HOME</span>
        <span>fi</span>
        <span>exit</span>
    <span>fi</span>
<span>else</span>
    <span>echo</span> <span>"Invalid entry."</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文件操作</title>
    <id>https://list-jiang.github.io/linux/bash/archives/file-operation/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/file-operation/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件操作"> 文件操作</h1>
<h2 id="cp"> cp</h2>
<p><code>cp</code> 命令用于将文件(或目录)拷贝到目的地。</p>
<div><pre><code><span># 拷贝单个文件</span>
$ <span>cp</span> <span>source</span> dest

<span># 拷贝多个文件</span>
$ <span>cp</span> source1 source2 source3 dest

<span># -i 目的地有同名文件时会提示确认</span>
$ <span>cp</span> -i file1 file2

<span># -r 递归拷贝，将dir1拷贝到dir2，完成后dir2生成一个子目录dir1</span>
<span># dir2如果不存在，将被创建</span>
<span># 拷贝目录时，该参数是必需的</span>
$ <span>cp</span> -r dir1 dir2

<span># -u --update 只拷贝目的地没有的文件，或者比目的地同名文件更新的文件</span>
$ <span>cp</span> -u *.html destination
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>其他参数</p>
<ul>
<li><code>-a</code> 拷贝时保留所有属性，包括所有者与权限</li>
<li><code>-v</code> 显示拷贝的详细信息</li>
</ul>
<h2 id="mkdir"> mkdir</h2>
<p><code>mkdir</code> 命令用于新建目录。</p>
<div><pre><code><span># 新建多个目录</span>
$ <span>mkdir</span> dir1 dir2 dir3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mv"> mv</h2>
<p><code>mv</code> 命令用于将源文件移动到目的地。</p>
<div><pre><code><span># 移动单个文件</span>
$ <span>mv</span> item1 item2

<span># 移动多个文件</span>
$ <span>mv</span> file1 file2 dir1

<span># 将dir1拷贝进入dir2，完成后dir2将多出一个子目录dir1</span>
<span># 如果dir2不存在，将会被创建</span>
$ <span>mv</span> dir1 dir2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>参数</p>
<ul>
<li><code>-i</code> 覆盖已经存在的文件时，会提示确认</li>
<li><code>-u</code> 只移动目的地不存在的文件，或比目的地更新的文件</li>
</ul>
<h2 id="rm"> rm</h2>
<p><code>rm</code> 命令用于删除文件。</p>
<p>参数。</p>
<ul>
<li><code>-i</code> 文件存在时，会提示确认。</li>
<li><code>-r</code> 递归删除一个子目录</li>
<li><code>-f</code> 如果删除不存在的文件，不报错</li>
<li><code>-v</code> 删除时展示详细信息</li>
</ul>
<h2 id="ln"> ln</h2>
<p><code>ln</code> 命令用于建立链接文件。</p>
<div><pre><code><span># 新建硬链接</span>
$ <span>ln</span> <span>file</span> <span>link</span>

<span># 新建软链接</span>
$ <span>ln</span> -s item <span>link</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文件系统</title>
    <id>https://list-jiang.github.io/linux/bash/archives/file/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/file/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件系统"> 文件系统</h1>
<h2 id="pwd"> pwd</h2>
<p><code>pwd</code> 命令显示列出当前所在的目录。</p>
<div><pre><code><span>pwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="cd"> cd</h2>
<p><code>cd</code> 命令用来改变用户所在的目录。</p>
<div><pre><code><span># 进入用户的主目录</span>
$ <span>cd</span>

<span># 进入前一个工作目录</span>
$ <span>cd</span> -

<span># 进入指定用户的主目录</span>
$ <span>cd</span> ~user_name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="ls"> ls</h2>
<p><code>ls</code> 目录可以显示指定目录的内容。不加参数时，显示当前目录的内容。</p>
<div><pre><code><span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令显示当前目录的内容。</p>
<p><code>ls</code> 命令也可以显示指定文件是否存在。</p>
<div><pre><code>$ <span>ls</span> foo.txt
foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-l</code> 参数可以显示文件的详细信息。</p>
<div><pre><code>$ <span>ls</span> -l foo.txt
-rw-rw-r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令输出结果的第一栏，是文件的类型和权限。</p>
<p>文件类型分为以下几种。</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录</li>
<li><code>l</code> 符号链接。注意，对于符号链接文件，剩余的文件属性总是&quot;rwxrwxrwx&quot;。</li>
<li><code>c</code> 字符设备文件，指按照字节流处理数据的设备，比如调制解调器。</li>
<li><code>b</code> 块设备文件，指按照数据块处理数据的设备，比如硬盘。</li>
</ul>
<p>其他参数的用法。</p>
<div><pre><code><span># 显示多个目录的内容</span>
$ <span>ls</span> ~ /usr

<span># -a --all 显示隐藏文件</span>
$ <span>ls</span> -a

<span># -A 与-a类似，但是不显示当前目录和上一级目录两个点文件</span>
$ <span>ls</span> -A

<span># -l 显示详细信息</span>
$ <span>ls</span> -l

<span># -1 单列显示，每行只显示一个文件</span>
$ <span>ls</span> -1

<span># -d 显示当前目录本身，而不是它的内容</span>
<span># 通常与-l配合使用，列出一个目录本身的详细信息</span>
$ <span>ls</span> -dl

<span># -F 目录名之后添加斜杠，可执行文件后面添加星号</span>
$ <span>ls</span> -F

<span># -h 与-l配合使用，将文件大小显示为人类可读的格式</span>

<span># -t 按文件修改时间排序，修改晚的排在前面</span>
$ <span>ls</span> -t

<span># -s 按文件大小排序，</span>

<span># --reverse 显示结果倒序排列</span>
$ <span>ls</span> -lt --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>如果只显示一个目录里面的子目录，不显示文件，可以使用下面这些命令。</p>
<div><pre><code><span># 只显示常规目录</span>
$ <span>ls</span> -d */
$ <span>ls</span> -F <span>|</span> <span>grep</span> /
$ <span>ls</span> -l <span>|</span> <span>grep</span> ^d
$ tree -dL <span>1</span>

<span># 只显示隐藏目录</span>
$ <span>ls</span> -d .*/

<span># 隐藏目录和非隐藏目录都显示</span>
$ <span>find</span> -maxdepth <span>1</span> -type d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另一个简便方法是利用自动补全功能，先键入 <code>cd</code> 命令，然后连按两下 <code>tab</code> 键。</p>
<h2 id="stat"> stat</h2>
<p><code>stat</code> 命令是加强版的 <code>ls</code> 命令，可以显示一个文件的详细信息。</p>
<div><pre><code>$ <span>stat</span> timestamp
File: <span>'timestamp'</span>
Size: <span>0</span> Blocks: <span>0</span> IO Block: <span>4096</span> regular empty <span>file</span>
Device: 803h/2051d Inode: <span>14265061</span> Links: <span>1</span>
Access: <span>(</span>0644/-rw-r--r--<span>)</span> Uid: <span>(</span> <span>1001</span>/ me<span>)</span> Gid: <span>(</span> <span>1001</span>/ me<span>)</span>
Access: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Modify: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Change: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="touch"> touch</h2>
<p><code>touch</code> 用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个 不存在的文件，则会创建一个空文件。</p>
<div><pre><code><span>touch</span> timestamp
</code></pre>
<div><span>1</span><br></div></div><p>上面命令创建了一个名为 <code>timestamp</code> 空文件。如果该文件已经存在，就会把它的修改时间设置为当前时间。</p>
<div><pre><code><span>mkdir</span> -p playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>
<span>touch</span> playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>/file-<span>{</span>A<span>..</span>Z<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的命令创建了一个包含一百个子目录，每个子目录中包含了 26 个空文件。</p>
<h2 id="file"> file</h2>
<p><code>file</code> 命令显示指定文件的类型。</p>
<div><pre><code>$ <span>file</span> picture.jpg
picture.jpg: JPEG image data, JFIF standard <span>1.01</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="chmod"> chmod</h2>
<p><code>chmod</code> 命令用于更改文件的权限，是“change mode”的缩写。</p>
<div><pre><code><span>chmod</span> <span>600</span> foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将 <code>foo.txt</code> 的权限改成了 600。</p>
<p><code>chmod</code> 还可以接受四个缩写，为不同的对象单独设置权限。</p>
<ul>
<li><code>u</code> 所有者“user”的简写</li>
<li><code>g</code> 用户组“group”的缩写</li>
<li><code>o</code> 其他所有人“others”的简写</li>
<li><code>a</code> 所有人“all”的简写</li>
</ul>
<div><pre><code><span># 为所有者添加可执行权限</span>
$ <span>chmod</span> u+x foo.txt

<span># 删除所有者的可执行权限</span>
$ <span>chmod</span> u-x foo.txt

<span># 为所有人添加可执行权限，等价于 a+x</span>
$ <span>chmod</span> +x foo.txt

<span># 删除其他人的读权限和写权限。</span>
$ <span>chmod</span> o-rw foo.txt

<span># 设定用户组和其他人的权限是读权限和写权限</span>
$ <span>chmod</span> <span>go</span><span>=</span>rw foo.txt

<span># 为所有者添加执行权限，设定用户组和其他人为读权限和写权限，多种设定用逗号分隔</span>
$ <span>chmod</span> u+x,go<span>=</span>rw foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>添加权限。</p>
<ul>
<li>+x 添加执行权限</li>
<li>+r 设置读权限</li>
<li>+w 设置写权限</li>
<li>+rwx 设置所有读、写和执行权限。</li>
</ul>
<p>删除权限只需将 <code>+</code> 更改为 <code>-</code>，就可以删除任何已设置的指定权限。可以使用 <code>-R</code>(或 <code>--recursive</code>)选项来递归地操作目录和文件。</p>
<p>设置精确权限，可以使用<code>=</code>代替 <code>+</code> 或 <code>-</code> 来实现此操作。如果想为用户、组或其他用户设置不同的权限，可以使用逗号将不同表达式分开(例如 <code>ug=rwx,o=rx</code>)。</p>
<p>由于一共有 3 种可能的权限。也可以使用八进制数代替符号来设置权限。通过这种方式设置的权限最多使用 3 个八进制数。第 1 个数定义用户权限，第 2 个数定义组权限，第 3 个数定义其他权限。这 3 个数中的每一个都通过添加想要的权限设置来构造: 读 (4)、写 (2) 和执行 (1)。</p>
<ul>
<li>rwx 7</li>
<li>rw- 6</li>
<li>r-x 5</li>
<li>r-- 4</li>
<li>-wx 3</li>
<li>-w- 2</li>
<li>--x 1</li>
<li>--- 0</li>
</ul>
<h2 id="umask"> umask</h2>
<p><code>umask</code> 用来查看和设置权限掩码。</p>
<div><pre><code>$ <span>umask</span>
0022
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令显示当前系统之中，默认的文件掩码是 <code>0022</code>，转为二进制就是 <code>000 000 010 010</code>。</p>
<p>可以看到，这个掩码是一个 12 位的二进制数，后面的 9 位分别代表文件三种使用对象的三类权限。只要对应位置上是 <code>1</code>，就表示关闭该项权限，所以 <code>010</code> 就表示关闭读权限。</p>
<p>新建文件时，通常不会带有执行权限，也就是说，新建文件的默认权限是 <code>rw-rw-rw-</code>。如果文件掩码是 <code>0022</code>，那么用户组和其他人的写权限也会被拿掉。</p>
<div><pre><code>$ <span>touch</span> new.txt
$ <span>ls</span> -l new.txt
-rw-r--r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 new.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>new.txt</code> 的用户组和其他人的写权限就没了。</p>
<p><code>umask</code> 后面跟着参数，就表示设置权限掩码。</p>
<div><pre><code><span>umask</span> 0000
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将权限掩码设为 <code>0000</code>，实际上就是关闭了权限掩码。</p>
<p><code>umask</code> 命令设置的掩码值只能在当前 Shell 会话中生效，若当前 Shell 会话结束后，则必须重新设置。</p>
<h2 id="du"> du</h2>
<p><code>du</code> 命令用于查看指定目录的大小。</p>
<div><pre><code><span>du</span> -hs /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><p>显示第一层子目录的大小。</p>
<div><pre><code><span>du</span> -h --max-depth<span>=</span><span>1</span> /path/to/folder
</code></pre>
<div><span>1</span><br></div></div><p>参数的含义。</p>
<ul>
<li><code>-h</code> 表示人类可读的格式</li>
<li><code>-s</code> 表示总结信息，否则会显示该目录内所有文件和子目录的信息。</li>
</ul>
<p><code>tree</code> 命令也可以显示子目录大小。</p>
<div><pre><code>tree --du -h /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><h2 id="md5sum"> md5sum</h2>
<p><code>md5sum</code> 命令用来显示一个文件的 md5 校验码。</p>
<div><pre><code>$ md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece    image.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="locate"> locate</h2>
<p><code>locate</code> 程序快速搜索本机的路径名数据库，并且输出每个与给定字符串相匹配的文件名。</p>
<div><pre><code>$ <span>locate</span> bin/zip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>locate</code> 数据库由另一个叫做 <code>updatedb</code> 的程序创建。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，您会发现 目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序， 更改为超级用户身份，在提示符下运行 updatedb 命令。</p>
<p><code>locate</code> 支持正则查找。<code>--regexp</code> 参数支持基本的正则表达式，<code>--regex</code> 参数支持扩展的正则表达式。</p>
<div><pre><code><span>locate</span> --regex <span>'bin/(bz|gz|zip)'</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="find"> find</h2>
<p><code>locate</code> 程序只能依据文件名来查找文件，而 <code>find</code> 程序能基于各种各样的属性，搜索一个给定目录(以及它的子目录)，来查找文件。</p>
<div><pre><code><span># 输出当前目录的所有子目录和文件(含子目录)</span>
$ <span>find</span>
$ <span>find</span> <span>.</span>

<span># 显示当前目录的文件总数</span>
$ <span>find</span> <span>.</span> <span>|</span> <span>wc</span> -l

<span># 当前目录的子目录总数</span>
$ <span>find</span> <span>.</span> -type d <span>|</span> <span>wc</span> -l

<span># 当前目录的文件总数(不含子目录)</span>
$ <span>find</span> <span>.</span> -type f <span>|</span> <span>wc</span> -l

<span># 当前目录的文件名匹配“*.JPG”且大于1M的文件总数</span>
$ <span>find</span> <span>.</span> -type f -name <span>"\*.JPG"</span> -size +1M <span>|</span> <span>wc</span> -l
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>-type</code> 参数支持的文件类型。</p>
<ul>
<li><code>b</code> 块设备文件</li>
<li><code>c</code> 字符设备文件</li>
<li><code>d</code> 目录</li>
<li><code>f</code> 普通文件</li>
<li><code>l</code> 符号链接</li>
</ul>
<p><code>-size</code> 参数支持的文件大小类型。</p>
<ul>
<li>b 512 个字节块。如果没有指定单位，则这是默认值。</li>
<li>c 字节</li>
<li>w 两个字节的字</li>
<li>k 千字节</li>
<li>M 兆字节</li>
<li>G 千兆字节</li>
</ul>
<p><code>find</code> 程序支持的查询参数。</p>
<ul>
<li>-cmin n 匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</li>
<li>-cnewer file 匹配的文件和目录的内容或属性最后修改时间早于那些文件。</li>
<li>-ctime n 匹配的文件和目录的内容和属性最后修改时间在 n*24 小时之前。</li>
<li>-empty 匹配空文件和目录。</li>
<li>-group name 匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。</li>
<li>-iname pattern 就像-name 测试条件，但是不区分大小写。</li>
<li>-inum n 匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。</li>
<li>-mmin n 匹配的文件或目录的内容被修改于 n 分钟之前。</li>
<li>-mtime n 匹配的文件或目录的内容被修改于 n*24 小时之前。</li>
<li>-name pattern 用指定的通配符模式匹配的文件和目录。</li>
<li>-newer file 匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。每次您制作一个备份，更新文件(比如说日志)，然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。</li>
<li>-nouser 匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。</li>
<li>-nogroup 匹配的文件和目录不属于一个有效的组。</li>
<li>-perm mode 匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。</li>
<li>-samefile name 相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</li>
<li>-size n 匹配的文件大小为 n。</li>
<li>-type c 匹配的文件类型是 c。</li>
<li>-user name 匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。</li>
<li>-depth 指导 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。</li>
<li>-maxdepth levels 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数</li>
<li>-mindepth levels 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。</li>
<li>-mount 指导 find 程序不要搜索挂载到其它文件系统上的目录。</li>
<li>-regex 指定正则表达式</li>
</ul>
<div><pre><code><span># 找出包括空格或其它不规范字符的文件名或路径名</span>
$ <span>find</span> <span>.</span> -regex <span>'.*[^-\_./0-9a-zA-Z].*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>find</code> 程序还支持逻辑操作符。</p>
<ul>
<li><code>-and</code> 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。注意若没有使用操作符，则默认使用 -and。</li>
<li><code>-or</code> 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</li>
<li><code>-not</code> 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号(!)。</li>
<li><code>()</code> 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。</li>
</ul>
<div><pre><code><span># 或关系</span>
<span>(</span> expression <span>1</span> <span>)</span> -or <span>(</span> expression <span>2</span> <span>)</span>

<span># 找出不是600权限的文件，或者不是700权限的目录</span>
$ <span>find</span> ~ <span>\</span><span>(</span> -type f -not -perm 0600 <span>\</span><span>)</span> -or <span>\</span><span>(</span> -type d -not -perm 0700 <span>\</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>find</code> 程序的逻辑表达式，具有“短路运算”的特点，即对于 <code>expr1 -operator expr2</code> 这个表达式，<code>expr2</code> 不一定执行。这是为了提高运行速度。</p>
<ul>
<li>expr1 为真，且操作符为 <code>-and</code>，expr2 总是执行</li>
<li>expr1 为假，且操作符为 <code>-and</code>，expr2 从不执行</li>
<li>expr1 为真，且操作符为 <code>-or</code>，expr2 从不执行</li>
<li>expr1 为假，且操作符为 <code>-or</code>，expr2 总是执行</li>
</ul>
<p>为了方便执行一些常见操作，<code>find</code> 程序定义了一些预定义操作。</p>
<ul>
<li>-delete 删除当前匹配的文件。</li>
<li>-ls 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。</li>
<li>-print 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</li>
<li>-quit 一旦找到一个匹配，退出。</li>
</ul>
<div><pre><code><span># 找到匹配的文件，并显示在标准输出</span>
<span># -print 是默认操作，可以省略</span>
$ <span>find</span> <span>.</span> -print

<span># 删除后缀名为BAK的文件</span>
<span># 执行 delete 操作前，最好先执行 print 操作，确认要删除哪些文件</span>
$ <span>find</span> <span>.</span> -type f -name <span>'*.BAK'</span> -delete
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>预定义操作可以与逻辑表达式，结合使用。</p>
<div><pre><code><span>find</span> ~ -type f -and -name <span>'*.BAK'</span> -and -print
</code></pre>
<div><span>1</span><br></div></div><p>除了预定义操作以外，用户还可以使用 <code>-exec</code> 参数自定义操作。</p>
<div><pre><code>-exec <span>command</span> <span>{</span><span>}</span> <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，<code>command</code> 是一个命令行命令，<code>{}</code> 用来指代当前路径，分号表示命令结束。</p>
<div><pre><code><span># 预定义的 -delete 操作，等同于下面的操作</span>
-exec <span>rm</span> <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-exec</code> 使用时，每次找到一个匹配的文件，会启动一个新的指定命令的实例。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令，<code>ls</code> 程序可能会被调用多次。</p>
<div><pre><code><span>ls</span> -l file1
<span>ls</span> -l file2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果想改成 <code>ls</code> 程序只调用一次，要把 <code>find</code> 命令里面的分号，改成加号。</p>
<div><pre><code>$ <span>ls</span> -l file1 file2
<span># 相当于</span>
$ <span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> +
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="xargs"> xargs</h2>
<p><code>xargs</code> 命令从标准输入接受输入，并把输入转换为一个特定命令的参数列表。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo\*'</span> -print <span>|</span> <span>xargs</span> <span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">硬件操作</title>
    <id>https://list-jiang.github.io/linux/bash/archives/hardware/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/hardware/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="硬件操作"> 硬件操作</h1>
<h2 id="df"> df</h2>
<p><code>df</code> 命令查看硬盘信息。</p>
<div><pre><code>$ <span>df</span>
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/sda2 <span>15115452</span> <span>5012392</span> <span>9949716</span> <span>34</span>% /
/dev/sda5 <span>59631908</span> <span>26545424</span> <span>30008432</span> <span>47</span>% /home
/dev/sda1 <span>147764</span> <span>17370</span> <span>122765</span> <span>13</span>% /boot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="free"> free</h2>
<p><code>free</code> 命令查看内存占用情况。</p>
<div><pre><code>$ <span>free</span>
 total used <span>free</span> shared buffers cached
Mem: <span>513712</span> <span>503976</span> <span>9736</span> <span>0</span> <span>5312</span> <span>122916</span>
-/+ buffers/cache: <span>375748</span> <span>137964</span>
Swap: <span>1052248</span> <span>104712</span> <span>947536</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="硬盘"> 硬盘</h2>
<p>文件<code>/etc/fstab</code> 配置系统启动时要挂载的设备。</p>
<div><pre><code>LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>输出结果一共有 6 个字段，含义依次如下。</p>
<ul>
<li>设备名: 与物理设备相关联的设备文件(或设备标签)的名字，比如说<code>/dev/hda1</code>(第一个 IDE 通道上第一个主设备分区)。</li>
<li>挂载点: 设备所连接到的文件系统树的目录。</li>
<li>文件系统类型: Linux 允许挂载许多文件系统类型。</li>
<li>选项: 文件系统可以通过各种各样的选项来挂载。</li>
<li>频率: 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。</li>
<li>次序: 一位数字，指定 fsck 命令按照什么次序来检查文件系统。</li>
</ul>
<h2 id="mount"> mount</h2>
<p><code>mount</code> 不带参数时，显示当前挂载的文件系统。</p>
<div><pre><code>$ <span>mount</span>
/dev/sda2 on / <span>type</span> ext3 <span>(</span>rw<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw<span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>rw<span>)</span>
devpts on /dev/pts <span>type</span> devpts <span>(</span>rw,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span><span>)</span>
/dev/sda5 on /home <span>type</span> ext3 <span>(</span>rw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个列表的格式是: 设备 on 挂载点 type 文件系统类型(可选的)。</p>
<p><code>mount</code> 带参数时，用于将设备文件挂载到挂载点，<code>-t</code> 参数用来指定文件系统类型。</p>
<div><pre><code>$ <span>mount</span> -t iso9660 /dev/hdc /mnt/cdrom

<span># 挂载一个iso文件</span>
$ <span>mount</span> -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="umount"> umount</h2>
<p><code>umount</code> 命令用来卸载设备。</p>
<div><pre><code><span>umount</span> <span>[</span>设备名<span>]</span>

<span>umount</span> /dev/hdc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="fdisk"> fdisk</h2>
<p><code>fdisk</code> 命令用于格式化磁盘。</p>
<div><pre><code><span>sudo</span> <span>umount</span> /dev/sdb1
<span>sudo</span> <span>fdisk</span> /dev/sdb
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mkfs"> mkfs</h2>
<p><code>mkfs</code> 命令用于在一个设备上新建文件系统。</p>
<div><pre><code><span>sudo</span> <span>mkfs</span> -t ext3 /dev/sdb1
<span>sudo</span> <span>mkfs</span> -t vfat /dev/sdb1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="fsck"> fsck</h2>
<p><code>fsck</code> 命令用于检查(修复)文件系统。</p>
<div><pre><code><span>sudo</span> <span>fsck</span> /dev/sdb1
</code></pre>
<div><span>1</span><br></div></div><h2 id="dd"> dd</h2>
<p><code>dd</code> 命令用于将大型数据块，从一个磁盘复制到另一个磁盘。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>input_file <span>of</span><span>=</span>output_file <span>[</span>bs<span>=</span>block_size <span>[</span>count<span>=</span>blocks<span>]</span><span>]</span>

<span># 将 /dev/sdb 的所有数据复制到 /dev/sdc</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>/dev/sdc

<span># 将 /dev/sdb 的所有数据拷贝到一个镜像文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>flash_drive.img

<span># 从cdrom制作一个iso文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/cdrom <span>of</span><span>=</span>ubuntu.iso
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="dmidecode"> dmidecode</h2>
<p><code>dmidecode</code> 命令用于输出 BIOS 信息。</p>
<div><pre><code><span>sudo</span> dmidecode
</code></pre>
<div><span>1</span><br></div></div><p>以上命令会输出全部 BIOS 信息。为了便于查看，往往需要指定所需信息的类别。</p>
<ul>
<li>0 BIOS</li>
<li>1 System</li>
<li>2 Base Board</li>
<li>3 Chassis 4 Processor</li>
<li>5 Memory Controller</li>
<li>6 Memory Module</li>
<li>7 Cache</li>
<li>8 Port Connector</li>
<li>9 System Slots</li>
<li>10 On Board Devices</li>
<li>11 OEM Strings</li>
<li>12 System Configuration Options</li>
<li>13 BIOS Language</li>
<li>14 Group Associations</li>
<li>15 System Event Log</li>
<li>16 Physical Memory Array</li>
<li>17 Memory Device</li>
<li>18 32-bit Memory Error</li>
<li>19 Memory Array Mapped Address</li>
<li>20 Memory Device Mapped Address</li>
<li>21 Built-in Pointing Device</li>
<li>22 Portable Battery</li>
<li>23 System Reset</li>
<li>24 Hardware Security</li>
<li>25 System Power Controls</li>
<li>26 Voltage Probe</li>
<li>27 Cooling Device</li>
<li>28 Temperature Probe</li>
<li>29 Electrical Current Probe</li>
<li>30 Out-of-band Remote Access</li>
<li>31 Boot Integrity Services</li>
<li>32 System Boot</li>
<li>33 64-bit Memory Error</li>
<li>34 Management Device</li>
<li>35 Management Device Component</li>
<li>36 Management Device Threshold Data</li>
<li>37 Memory Channel</li>
<li>38 IPMI Device</li>
<li>39 Power Supply</li>
</ul>
<p>查看内存信息的命令如下。</p>
<div><pre><code>$ <span>sudo</span> dmidecode -t <span>17</span>
<span># 或者</span>
$ dmidecode --type <span>17</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以下是其他一些选项。</p>
<div><pre><code><span># 查看BIOS信息</span>
$ <span>sudo</span> dmidecode –t <span>0</span>

<span># 查看CPU信息</span>
$ <span>sudo</span> dmidecode -t <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>dmidecode</code> 也支持关键词查看，关键词与类别的对应关系如下。</p>
<ul>
<li>bios 0, 13</li>
<li>system 1, 12, 15, 23, 32</li>
<li>baseboard 2, 10</li>
<li>chassis 3</li>
<li>processor 4</li>
<li>memory 5, 6, 16, 17</li>
<li>cache 7</li>
<li>connector 8</li>
<li>slot 9</li>
</ul>
<p>查看系统信息的命令如下。</p>
<div><pre><code><span>sudo</span> dmidecode -t system
</code></pre>
<div><span>1</span><br></div></div><h2 id="lspci"> lspci</h2>
<p><code>lspci</code> 命令列出本机的所有 PCI 设备。</p>
<div><pre><code>lspci
</code></pre>
<div><span>1</span><br></div></div><p>该命令输出信息的格式如下。</p>
<div><pre><code>03:00.0 Unassigned class <span>[</span>ff00<span>]</span>: Realtek Semiconductor Co., Ltd. RTS5209 PCI Express Card Reader <span>(</span>rev 01<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>输出信息一共分成三个字段。</p>
<ul>
<li>Field 1: PCI bus slot 的编号</li>
<li>Field 2: PCI slot 的名字</li>
<li>Field 3: 设备名和厂商名</li>
</ul>
<p>如果想查看更详细信息，可以使用下面的命令。</p>
<div><pre><code>lspci -vmm
</code></pre>
<div><span>1</span><br></div></div><h2 id="lsusb"> lsusb</h2>
<p><code>lsusb</code> 命令用于操作 USB 端口。</p>
<p>下面命令列出本机所有 USB 端口。</p>
<div><pre><code>lsusb
</code></pre>
<div><span>1</span><br></div></div><p>它的输出格式如下。</p>
<div><pre><code>Bus 002 Device 003: ID 0781:5567 SanDisk Corp. Cruzer Blade
</code></pre>
<div><span>1</span><br></div></div><p>各个字段的含义如下。</p>
<ul>
<li>Bus 002 : bus 编号</li>
<li>Device 003: bus 002 连接的第三个设备</li>
<li>ID 0781:5567: 当前设备的编号，冒号前是厂商编号，冒号后是设备编号</li>
<li>SanDisk Corp. Cruzer Blade: 厂商和设备名</li>
</ul>
<p>找出本机有多少个 USB 接口可用。</p>
<div><pre><code>$ <span>find</span> /dev/bus/
/dev/bus/
/dev/bus/usb
/dev/bus/usb/002
/dev/bus/usb/002/006
/dev/bus/usb/002/005
/dev/bus/usb/002/004
/dev/bus/usb/002/002
/dev/bus/usb/002/001
/dev/bus/usb/001
/dev/bus/usb/001/007
/dev/bus/usb/001/003
/dev/bus/usb/001/002
/dev/bus/usb/001/001
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>查看某个 USB 设备的详细情况。</p>
<div><pre><code>lsusb -D /dev/bus/usb/002/005
</code></pre>
<div><span>1</span><br></div></div><p>查看所有设备的详细情况。</p>
<div><pre><code>lsusb -v
</code></pre>
<div><span>1</span><br></div></div><p>查看 USB 端口的版本。</p>
<div><pre><code>lsusb -v <span>|</span> <span>grep</span> -i bcdusb
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">主机管理</title>
    <id>https://list-jiang.github.io/linux/bash/archives/host/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/host/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="主机管理"> 主机管理</h1>
<h2 id="hostname-命令"> hostname 命令</h2>
<p><code>hostname</code> 命令返回当前服务器的主机名。</p>
<div><pre><code><span>hostname</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">命名管道</title>
    <id>https://list-jiang.github.io/linux/bash/archives/named-pipe/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/named-pipe/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="命名管道"> 命名管道</h1>
<p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。</p>
<p>命令管道的行为类似于文件，但实际上形成了先入先出(FIFO)的缓冲。和普通(未命令的)管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西:</p>
<div><pre><code>process1 <span>></span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>process2 <span>&lt;</span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>表现出来就像这样:</p>
<div><pre><code>process1 <span>|</span> process2
</code></pre>
<div><span>1</span><br></div></div><h2 id="设置一个命名管道"> 设置一个命名管道</h2>
<p>使用 mkfifo 命令能够创建命令管道:</p>
<div><pre><code>$ <span>mkfifo</span> pipe1
$ <span>ls</span> -l pipe1
prw-r--r-- <span>1</span> me me <span>0</span> <span>2009</span>-07-17 06:41 pipe1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p>
<h2 id="使用命名管道"> 使用命名管道</h2>
<p>为了演示命名管道是如何工作的，我们将需要两个终端窗口(或用两个虚拟控制台代替)。在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道:</p>
<div><pre><code><span>ls</span> -l <span>></span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。使用第二个终端窗口，我们输入这个命令。</p>
<div><pre><code><span>cat</span> <span>&lt;</span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">进程管理</title>
    <id>https://list-jiang.github.io/linux/bash/archives/process/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/process/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="进程管理"> 进程管理</h1>
<h2 id="ps"> ps</h2>
<p><code>ps</code> 命令用来列出进程信息。</p>
<div><pre><code>$ <span>ps</span>
PID TTY           TIME CMD
<span>5198</span> pts/1    00:00:00 <span>bash</span>
<span>10129</span> pts/1   00:00:00 <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不带任何参数时，<code>ps</code> 只列出与当前 Session 相关的进程。输出结果中，<code>PID</code> 是进程 ID、<code>TTY</code> 是进程的终端号(如果显示<code>?</code>，则表示进程没有终端)，<code>TIME</code> 是消耗的 CPU 时间，<code>CMD</code> 是触发进程的命令。</p>
<p><code>x</code> 参数列出所有进程的详细信息，包括不在当前 Session 的信息。</p>
<div><pre><code>$ <span>ps</span> x
PID TTY   STAT   TIME COMMAND
<span>2799</span> ?    Ssl    <span>0</span>:00 /usr/libexec/bonobo-activation-server –ac
<span>2820</span> ?    Sl     <span>0</span>:01 /usr/libexec/evolution-data-server-1.10 --
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这时的输出结果，会多出 <code>STAT</code> 一栏，表示状态。它的各种值如下。</p>
<ul>
<li><code>R</code> 正在运行或准备运行</li>
<li><code>S</code> 正在睡眠，即没有运行，正在等待一个事件唤醒</li>
<li><code>D</code> 不可中断睡眠。进程正在等待 I/O，比如磁盘驱动器的 I/O</li>
<li><code>T</code> 已停止，即进程停止运行</li>
<li><code>Z</code> “僵尸”进程。即这是一个已经终止的子进程，但父进程还没有清空它(没有把子进程从进程表中删除)</li>
<li><code>&lt;</code> 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。</li>
<li><code>N</code> 低优先级进程。一个低优先级进程(一个“好”进程)只有当其它高优先级进程执行之后，才会得到处理器时间。</li>
</ul>
<p><code>aux</code> 参数可以显示更多信息。</p>
<div><pre><code>$ <span>ps</span> aux
<span>USER</span>   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     <span>1</span>   <span>0.0</span>   <span>0.0</span>    <span>2136</span>    <span>644</span>  ?     Ss     Mar05   <span>0</span>:31  init
root     <span>2</span>   <span>0.0</span>   <span>0.0</span>       <span>0</span>      <span>0</span>  ?     S<span>&amp;</span>lt<span>;</span>     Mar05   <span>0</span>:00  <span>[</span>kt<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出结果包含的列的含义如下。</p>
<ul>
<li><code>USER</code> 用户 ID，表示进程的所有者</li>
<li><code>%CPU</code> 百分比表示的 CPU 使用率</li>
<li><code>%MEM</code> 百分比表示的内存使用率</li>
<li><code>VSZ</code> 虚拟内存大小</li>
<li><code>RSS</code> 进程占用的物理内存的大小，以千字节为单位。</li>
<li><code>START</code> 进程运行的起始时间。若超过 24 小时，则用天表示。</li>
</ul>
<h2 id="top"> top</h2>
<p><code>top</code> 命令可以查看机器的当前状态。</p>
<div><pre><code><span>top</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的输出结果分为两部分，最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p>
<p>输出结果是动态更新的，默认每三分钟更新一次。</p>
<h2 id="jobs"> jobs</h2>
<p><code>jobs</code> 命令用来查看后台任务。</p>
<div><pre><code>$ <span>jobs</span>
<span>[</span><span>1</span><span>]</span>+ Running            xlogo <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出结果之中，每个后台任务会有一个编号。上面结果中，<code>xlogo</code> 的编号是 <code>1</code>，<code>+</code> 表示正在运行。</p>
<h2 id="fg"> fg</h2>
<p><code>fg</code> 命令用于将后台任务切换到前台。</p>
<div><pre><code><span>fg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>fg</code> 命令之后，跟随着一个百分号和工作序号，用来指定切换哪一个后台任务。如果只有一个后台任务，那么 <code>fg</code> 命令可以不带参数。</p>
<h2 id="bg"> bg</h2>
<p><code>bg</code> 命令用于将一个暂停的前台任务，转移到后台。只有暂停的任务，才能使用 <code>bg</code> 命令，因为正在运行的任务，命令行是无法输入的。</p>
<div><pre><code><span>bg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>Ctrl + z</code> 可以暂停正在运行的前台任务。</p>
<h2 id="kill"> kill</h2>
<p><code>kill</code> 命令用于杀死进程。它的参数是进程 ID。</p>
<div><pre><code><span>kill</span> <span>28401</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>kill</code> 命令的实质是操作系统向进程发送信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT(中断)的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP(终端停止)的信号。</p>
<p><code>kill</code> 命令可以用来向进程发送指定信号。</p>
<div><pre><code><span>kill</span> <span>[</span>-signal<span>]</span> PID
</code></pre>
<div><span>1</span><br></div></div><p>下面是常见信号。</p>
<ul>
<li>HUP: 编号 1，表示挂起。发送这个信号到前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</li>
<li>INT: 编号 2，中断。实现和 <code>Ctrl-c</code> 一样的功能，由终端发送。通常，它会终止一个程序。</li>
<li>KILL: 编号 9，杀死。进程可能选择忽略这个信号。所以，操作系统不发送该信号到目标进程，而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</li>
<li>TERM: 编号 15，终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。</li>
<li>CONT: 编号 18，继续。在停止一段时间后，进程恢复运行。</li>
<li>STOP: 编号 19，停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</li>
<li>QUIT: 编号 3，退出</li>
<li>SEGV: 编号 11，段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。</li>
<li>TSTP: 编号 20，终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</li>
<li>WINCH: 编号 28，改变窗口大小。当改变窗口大小时，系统会发送这个信号。一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</li>
</ul>
<p><code>-l</code> 参数可以列出所有信号。</p>
<div><pre><code><span>kill</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="killall"> killall</h2>
<p><code>killall</code> 命令用于向指定的程序或用户发送信号。</p>
<div><pre><code><span>killall</span> <span>[</span>-u user<span>]</span> <span>[</span>-signal<span>]</span> name
</code></pre>
<div><span>1</span><br></div></div><h2 id="其他进程相关命令"> 其他进程相关命令</h2>
<ul>
<li><code>pstree</code> 输出树型结构的进程列表，这个列表展示了进程间父/子关系。</li>
<li><code>vmstat</code> 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。为了看到连续的显示结果，则在命令名后加上延时的时间(以秒为单位)。例如，“vmstat 5”。终止输出，按下 Ctrl-c 组合键。</li>
<li><code>xload</code> 一个图形界面程序，可以画出系统负载的图形。</li>
<li><code>tload</code> 与 <code>xload</code> 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">重定向</title>
    <id>https://list-jiang.github.io/linux/bash/archives/redirection/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/redirection/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="重定向"> 重定向</h1>
<p>重定向指的是将命令行输出写入指定位置。</p>
<ul>
<li><code>cmd1 | cmd2</code>: Pipe; take standard output of cmd1 as standard input to cmd2.</li>
<li><code>&gt; file</code>: Direct standard output to file.</li>
<li><code>&lt; file</code>: Take standard input from file.</li>
<li><code>&gt;&gt; file</code>: Direct standard output to file; append to file if it already exists.</li>
<li><code>&gt;| file</code>: Force standard output to file even if noclobber is set.</li>
<li><code>n&gt;| file</code>: Force output to file from file descriptor n even if noclobber is set.</li>
<li><code>&lt;&gt; file</code>: Use file as both standard input and standard output.</li>
<li><code>n&lt;&gt; file</code>: Use file as both input and output for file descriptor n.</li>
<li><code>&lt;&lt; label</code>: Here-document; see text.</li>
<li><code>n &gt; file</code>: Direct file descriptor n to file.</li>
<li><code>n &lt; file</code>: Take file descriptor n from file.</li>
<li><code>n &gt;&gt; file</code>: Direct file descriptor n to file; append to file if it already exists.</li>
<li><code>n&gt;&amp;</code>: Duplicate standard output to file descriptor n.</li>
<li><code>n&lt;&amp;</code>: Duplicate standard input from file descriptor n.</li>
<li><code>n&gt;&amp;m</code>: File descriptor  n is made to be a copy of the output file descriptor.</li>
<li><code>n&lt;&amp;m</code>: File descriptor  n is made to be a copy of the input file descriptor.</li>
<li><code>&amp;&gt;file</code>: Directs standard output and standard error to file.</li>
<li><code>&lt;&amp;-</code>: Close the standard input.</li>
<li><code>&gt;&amp;-</code>: Close the standard output.</li>
<li><code>n&gt;&amp;-</code>: Close the output from file descriptor  n.</li>
<li><code>n&lt;&amp;-</code>: Close the input from file descriptor  n.</li>
<li><code>n&gt;&amp;word</code>: If  n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. As a special case, if n is omitted, and word does not expand to one or more digits, the standard output and standard error are redirected as described previously.</li>
<li><code>n&lt;&amp;word</code>: If word expands to one or more digits, the file descriptor denoted by  n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.</li>
<li><code>n&gt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard output (file descriptor 1) if n is not specified.</li>
<li><code>n&lt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.</li>
</ul>
<p><code>&gt;</code> 用来将标准输出重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果重定向后的指定文件已经存在，就会被覆盖，不会有任何提示。</p>
<p>如果命令没有任何输出，那么重定向之后，得到的是一个长度为 <code>0</code> 的文件。因此，<code>&gt;</code> 具有创建新文件或改写现存文件、将其改为长度 <code>0</code> 的作用。</p>
<div><pre><code><span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>&gt;&gt;</code> 用来将标准输出重定向追加到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>2&gt;</code> 用来将标准错误重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> ls-error.txt
</code></pre>
<div><span>1</span><br></div></div><p>标准输出和标准错误，可以重定向到同一个文件。</p>
<div><pre><code>$ <span>ls</span> -l /bin/usr <span>></span> ls-output.txt <span><span>2</span>></span><span>&amp;1</span>
<span># 或者</span>
$ <span>ls</span> -l /bin/usr <span>&amp;></span> ls-output.txt

<span># 追加到同一个文件</span>
$ <span>ls</span> -l /bin/usr <span>&amp;>></span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果不希望输出错误信息，可以将它重定向到一个特殊文件<code>/dev/null</code>。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> /dev/null
</code></pre>
<div><span>1</span><br></div></div><p><code>|</code> 用于将一个命令的标准输出，重定向到另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>不要将<code>&gt;</code> 与 <code>|</code> 混淆。</p>
<div><pre><code><span>ls</span> <span>></span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会在当前目录，生成一个名为 <code>less</code> 的文本文件。</p>
<p>下面是标准错误重定向的一个例子。</p>
<div><pre><code><span>invalid_input</span> <span>(</span><span>)</span> <span>{</span>
    <span>echo</span> <span>"Invalid input '<span>$REPLY</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>}</span>
<span>read</span> -p <span>"Enter a single item > "</span>
<span>[</span><span>[</span> -z <span>$REPLY</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> invalid_input
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="tee"> tee</h2>
<p><code>tee</code> 命令用于同时将标准输出重定向到文件，以及另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>tee</span> ls.txt <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="命令替换"> 命令替换</h2>
<p>命令替换(command substitution)指的是将一个命令的输出，替换进入另一个命令。<code>$(command)</code> 表示命令替换，另一种写法是使用反引号。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>ls</span><span>)</span></span>
<span># 或者</span>
$ <span>echo</span> <span><span>`</span><span>ls</span><span>`</span></span>

$ <span>ls</span> -l <span><span>$(</span><span>which</span> <span>cp</span><span>)</span></span>
<span># 或者</span>
$ <span>ls</span> -l <span><span>`</span><span>which</span> <span>cp</span><span>`</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="basename"> basename</h2>
<p><code>basename</code> 命令清除 一个路径名的开头部分，只留下一个文件的基本名称。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># file_info: simple file information program</span>
<span>PROGNAME</span><span>=</span><span><span>$(</span><span>basename</span> $0<span>)</span></span>
<span>if</span> <span>[</span><span>[</span> -e <span>$1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Type:"</span>
    <span>file</span> <span>$1</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Status:"</span>
    <span>stat</span> <span>$1</span>
<span>else</span>
    <span>echo</span> <span>"<span>$PROGNAME</span>: usage: <span>$PROGNAME</span> file"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">正则表达式</title>
    <id>https://list-jiang.github.io/linux/bash/archives/regex/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/regex/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="正则表达式"> 正则表达式</h1>
<p><code>正则表达式</code>是表达文本模式的方法。</p>
<ul>
<li><code>.</code>: 匹配任何单个字符。</li>
<li><code>?</code>: 上一项是可选的，最多匹配一次。</li>
<li><code>*</code>: 前一项将被匹配零次或多次。</li>
<li><code>+</code>: 前一项将被匹配一次或多次。</li>
<li><code>{N}</code>: 上一项完全匹配 N 次。</li>
<li><code>{N，}</code>: 前一项匹配 N 次或多次。</li>
<li><code>{N，M}</code>: 前一项至少匹配 N 次，但不超过 M 次。</li>
<li><code>--</code>: 表示范围，如果它不是列表中的第一个或最后一个，也不是列表中某个范围的终点。</li>
<li><code>^</code>: 匹配行首的空字符串；也代表不在列表范围内的字符。</li>
<li><code>$</code>: 匹配行尾的空字符串。</li>
<li><code>\b</code>: 匹配单词边缘的空字符串。</li>
<li><code>\B</code>: 匹配空字符串，前提是它不在单词的边缘。</li>
<li><code>\&lt;</code>: 匹配单词开头的空字符串。</li>
<li><code>\&gt;</code>: 匹配单词末尾的空字符串。</li>
</ul>
<h2 id="元字符"> 元字符</h2>
<p><code>元字符</code>是表示特殊函数的字符，包括以下这些 <code>^ $ . [ ] { } - ? * + ( ) | \\</code>。除了元字符，其他字符在正则表达式中，都表示原来的含义。</p>
<ul>
<li><code>.</code> 匹配任意字符，但不含空字符</li>
<li><code>^</code> 匹配文本行开头</li>
<li><code>$</code> 匹配文本行结尾</li>
</ul>
<div><pre><code><span>grep</span> -h <span>'.zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在文件中查找包含正则表达式“.zip”的文本行。注意，上面命令不会匹配 <code>zip</code> 程序，因为 <code>zip</code> 只有三个字符，而 <code>.zip</code> 要求四个字符。</p>
<div><pre><code><span>grep</span> -h <span>'^zip'</span> dirlist*.txt
<span>grep</span> -h <span>'zip$'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“zip”(例如，zip 独占一行)的匹配行。注意正则表达式‘^$’(行首和行尾之间没有字符)会匹配空行。</p>
<h2 id="方括号"> 方括号</h2>
<p>方括号之中的字符，表示可以任意匹配其中的一个。</p>
<div><pre><code><span>grep</span> -h <span>'[bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含字符串“bzip”或者“gzip”的任意行。</p>
<p>注意，元字符放入方括号之中，会失去其特殊含义。但有两种情况除外，<code>^</code> 在方括号的开头，表示否定，否则只是一个普通字符，表示原义。</p>
<div><pre><code><span>grep</span> -h <span>'[^bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配不以 <code>b</code> 或 <code>g</code> 开头的 <code>zip</code> 字符串。注意，上面命令不会匹配 <code>zip</code>，因为一个否定的字符集仍然要求存在一个字符。</p>
<p><code>-</code> 在方括号之中表示一个字符区域。</p>
<div><pre><code><span>grep</span> -h <span>'^[A-Z]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配所有以大写字母开头的文本行。类似的，<code>^[A-Za-z0-9]</code> 表示以大写字母、小写字母、数字开头的文本行。</p>
<p>注意，连字号如果不构成一个字符区域，则表示其本来的含义。</p>
<div><pre><code><span>grep</span> -h <span>'[-AZ]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。</p>
<h2 id="预定义字符类"> 预定义字符类</h2>
<p>由于 <code>locale</code> 设置不同，Shell 展开正则表达式 <code>[A-Z]</code> 时，可能不是解释为所有大写字母，而是解释为包括所有字母的字典顺序。</p>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span>A-Z<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在某些发行版里面，会返回所有大写字母或小写字母开头的文件。</p>
<p>为了避免这个问题，可以使用正则表达式的预定义字符类。</p>
<ul>
<li><code>[:alnum:]</code> 字母数字字符。在 ASCII 中，等价于: <code>[A-Za-z0-9]</code></li>
<li><code>[:word:]</code> 与 <code>[:alnum:]</code> 相同, 但增加了下划线字符。</li>
<li><code>[:alpha:]</code> 字母字符。在 ASCII 中，等价于 <code>[A-Za-z]</code></li>
<li><code>[:blank:]</code> 包含空格和 tab 字符。</li>
<li><code>[:cntrl:]</code> ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。</li>
<li><code>[:digit:]</code> 数字 0 到 9</li>
<li><code>[:graph:]</code> 可视字符。在 ASCII 中，它包含 33 到 126 的字符。</li>
<li><code>[:lower:]</code> 小写字母。</li>
<li><code>[:punct:]</code> 标点符号字符。</li>
<li><code>[:print:]</code> 可打印的字符。等于 <code>[:graph:]</code> 中的所有字符，再加上空格字符。</li>
<li><code>[:space:]</code> 空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed.在 ASCII 中， 等价于 <code>[ \t\r\n\v\f]</code></li>
<li><code>[:upper:]</code> 大写字母。</li>
<li><code>[:xdigit:]</code> 用来表示十六进制数字的字符。在 ASCII 中，等价于 <code>[0-9A-Fa-f]</code></li>
</ul>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回所有大写字母开头的文件名。</p>
<h2 id="选择"> 选择</h2>
<p><code>|</code> 表示匹配一系列字符串之中的一个。注意与方括号区分，方括号表示匹配一系列字符之中的一个。</p>
<div><pre><code>$ <span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
AAA
$ <span>echo</span> <span>"BBB"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
BBB
$ <span>echo</span> <span>"CCC"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>AAA|BBB</code> 表示匹配字符串 <code>AAA</code> 或者是字符串 <code>BBB</code>。<code>grep</code> 程序使用 <code>-E</code> 参数，表示按照正则表达式规则匹配。并且，这个正则表达式放在单引号之中，为的是阻止 Shell 把 <code>|</code> 解释为管道操作符。</p>
<p><code>|</code> 可以多个连用，也可以与其他正则规则结合使用。</p>
<div><pre><code><span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB|CCC'</span>

<span>grep</span> -Eh <span>'^(bz|gz|zip)'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="量词操作符"> 量词操作符</h2>
<p>量词操作符表示一个元素被匹配的次数。</p>
<ul>
<li><code>?</code> 匹配前面的元素出现 0 次或 1 次</li>
<li><code>*</code> 匹配前面的元素出现 0 次或多次</li>
<li><code>+</code> 匹配前面的元素出现 1 次或多次</li>
<li><code>{n}</code> 匹配前面的元素出现了 <code>n</code> 次</li>
<li><code>{n,m}</code> 匹配前面的元素它至少出现了 <code>n</code> 次，但是不多于 <code>m</code> 次</li>
<li><code>{n,}</code> 匹配前面的元素至少出现了 <code>n</code> 次</li>
<li><code>{,m}</code> 匹配前面的元素，如果它出现的次数不多于 m 次。</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">系统信息</title>
    <id>https://list-jiang.github.io/linux/bash/archives/system/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/system/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="系统信息"> 系统信息</h1>
<h2 id="uname"> uname</h2>
<p><code>uname</code> 命令返回当前机器的信息。</p>
<div><pre><code><span># 内核的版本</span>
$ <span>uname</span> -r
<span>3.2</span>.0-24-virtual

<span># CPU 架构</span>
$ <span>uname</span> -m
x86_64
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果要了解操作系统的版本，可以查看<code>/etc/issue</code> 文件。</p>
<div><pre><code>$ <span>cat</span> /etc/issue
Debian GNU/Linux <span>9</span> <span>\</span>n <span>\</span>l
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="service"> service</h2>
<p><code>service</code> 命令可以查看当前正在运行的服务。</p>
<div><pre><code>$ <span>service</span> --status-all
 <span>[</span> + <span>]</span>  apache2
 <span>[</span> ? <span>]</span>  atd
 <span>[</span> - <span>]</span>  bootlogd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>+</code> 表示正在运行，<code>-</code> 表示已经停止，<code>?</code>表示 <code>service</code> 命令不了解相关信息。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文本处理</title>
    <id>https://list-jiang.github.io/linux/bash/archives/text/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/text/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文本处理"> 文本处理</h1>
<h2 id="cat"> cat</h2>
<p><code>cat</code> 可以文件的内容，显示在标准输出。</p>
<div><pre><code>$ <span>cat</span> text1
<span>1</span> apple
<span>2</span> pear
<span>3</span> banana
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>它也可以同时输出多个文件内容。</p>
<div><pre><code><span>cat</span> text1 text2
</code></pre>
<div><span>1</span><br></div></div><p>它与重定向结合，就可以合并多个文件。</p>
<div><pre><code><span># 合并文本文件</span>
$ <span>cat</span> text* <span>></span> text.all

<span># 合并二进制文件</span>
$ <span>cat</span> movie.mpeg.0* <span>></span> movie.mpeg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果调用 <code>cat</code> 命令时没有任何参数，它将读取标准输入，然后显示到标准输出。按下 <code>Ctrl + d</code>，将会结束 <code>cat</code> 读取标准输入。利用这一点，可以将键盘输入写入指定文件，按下 <code>Ctrl + d</code> 结束输入。</p>
<div><pre><code><span>cat</span> <span>></span> lazy_dog.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-n</code> 输出结果显示行号</li>
<li><code>-s</code> 将多个连续的空白行，输出为一行</li>
<li><code>-A</code> 输出结果中显示控制符，比如 Tab 键显示为 <code>^I</code>，行尾显示<code>$</code></li>
</ul>
<p><code>cat</code> 支持 Here document，显示多行文本。</p>
<div><pre><code><span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;HTML>
         &lt;HEAD>
                &lt;TITLE><span>$TITLE</span>&lt;/TITLE>
         &lt;/HEAD>
         &lt;BODY>
                &lt;H1><span>$TITLE</span>&lt;/H1>
                &lt;P><span>$TIME_STAMP</span>&lt;/P>
         &lt;/BODY>
&lt;/HTML>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Here document 常在脚本当中作为输入的手段。</p>
<div><pre><code>$ <span>sort</span> -k2 <span>&lt;&lt;</span>END
<span>></span> <span>1</span> apple
<span>></span> <span>2</span> pear
<span>></span> <span>3</span> banana
<span>></span> END
<span>1</span> apple
<span>3</span> banana
<span>2</span> pear
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果使用 <code>&lt;&lt;-</code> 代替 <code>&lt;&lt;</code>，行首的 tab 键将被剥离。</p>
<h2 id="nl"> nl</h2>
<p><code>nl</code> 命令为文本文件添加行号，显示在标准输出。</p>
<div><pre><code><span>nl</span> example.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="sort"> sort</h2>
<p><code>sort</code> 命令将文本文件的所有行排序后输出。</p>
<div><pre><code><span>sort</span> file1.txt file2.txt file3.txt <span>></span> final_sorted_list.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-b</code> <code>--ignore-leading-blanks</code> 默认情况下，排序用的是每行的第一个字符。这个参数忽略每行开头的空格，从第一个非空白字符开始排序。</li>
<li><code>-f</code> <code>--ignore-case</code> 让排序不区分大小写。</li>
<li><code>-n</code> <code>--numeric-sort</code> 按照数值排序，而不是字符值，用于行首是数值的情况。</li>
<li><code>-r</code> <code>--reverse</code> 按相反顺序排序。结果按照降序排列，而不是升序。</li>
<li><code>-k</code> <code>--key=field1[,field2]</code> 指定按照每行的第几个字段(从 1 开始)排序，而不是按照行首字符排序。该属性可以多个连用，用于指定多重排序标准，还可以指定每个字段指定排序标准，这些值与全局属性一致，比如 b(忽略开头的空格)，n(数值排序)，r(逆向排序)等等。</li>
<li><code>-m</code> <code>--merge</code> 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</li>
<li><code>-o</code> <code>--output=file</code> 把排好序的输出结果发送到文件，而不是标准输出。</li>
<li><code>-t</code> <code>--field-separator=char</code> 定义字段分隔字符。默认情况下，字段由空格或制表符分隔。</li>
<li><code>-u</code> 输出结果中删除重复行</li>
</ul>
<div><pre><code><span>sort</span> --key<span>=</span><span>1,1</span> --key<span>=</span>2n distros.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，第一个 <code>--key</code> 指定第一排序标准是只用第一字段(<code>1,1</code>)，也可以指定使用第一字段第一个字符(<code>1.1</code>)；第二排序标准是第二字段，按数值排序。</p>
<h2 id="uniq"> uniq</h2>
<p><code>uniq</code> 命令在排序后的行中，删除所有重复的行，保证所有输出没有重复。</p>
<div><pre><code><span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-c</code> 输出所有的重复行，并且每行开头显示重复的次数。</li>
<li><code>-d</code> 只输出重复行，而不是不重复的文本行。</li>
<li><code>-f n</code> 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。</li>
<li><code>-i</code> 在比较文本行的时候忽略大小写。</li>
<li><code>-s n</code> 跳过(忽略)每行开头的 n 个字符。</li>
<li><code>-u</code> 只是输出独有的文本行。这是默认的。</li>
<li><code>-V</code> 按照版本号排序。</li>
</ul>
<p><code>-V</code> 参数可以按版本号排列(从小到大)。</p>
<div><pre><code>$ <span>sort</span> -V input.txt
<span>1.0</span>.15
<span>1.3</span>.0
<span>2.1</span>.2
<span>3.0</span>.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>-rV</code> 参数可以按版本号逆序排列。</p>
<div><pre><code>$ <span>sort</span> -rV input.txt
<span>3.0</span>.0
<span>2.1</span>.2
<span>1.3</span>.0
<span>1.0</span>.15
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="cut"> cut</h2>
<p><code>cut</code> 程序用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。</p>
<p>它的参数如下。</p>
<ul>
<li><code>-c char_list</code> 抽取指定范围的文本</li>
<li><code>-f field_list</code> 抽取指定字段，字段之间可以 tab 分隔也可以逗号分隔</li>
<li><code>-d delim_char</code> 指定字段分隔符，默认是 tab 键</li>
<li><code>--complement</code> 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</li>
</ul>
<div><pre><code><span># 抽取每行的第三个字段</span>
$ <span>cut</span> -f <span>3</span> distros.txt

<span># 抽取每行的第7到第10个字符</span>
$ <span>cut</span> -c <span>7</span>-10 distros.txt

<span># 抽取每行的第23个到结尾的字符1</span>
$ <span>cut</span> -c <span>23</span>- distros.txt

<span># 指定字段分隔符为冒号</span>
$ <span>cut</span> -d <span>':'</span> -f <span>1</span> /etc/passwd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="paste"> paste</h2>
<p><code>paste</code> 程序将多个文本文件按行合并，即每一行都由原来文本文件的每一行组成，显示在标准输出。</p>
<div><pre><code><span>paste</span> distros-dates.txt distros-versions.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="wc"> wc</h2>
<p><code>wc</code> 命令输出一个文本文件的统计信息(word count)，一共有三个值，分别为行数、词数和字节数。</p>
<div><pre><code>$ <span>wc</span> ls-output.txt
 <span>7902</span> <span>64566</span> <span>503634</span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果使用 <code>-l</code> 参数，则只输出行数。</p>
<div><pre><code>$ <span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span> <span>|</span> <span>wc</span> -l
 <span>2728</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="head"> head</h2>
<p><code>head</code> 命令返回文本文件的头部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>head</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="tail"> tail</h2>
<p><code>tail</code> 命令返回文本文件的尾部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>tail</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-f</code> 会实时追加显示新增的内容，常用于实时监控日志，按 <code>Ctrl + c</code> 停止。</p>
<div><pre><code><span>tail</span> -f /var/log/messages
</code></pre>
<div><span>1</span><br></div></div><h2 id="grep"> grep</h2>
<p><code>grep</code> 程序用于在指定文件之中，搜索符合某个模式的行，并把搜索结果输出到标准输出。</p>
<div><pre><code><span>grep</span> keyword foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出 <code>foo.txt</code> 之中匹配 <code>keyword</code> 的行。</p>
<p><code>grep</code> 程序可以同时搜索多个文件。</p>
<div><pre><code><span>grep</span> keyword f*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出多个文件中匹配 <code>keyword</code> 的行。</p>
<p><code>-l</code> 参数输出匹配的文件名，而不是文件行。</p>
<div><pre><code><span>grep</span> -l bzip dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果想搜索文件名，而不是文件内容，可以使用重定向。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会输出<code>/usr/bin</code> 目录中，文件名中包含子字符串 <code>zip</code> 的所有文件。</p>
<p>参数的含义。</p>
<ul>
<li><code>-c</code> 或 <code>--count</code> 输出匹配的数量，而不是匹配的文本行。如果使用了 <code>-v</code>，则输出不匹配的数量。</li>
<li><code>-h</code> 或 <code>--no-filename</code> 应用于多文件搜索，不在每行匹配的文本前，输出文件名</li>
<li><code>-i</code> 或 <code>--ignore-case</code> 忽略大小写</li>
<li><code>-l</code> 或 <code>--files-with-matches</code> 输出包含匹配项的文件名，而不是文本行本身</li>
<li><code>-L</code> 或 <code>--files-without-match</code> 类似于 <code>-l</code>，但输出不包含匹配项的文件名</li>
<li><code>-n</code> 或 <code>--line-number</code> 每个匹配行之前输出其对应的行号</li>
<li><code>-v</code> 或 <code>--invert-match</code> 只返回不符合模式的行</li>
</ul>
<h2 id="sed"> sed</h2>
<p><code>sed</code> 是一个强大的文本编辑工具。</p>
<div><pre><code><span># 输出前5行</span>
$ <span>sed</span> -n <span>'1,5p'</span> distros.txt

<span># 输出包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/p'</span> distros.txt

<span># 输出不包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/!p'</span> distros.txt

<span># 替换内容(只替换第一个)</span>
$ <span>sed</span> <span>'s/regexp/replacement/'</span> distros.txt

<span># 替换内容(全局替换)</span>
$ <span>sed</span> <span>'s/regexp/replacement/g'</span> distros.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">时间管理</title>
    <id>https://list-jiang.github.io/linux/bash/archives/time/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/time/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="时间管理"> 时间管理</h1>
<h2 id="date-命令"> date 命令</h2>
<p><code>date</code> 命令用于输出当前时间</p>
<div><pre><code>$ <span>date</span>
<span>2016</span>年 03月 <span>14</span>日 星期一 <span>17</span>:32:35 CST
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>date</code> 命令后面用加号(<code>+</code>)指定显示的格式。</p>
<div><pre><code>$ <span>date</span> +%d_%b_%Y
10_Sep_2018

$ <span>date</span> +%D
09/10/18

$ <span>date</span> +%F-%T
<span>2018</span>-09-10-11:09:51
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>完整的格式参数如下。</p>
<ul>
<li>%a 星期名的缩写(Sun)</li>
<li>%A 星期名的全称(Sunday)</li>
<li>%b 月份的缩写(Jan)</li>
<li>%B 月份的全称(January)</li>
<li>%c 日期和时间(Thu Mar 3 23:05:25 2005)</li>
<li>%C 世纪，就是年份数省略后两位(20)</li>
<li>%d 一个月的第几天(01)</li>
<li>%D 日期，等同于<code>%m/%d/%y</code></li>
<li>%e 一个月的第几天，用空格补零，等同于<code>%_d</code></li>
<li>%F 完整的日期，等同于<code>%Y-%m-%d</code></li>
<li>%g last two digits of year of ISO week number (see %G)</li>
<li>%G year of ISO week number (see %V); normally useful only with %V</li>
<li>%h 等同于<code>%b</code></li>
<li>%H 小时(00..23)</li>
<li>%I 小时(01..12)</li>
<li>%j day of year (001..366)</li>
<li>%k hour ( 0..23)</li>
<li>%l hour ( 1..12)</li>
<li>%m month (01..12)</li>
<li>%M minute (00..59)</li>
<li>%N nanoseconds (000000000..999999999)</li>
<li>%p locale’s equivalent of either AM or PM; blank if not known</li>
<li>%P like %p, but lower case</li>
<li>%r locale’s 12-hour clock time (e.g., 11:11:04 PM)</li>
<li>%R 24-hour hour and minute; same as %H:%M</li>
<li>%s seconds since 1970-01-01 00:00:00 UTC</li>
<li>%S second (00..60)</li>
<li>%T time; same as %H:%M:%S</li>
<li>%u day of week (1..7); 1 is Monday</li>
<li>%U week number of year, with Sunday as first day of week (00..53)</li>
<li>%V ISO week number, with Monday as first day of week (01..53)</li>
<li>%w day of week (0..6); 0 is Sunday</li>
<li>%W week number of year, with Monday as first day of week (00..53)</li>
<li>%x locale’s date representation (e.g., 12/31/99)</li>
<li>%X locale’s time representation (e.g., 23:13:48)</li>
<li>%y last two digits of year (00..99)</li>
<li>%Y year</li>
<li>%z +hhmm numeric timezone (e.g., -0400)</li>
<li>%😒 +hh:mm numeric timezone (e.g., -04:00)</li>
<li>%:😒 +hh:mm:ss numeric time zone (e.g., -04:00:00)</li>
<li>%Z alphabetic time zone abbreviation (e.g., EDT)</li>
</ul>
<h2 id="cal-命令"> cal 命令</h2>
<p><code>cal</code> 命令用于显示日历。不带有参数时，显示的是当前月份。</p>
<div><pre><code>$ <span>cal</span>
      三月 <span>2016</span>
日 一 二 三 四 五 六
       <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>  <span>5</span>
 <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span> <span>12</span>
<span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span> <span>19</span>
<span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span> <span>26</span>
<span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">用户管理</title>
    <id>https://list-jiang.github.io/linux/bash/archives/user/</id>
    <link href="https://list-jiang.github.io/linux/bash/archives/user/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户管理"> 用户管理</h1>
<h2 id="id"> id</h2>
<p><code>id</code> 命令用于查看指定用户的用户名和组名。</p>
<div><pre><code>$ <span>id</span>
<span>uid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>gid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>groups</span><span>=</span><span>500</span><span>(</span>me<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>id</code> 输出结果分为三个部分，分别是 UID(用户编号和用户名)、GID(组编号和组名)，groups(用户所在的所有组)。</p>
<p>用户帐户的信息，存放在<code>/etc/passwd</code> 文件里面；用户组的信息，存放在<code>/etc/group</code> 文件里面。</p>
<div><pre><code><span># 返回UID</span>
$ <span>id</span> -u <span>[</span>UserName<span>]</span>

<span># 返回GID</span>
$ <span>id</span> -g <span>[</span>UserName<span>]</span>

<span># 返回用户名</span>
$ <span>id</span> -un <span>[</span>UserName<span>]</span>

<span># 返回组名</span>
$ <span>id</span> -gn <span>[</span>UserName<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的命令，如果省略用户名，则返回当前用户的信息。</p>
<h2 id="su"> su</h2>
<p><code>su</code> 命令允许您以另一个用户的身份，启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。</p>
<div><pre><code><span>su</span> otherUser
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令以后，系统会提示输入密码。通过以后，就以另一个用户身份在执行命令了。</p>
<p>如果不加用户名，则表示切换到 root 用户。</p>
<div><pre><code><span>su</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数表示启动一个需要登录的新的 Shell，这意味着工作目录会切换到该用户的主目录。它的缩写形式是 <code>-</code>。</p>
<div><pre><code><span>su</span> -
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示，切换到 root 用户的身份，且工作目录也切换到 root 用户的主目录。</p>
<p><code>-c</code> 参数表示只以其他用户的身份，执行单个命令，而不是启动一个新的 Session。</p>
<div><pre><code>$ <span>su</span> -c <span>'command'</span>

<span># 实例</span>
$ <span>su</span> -c <span>'ls -l /root/*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="sudo"> sudo</h2>
<p><code>sudo</code> 命令很类似 <code>su</code> 命令，但有几点差别。</p>
<ul>
<li>对于管理员来说，<code>sudo</code> 命令的可配置性更高</li>
<li><code>sudo</code> 命令通常只用于执行单个命令，而不是开启另一个 Session。</li>
<li><code>sudo</code> 命令不要求超级用户的密码，而是用户使自己的密码来认证。</li>
</ul>
<p><code>sudo</code> 的设置在文件<code>/etc/sudoers</code> 之中。</p>
<p><code>-l</code> 参数列出用户拥有的所有权限。</p>
<div><pre><code><span>sudo</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="chown"> chown</h2>
<p><code>chown</code> 命令用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p>
<div><pre><code><span>chown</span> <span>[</span>owner<span>]</span><span>[</span>:<span>[</span>group<span>]</span><span>]</span> <span>file</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一些例子。</p>
<div><pre><code><span># 更改文件所有者</span>
$ <span>sudo</span> <span>chown</span> bob foo.txt

<span># 更改文件所有者和用户组</span>
$ <span>sudo</span> <span>chown</span> bob:users foo.txt

<span># 更改用户组</span>
$ <span>sudo</span> <span>chown</span> :admins foo.txt

<span># 更改文件所有者和用户组(用户 bob 登录系统时，所属的用户组)</span>
$ <span>sudo</span> <span>chown</span> bob: foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="chgrp"> chgrp</h2>
<p><code>chgrp</code> 命令更改用户组，用法与 <code>chown</code> 命令类似。</p>
<h2 id="useradd"> useradd</h2>
<p><code>useradd</code> 命令用来新增用户。</p>
<div><pre><code><span>useradd</span> -G admin -d /home/bill -s /bin/bash -m bill
</code></pre>
<div><span>1</span><br></div></div><p>上面命令新增用户 <code>bill</code>，参数 <code>-G</code> 指定用户所在的组，参数 <code>d</code> 指定用户的主目录，参数 <code>s</code> 指定用户的 Shell，参数 <code>m</code> 表示如果该目录不存在，则创建该目录。</p>
<h2 id="usermod"> usermod</h2>
<p><code>usermod</code> 命令用来修改用户的各项属性。</p>
<div><pre><code><span>usermod</span> -g sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的主要用户组为 <code>sales</code>。</p>
<div><pre><code><span>usermod</span> -G sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的次要用户组为 <code>sales</code>。</p>
<h2 id="adduser"> adduser</h2>
<p><code>adduser</code> 命令用来将一个用户加入用户组。</p>
<div><pre><code><span>sudo</span> adduser username grouptoadd
</code></pre>
<div><span>1</span><br></div></div><h2 id="groupadd"> groupadd</h2>
<p><code>groupadd</code> 命令用来新建一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupadd</span> group1
<span>sudo</span> adduser foobar group1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="groupdel"> groupdel</h2>
<p><code>groupdel</code> 命令用来删除一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupdel</span> group1
</code></pre>
<div><span>1</span><br></div></div><h2 id="passwd"> passwd</h2>
<p><code>passwd</code> 命令用于修改密码。</p>
<div><pre><code><span># 修改自己的密码</span>
$ <span>passwd</span>

<span># 修改其他用户的密码</span>
$ <span>sudo</span> <span>passwd</span> <span>[</span>user<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Bash 的算术运算</title>
    <id>https://list-jiang.github.io/linux/bash/arithmetic/</id>
    <link href="https://list-jiang.github.io/linux/bash/arithmetic/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="算术表达式"> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>
$ <span>echo</span> <span>$foo</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>
<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>
<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div><pre><code>$ <span>i</span><span>=</span><span>0</span>
$ <span>echo</span> <span>$i</span>
<span>0</span>
$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>
<span>0</span>
$ <span>echo</span> <span>$i</span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>
<span>2</span>
$ <span>echo</span> <span>$i</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>
<span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>
<span>75</span>
<span># 等同于</span>
$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>
<span>75</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>
bash: 语法错误
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div><pre><code>$ <span>number</span><span>=</span><span>2</span>
$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> "hello" <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
$ <span>echo</span> <span><span>$((</span> "hello" <span>*</span> <span>2</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>hello</span><span>=</span><span>3</span>
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="数值的进制"> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>
<span>255</span>
$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>
<span>255</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2 id="位运算"> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>
<span>64</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>
<span>19</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>
<span>18</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="逻辑运算"> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div><pre><code>$ <span>a</span><span>=</span><span>0</span>
$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算"> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span>$a</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>
$ <span>echo</span> <span><span>$((</span>foo<span>*=</span><span>2</span><span>))</span></span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-=</span><span>1</span><span>)</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="求值运算"> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>
<span>12</span>
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2 id="expr-命令"> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>
$ <span>expr</span> <span>$foo</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>
expr: 非整数参数
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">数组</title>
    <id>https://list-jiang.github.io/linux/bash/array/</id>
    <link href="https://list-jiang.github.io/linux/bash/array/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>
]]></summary>
    <content type="html"><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>

<h2 id="创建数组"> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val
array<span>[</span><span>1</span><span>]</span><span>=</span>val
array<span>[</span><span>2</span><span>]</span><span>=</span>val
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>

<span># 等同于</span>

<span>ARRAY</span><span>=</span><span>(</span>
  value1
  value2
  value3
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>
<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>

<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>
<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>只为某些值指定位置，也是可以的。</p>
<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div><pre><code><span>declare</span> -a ARRAYNAME
</code></pre>
<div><span>1</span><br></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div><pre><code><span>read</span> -a dice
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2 id="读取数组"> 读取数组</h2>
<h3 id="读取单个元素"> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a

$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>
a

$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>
a<span>[</span><span>0</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3 id="读取所有成员"> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>"<span>${names<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>"water skiing"</span> canoeing <span>"white-water rafting"</span> surfing <span>)</span>
$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>*<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"${activities[@]"</span> diving <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置"> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div><pre><code>$ <span>declare</span> -a foo
$ <span>foo</span><span>=</span>A
$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>
A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo}</span>
a
$ <span>echo</span> <span>$foo</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2 id="数组的长度"> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>
<span>1</span>

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo
$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2 id="提取数组序号"> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>
  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="提取数组成员"> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>
bananas
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>
bananas cucumbers dates
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>
eggs fajitas grapes
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员"> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c

$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="删除数组"> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f

$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>foo</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div><pre><code>$ <span>unset</span> ARRAY

$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>
<span>&lt;</span>--no output--<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="关联数组"> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div><pre><code><span>declare</span> -A colors
colors<span>[</span><span>"red"</span><span>]</span><span>=</span><span>"#ff0000"</span>
colors<span>[</span><span>"green"</span><span>]</span><span>=</span><span>"#00ff00"</span>
colors<span>[</span><span>"blue"</span><span>]</span><span>=</span><span>"#0000ff"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div><pre><code><span>echo</span> <span>${colors<span>[</span>"blue"<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">条件判断</title>
    <id>https://list-jiang.github.io/linux/bash/condition/</id>
    <link href="https://list-jiang.github.io/linux/bash/condition/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>

<h2 id="if-结构"> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>
  commands
<span>[</span>elif commands<span>;</span> <span>then</span>
  commands<span>..</span>.<span>]</span>
<span>[</span>else
  commands<span>]</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>"foo"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Hello foo."</span>
<span>else</span>
  <span>echo</span> <span>"You are not foo."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div><pre><code><span>if</span> <span>true</span>
<span>then</span>
  <span>echo</span> <span>'hello world'</span>
<span>fi</span>

<span>if</span> <span>false</span>
<span>then</span>
  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world

$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>"It's true."</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hi
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>if</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>1</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"2"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>2</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>3</span>
<span>else</span>
    <span>echo</span> 输入不符合要求
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2 id="test-命令"> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div><pre><code><span># 写法一</span>
<span>test</span> expression

<span># 写法二</span>
<span>[</span> expression <span>]</span>

<span># 写法三</span>
<span>[</span><span>[</span> expression <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div><pre><code>$ <span>test</span> -f /etc/hosts
$ <span>echo</span> <span>$?</span>
<span>0</span>

$ <span>[</span> -f /etc/hosts <span>]</span>
$  <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div><pre><code><span># 写法一</span>
<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法二</span>
<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法三</span>
<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="判断表达式"> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断"> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>FILE</span><span>=~</span>/.bashrc

<span>if</span> <span>[</span> -e <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span> -f <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a regular file."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -d <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a directory."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -r <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is readable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -w <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is writable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -x <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is executable/searchable."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span>$FILE</span> does not exist"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>
<h3 id="字符串判断"> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>ANSWER</span><span>=</span>maybe

<span>if</span> <span>[</span> -z <span>"<span>$ANSWER</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"There is no answer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"yes"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is YES."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"no"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is NO."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"maybe"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is MAYBE."</span>
<span>else</span>
  <span>echo</span> <span>"The answer is UNKNOWN."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>
<h3 id="整数判断"> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span> -z <span>"<span>$INT</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is empty."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is zero."</span>
<span>else</span>
  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is negative."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is positive."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is even."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is odd."</span>
  <span>fi</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断"> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div><pre><code><span>[</span><span>[</span> string1 <span>=~</span> regex <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is an integer."</span>
  <span>exit</span> <span>0</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算"> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>MIN_VAL</span><span>=</span><span>1</span>
<span>MAX_VAL</span><span>=</span><span>100</span>

<span>INT</span><span>=</span><span>50</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is out of range."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
<span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is in range."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断"> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>fi</span>
It is true.
$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>else</span> <span>echo</span> <span>"it is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"foo is <span>$foo</span>"</span><span>;</span> <span>fi</span>
foo is <span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span><span>else</span> <span>echo</span> <span>"It is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is zero."</span>
  <span>else</span>
    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is negative."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is positive."</span>
    <span>fi</span>
    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is even."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is odd."</span>
    <span>fi</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="./arithmetic.html">Bash 的算术运算</a> 一章。</p>
<h3 id="普通命令的逻辑运算"> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>
  <span>command</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个示例。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>filename</span><span>=</span><span>$1</span>
<span>word1</span><span>=</span><span>$2</span>
<span>word2</span><span>=</span><span>$3</span>

<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>
<span>then</span>
  <span>echo</span> <span>"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>"<span>$dir_name</span>"</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 等同于</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"No such directory: '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>cd</span> <span>"<span>$dir_name</span>"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Cannot cd to '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>
  <span>echo</span> <span>"File deletion failed. Check results"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="case-结构"> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div><pre><code><span>case</span> expression <span>in</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  <span>..</span>.
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>
    <span>;</span><span>;</span>
  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>
    <span>;</span><span>;</span>
  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>
    <span>;</span><span>;</span>
  * <span>)</span> <span>echo</span> 输入不符合要求
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>

<span>case</span> <span>"<span>$OS</span>"</span> <span>in</span>
  FreeBSD<span>)</span> <span>echo</span> <span>"This is FreeBSD"</span> <span>;</span><span>;</span>
  Darwin<span>)</span> <span>echo</span> <span>"This is Mac OSX"</span> <span>;</span><span>;</span>
  AIX<span>)</span> <span>echo</span> <span>"This is AIX"</span> <span>;</span><span>;</span>
  Minix<span>)</span> <span>echo</span> <span>"This is Minix"</span> <span>;</span><span>;</span>
  Linux<span>)</span> <span>echo</span> <span>"This is Linux"</span> <span>;</span><span>;</span>
  *<span>)</span> <span>echo</span> <span>"Failed to identify this OS"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个字母或数字 > "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>"输入了字母 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>"输入了数字 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  * <span>)</span>                         <span>echo</span> <span>"输入不符合要求"</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>read</span> -n <span>1</span> -p <span>"Type a character > "</span>
<span>echo</span>
<span>case</span> <span>$REPLY</span> <span>in</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is upper case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is lower case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is alphabetic."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a digit."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a visible character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a punctuation symbol."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a whitespace character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>"'<span>$REPLY</span>' is a hexadecimal digit."</span> <span>;</span><span>;</span><span>&amp;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div><pre><code>$ test.sh
Type a character <span>></span> a
<span>'a'</span> is lower case.
<span>'a'</span> is alphabetic.
<span>'a'</span> is a visible character.
<span>'a'</span> is a hexadecimal digit.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line</a>, William Shotts</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">脚本除错</title>
    <id>https://list-jiang.github.io/linux/bash/debug/</id>
    <link href="https://list-jiang.github.io/linux/bash/debug/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>

<h2 id="常见错误"> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>dir_name</span><span>=</span>/path/not/exist

<span>cd</span> <span>$dir_name</span>
<span>rm</span> *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-的-x-参数"> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div><pre><code><span># script.sh</span>
<span>echo</span> hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div><pre><code>$ <span>bash</span> -x script.sh
+ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div><pre><code><span>#! /bin/bash -x</span>
<span># trouble: script to demonstrate common errors</span>

<span>number</span><span>=</span><span>1</span>
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number is equal to 1."</span>
<span>else</span>
  <span>echo</span> <span>"Number is not equal to 1."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div><pre><code>$ trouble
+ <span>number</span><span>=</span><span>1</span>
+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
+ <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'$LINENO + '</span>
$ trouble
<span>5</span> + <span>number</span><span>=</span><span>1</span>
<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="./set.html">set 命令</a> 一章。</p>
<h2 id="环境变量"> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno"> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"This is line <span>$LINENO</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div><pre><code>$ ./test.sh
This is line <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="funcname"> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>

<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div><pre><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3 id="bash-source"> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3 id="bash-lineno"> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>

  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: <span>BASH_LINENO</span> is <span>7</span>
func1: FUNCNAME is func1
func1: <span>BASH_SOURCE</span> is main.sh
func2: <span>BASH_LINENO</span> is <span>8</span>
func2: FUNCNAME is func2
func2: <span>BASH_SOURCE</span> is lib1.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 的模式扩展</title>
    <id>https://list-jiang.github.io/linux/bash/expansion/</id>
    <link href="https://list-jiang.github.io/linux/bash/expansion/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div><pre><code>$ <span>set</span> -o noglob
<span># 或者</span>
$ <span>set</span> -f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面的命令可以重新打开扩展。</p>
<div><pre><code>$ <span>set</span> +o noglob
<span># 或者</span>
$ <span>set</span> +f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="波浪线扩展"> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div><pre><code>$ <span>echo</span> ~
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div><pre><code><span># 进入 /home/me/foo 目录</span>
$ <span>cd</span> ~/foo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div><pre><code>$ <span>echo</span> ~foo
/home/foo

$ <span>echo</span> ~root
/root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div><pre><code>$ <span>echo</span> ~nonExistedUser
~nonExistedUser
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div><pre><code>$ <span>cd</span> ~/foo
$ <span>echo</span> ~+
/home/me/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="字符扩展"> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> ?.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> ??.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div><pre><code><span># 当前目录有 a.txt 文件</span>
$ <span>echo</span> ?.txt
a.txt

<span># 当前目录为空目录</span>
$ <span>echo</span> ?.txt
?.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2 id="字符扩展-2"> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> *.txt
a.txt b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div><pre><code><span>ls</span> *
</code></pre>
<div><span>1</span><br></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> a*.txt
a.txt ab.txt

$ <span>ls</span> *b*
b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div><pre><code><span># 显示所有隐藏文件</span>
$ <span>echo</span> .*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div><pre><code><span># 当前目录不存在 c 开头的文件</span>
$ <span>echo</span> c*.txt
c*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div><pre><code><span># 子目录有一个 a.txt</span>
<span># 无效的写法</span>
$ <span>ls</span> *.txt

<span># 有效的写法</span>
$ <span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2 id="方括号扩展"> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt b.txt

<span># 只存在文件 a.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
ls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>
$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?
aba bbb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展"> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt
a.txt
b.txt
c.txt

<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt
report1.txt
report2.txt
report3.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt
report4.txt report5.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2 id="大括号扩展"> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>
<span>1</span> <span>2</span> <span>3</span>

$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g
dag deg <span>dig</span> dug dog

$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt
ls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>
<span>{</span><span>1</span> , <span>2</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>

<span># 等同于</span>
<span># cp a.log a.log.bak</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>大括号可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>
jpg jpeg png

$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b
aA1b aA2b aB3b aB4b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>
<span>cat</span> dawg dg <span>dig</span> dog doug dug
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>
<span>cat</span> dog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div><pre><code><span># 不存在 a.txt 和 b.txt</span>
$ <span>echo</span> <span>[</span>ab<span>]</span>.txt
<span>[</span>ab<span>]</span>.txt

$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2 id="start-end-扩展-2"> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>
a b c

$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g
dag dbg dcg ddg

$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span>

$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这种简写形式支持逆序。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>
c b a

$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>
<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>
<span>{</span>a1<span>..</span>3c<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>
01 02 03 04 05

$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>
001 002 003 004 005
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>
<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="变量扩展"> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="./variable.html">Bash 变量</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>
<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2 id="子命令扩展"> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展"> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="./arithmetic.html">Bash 的算术运算</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="字符类"> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div><pre><code><span># 不存在以大写字母开头的文件</span>
$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点"> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div><pre><code>$ <span>ls</span> a*.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div><pre><code><span># 不存在 r 开头的文件名</span>
$ <span>echo</span> r*
r*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div><pre><code>$ <span>ls</span> *.csv
ls: *.csv: No such <span>file</span> or directory
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div><pre><code><span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div><pre><code>$ <span>touch</span> <span>'fo*'</span>
$ <span>ls</span>
fo*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2 id="量词语法"> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt
abctxt abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>
abc abcdef
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>
abc.php abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>
abc.txt abc.txt.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div><pre><code><span># 没有 abc 开头的文件名</span>
$ <span>ls</span> abc?<span>(</span>def<span>)</span>
ls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div><pre><code><span># 打开某个参数</span>
$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>

<span># 关闭某个参数</span>
$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>

<span># 查询某个参数关闭还是打开</span>
$ <span>shopt</span> <span>[</span>optionname<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div><pre><code>$ <span>ls</span> *
abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div><pre><code>$ <span>shopt</span> -s dotglob
$ <span>ls</span> *
abc.txt .config
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div><pre><code>$ <span>rm</span> b*
rm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div><pre><code>$ <span>shopt</span> -s nullglob
$ <span>rm</span> b*
rm: 缺少操作数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div><pre><code>$ <span>shopt</span> -s failglob
$ <span>rm</span> b*
bash: 无匹配: b*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div><pre><code><span>shopt</span> -u extglob
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div><pre><code>$ <span>shopt</span> -s nocaseglob
$ <span>ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span>(</span>x86<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div><pre><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div><pre><code>$ <span>shopt</span> -s globstar
$ <span>ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 的基本语法</title>
    <id>https://list-jiang.github.io/linux/bash/grammar/</id>
    <link href="https://list-jiang.github.io/linux/bash/grammar/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>

<h2 id="echo-命令"> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div><pre><code>$ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div><pre><code>$ <span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3 id="n-参数"> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div><pre><code>$ <span>echo</span> -n hello world
hello world$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b
a
b

$ <span>echo</span> -n a<span>;</span><span>echo</span> b
ab
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3 id="e-参数"> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div><pre><code>$ <span>echo</span> <span>"Hello<span title="\n">\n</span>World"</span>
Hello<span>\</span>nWorld

<span># 双引号的情况</span>
$ <span>echo</span> -e <span>"Hello<span title="\n">\n</span>World"</span>
Hello
World

<span># 单引号的情况</span>
$ <span>echo</span> -e <span>'Hello\nWorld'</span>
Hello
World
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式"> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div><pre><code><span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div><pre><code><span># 短形式</span>
$ <span>ls</span> -r

<span># 长形式</span>
$ <span>ls</span> --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div><pre><code>$ <span>echo</span> foo bar

<span># 等同于</span>
$ <span>echo</span> foo <span>\</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="空格"> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div><pre><code><span>command</span> foo bar
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div><pre><code>$ <span>echo</span> this is a     <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号"> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div><pre><code><span>clear</span><span>;</span> <span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-和"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div><pre><code>Command1 <span>&amp;&amp;</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div><pre><code>Command1 <span>||</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2 id="type-命令"> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div><pre><code>$ <span>type</span> <span>echo</span>
<span>echo</span> is a shell <span>builtin</span>
$ <span>type</span> <span>ls</span>
<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div><pre><code>$ <span>type</span> -a <span>echo</span>
<span>echo</span> is shell <span>builtin</span>
<span>echo</span> is /usr/bin/echo
<span>echo</span> is /bin/echo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div><pre><code>$ <span>type</span> -t <span>bash</span>
<span>file</span>
$ <span>type</span> -t <span>if</span>
keyword
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2 id="快捷键"> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="./readline.html">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 函数</title>
    <id>https://list-jiang.github.io/linux/bash/function/</id>
    <link href="https://list-jiang.github.io/linux/bash/function/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 函数的用法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 函数的用法。</p>

<h2 id="简介"> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div><pre><code><span># 第一种</span>
<span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>

<span># 第二种</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"Hello <span>$1</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div><pre><code>$ hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> -n <span>"Today's date is: "</span>
  <span>date</span> +<span>"%A, %B %-d, %Y"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div><pre><code><span>unset</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div><pre><code><span>declare</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div><pre><code><span>declare</span> -F
</code></pre>
<div><span>1</span><br></div></div><h2 id="参数变量"> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>function</span> <span>alice</span> <span>{</span>
  <span>echo</span> <span>"alice: <span>$@</span>"</span>
  <span>echo</span> <span>"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>"</span>
  <span>echo</span> <span>"<span>$#</span> arguments"</span>

<span>}</span>

alice <span>in</span> wonderland
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>运行该脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
alice: <span>in</span> wonderland
test.sh: <span>in</span> wonderland
<span>2</span> arguments
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用方法如下。</p>
<div><pre><code>$ log_msg <span>"This is sample log message"</span>
<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="return-命令"> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>
  <span>return</span> <span>10</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div><pre><code>$ func_return_value
$ <span>echo</span> <span>"Value returned by function is: <span>$?</span>"</span>
Value returned by <span>function</span> is: <span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div><pre><code><span>function</span> <span>name</span> <span>{</span>
  commands
  <span>return</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="全局变量和局部变量-local-命令"> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div><pre><code><span>foo</span><span>=</span><span>1</span>

<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>2</span>
<span>}</span>

<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>local</span> foo
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 简介</title>
    <id>https://list-jiang.github.io/linux/bash/intro/</id>
    <link href="https://list-jiang.github.io/linux/bash/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>

<h2 id="shell-的含义"> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell-的种类"> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div><pre><code><span>cat</span> /etc/shells
</code></pre>
<div><span>1</span><br></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境"> 命令行环境</h2>
<h3 id="终端模拟器"> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符"> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div><pre><code><span>[</span>user@hostname<span>]</span> $
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3 id="进入和退出方法"> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div><pre><code><span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div><pre><code>$ <span>pwd</span>
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div><pre><code>$ pwe
bash: pwe: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="shell-和-bash-的历史"> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div><pre><code>$ <span>bash</span> --version
GNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>

<span># 或者</span>
$ <span>echo</span> <span>$BASH_VERSION</span>
<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">循环</title>
    <id>https://list-jiang.github.io/linux/bash/loop/</id>
    <link href="https://list-jiang.github.io/linux/bash/loop/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>

<h2 id="while-循环"> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2 id="until-循环"> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div><pre><code><span>until</span> condition
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
^C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>until</span> <span>[</span> <span>"<span>$number</span>"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2 id="for-in-循环"> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>
  <span>ls</span> -l <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>count</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>
  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>
  <span>echo</span> <span>"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>

<span># 等同于</span>

<span>for</span> <span>filename</span> <span>in</span> <span>"<span>$@</span>"</span> <span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2 id="for-循环"> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div><pre><code><span><span>((</span> expression1 <span>))</span></span>
<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>
  commands
  <span><span>((</span> expression3 <span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>
<span>do</span>
  <span>read</span> var
  <span>if</span> <span>[</span> <span>"<span>$var</span>"</span> <span>=</span> <span>"."</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2 id="break-continue"> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>
<span>do</span>
  <span>echo</span> <span>"number is <span>$number</span>"</span>
  <span>if</span> <span>[</span> <span>"<span>$number</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>read</span> -p <span>"What file do you want to test?"</span> filename
<span>do</span>
  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"The file does not exist."</span>
    <span>continue</span>
  <span>fi</span>

  <span>echo</span> <span>"You entered a valid file.."</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2 id="select-结构"> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div><pre><code><span>select</span> name
<span>[</span>in list<span>]</span>
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># select.sh</span>

<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton
<span>do</span>
  <span>echo</span> <span>"You have chosen <span>$brand</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div><pre><code>$ ./select.sh
<span>1</span><span>)</span> Samsung
<span>2</span><span>)</span> Sony
<span>3</span><span>)</span> iphone
<span>4</span><span>)</span> symphony
<span>5</span><span>)</span> Walton
<span>#?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Which Operating System do you like?"</span>

<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span>do</span>
  <span>case</span> <span>$os</span> <span>in</span>
    <span>"Ubuntu"</span><span>|</span><span>"LinuxMint"</span><span>)</span>
      <span>echo</span> <span>"I also use <span>$os</span>."</span>
    <span>;</span><span>;</span>
    <span>"Windows8"</span> <span>|</span> <span>"Windows10"</span> <span>|</span> <span>"WindowsXP"</span><span>)</span>
      <span>echo</span> <span>"Why don't you try Linux?"</span>
    <span>;</span><span>;</span>
    *<span>)</span>
      <span>echo</span> <span>"Invalid entry."</span>
      <span>break</span>
    <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">mktemp 命令，trap 命令</title>
    <id>https://list-jiang.github.io/linux/bash/mktemp/</id>
    <link href="https://list-jiang.github.io/linux/bash/mktemp/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>

<h2 id="临时文件的安全问题"> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div><pre><code>$ <span>touch</span> /tmp/info.txt
$ <span>ls</span> -l /tmp/info.txt
-rw-r--r-- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>17</span>:12 /tmp/info.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法"> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div><pre><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span>ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="mktemp-命令的参数"> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div><pre><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div><pre><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div><pre><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="trap-命令"> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div><pre><code>$ <span>trap</span> -l
 <span>1</span><span>)</span> SIGHUP  <span>2</span><span>)</span> SIGINT  <span>3</span><span>)</span> SIGQUIT  <span>4</span><span>)</span> SIGILL  <span>5</span><span>)</span> SIGTRAP
 <span>6</span><span>)</span> SIGABRT  <span>7</span><span>)</span> SIGBUS  <span>8</span><span>)</span> SIGFPE  <span>9</span><span>)</span> SIGKILL <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV <span>12</span><span>)</span> SIGUSR2 <span>13</span><span>)</span> SIGPIPE <span>14</span><span>)</span> SIGALRM <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT <span>17</span><span>)</span> SIGCHLD <span>18</span><span>)</span> SIGCONT <span>19</span><span>)</span> SIGSTOP <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN <span>22</span><span>)</span> SIGTTOU <span>23</span><span>)</span> SIGURG <span>24</span><span>)</span> SIGXCPU <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM <span>27</span><span>)</span> SIGPROF <span>28</span><span>)</span> SIGWINCH <span>29</span><span>)</span> SIGIO <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS <span>34</span><span>)</span> SIGRTMIN <span>35</span><span>)</span> SIGRTMIN+1 <span>36</span><span>)</span> SIGRTMIN+2 <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4 <span>39</span><span>)</span> SIGRTMIN+5 <span>40</span><span>)</span> SIGRTMIN+6 <span>41</span><span>)</span> SIGRTMIN+7 <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9 <span>44</span><span>)</span> SIGRTMIN+10 <span>45</span><span>)</span> SIGRTMIN+11 <span>46</span><span>)</span> SIGRTMIN+12 <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14 <span>49</span><span>)</span> SIGRTMIN+15 <span>50</span><span>)</span> SIGRTMAX-14 <span>51</span><span>)</span> SIGRTMAX-13 <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11 <span>54</span><span>)</span> SIGRTMAX-10 <span>55</span><span>)</span> SIGRTMAX-9 <span>56</span><span>)</span> SIGRTMAX-8 <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 <span>59</span><span>)</span> SIGRTMAX-5 <span>60</span><span>)</span> SIGRTMAX-4 <span>61</span><span>)</span> SIGRTMAX-3 <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1 <span>64</span><span>)</span> SIGRTMAX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>trap</code> 的命令格式如下。</p>
<div><pre><code><span>trap</span> <span>[</span>动作<span>]</span> <span>[</span>信号1<span>]</span> <span>[</span>信号2<span>]</span> <span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div><pre><code><span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>ls</span> /etc <span>></span> <span>$TMPFILE</span>
<span>if</span> <span>grep</span> -qi <span>"kernel"</span> <span>$TMPFILE</span><span>;</span> <span>then</span>
  <span>echo</span> <span>'find'</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div><pre><code><span>function</span> <span>egress</span> <span>{</span>
  command1
  command2
  command3
<span>}</span>

<span>trap</span> egress EXIT
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">命令提示符</title>
    <id>https://list-jiang.github.io/linux/bash/prompt/</id>
    <link href="https://list-jiang.github.io/linux/bash/prompt/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>
]]></summary>
    <content type="html"><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>

<h2 id="环境变量-ps1"> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div><pre><code><span>echo</span> <span>$PS1</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div><pre><code><span>[</span>user@host ~<span>]</span>$ <span>echo</span> <span>$PS1</span>
<span>[</span><span>\</span>u@<span>\</span>h <span>\</span>W<span>]</span><span>\</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div><pre><code>$ <span><span>PS1</span></span><span>=</span><span>"\A \h \$ "</span>
<span>17</span>:33 <span>host</span> $
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色"> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$'</span>
</code></pre>
<div><span>1</span><br></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$\[\033[00m\]'</span>
</code></pre>
<div><span>1</span><br></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;41m\]&lt;\u@\h \W>\$\[\033[0m\] '</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="环境变量-ps2-ps3-ps4"> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
> world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"hello world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div><pre><code>$ <span>bash</span> -x test.sh
+ <span>echo</span> <span>'hello world'</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">引号和转义</title>
    <id>https://list-jiang.github.io/linux/bash/quotation/</id>
    <link href="https://list-jiang.github.io/linux/bash/quotation/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>

<h2 id="转义"> 转义</h2>
<p>某些字符在 Bash 里面有特殊含义(比如<code>$</code>、<code>&amp;</code>、<code>*</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>$date</span>

$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出 <code>$date</code> 不会有任何结果，因为 <code>$</code> 是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”(escape)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>$date</span>
<span>$date</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，只有在特殊字符 <code>$</code> 前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线 (<code>\\</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>\</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>: 响铃</li>
<li><code>\b</code>: 退格</li>
<li><code>\n</code>: 换行</li>
<li><code>\r</code>: 回车</li>
<li><code>\t</code>: 制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<div><pre><code>$ <span>echo</span> a<span>\</span>tb
atb

$ <span>echo</span> -e <span>"a<span title="\t">\t</span>b"</span>
a        b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div><pre><code>$ <span>mv</span> <span>\</span>
/path/to/foo <span>\</span>
/path/to/bar

<span># 等同于</span>
$ <span>mv</span> /path/to/foo /path/to/bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号"> 单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号 (<code>*</code>)、美元符号( <code>$</code>)、反斜杠 (<code>\</code>)等。</p>
<div><pre><code>$ <span>echo</span> <span>'*'</span>
*

$ <span>echo</span> <span>'$USER'</span>
<span>$USER</span>

$ <span>echo</span> <span>'$((2+2))'</span>
<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>

$ <span>echo</span> <span>'$(echo foo)'</span>
<span><span>$(</span><span>echo</span> foo<span>)</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号 (<code>$</code>)，然后再对里层的单引号转义。</p>
<div><pre><code><span># 不正确</span>
$ <span>echo</span> it<span>'s

# 不正确
$ echo '</span>it<span>\</span>'s<span>'

# 正确
$ echo $'</span>it<span>\</span>'s'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div><pre><code>$ <span>echo</span> <span>"it's"</span>
it's
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="双引号"> 双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外: 美元符号(<code>$</code>)、反引号(<code>`</code>)和反斜杠(<code>\</code>)。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"*"</span>
*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，通配符 <code>*</code> 放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"<span>$SHELL</span>"</span>
/bin/bash

$ <span>echo</span> <span>"<span><span>`</span><span>date</span><span>`</span></span>"</span>
Mon Jan <span>27</span> <span>13</span>:33:18 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div><pre><code>$ <span>echo</span> <span>"I'd say: <span title="\&quot;">\"</span>hello!<span title="\&quot;">\"</span>"</span>
I'd say: <span>"hello!"</span>

$ <span>echo</span> <span>"<span title="\\">\\</span>"</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
world"</span>
hello
world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code> 命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div><pre><code><span>ls</span> <span>"two words.txt"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>two words.txt</code> 是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div><pre><code>$ <span>echo</span> <span>"this is a     test"</span>
this is a     <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div><pre><code><span># 单行输出</span>
$ <span>echo</span> <span><span>$(</span><span>cal</span><span>)</span></span>
一月 <span>2020</span> 日 一 二 三 四 五 六 <span>1</span> <span>2</span> <span>3</span> <span>..</span>. <span>31</span>

<span># 原始格式输出</span>
$ <span>echo</span> <span>"<span><span>$(</span><span>cal</span><span>)</span></span>"</span>
      一月 <span>2020</span>
日 一 二 三 四 五 六
          <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>
 <span>5</span>  <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span>
<span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span>
<span>19</span> <span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span>
<span>26</span> <span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果 <code>$(cal)</code> 不放在双引号之中，<code>echo</code> 就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here-文档"> Here 文档</h2>
<p>Here 文档(here document)是一种输入多行字符串的方法，格式如下。</p>
<div><pre><code><span>&lt;&lt;</span> <span>token
text
token</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>它的格式分成开始标记(<code>&lt;&lt; token</code>)和结束标记(<code>token</code>)。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>_example_
<span>$foo</span>
"<span>$foo</span>"
'<span>$foo</span>'
_example_</span>

hello world
<span>"hello world"</span>
<span>'hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span>$foo</span>
<span>"<span>$foo</span>"</span>
<span>'$foo'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，Here 文档的开始标记(<code>_example_</code>)放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>command</span> <span>&lt;&lt;</span> <span>token
  string
token</span>

<span># 等同于</span>

$ <span>echo</span> string <span>|</span> <span>command</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，Here 文档相当于 <code>echo</code> 命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如 <code>echo</code> 命令就不能用 Here 文档作为参数。</p>
<div><pre><code>$ <span>echo</span> <span>&lt;&lt;</span> <span>_example_
hello
_example_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子不会有任何输出，因为 Here 文档对于 <code>echo</code> 命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here-字符串"> Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串(Here string)，使用三个小于号(<code>&lt;&lt;&lt;</code>)表示。</p>
<div><pre><code><span>&lt;&lt;&lt;</span> string
</code></pre>
<div><span>1</span><br></div></div><p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 <code>cat</code> 命令只接受标准输入传入的字符串。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;&lt;</span> <span>'hi there'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'hi there'</span> <span>|</span> <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div><pre><code>$ md5sum <span>&lt;&lt;&lt;</span> <span>'ddd'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'ddd'</span> <span>|</span> md5sum
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>md5sum</code> 命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即 <code>md5sum ddd</code> 里面的 <code>ddd</code> 会被解释成文件名。这时就可以用 Here 字符串，将字符串传给 <code>md5sum</code> 命令。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">read 命令</title>
    <id>https://list-jiang.github.io/linux/bash/read/</id>
    <link href="https://list-jiang.github.io/linux/bash/read/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用法"> 用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用 <code>read</code> 命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code> 命令的格式如下。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>options</code> 是参数选项，<code>variable</code> 是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>下面是一个例子 <code>demo.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>read</span> text
<span>echo</span> <span>"您的输入: <span>$text</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量 <code>text</code>，在下一行显示出来。</p>
<div><pre><code>$ <span>bash</span> demo.sh
输入一些文本 <span>></span> 您好，世界
您的输入: 您好，世界
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 可以接受用户输入的多个值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> Please, enter your firstname and lastname
<span>read</span> FN LN
<span>echo</span> <span>"Hi! <span>$LN</span>, <span>$FN</span> !"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>read</code> 根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于 <code>read</code> 命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果 <code>read</code> 命令之后没有定义变量名，那么环境变量 <code>REPLY</code> 会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 命令除了读取键盘输入，可以用来读取文件。</p>
<div><pre><code><span>while</span> <span>read</span> myline
<span>do</span>
  <span>echo</span> <span>"<span>$myline</span>"</span>
<span>done</span> <span>&lt;</span> <span>$filename</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子通过 <code>read</code> 命令，读取一个文件的内容。<code>done</code> 命令后面的定向符 <code>&lt;</code>，将文件导向 <code>read</code> 命令，每次读取一行，存入变量 <code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数"> 参数</h2>
<p><code>read</code> 命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-t</code> 参数</strong></p>
<p><code>read</code> 命令的 <code>-t</code> 参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>if</span> <span>read</span> -t <span>3</span> response<span>;</span> <span>then</span>
  <span>echo</span> <span>"用户已经输入了"</span>
<span>else</span>
  <span>echo</span> <span>"用户没有输入"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code> 根据命令的返回值，转入 <code>else</code> 代码块，继续往下执行。</p>
<p>环境变量 <code>TMOUT</code> 也可以起到同样作用，指定 <code>read</code> 命令等待用户输入的时间(单位为秒)。</p>
<div><pre><code><span>TMOUT</span><span>=</span><span>3</span>
<span>read</span> response
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子也是等待 3 秒，如果用户还没有输入，就会超时。</p>
</li>
<li>
<p><strong><code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数指定用户输入的提示信息。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，先显示 <code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
</li>
<li>
<p><strong><code>-a</code> 参数</strong></p>
<p><code>-a</code> 参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div><pre><code>$ <span>read</span> -a people
alice duchess dodo
$ <span>echo</span> <span>${people<span>[</span>2<span>]</span>}</span>
dodo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，用户输入被赋值给一个数组 <code>people</code>，这个数组的 2 号成员就是 <code>dodo</code>。</p>
</li>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div><pre><code>$ <span>read</span> -n <span>3</span> letter
abcdefghij
$ <span>echo</span> <span>$letter</span>
abc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>letter</code> 只包含 3 个字母。</p>
</li>
<li>
<p><strong>-e 参数</strong></p>
<p><code>-e</code> 参数允许用户输入的时候，使用 <code>readline</code> 库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> Please input the path to the file:

<span>read</span> -e fileName

<span>echo</span> <span>$fileName</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>read</code> 命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是 <code>read</code> 命令的输入默认不支持 <code>readline</code> 库的功能。<code>-e</code> 参数就可以允许用户使用自动补全。</p>
</li>
<li>
<p><strong>其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>: 定义字符串 <code>delimiter</code> 的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>: raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>: 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>: 使用文件描述符 <code>fd</code> 作为输入。</li>
</ul>
</li>
</ol>
<h2 id="ifs-变量"> IFS 变量</h2>
<p><code>read</code> 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 <code>IFS</code>(内部字段分隔符，Internal Field Separator 的缩写)，修改分隔标志。</p>
<p><code>IFS</code> 的默认值是空格、Tab 符号、换行符号，通常取第一个(即空格)。</p>
<p>如果把 <code>IFS</code> 定义成冒号(<code>:</code>)或分号(<code>;</code>)，就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>

<span>FILE</span><span>=</span>/etc/passwd

<span>read</span> -p <span>"Enter a username > "</span> user_name
<span>file_info</span><span>=</span><span>"<span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>"</span>

<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
  <span>echo</span> <span>"User = '<span>$user</span>'"</span>
  <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
  <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
  <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
  <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
  <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
  <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面例子中，<code>IFS</code> 设为冒号，然后用来分解 <code>/etc/passwd</code> 文件的一行。<code>IFS</code> 的赋值命令和 <code>read</code> 命令写在一行，这样的话，<code>IFS</code> 的改变仅对后面的命令生效，该命令执行后 <code>IFS</code> 会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div><pre><code><span>OLD_IFS</span><span>=</span><span>"<span>$IFS</span>"</span>
<span><span>IFS</span></span><span>=</span><span>":"</span>
<span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
<span><span>IFS</span></span><span>=</span><span>"<span>$OLD_IFS</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外，上面例子中，<code>&lt;&lt;&lt;</code> 是 Here 字符串，用于将变量值转为标准输入，因为 <code>read</code> 命令只能解析标准输入。</p>
<p>如果 <code>IFS</code> 设为空字符串，就等同于将整行读入一个变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>input</span><span>=</span><span>"/path/to/txt/file"</span>
<span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r line
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>
<span>done</span> <span>&lt;</span> <span>"<span>$input</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的命令可以逐行读取文件，每一行存入变量 <code>line</code>，打印出来以后再读取下一行。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 行操作</title>
    <id>https://list-jiang.github.io/linux/bash/readline/</id>
    <link href="https://list-jiang.github.io/linux/bash/readline/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div><pre><code><span>set</span> -o <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面的命令可以改回 Emacs 快捷键。</p>
<div><pre><code><span>set</span> -o emacs
</code></pre>
<div><span>1</span><br></div></div><p>如果想永久性更改编辑模式(Emacs / Vi)，可以将命令写在 <code>~/.inputrc</code> 文件，这个文件是 Readline 的配置文件。</p>
<div><pre><code><span>set</span> editing-mode <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div><pre><code><span>bash</span> --noediting
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>--noediting</code> 参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动"> 光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>: 移到行首。</li>
<li><code>Ctrl + b</code>: 向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>: 移到行尾。</li>
<li><code>Ctrl + f</code>: 向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>: 移动到当前单词的词尾。</li>
<li><code>Alt + b</code>: 移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕"> 清除屏幕</h2>
<p><code>Ctrl + l</code> 快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与 <code>clear</code> 命令作用相同。</p>
<h2 id="编辑操作"> 编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>: 删除光标位置的字符(delete)。</li>
<li><code>Ctrl + w</code>: 删除光标前面的单词。</li>
<li><code>Ctrl + t</code>: 光标位置的字符与它前面一位的字符交换位置(transpose)。</li>
<li><code>Alt + t</code>: 光标位置的词与它前面一位的词交换位置(transpose)。</li>
<li><code>Alt + l</code>: 将光标位置至词尾转为小写(lowercase)。</li>
<li><code>Alt + u</code>: 将光标位置至词尾转为大写(uppercase)。</li>
</ul>
<p>使用 <code>Ctrl + d</code> 的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>: 剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>: 剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>: 剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>: 剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>: 在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全"> 自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入 <code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为 <code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以 <code>$</code> 开头，则按下 Tab 键会补全变量；如果以 <code>~</code> 开头，则补全用户名；如果以 <code>@</code> 开头，则补全主机名(hostname)，主机名以列在 <code>/etc/hosts</code> 文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab: 完成自动补全。</li>
<li><code>Alt + ?</code>: 列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>: 尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>: 先按 <code>Ctrl + x</code>，再按 <code>/</code>，等同于 <code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>: 命令补全。</li>
<li><code>Ctrl + x !</code>: 先按 <code>Ctrl + x</code>，再按 <code>!</code>，等同于 <code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>: 用户名补全。</li>
<li><code>Ctrl + x ~</code>: 先按 <code>Ctrl + x</code>，再按 <code>~</code>，等同于 <code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>: 变量名补全。</li>
<li><code>Ctrl + x $</code>: 先按 <code>Ctrl + x</code>，再按 <code>$</code>，等同于 <code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>: 主机名补全。</li>
<li><code>Ctrl + x @</code>: 先按 <code>Ctrl + x</code>，再按 <code>@</code>，等同于 <code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>: 在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>: 尝试用 <code>.bash_history</code> 里面以前执行命令，进行补全。</li>
</ul>
<p>上面的 <code>Alt</code> 键也可以用 ESC 键代替。</p>
<h2 id="操作历史"> 操作历史</h2>
<h3 id="基本用法"> 基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 <code>~/.bash_history</code> 文件，该文件默认储存 500 个操作。</p>
<p>环境变量 <code>HISTFILE</code> 总是指向这个文件。</p>
<div><pre><code>$ <span>echo</span> <span>$HISTFILE</span>
/home/me/.bash_history
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有了操作历史以后，就可以使用方向键的 <code>↑</code> 和 <code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div><pre><code>$ <span>echo</span> Hello World
Hello World

$ <span>echo</span> Goodbye
Goodbye

$ <span>!</span>e
<span>echo</span> Goodbye
Goodbye
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>!e</code> 表示找出操作历史之中，最近的那一条以 <code>e</code> 开头的命令并执行。Bash 会先输出那一条命令 <code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code> 也会执行最近一条以 <code>echo</code> 开头的命令。</p>
<div><pre><code>$ <span>!</span>echo
<span>echo</span> Goodbye
Goodbye

$ <span>!</span>echo H
<span>echo</span> Goodbye H
Goodbye H

$ <span>!</span>echo H G
<span>echo</span> Goodbye H G
Goodbye H G
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意，<code>!string</code> 语法只会匹配命令，不会匹配参数。所以 <code>!echo H</code> 不会执行 <code>echo Hello World</code>，而是会执行 <code>echo Goodbye</code>，并把参数 <code>H</code> 附加在这条命令之后。同理，<code>!echo H G</code> 也是等同于 <code>echo Goodbye</code> 命令之后附加 <code>H G</code>。</p>
<p>最后，按下 <code>Ctrl + r</code> 会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history-命令"> history 命令</h3>
<p><code>history</code> 命令能显示操作历史，即 <code>.bash_history</code> 文件的内容。</p>
<div><pre><code>$ <span>history</span>
<span>..</span>.
<span>498</span> <span>echo</span> Goodbye
<span>499</span> <span>ls</span> ~
<span>500</span> <span>cd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用该命令，而不是直接读取 <code>.bash_history</code> 文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量 <code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div><pre><code>$ <span>export</span> <span>HISTTIMEFORMAT</span><span>=</span><span>'%F %T  '</span>
$ <span>history</span>
<span>1</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>cat</span> /etc/issue
<span>2</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>clear</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>%F</code> 相当于 <code>%Y - %m - %d</code>，<code>%T</code> 相当于 <code>%H : %M : %S</code>。</p>
<p>只要设置 <code>HISTTIMEFORMAT</code> 这个环境变量，就会在 <code>.bash_history</code> 文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量 <code>HISTSIZE</code> 等于 0。</p>
<div><pre><code><span>export</span> <span><span>HISTSIZE</span></span><span>=</span><span>0</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果 <code>HISTSIZE=0</code> 写入用户主目录的 <code>~/.bashrc</code> 文件，那么就不会保留该用户的操作历史。如果写入 <code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合 <code>grep</code> 命令搜索操作历史。</p>
<div><pre><code><span>history</span> <span>|</span> <span>grep</span> /usr/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回 <code>.bash_history</code> 文件里面，那些包含 <code>/usr/bin</code> 的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用 <code>感叹号 + 编号</code> 执行该命令。如果想要执行 <code>.bash_history</code> 里面的第 8 条命令，可以像下面这样操作。</p>
<div><pre><code><span>!</span><span>8</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>history</code> 命令的 <code>-c</code> 参数可以清除操作历史。</p>
<div><pre><code><span>history</span> -c
</code></pre>
<div><span>1</span><br></div></div><h3 id="相关快捷键"> 相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>: 显示上一个命令，与向上箭头效果相同(previous)。</li>
<li><code>Ctrl + n</code>: 显示下一个命令，与向下箭头效果相同(next)。</li>
<li><code>Alt + &lt;</code>: 显示第一个命令。</li>
<li><code>Alt + &gt;</code>: 显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>: 执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>: 执行上一个命令。</li>
<li><code>!n</code>: 执行历史文件里面行号为 <code>n</code> 的命令。</li>
<li><code>!-n</code>: 执行当前命令之前 <code>n</code> 条的命令。</li>
<li><code>!string</code>: 执行最近一个以指定字符串 <code>string</code> 开头的命令。</li>
<li><code>!?string</code>: 执行最近一条包含字符串 <code>string</code> 的命令。</li>
<li><code>^string1^string2</code>: 执行最近一条包含 <code>string1</code> 的命令，将其替换成 <code>string2</code>。</li>
</ul>
<h2 id="其他快捷键"> 其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>: 等同于回车键(LINEFEED)。</li>
<li><code>Ctrl + m</code>: 等同于回车键(CARRIAGE RETURN)。</li>
<li><code>Ctrl + o</code>: 等同于回车键，并展示操作历史的下一个命令。</li>
<li><code>Ctrl + v</code>: 将下一个输入的特殊字符变成字面量，比如回车变成 <code>^M</code>。</li>
<li><code>Ctrl + [</code>: 等同于 ESC。</li>
<li><code>Alt + .</code>: 插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>: 等同于 <code>Alt + .</code>。</li>
</ul>
<p>上面的 <code>Alt + .</code> 快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div><pre><code><span>mkdir</span> foo_bar
<span>cd</span> <span>#按下 Alt + .</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，在 <code>cd</code> 命令后按下 <code>Alt + .</code>，就会自动插入 <code>foo_bar</code>。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 教程</title>
    <id>https://list-jiang.github.io/linux/bash/</id>
    <link href="https://list-jiang.github.io/linux/bash/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">简介</a></p>
</li>
<li>
<p><a href="./grammar.html">基本语法</a></p>
</li>
<li>
<p><a href="./expansion.html">模式扩展</a></p>
</li>
<li>
<p><a href="./quotation.html">引号和转义</a></p>
</li>
<li>
<p><a href="./variable.html">变量</a></p>
</li>
<li>
<p><a href="./string.html">字符串操作</a></p>
</li>
<li>
<p><a href="./arithmetic.html">算术运算</a></p>
</li>
<li>
<p><a href="./readline.html">行操作</a></p>
</li>
<li>
<p><a href="./stack.html">目录堆栈</a></p>
</li>
<li>
<p><a href="./script.html">脚本入门</a></p>
</li>
<li>
<p><a href="./read.html">read 命令</a></p>
</li>
<li>
<p><a href="./condition.html">条件判断</a></p>
</li>
<li>
<p><a href="./loop.html">循环</a></p>
</li>
<li>
<p><a href="./function.html">函数</a></p>
</li>
<li>
<p><a href="./array.html">数组</a></p>
</li>
<li>
<p><a href="./set.html">set 命令</a></p>
</li>
<li>
<p><a href="./debug.html">脚本除错</a></p>
</li>
<li>
<p><a href="./mktemp.html">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="./startup.html">启动环境</a></p>
</li>
<li>
<p><a href="./prompt.html">命令提示符</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 脚本入门</title>
    <id>https://list-jiang.github.io/linux/bash/script/</id>
    <link href="https://list-jiang.github.io/linux/bash/script/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>
]]></summary>
    <content type="html"><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>

<h2 id="shebang-行"> Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code> 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 <code>/bin/sh</code> 或 <code>/bin/bash</code>。</p>
<div><pre><code><span>#!/bin/sh</span>
<span># 或者</span>
<span>#!/bin/bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>#!</code> 与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录 <code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令使用 <code>env</code> 命令(这个命令总是在 <code>/usr/bin</code> 目录)，返回 Bash 可执行文件的位置。<code>env</code> 命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是 <code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div><pre><code>./script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是脚本文件名。脚本通常使用 <code>.sh</code> 后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div><pre><code>$ /bin/sh ./script.sh
<span># 或者</span>
$ <span>bash</span> ./script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="执行权限和路径"> 执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div><pre><code><span># 给所有用户执行权限</span>
$ <span>chmod</span> +x script.sh

<span># 给所有用户读权限和执行权限</span>
$ <span>chmod</span> +rx script.sh
<span># 或者</span>
$ <span>chmod</span> <span>755</span> script.sh

<span># 只给脚本拥有者读权限和执行权限</span>
$ <span>chmod</span> u+rx script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>脚本的权限通常设为 <code>755</code> (拥有者有所有权限，其他人有读和执行权限)或者 <code>700</code>(只有拥有者可以执行)。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径(比如 <code>path/script.sh</code>)。如果将脚本放在环境变量 <code>$PATH</code> 指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个 <code>~/bin</code> 子目录，专门存放可执行脚本，然后把 <code>~/bin</code> 加入 <code>$PATH</code>。</p>
<div><pre><code><span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:~/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令改变环境变量 <code>$PATH</code>，将 <code>~/bin</code> 添加到 <code>$PATH</code> 的末尾。可以将这一行加到 <code>~/.bashrc</code> 文件里面，然后重新加载一次 <code>.bashrc</code>，这个配置就可以生效了。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div><pre><code>script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面命令没有指定脚本路径，因为 <code>script.sh</code> 在 <code>$PATH</code> 指定的目录中。</p>
<h2 id="env-命令"> env 命令</h2>
<p><code>env</code> 命令总是指向 <code>/usr/bin/env</code> 文件，或者说，这个二进制文件总是在目录 <code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code> 这个语法的意思是，让 Shell 查找 <code>$PATH</code> 环境变量里面第一个匹配的 <code>NAME</code>。如果您不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code> 的意思就是，返回 <code>bash</code> 可执行文件的位置，前提是 <code>bash</code> 的路径是在 <code>$PATH</code> 里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env node</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>env</code> 命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>: 不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>: 从环境变量中删除一个变量。</li>
<li><code>--help</code>: 显示帮助。</li>
<li><code>--version</code>: 输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div><pre><code><span>env</span> -i /bin/sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="注释"> 注释</h2>
<p>Bash 脚本中，<code>#</code> 表示注释，可以放在行首，也可以放在行尾。</p>
<div><pre><code><span># 本行是注释</span>
<span>echo</span> <span>'Hello World!'</span>

<span>echo</span> <span>'Hello World!'</span> <span># 井号后面的部分也是注释</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数"> 脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div><pre><code>script.sh word1 word2 word3
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是一个脚本文件，<code>word1</code>、<code>word2</code> 和 <code>word3</code> 是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>: 脚本文件名，即 <code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>: 对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>: 参数的总数。</li>
<li><code>$@</code>: 全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 全部的参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>注意，如果命令是 <code>command -o foo bar</code>，那么 <code>-o</code> 是 <code>$1</code>，<code>foo</code> 是 <code>$2</code>，<code>bar</code> 是 <code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># script.sh</span>

<span>echo</span> <span>"全部参数: "</span> <span>$@</span>
<span>echo</span> <span>"命令行参数数量: "</span> <span>$#</span>
<span>echo</span> <span>'$0 = '</span> <span>$0</span>
<span>echo</span> <span>'$1 = '</span> <span>$1</span>
<span>echo</span> <span>'$2 = '</span> <span>$2</span>
<span>echo</span> <span>'$3 = '</span> <span>$3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ ./script.sh a b c
全部参数: a b c
命令行参数数量: <span>3</span>
<span>$0</span> <span>=</span>  script.sh
<span>$1</span> <span>=</span>  a
<span>$2</span> <span>=</span>  b
<span>$3</span> <span>=</span>  c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>用户可以输入任意数量的参数，利用 <code>for</code> 循环，可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>$@</code> 返回一个全部参数的列表，然后使用 <code>for</code> 循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div><pre><code>./script.sh <span>"a b"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 会认为 <code>&quot;a b&quot;</code> 是一个参数，<code>$1</code> 会返回 <code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令"> shift 命令</h2>
<p><code>shift</code> 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数 (<code>$1</code>)，使得后面的参数向前一位，即 <code>$2</code> 变成 <code>$1</code>、<code>$3</code> 变成 <code>$2</code>、<code>$4</code> 变成 <code>$3</code>，以此类推。</p>
<p><code>while</code> 循环结合 <code>shift</code> 命令，也可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"一共输入了 <span>$#</span> 个参数"</span>

<span>while</span> <span>[</span> <span>"<span>$1</span>"</span> <span>!=</span> <span>""</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"剩下 <span>$#</span> 个参数"</span>
  <span>echo</span> <span>"参数: <span>$1</span>"</span>
  <span>shift</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>shift</code> 命令每次移除当前第一个参数，从而通过 <code>while</code> 循环遍历所有参数。</p>
<p><code>shift</code> 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 <code>1</code>。</p>
<div><pre><code><span>shift</span> <span>3</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令移除前三个参数，原来的 <code>$4</code> 变成 <code>$1</code>。</p>
<h2 id="getopts-命令"> getopts 命令</h2>
<p><code>getopts</code> 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 <code>while</code> 循环一起使用，取出脚本所有的带有前置连词线 (<code>-</code>) 的参数。</p>
<div><pre><code><span>getopts</span> optstring name
</code></pre>
<div><span>1</span><br></div></div><p>它带有两个参数。第一个参数 <code>optstring</code> 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 <code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有 <code>-a</code> 可以带有参数值，而 <code>-l</code> 和 <code>-h</code> 是开关参数，那么 <code>getopts</code> 的第一个参数写成 <code>lha:</code>，顺序不重要。注意，<code>a</code> 后面有一个冒号，表示该参数带有参数值，<code>getopts</code> 规定带有参数值的配置项参数，后面必须带有一个冒号 (<code>:</code>)。<code>getopts</code> 的第二个参数 <code>name</code> 是一个变量名，用来保存当前取到的配置项参数，即 <code>l</code>、<code>h</code> 或 <code>a</code>。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>while</span> <span>getopts</span> <span>'lha:'</span> OPTION<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>$OPTION</span>"</span> <span>in</span>
    l<span>)</span>
      <span>echo</span> <span>"linuxconfig"</span>
      <span>;</span><span>;</span>

    h<span>)</span>
      <span>echo</span> <span>"h stands for h"</span>
      <span>;</span><span>;</span>

    a<span>)</span>
      <span>avalue</span><span>=</span><span>"<span>$OPTARG</span>"</span>
      <span>echo</span> <span>"The value provided is <span>$OPTARG</span>"</span>
      <span>;</span><span>;</span>
    ?<span>)</span>
      <span>echo</span> <span>"script usage: <span><span>$(</span><span>basename</span> $0<span>)</span></span> [-l] [-h] [-a somevalue]"</span> <span>></span><span>&amp;2</span>
      <span>exit</span> <span>1</span>
      <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>shift</span> <span>"<span><span>$((</span>$OPTIND <span>-</span> <span>1</span><span>))</span></span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>上面例子中，<code>while</code> 循环不断执行 <code>getopts 'lha:' OPTION</code> 命令，每次执行就会读取一个连词线参数(以及对应的参数值)，然后进入循环体。变量 <code>OPTION</code> 保存的是，当前处理的那一个连词线参数(即 <code>l</code>、<code>h</code> 或 <code>a</code>)。如果用户输入了没有指定的参数(比如 <code>-x</code>)，那么 <code>OPTION</code> 等于 <code>?</code>。循环体内使用 <code>case</code> 判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如 <code>-a foo</code>，那么处理 <code>a</code> 参数的时候，环境变量 <code>$OPTARG</code> 保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code> 就会执行失败，从而退出 <code>while</code> 循环。比如，<code>getopts</code> 可以解析 <code>command -l foo</code>，但不可以解析 <code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如 <code>command -lh</code>，<code>getopts</code> 也可以正确处理。</p>
<p>变量 <code>$OPTIND</code> 在 <code>getopts</code> 开始执行前是 <code>1</code>，然后每次执行就会加 <code>1</code>。等到退出 <code>while</code> 循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code> 就是已经处理的连词线参数个数，使用 <code>shift</code> 命令将这些参数移除，保证后面的代码可以用 <code>$1</code>、<code>$2</code> 等处理命令的主参数。</p>
<h2 id="配置项参数终止符"> 配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 <code>--</code>。</p>
<div><pre><code><span>myPath</span><span>=</span><span>"~/docs"</span>
<span>ls</span> -- <span>$myPath</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>--</code> 强制变量 <code>$myPath</code> 只能当作实体参数(即路径名)解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div><pre><code>$ <span>myPath</span><span>=</span><span>"-l"</span>
$ <span>ls</span> -- <span>$myPath</span>
ls: 无法访问<span>'-l'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>myPath</code> 的值为 <code>-l</code>，不是路径。但是，<code>--</code> 强制 <code>$myPath</code> 只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="exit-命令"> exit 命令</h2>
<p><code>exit</code> 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code> 命令后面可以跟参数，该参数就是退出状态。</p>
<div><pre><code><span># 退出值为0(成功)</span>
$ <span>exit</span> <span>0</span>

<span># 退出值为1(失败)</span>
$ <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code> 表示正常，<code>1</code> 表示发生错误，<code>2</code> 表示用法不对，<code>126</code> 表示不是可执行脚本，<code>127</code> 表示命令没有发现。如果脚本被信号 <code>N</code> 终止，则退出值为 <code>128 + N</code>。简单来说，只要退出值非 0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> <span>!=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"根用户才能执行当前脚本"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子中，<code>id -u</code> 命令返回用户的 ID，一旦用户的 ID 不等于 <code>0</code>(根用户的 ID)，脚本就会退出，并且退出码为 <code>1</code>，表示运行失败。</p>
<p><code>exit</code> 与 <code>return</code> 命令的差别是，<code>return</code> 命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code> 是整个脚本的退出，如果在函数之中调用 <code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果"> 命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code> 表示执行成功，非 <code>0</code> (通常是 <code>1</code>)表示执行失败。环境变量 <code>$?</code> 可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div><pre><code><span>cd</span> <span>$some_directory</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"无法切换目录!"</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cd $some_directory</code> 这个命令如果执行成功(返回值等于 <code>0</code>)，就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 <code>1</code>，表示执行失败。</p>
<p>由于 <code>if</code> 可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div><pre><code><span>if</span> <span>cd</span> <span>$some_directory</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"Could not change directory! Aborting."</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>更简洁的写法是利用两个逻辑运算符 <code>&amp;&amp;</code>(且)和 <code>||</code>(或)。</p>
<div><pre><code><span># 第一步执行成功，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 第一步执行失败，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="source-命令"> source 命令</h2>
<p><code>source</code> 命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div><pre><code><span>source</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><p><code>source</code> 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code> 命令执行脚本时，不需要 <code>export</code> 变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>
<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面脚本输出 <code>$foo</code> 变量的值。</p>
<div><pre><code><span># 当前 Shell 新建一个变量 foo</span>
$ <span>foo</span><span>=</span><span>1</span>

<span># 打印输出 1</span>
$ <span>source</span> test.sh
<span>1</span>

<span># 打印输出空字符串</span>
$ <span>bash</span> test.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，当前 Shell 的变量 <code>foo</code> 并没有 <code>export</code>，所以直接执行无法读取，但是 <code>source</code> 执行可以读取。</p>
<p><code>source</code> 命令的另一个用途，是在脚本内部加载外部库。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>source</span> ./lib.sh

function_from_lib
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本在内部使用 <code>source</code> 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code> 有一个简写形式，可以使用一个点 (<code>.</code>) 来表示。</p>
<div><pre><code><span>.</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><h2 id="别名-alias-命令"> 别名，alias 命令</h2>
<p><code>alias</code> 命令用来为一个命令指定别名，这样更便于记忆。下面是 <code>alias</code> 的格式。</p>
<div><pre><code><span>alias</span> <span>NAME</span><span>=</span>DEFINITION
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>NAME</code> 是别名的名称，<code>DEFINITION</code> 是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为 <code>grep</code> 命令起一个 <code>search</code> 的别名。</p>
<div><pre><code><span>alias</span> <span>search</span><span>=</span>grep
</code></pre>
<div><span>1</span><br></div></div><p><code>alias</code> 也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个 <code>today</code> 的命令。</p>
<div><pre><code>$ <span>alias</span> <span>today</span><span>=</span><span>'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span>6</span>, <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有时为了防止误删除文件，可以指定 <code>rm</code> 命令的别名。</p>
<div><pre><code><span>alias</span> <span>rm</span><span>=</span><span>'rm -i'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令指定 <code>rm</code> 命令是 <code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code> 定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div><pre><code>$ <span>alias</span> <span>echo</span><span>=</span><span>'echo It says: '</span>
$ <span>echo</span> hello world
It says: hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，别名定义了 <code>echo</code> 命令的前两个参数，等同于修改了 <code>echo</code> 命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在 <code>~/.bashrc</code> 的末尾。另外，只能为命令定义别名，为其他部分(比如很长的路径)定义别名是无效的。</p>
<p>直接调用 <code>alias</code> 命令，可以显示所有别名。</p>
<div><pre><code><span>alias</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>unalias</code> 命令可以解除别名。</p>
<div><pre><code><span>unalias</span> lt
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options" target="_blank" rel="noopener noreferrer">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">set 命令</title>
    <id>https://list-jiang.github.io/linux/bash/set/</id>
    <link href="https://list-jiang.github.io/linux/bash/set/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>
]]></summary>
    <content type="html"><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>

<h2 id="简介"> 简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div><pre><code><span>bash</span> script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code> 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div><pre><code><span>set</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-u"> set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh

bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -u

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p>
<div><pre><code><span>set</span> -o nounset
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-x"> set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -x

<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行上面的脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
+ <span>echo</span> bar
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p>
<div><pre><code><span>set</span> -o xtrace
</code></pre>
<div><span>1</span><br></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>1</span>

<span>set</span> -x
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number equals 1"</span>
<span>else</span>
  <span>echo</span> <span>"Number does not equal 1"</span>
<span>fi</span>
<span>set</span> +x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash-的错误处理"> Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div><pre><code><span>command</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div><pre><code><span># 写法一</span>
<span>command</span> <span>||</span> <span>{</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>}</span>

<span># 写法二</span>
<span>if</span> <span>!</span> <span>command</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>

<span># 写法三</span>
<span>command</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-e"> set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p>
<div><pre><code><span>set</span> +e
command1
command2
<span>set</span> -e
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

foo <span>||</span> <span>true</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p>
<p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p>
<div><pre><code><span>set</span> -o errexit
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-o-pipefail"> set -o pipefail</h2>
<p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p>
<p>请看下面这个例子。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -eo pipefail

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行后，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p>
<h2 id="其他参数"> 其他参数</h2>
<p><code>set</code> 命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p>
<h2 id="set-命令总结"> set 命令总结</h2>
<p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p>
<div><pre><code><span># 写法一</span>
<span>set</span> -euxo pipefail

<span># 写法二</span>
<span>set</span> -eux
<span>set</span> -o pipefail
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div><pre><code><span>bash</span> -euxo pipefail script.sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p>
<p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div><pre><code><span>shopt</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p>
<div><pre><code>$ <span>shopt</span> globstar
globstar  off
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p>
<ol>
<li>
<p><strong><code>-s</code></strong></p>
<p><code>-s</code> 用来打开某个参数。</p>
<div><pre><code><span>shopt</span> -s optionNameHere
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-u</code></strong></p>
<p><code>-u</code> 用来关闭某个参数。</p>
<div><pre><code><span>shopt</span> -u optionNameHere
</code></pre>
<div><span>1</span><br></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div><pre><code><span>shopt</span> -u histappend
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-q</code></strong></p>
<p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p>
<div><pre><code>$ <span>shopt</span> -q globstar
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p>
<div><pre><code><span>if</span> <span>shopt</span> -q globstar<span>;</span> <span>then</span>
  <span>..</span>.
<span>if</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">The Set built-in</a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/" target="_blank" rel="noopener noreferrer">Safer bash scripts with 'set -euxo pipefail’</a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener noreferrer">Writing Robust Bash Shell Scripts</a></li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">目录堆栈</title>
    <id>https://list-jiang.github.io/linux/bash/stack/</id>
    <link href="https://list-jiang.github.io/linux/bash/stack/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>
]]></summary>
    <content type="html"><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>

<h2 id="cd"> cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code> 命令可以返回前一次的目录。</p>
<div><pre><code><span># 当前目录是 /path/to/foo</span>
$ <span>cd</span> bar

<span># 重新回到 /path/to/foo</span>
$ <span>cd</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，用户原来所在的目录是 <code>/path/to/foo</code>，进入子目录 <code>bar</code> 以后，使用 <code>cd -</code> 可以回到原来的目录。</p>
<h2 id="pushd-popd"> pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用 <code>pushd</code> 命令和 <code>popd</code> 命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code> 命令的用法类似 <code>cd</code> 命令，可以进入指定的目录。</p>
<div><pre><code><span>pushd</span> <span>dirname</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会进入目录 <code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用 <code>pushd</code> 命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用 <code>pushd</code> 命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code> 命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录(即原来的第二条目录)。</p>
<p>下面是一个例子。</p>
<div><pre><code><span># 当前处在主目录，堆栈为空</span>
$ <span>pwd</span>
/home/me

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>pushd</span> ~/foo

<span># 进入 /etc</span>
<span># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span>pushd</span> /etc

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>popd</span>

<span># 进入 /home/me</span>
<span># 当前堆栈为 /home/me</span>
$ <span>popd</span>

<span># 目录不变，当前堆栈为空</span>
$ <span>popd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这两个命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 的参数表示仅操作堆栈，不改变目录。</p>
<div><pre><code><span>popd</span> -n
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
</li>
<li>
<p><strong>整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录(从 0 开始)，作为操作对象。这时不会切换目录。</p>
<div><pre><code><span># 从栈顶算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> +3

<span># 从栈底算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> -3

<span># 删除从栈顶算起的3号目录(从0开始)</span>
$ <span>popd</span> +3

<span># 删除从栈底算起的3号目录(从0开始)</span>
$ <span>popd</span> -3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子的整数编号都是从 0 开始计算，<code>popd +0</code> 是删除第一个目录，<code>popd +1</code> 是删除第二个，<code>popd -0</code> 是删除最后一个目录，，<code>popd -1</code> 是删除倒数第二个。</p>
</li>
<li>
<p><strong>目录参数</strong></p>
<p><code>pushd</code> 可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div><pre><code><span>pushd</span> <span>dir</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>popd</code> 没有这个参数。</p>
</li>
</ol>
<h2 id="dirs-命令"> dirs 命令</h2>
<p><code>dirs</code> 命令可以显示目录堆栈的内容，一般用来查看 <code>pushd</code> 和 <code>popd</code> 操作后的结果。</p>
<div><pre><code><span>dirs</span>
</code></pre>
<div><span>1</span><br></div></div><p>它有以下参数。</p>
<ul>
<li><code>-c</code>: 清空目录栈。</li>
<li><code>-l</code>: 用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>: 每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>: 每行一个条目，每个条目之前显示位置编号(从 0 开始)。</li>
<li><code>+N</code>: <code>N</code> 为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>: <code>N</code> 为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 启动环境</title>
    <id>https://list-jiang.github.io/linux/bash/startup/</id>
    <link href="https://list-jiang.github.io/linux/bash/startup/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="session"> Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session(对话)。</p>
<p>Session 有两种类型: 登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-session"> 登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>: 所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code> 目录里面所有 <code>.sh</code> 文件</li>
<li><code>~/.bash_profile</code>: 用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>: 如果 <code>~/.bash_profile</code> 没找到，则尝试执行这个脚本(C shell 的初始化脚本)。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>: 如果<code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都没找到，则尝试读取这个脚本(Bourne shell 和 Korn shell 的初始化脚本)。</li>
</ul>
<p>Linux 发行版更新的时候，会更新 <code>/etc</code> 里面的文件，比如 <code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在 <code>/etc/profile.d</code> 目录里面新建 <code>.sh</code> 脚本。</p>
<p>如果想修改您个人的登录环境，一般是写在 <code>~/.bash_profile</code> 里面。下面是一个典型的 <code>.bash_profile</code> 文件。</p>
<div><pre><code><span># .bash_profile</span>
<span><span>PATH</span></span><span>=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$HOME</span>/bin

<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>MANPATH</span><span>=</span>/usr/man:/usr/X11/man
<span>EDITOR</span><span>=</span>/usr/bin/vi
<span><span>PS1</span></span><span>=</span><span>'\h:\w\$ '</span>
<span><span>PS2</span></span><span>=</span><span>'> '</span>

<span>if</span> <span>[</span> -f ~/.bashrc <span>]</span><span>;</span> <span>then</span>
<span>.</span> ~/.bashrc
<span>fi</span>

<span>export</span> <span>PATH</span>
<span>export</span> EDITOR
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了 <code>~/.bashrc</code>。</p>
<p><code>bash</code> 命令的 <code>--login</code> 参数，会强制执行登录 Session 会执行的脚本。</p>
<div><pre><code><span>bash</span> --login
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--noprofile</code> 参数，会跳过上面这些 Profile 脚本。</p>
<div><pre><code><span>bash</span> --noprofile
</code></pre>
<div><span>1</span><br></div></div><h3 id="非登录-session"> 非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行 <code>bash</code> 命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>: 对全体用户有效。</li>
<li><code>~/.bashrc</code>: 仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code> 通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以 <code>~/.bashrc</code> 也是每次执行脚本都会执行的。</p>
<p><code>bash</code> 命令的 <code>--norc</code> 参数，可以禁止在非登录 Session 执行 <code>~/.bashrc</code> 脚本。</p>
<div><pre><code><span>bash</span> --norc
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--rcfile</code> 参数，指定另一个脚本代替 <code>.bashrc</code>。</p>
<div><pre><code><span>bash</span> --rcfile testrc
</code></pre>
<div><span>1</span><br></div></div><h3 id="bash-logout"> .bash_logout</h3>
<p><code>~/.bash_logout</code> 脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项"> 启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>: 不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>: 输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>: 每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div><pre><code><span>bash</span> -n scriptname
<span>bash</span> -v scriptname
<span>bash</span> -x scriptname
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="键盘绑定"> 键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为 <code>/etc/inputrc</code>，您可以在主目录创建自己的键盘绑定文件 <code>.inputrc</code> 文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div><pre><code><span>$include</span> /etc/inputrc
</code></pre>
<div><span>1</span><br></div></div><p><code>.inputrc</code> 文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code> 表示将 <code>Ctrl + t</code> 绑定为运行 <code>pwd</code> 命令。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">字符串操作</title>
    <id>https://list-jiang.github.io/linux/bash/string/</id>
    <link href="https://list-jiang.github.io/linux/bash/string/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>
]]></summary>
    <content type="html"><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>

<h2 id="字符串的长度"> 字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div><pre><code><span>${<span>#</span>varname}</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name
$ <span>echo</span> <span>${<span>#</span>myPath}</span>
<span>29</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>大括号 <code>{}</code> 是必需的，否则 Bash 会将 <code>$#</code> 理解成脚本的参数个数，将变量名理解成文本。</p>
<div><pre><code>$ <span>echo</span> <span>$#</span>myvar
0myvar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，Bash 将 <code>$#</code> 和 <code>myvar</code> 分开解释了。</p>
<h2 id="子字符串"> 子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div><pre><code><span>${varname<span>:</span>offset<span>:</span>length}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是返回变量 <code>$varname</code> 的子字符串，从位置 <code>offset</code> 开始(从 <code>0</code> 开始计算)，长度为 <code>length</code>。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4<span>:</span>4}</span>
foot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子返回字符串 <code>frogfootman</code> 从 4 号位置开始的长度为 4 的子字符串 <code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span>${"hello"<span>:</span>2<span>:</span>3}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 不是变量名，导致 Bash 报错。</p>
<p>如果省略 <code>length</code>，则从位置 <code>offset</code> 开始，一直返回到字符串的结尾。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4}</span>
footman
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子是返回变量 <code>count</code> 从 4 号位置一直到结尾的子字符串。</p>
<p>如果 <code>offset</code> 为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与 <code>${variable:-word}</code> 的变量的设置默认值语法混淆。这时，如果还指定 <code>length</code>，则 <code>length</code> 不能小于零。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>"This string is long."</span>
$ <span>echo</span> <span>${foo<span>:</span> -5}</span>
long.
$ <span>echo</span> <span>${foo<span>:</span> -5<span>:</span>2}</span>
lo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>offset</code> 为 <code>-5</code>，表示从倒数第 5 个字符开始截取，所以返回 <code>long.</code>。如果指定长度为 <code>2</code>，则返回 <code>lo</code>。</p>
<h2 id="搜索和替换"> 搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<h3 id="字符串头部的模式匹配"> 字符串头部的模式匹配</h3>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>#</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>##</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串开头的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<p>匹配模式 <code>pattern</code> 可以使用 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>#</span><span>/</span>*<span>/</span>}</span>
cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>##</span><span>/</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配的模式是 <code>/*/</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>/home/</code>，最长匹配是 <code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>##</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>*/</code> 匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>*-}</span>
<span>456</span>-1414
$ <span>echo</span> <span>${phone<span>##</span>*-}</span>
<span>1414</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>444}</span>
<span>555</span>-456-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，原始字符串里面无法匹配模式 <code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>#</span>JPG<span>/</span>jpg}</span>
jpg.JPG
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串头部，所以返回 <code>jpg.JPG</code>。</p>
<h3 id="字符串尾部的模式匹配"> 字符串尾部的模式匹配</h3>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%%</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串结尾的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span>.*}</span>
/home/cam/book/long.file

$ <span>echo</span> <span>${path<span>%%</span>.*}</span>
/home/cam/book/long
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配模式是 <code>.*</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>.name</code>，最长匹配是 <code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span><span>/</span>*}</span>
/home/cam/book
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>/*</code> 匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div><pre><code>$ <span>file</span><span>=</span>foo.png
$ <span>echo</span> <span>${file<span>%</span>.png}</span>.jpg
foo.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将文件的后缀名，从 <code>.png</code> 改成了 <code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>%</span>-*}</span>
<span>555</span>-456
$ <span>echo</span> <span>${phone<span>%%</span>-*}</span>
<span>555</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>%</span>JPG<span>/</span>jpg}</span>
JPG.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串尾部，所以返回 <code>JPG.jpg</code>。</p>
<h3 id="任意位置的模式匹配"> 任意位置的模式匹配</h3>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，但仅替换第一个匹配</span>
<span>${variable<span>/</span>pattern<span>/</span>string}</span>

<span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，所有匹配都替换</span>
<span>${variable<span>/</span><span>/</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法都是最长匹配(贪婪匹配)下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/foo.name

$ <span>echo</span> <span>${path<span>/</span><span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，前一个命令只替换了第一个 <code>foo</code>，后一个命令将两个 <code>foo</code> 都替换了。</p>
<p>下面的例子将分隔符从 <code>:</code> 换成换行符。</p>
<div><pre><code>$ <span>echo</span> -e <span>${<span>PATH</span><span>/</span><span>/</span><span>:</span><span>/</span>'\n'}</span>
/usr/local/bin
/usr/bin
/bin
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>echo</code> 命令的 <code>-e</code> 参数，表示将替换后的字符串的 <code>\n</code> 字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>/</span>5?4<span>/</span>-}</span>
<span>55</span>-56-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将 <code>5-4</code> 替换成 <code>-</code>。</p>
<p>如果省略了 <code>string</code> 部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>.*<span>/</span>}</span>
/home/cam/foo/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，第二个斜杠后面的 <code>string</code> 部分省略了，所以模式 <code>.*</code> 匹配的部分 <code>.name</code> 被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="改变大小写"> 改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div><pre><code><span># 转为大写</span>
<span>${varname<span>^^</span>}</span>

<span># 转为小写</span>
<span>${varname<span>,,</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span>heLLo
$ <span>echo</span> <span>${foo<span>^^</span>}</span>
HELLO
$ <span>echo</span> <span>${foo<span>,,</span>}</span>
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Bash 变量</title>
    <id>https://list-jiang.github.io/linux/bash/variable/</id>
    <link href="https://list-jiang.github.io/linux/bash/variable/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>

<h2 id="简介"> 简介</h2>
<p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code> 命令或 <code>printenv</code> 命令，可以显示所有环境变量。</p>
<div><pre><code>$ <span>env</span>
<span># 或者</span>
$ <span>printenv</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>: Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>: 当前 Shell 的参数，可以用 <code>shopt</code> 命令修改。</li>
<li><code>DISPLAY</code>: 图形环境的显示器名字，通常是 <code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>: 默认的文本编辑器。</li>
<li><code>HOME</code>: 用户的主目录。</li>
<li><code>HOST</code>: 当前主机的名称。</li>
<li><code>IFS</code>: 词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>: 字符集以及语言编码，比如 <code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>: 由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>: Shell 提示符。</li>
<li><code>PS2</code>: 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>: 当前工作目录。</li>
<li><code>RANDOM</code>: 返回一个 0 到 32767 之间的随机数。</li>
<li><code>SHELL</code>: Shell 的名字。</li>
<li><code>SHELLOPTS</code>: 启动当前 Shell 的 <code>set</code> 命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>: 终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>: 当前用户的 ID 编号。</li>
<li><code>USER</code>: 当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code> 和 <code>home</code> 是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用 <code>printenv</code> 命令或 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>printenv</span> <span>PATH</span>
<span># 或者</span>
$ <span>echo</span> <span>$PATH</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，<code>printenv</code> 命令后面的变量名，不用加前缀 <code>$</code>。</p>
<p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code> 命令可以显示所有变量(包括环境变量和自定义变量)，以及所有的 Bash 函数。</p>
<div><pre><code><span>set</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="创建变量"> 创建变量</h2>
<p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<div><pre><code><span>variable</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<div><pre><code><span>myvar</span><span>=</span><span>"hello world"</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<div><pre><code><span>a</span><span>=</span>z                     <span># 变量 a 赋值为字符串 z</span>
<span>b</span><span>=</span><span>"a string"</span>            <span># 变量值包含空格，就必须放在引号里面</span>
<span>c</span><span>=</span><span>"a string and <span>$b</span>"</span>     <span># 变量值可以引用其他变量的值</span>
<span>d</span><span>=</span><span>"<span title="\t">\t</span><span title="\t">\t</span>a string<span title="\n">\n</span>"</span>      <span># 变量值可以使用转义字符</span>
<span>e</span><span>=</span><span><span>$(</span><span>ls</span> -l foo.txt<span>)</span></span>      <span># 变量值可以是命令的执行结果</span>
<span>f</span><span>=</span><span><span>$((</span><span>5</span> <span>*</span> <span>7</span><span>))</span></span>            <span># 变量值可以是数学运算的结果</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
$ <span>echo</span> <span>$foo</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>foo</code> 的第二次赋值会覆盖第一次赋值。</p>
<h2 id="读取变量"> 读取变量</h2>
<p>读取变量的时候，直接在变量名前加上 <code>$</code> 就可以了。</p>
<div><pre><code>$ <span>foo</span><span>=</span>bar
$ <span>echo</span> <span>$foo</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>每当 Shell 看到以 <code>$</code> 开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于 <code>$</code> 在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<div><pre><code>$ <span>echo</span> The total is <span>$100</span>.00
The total is 00.00
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的原意是输入 <code>$100</code>，但是 Bash 将 <code>$1</code> 解释成了变量，该变量为空，因此输入就变成了 <code>00.00</code>。所以，如果要使用 <code>$</code> 的原义，需要在 <code>$</code> 前面放上反斜杠，进行转义。</p>
<div><pre><code>$ <span>echo</span> The total is <span>\</span><span>$100</span>.00
The total is <span>$100</span>.00
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>读取变量的时候，变量名也可以使用花括号 <code>{}</code> 包围，比如 <code>$a</code> 也可以写成 <code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<div><pre><code>$ <span>a</span><span>=</span>foo
$ <span>echo</span> <span>$a_file</span>

$ <span>echo</span> <span>${a}</span>_file
foo_file
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，变量名 <code>a_file</code> 不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分 <code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法 <code>$foo</code>，可以看作是 <code>${foo}</code> 的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用 <code>${!varname}</code> 的语法，读取最终的值。</p>
<div><pre><code>$ <span>myvar</span><span>=</span><span>USER</span>
$ <span>echo</span> <span>${<span>!</span>myvar}</span>
ruanyf
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子中，变量 <code>myvar</code> 的值是 <code>USER</code>，<code>${!myvar}</code> 的写法将其展开成最终的值。</p>
<h2 id="删除变量"> 删除变量</h2>
<p><code>unset</code> 命令用来删除一个变量。</p>
<div><pre><code><span>unset</span> NAME
</code></pre>
<div><span>1</span><br></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使 <code>unset</code> 命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<div><pre><code><span>foo</span><span>=</span><span>''</span>
<span>foo</span><span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面两种写法，都是删除了变量 <code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="输出变量-export-命令"> 输出变量，export 命令</h2>
<p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 <code>export</code> 命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code> 命令用来向子 Shell 输出变量。</p>
<div><pre><code><span>NAME</span><span>=</span>foo
<span>export</span> NAME
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令输出了变量 <code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<div><pre><code><span>export</span> <span>NAME</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量 <code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<div><pre><code><span># 输出变量 $foo</span>
$ <span>export</span> <span>foo</span><span>=</span>bar

<span># 新建子 Shell</span>
$ <span>bash</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar

<span># 修改继承的变量</span>
$ <span>foo</span><span>=</span>baz

<span># 退出子 Shell</span>
$ <span>exit</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上面例子中，子 Shell 修改了继承的变量 <code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="特殊变量"> 特殊变量</h2>
<p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>(1) <code>$?</code></p>
<p><code>$?</code> 为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 <code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<div><pre><code>$ <span>ls</span> doesnotexist
ls: doesnotexist: No such <span>file</span> or directory

$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>ls</code> 命令查看一个不存在的文件，导致报错。<code>$?</code> 为 1，表示上一个命令执行失败。</p>
<p>(2) <code>$$</code></p>
<p><code>$$</code> 为当前 Shell 的进程 ID。</p>
<div><pre><code>$ <span>echo</span> <span>$$</span>
<span>10662</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个特殊变量可以用来命名临时文件。</p>
<div><pre><code><span>LOGFILE</span><span>=</span>/tmp/output_log.<span>$$</span>
</code></pre>
<div><span>1</span><br></div></div><p>(3) <code>$_</code></p>
<p><code>$_</code> 为上一个命令的最后一个参数。</p>
<div><pre><code>$ <span>grep</span> dictionary /usr/share/dict/words
dictionary

$ <span>echo</span> <span>$_</span>
/usr/share/dict/words
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>(4) <code>$!</code></p>
<p><code>$!</code> 为最近一个后台执行的异步命令的进程 ID。</p>
<div><pre><code>$ firefox <span>&amp;</span>
<span>[</span><span>1</span><span>]</span> <span>11064</span>

$ <span>echo</span> <span>$!</span>
<span>11064</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>firefox</code> 是后台运行的命令，<code>$!</code> 返回该命令的进程 ID。</p>
<p>(5) <code>$0</code></p>
<p><code>$0</code> 为当前 Shell 的名称(在命令行直接执行时)或者脚本名(在脚本中执行时)。</p>
<div><pre><code>$ <span>echo</span> <span>$0</span>
<span>bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>$0</code> 返回当前运行的是 Bash。</p>
<p>(6) <code>$-</code></p>
<p><code>$-</code> 为当前 Shell 的启动参数。</p>
<div><pre><code>$ <span>echo</span> $-
himBHs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>(7) <code>$@</code> 和 <code>$#</code></p>
<p><code>$@</code> 和 <code>$#</code> 表示脚本的参数数量，参见脚本一章。</p>
<h2 id="变量的默认值"> 变量的默认值</h2>
<p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<div><pre><code><span>${varname<span>:-</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则返回 <code>word</code>。它的目的是返回一个默认值，比如 <code>${count:-0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:=</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则将它设为 <code>word</code>，并且返回 <code>word</code>。它的目的是设置变量的默认值，比如 <code>${count:=0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>，且将 <code>count</code> 设为 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:+</span>word}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量名存在且不为空，则返回 <code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如 <code>${count:+1}</code> 表示变量 <code>count</code> 存在时返回 <code>1</code>(表示 <code>true</code>)，否则返回空值。</p>
<div><pre><code><span>${varname<span>:?</span>message}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则打印出 <code>varname: message</code>，并中断脚本的执行。如果省略了 <code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如 <code>${count:?&quot;undefined!&quot;}</code> 表示变量 <code>count</code> 未定义时就中断执行，抛出错误，返回给定的报错信息 <code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用到数字 <code>1</code> 到 <code>9</code>，表示脚本的参数。</p>
<div><pre><code><span>filename</span><span>=</span><span>${1<span>:?</span>"filename missing."}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码出现在脚本中，<code>1</code> 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare-命令"> declare 命令</h2>
<p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<div><pre><code><span>declare</span> OPTION <span>VARIABLE</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p><code>declare</code> 命令的主要参数(OPTION)如下。</p>
<ul>
<li><code>-a</code>: 声明数组变量。</li>
<li><code>-f</code>: 输出所有函数定义。</li>
<li><code>-F</code>: 输出所有函数名。</li>
<li><code>-i</code>: 声明整数变量。</li>
<li><code>-l</code>: 声明变量为小写字母。</li>
<li><code>-p</code>: 查看变量信息。</li>
<li><code>-r</code>: 声明只读变量。</li>
<li><code>-u</code>: 声明变量为大写字母。</li>
<li><code>-x</code>: 该变量输出为环境变量。</li>
</ul>
<p><code>declare</code> 命令如果用在函数中，声明的变量只在函数内部有效，等同于 <code>local</code> 命令。</p>
<p>不带任何参数时，<code>declare</code> 命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的 <code>set</code> 命令。</p>
<div><pre><code><span>declare</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>(1) <code>-i</code> 参数</strong></p>
<p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p>
<div><pre><code>$ <span>declare</span> -i <span>val1</span><span>=</span><span>12</span> <span>val2</span><span>=</span><span>5</span>
$ <span>declare</span> -i result
$ <span>result</span><span>=</span>val1*val2
$ <span>echo</span> <span>$result</span>
<span>60</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，如果变量 <code>result</code> 不声明为整数，<code>val1*val2</code> 会被当作字面量，不会进行整数运算。另外，<code>val1</code> 和 <code>val2</code> 其实不需要声明为整数，因为只要 <code>result</code> 声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<div><pre><code>$ <span>declare</span> -i <span>var</span><span>=</span><span>12</span>
$ <span>var</span><span>=</span>foo
$ <span>echo</span> <span>$var</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>var</code> 声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。</p>
<p><strong>(2) <code>-x</code> 参数</strong></p>
<p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 Shell 的环境变量。</p>
<div><pre><code>$ <span>declare</span> -x foo
<span># 等同于</span>
$ <span>export</span> foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>(3) <code>-r</code> 参数</strong></p>
<p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>declare</span> -r <span>bar</span><span>=</span><span>1</span>

$ <span>bar</span><span>=</span><span>2</span>
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>

$ <span>unset</span> bar
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>(4) <code>-u</code> 参数</strong></p>
<p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<div><pre><code>$ <span>declare</span> -u foo
$ <span>foo</span><span>=</span>upper
$ <span>echo</span> <span>$foo</span>
UPPER
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>(5) <code>-l</code> 参数</strong></p>
<p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<div><pre><code>$ <span>declare</span> -l bar
$ <span>bar</span><span>=</span>LOWER
$ <span>echo</span> <span>$bar</span>
lower
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>(6) <code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数输出变量信息。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>declare</span> -p foo
<span>declare</span> -- <span>foo</span><span>=</span><span>"hello"</span>
$ <span>declare</span> -p bar
bar: 未找到
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>declare -p</code> 可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code> 输出所有变量的信息。</p>
<div><pre><code><span>declare</span> -p
</code></pre>
<div><span>1</span><br></div></div><p><strong>(7) <code>-f</code> 参数</strong></p>
<p><code>-f</code> 参数输出当前环境的所有函数，包括它的定义。</p>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p><strong>(8) <code>-F</code> 参数</strong></p>
<p><code>-F</code> 参数输出当前环境的所有函数名，不包含函数定义。</p>
<div><pre><code><span>declare</span> -F
</code></pre>
<div><span>1</span><br></div></div><h2 id="readonly-命令"> readonly 命令</h2>
<p><code>readonly</code> 命令等同于 <code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>readonly</span> <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
bash: foo: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，更改只读变量 <code>foo</code> 会报错，命令执行失败。</p>
<p><code>readonly</code> 命令有三个参数。</p>
<ul>
<li><code>-f</code>: 声明的变量为函数名。</li>
<li><code>-p</code>: 打印出所有的只读变量。</li>
<li><code>-a</code>: 声明的变量为数组。</li>
</ul>
<h2 id="let-命令"> let 命令</h2>
<p><code>let</code> 命令声明变量时，可以直接执行算术表达式。</p>
<div><pre><code>$ <span>let</span> <span>foo</span><span>=</span><span>1</span>+2
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>let</code> 命令可以直接计算 <code>1 + 2</code>。</p>
<p><code>let</code> 命令的参数表达式如果包含空格，就需要使用引号。</p>
<div><pre><code><span>let</span> <span>"foo = 1 + 2"</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>let</code> 可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<div><pre><code>$ <span>let</span> <span>"v1 = 1"</span> <span>"v2 = v1++"</span>
$ <span>echo</span> <span>$v1</span>,<span>$v2</span>
<span>2,1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>let</code> 声明了两个变量 <code>v1</code> 和 <code>v2</code>，其中 <code>v2</code> 等于 <code>v1++</code>，表示先返回 <code>v1</code> 的值，然后 <code>v1</code> 自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
]]></content>
    <author>
      <name>阮一峰</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>阮一峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">命令补全</title>
    <id>https://list-jiang.github.io/linux/command/add/</id>
    <link href="https://list-jiang.github.io/linux/command/add/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <summary type="html"><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>
]]></summary>
    <content type="html"><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>

<p>举个例子，在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /etc</span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> fs <span>&lt;</span>-- 按一次 Tab 键</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当按下 Tab 键时，您会发现 Shell 自动将 &quot;fs&quot; 补全成了 &quot;fatab&quot;，这是因为当前 <code>/etc</code> 目录中只有 fstab 是以 &quot;fs&quot; 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。</p>
<p>那么，如果当前目录中含有多个以指定字符(或字符串)开头的目录或文件，Shell 还可以成功辨认吗? 答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。</p>
<p>例如，还是在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> b <span>&lt;</span>-- 连续按两次 Tab 键</span></span>
<span>bash_completion.d/      blkid/          bonobo-activation/
bashrc                  bluetooth
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 &quot;b&quot; 为开头的文件或目录有多个(2 个以上)，仅凭一个字符 &quot;b&quot; 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 &quot;b&quot; 开头的文件或目录。</p>
<p>事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 <code>ca</code> 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 &quot;ca&quot; 开头的 Linux 命令，如下所示:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>ca <span>&lt;</span>--连续按两次 Tab 键</span></span>
<span>cacertdir_rehash    cache_restore       capsh       catchsegv
cache_check         cal                 captoinfo
cache_dump          caller              case
cache_repair        canberra-gtk-play   cat
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>另外，Shell 还有一套被称作通配符的转用符号，这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。</p>
<ul>
<li><code>*</code>: 匹配任意数量的字符。</li>
<li><code>?</code>: 匹配任意一个字符。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符，甚至 <code>[]</code> 中还可以包含用 <code>-</code>(短横线)连接的字符或数字，表示一定范围内的字符或数字。</li>
</ul>
<p>为了学习这些通配符的用法，首先需要建立一个空目录(如 test)，并在该目录中创建一些文件(供测试用)，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>makdir <span>test</span></span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> <span>test</span></span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>touch</span> apple banana grape grapefruit watermelon</span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>apple banana grape grapefruit watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在此基础上，继续执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> a* <span>&lt;</span>--匹配所有以 a 字符开头的文件名</span></span>
<span>apple
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g*t <span>&lt;</span>--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span></span>
<span>grapefruit
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *e* <span>&lt;</span>--匹配所有包含 e 字符的文件名</span></span>
<span>apple grape grapefruit watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *n* <span>&lt;</span>--匹配所有包含 n 字符的文件名</span></span>
<span>banana watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>结合以上实例，因为 <code>*</code> 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。</p>
<p>接下来，列举一下使用 ? 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> ????e</span></span>
<span>apple grape
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g???e*</span></span>
<span>grape grapefruit
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件(apple 和 grape)，第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件(grape 和 grapefruit)。</p>
<p>最后，列举一些使用括号 <code>[]</code> 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>abw<span>]</span>*</span></span>
<span>apple banana watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>agw<span>]</span>*<span>[</span>ne<span>]</span></span></span>
<span>apple grape watermelon
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。</p>
<p>不仅如此，<code>[]</code> 中还可以通过 -(短横线)表示一定范围内的任意字符(或数字)，例如:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>a-g<span>]</span>*</span></span>
<span>apple banana grape grapefruit
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>其中，<code>[a-g]*</code> 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">基本格式</title>
    <id>https://list-jiang.github.io/linux/command/command/</id>
    <link href="https://list-jiang.github.io/linux/command/command/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="命令提示符"> 命令提示符</h2>
<p>登录系统后，第一眼看到的内容是:</p>
<div><pre><code><span>[root@localhost ~]#
</span></code></pre>
<div><span>1</span><br></div></div><p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢?</p>
<ul>
<li><code>[]</code>: 这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>: 显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li><code>@</code>: 分隔符号，没有特殊含义。</li>
<li><code>localhost</code>: 当前系统的简写主机名(完整主机名是 <code>localhost.localdomain</code>)。</li>
<li><code>~</code>: 代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>: 命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 <code>#</code>；如果是普通用户，提示符就是 <code>$</code>。</li>
</ul>
<p>家目录(又称主目录)是什么? Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家:
超级用户的家目录: <code>/root</code>。
普通用户的家目录: <code>/home/用户名</code>。</p>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /usr/local</span></span>
<span>[root@localhost local]#
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录(不显示完整的所在目录 <code>/usr/loca</code>l，只显示最后一个目录 <code>local</code>)。</p>
<h2 id="命令的基本格式"> 命令的基本格式</h2>
<p>接下来看看 Linux 命令的基本格式:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>命令<span>[</span>选项<span>]</span><span>[</span>参数<span>]</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>命令格式中的 <code>[]</code> 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 <code>ls</code> 命令来解释一下命令的格式(有关 <code>ls</code> 命令的具体用法，后续章节会详细介绍)。如果按照命令的分类，那么 <code>ls</code> 命令应该属于目录操作命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol>
<li>
<p>选项的作用</p>
<p>选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项(<code>-l</code>)和长格式选项(-<code>-all</code>)。短格式选项是英文的简写，用一个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
</code></pre>
<div><span>1</span><br></div></div><p>而长格式选项是英文完整单词，一般用两个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --all</span>
</code></pre>
<div><span>1</span><br></div></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 <code>ls</code> 命令的短格式选项 <code>-l</code> 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
</li>
<li>
<p>参数的作用</p>
<p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l anaconda-ks.cfg</span>
-rw-------.1 root root <span>1207</span> <span>1</span> 月 <span>14</span> <span>18</span>:18 anaconda-ks.cfg
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>但是为什么一开始 <code>ls</code> 命令可以省略参数? 那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这个 <code>ls</code> 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
</li>
</ol>
<p>总结一下: <strong>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</strong></p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">文件夹</title>
    <id>https://list-jiang.github.io/linux/command/dir/</id>
    <link href="https://list-jiang.github.io/linux/command/dir/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="pwd-命令"> pwd 命令</h2>
<p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录(目前的工作目录)搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢? 可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。</p>
<p>pwd 命令，是 Print Working Directory (打印工作目录)的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>pwd</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="cd-命令"> cd 命令</h2>
<p>cd 命令，是 Change Directory 的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。</p>
<p>cd 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>[</span>相对路径或绝对路径<span>]</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义。</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td><code>~&lt;用户名&gt;</code></td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td><code>-</code></td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表当前目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>在 Linux 系统中，根目录确实存在 <code>.</code>(当前目录)以及 <code>..</code>(当前目录的父目录)两个目录，但由于根目录是最顶级目录，因此根目录的 <code>..</code> 和 <code>.</code> 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
</div>
<h2 id="ls-命令"> ls 命令</h2>
<p>ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> <span>[</span>选项<span>]</span> 目录名称</span></span>
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示全部的文件，包括隐藏文件(开头为 <code>.</code> 的文件)也一起罗列出来，这是最常用的选项之一。</td>
</tr>
<tr>
<td>-A</td>
<td>显示全部的文件，连同隐藏文件，但不包括 <code>.</code> 与 <code>..</code> 这两个目录。</td>
</tr>
<tr>
<td>-d</td>
<td>仅列出目录本身，而不是列出目录内的文件数据。</td>
</tr>
<tr>
<td>-f</td>
<td>ls 默认会以文件名排序，使用 <code>-f</code> 选项会直接列出结果，而不进行排序。</td>
</tr>
<tr>
<td>-F</td>
<td>在文件或目录名后加上文件类型的指示符号，例如，<code>*</code> 代表可运行文件，<code>/</code> 代表目录，= 代表 socket 文件，</td>
</tr>
<tr>
<td>-h</td>
<td>以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td>
</tr>
<tr>
<td>-i</td>
<td>显示 inode 节点信息。</td>
</tr>
<tr>
<td>-l</td>
<td>使用长格式列出文件和目录信息。</td>
</tr>
<tr>
<td>-n</td>
<td>以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td>
</tr>
<tr>
<td>-r</td>
<td>将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td>
</tr>
<tr>
<td>-R</td>
<td>连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td>
</tr>
<tr>
<td>-S</td>
<td>以文件容量大小排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>-t</td>
<td>以时间排序，而不是以文件名排序。</td>
</tr>
<tr>
<td>--color=never<br />--color=always<br />--color=auto</td>
<td><code>never</code> 表示不依据文件特性给予颜色显示。<br /><code>always</code> 表示显示颜色，ls 默认采用这种方式。<br /><code>auto</code> 表示让系统自行依据配置来判断是否给予颜色。</td>
</tr>
<tr>
<td>--full-time</td>
<td>以完整时间模式 (包含年、月、日、时、分)输出</td>
</tr>
<tr>
<td>--time={atime,ctime}</td>
<td>输出 access 时间或改变权限属性时间(ctime)，而不是内容变更时间。</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色(蓝色显示目录，白色显示一般文件)。</p>
</div>
<div><p>提示</p>
<p>ls 命令使用了 <code>-l</code> 选项，显示出文件的详细信息，此选项显示的这 7 列的含义分别是:</p>
<ul>
<li>第一列: 规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列: 引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列: 所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列: 所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列: 大小，默认单位是字节。</li>
<li>第六列: 文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列: 文件名或目录名。</li>
</ul>
</div>
<h2 id="mkdir-命令"> mkdir 命令</h2>
<p>mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<p>mkdir 命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> <span>[</span>-mp<span>]</span> 目录名</span></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li>-p 选项递归创建所有目录，以创建 <code>/home/test/demo</code> 为例，在默认情况下，您需要一层一层的创建各个目录，而使用 <code>-p</code> 选项，则系统会自动帮您创建 <code>/home</code>、<code>/home/test</code> 以及 <code>/home/test/demo</code>。</li>
</ul>
<h2 id="rmdir-命令"> rmdir 命令</h2>
<p>和 mkdir 命令(创建空目录)恰好相反，rmdir(remove empty directories 的缩写)命令用于删除空目录，此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rmdir</span> <span>[</span>-p<span>]</span> 目录名</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>-p 选项用于递归删除空目录。</p>
<div><p>提示</p>
<p>rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</p>
</div>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">命令执行</title>
    <id>https://list-jiang.github.io/linux/command/excu/</id>
    <link href="https://list-jiang.github.io/linux/command/excu/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢?</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<ol>
<li>
<p>判断路径</p>
<p>判断用户是否以绝对路径或相对路径的方式输入命令(如 <code>/bin/ls</code>)，如果是的话直接执行。</p>
</li>
<li>
<p>检查别名</p>
<p>Linux 系统会检查用户输入的命令是否为 “别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p>
<p>例如，我们经常使用的 <code>rm</code> 命令，其实就是 <code>rm -i</code> 这个整体的别名:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt <span>&lt;</span>-- 假定当前目录中已经存在 a.txt 文件</span></span>
<span>rm: remove regular file 'a.txt'? y  &lt;-- 手动输入 y，即确定删除
[root@localhost ~]#
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里可以使用 <code>unalias</code> 命令，将 Linux 系统设置的 <code>rm</code> 别名删除掉，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>unalias</span> <span>rm</span></span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span>  <span><span>&lt;</span>--直接删除，不再询问</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>判断是内部命令还是外部命令</p>
<p>Linux 命令行解释器 (又称为 Shell) 会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p>
<p>判断一个命令属于内部命令还是外部命令，可以使用 <code>type</code> 命令实现。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>pwd</span></span></span>
<span>pwd is a shell builtin  &lt;-- pwd是内部命令
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>top</span></span></span>
<span>top is /usr/bin/top  &lt;-- top是外部命令
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>查找外部命令对应的可执行文件</p>
<p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止(如果找不到，Shell 会提供用户“找不到此命令”)。</p>
</li>
</ol>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>https://list-jiang.github.io/linux/command/file/</id>
    <link href="https://list-jiang.github.io/linux/command/file/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="touch-命令"> touch 命令</h2>
<p>需要注意的是，touch 命令不光可以用来创建文件(当指定操作文件不存在时，该命令会在当前位置建立一个空文件)，此命令更重要的功能是修改文件的时间参数(但当文件存在时，会修改此文件的时间参数)。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间:</p>
<ul>
<li>访问时间 (Access Time，简称 atime): 只要文件的内容被读取，访问时间就会更新。例如，使用 <code>cat</code> 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间 (Modify Time，简称 mtime): 当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间 (Change Time，简称 ctime): 当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<p>touch 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>[</span>选项<span>]</span> 文件名</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-a: 只修改文件的访问时间；</li>
<li>-c: 仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件。</li>
<li>-d: 后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m: 只修改文件的数据修改时间。</li>
<li>-t: 命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变(更新为操作当前文件的真正时间)。</p>
<h2 id="ln-命令"> ln 命令</h2>
<p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统(Linux 文件系统)是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。</p>
<p>ext4 文件系统会把分区主要分为两大部分(暂时不提超级块): 小部分用于保存文件的 inode (i 节点)信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限(r、w、x)、文件的所有者和属组、文件的大小、文件的状态改变时间(ctime)、文件的最近一次读取时间(atime)、文件的最近一次修改时间(mtime)、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息:</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种:</p>
<ul>
<li>软链接: 类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接: 我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>ln 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-s: 建立软链接文件。如果不加 <code>-s</code> 选项，则建立硬链接文件；</li>
<li>-f: 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<h3 id="ln-扩展介绍"> ln 扩展介绍</h3>
<ul>
<li><a href="./ln.html">点击前往</a></li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-19T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">其他文件命令</title>
    <id>https://list-jiang.github.io/linux/command/other/</id>
    <link href="https://list-jiang.github.io/linux/command/other/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="cp-命令"> cp 命令</h2>
<p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<p>cp 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-a: 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li>
<li>-d: 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接；</li>
<li>-i: 询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s: 把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p: 复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)；</li>
<li>-r: 递归复制，用于复制目录；</li>
<li>-u: 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p>
<h3 id="cp-命令基本用法"> cp 命令基本用法</h3>
<p>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>#把源文件不改名复制到 /tmp/ 目录下
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果需要改名复制，则命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/bols</span></span>
<span>#改名复制
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是 <code>cp -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>cp:是否覆盖"/tmp/cangls"?y
#目标位置有同名文件，所以会提示是否覆盖
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 <code>-r</code> 选项即可，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span>#建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -r /root/movie/ /tmp/</span></span>
<span>#目录原名复制
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="复制软链接文件"> 复制软链接文件</h3>
<p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢? 我们试试:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/cangls /tmp/cangls_slink</span></span>
<span>#建立一个测试软链接文件/tmp/cangls_slink
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_slink</span></span>
<span>lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -> /root/cangls
#源文件本身就是一个软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /tmp/cangls_slink /tmp/cangls_t1</span></span>
<span>#复制软链接文件，但是不加"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -d /tmp/cangls_slink /tmp/cangls_t2</span></span>
<span>#复制软链接文件，加入"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_t1 /tmp/cangls_t2</span></span>
<span>-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1
#会发现不加"-d"选项，实际复制的是软链接的源文件，而不是软链接文件
lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-> /root/cangls
#而如果加入了"-d"选项，则会复制软链接文件
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>这个例子说明，如果在复制软链接文件时不使用 <code>-d</code> 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 <code>-d</code> 选项，才会复制软链接文件。请大家注意，<code>-d</code> 选项对硬链接是无效的。</p>
<h3 id="保留源文件属性复制"> 保留源文件属性复制</h3>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /var/lib/mlocate/mlocate.db /tmp/</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db</span></span>
<span>-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db
#注意源文件的时间和所属组
[root@localhost ~]#ll /tmp/mlocate.db
-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db
#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 <code>-p</code> 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>#使用"-p"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2
-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db
#源文件和目标文件的所有属性都一致，包括时间
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们之前讲过，<code>-a</code> 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 <code>-a</code> 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 <code>-a</code> 选项来取代 &quot;-d、-p、-r&quot; 选项更加方便。</p>
<h3 id="l-和-s-选项"> &quot;-l&quot; 和 &quot;-s&quot; 选项</h3>
<p>我们如果使用 <code>-l</code> 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 <code>-s</code> 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 <code>-d</code> 选项是不同的，<code>d</code> 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 <code>-l</code> 和 <code>-s</code> 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> bols</span></span>
<span>#建立测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i bols</span></span>
<span>262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols
#源文件只是一个普通文件，而不是软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -l /root/bols /tmp/bols_h</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -s /root/bols /tmp/bols_s</span></span>
<span>#使用"-l" 和"-s"选项复制
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /tmp/bols_h /tmp/bols_s</span></span>
<span>262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h
#目标文件 /tmp/bols_h 为源文件的硬链接文件
932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -> /root/bols
#目标文件 /tmp/bols_s 为源文件的软链接文件
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="rm-命令"> rm 命令</h2>
<p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件(即垃圾)，这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p>
<p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>rm<span>[</span>选项<span>]</span> 文件或目录</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-f: 强制删除(force)，和 <code>-i</code> 选项相反，使用 <code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>-i: 和 <code>-f</code> 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 <code>-i</code> 可以有效防止不小心删除有用的文件或目录。</li>
<li>-r: 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<div><p>提示</p>
<p>rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p>
</div>
<h3 id="基本用法"> 基本用法</h3>
<p>rm 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> cangls</span></span>
<span>rm:是否删除普通空文件"cangls"?y
#删除前会询问是否删除
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="删除目录"> 删除目录</h3>
<p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#递归建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> /test</span></span>
<span>rm:无法删除"/test/": 是一个目录
#如果不加"-r"选项，则会报错
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -r /test</span></span>
<span>rm:是否进入目录"/test"?y
rm:是否进入目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm/movie/jp"?y
rm:是否删除目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm"?y
rm:是否删除目录"/test"?y
#会分别询问是否进入子目录、是否删除子目录
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p>
<h3 id="强制删除"> 强制删除</h3>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#重新建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -rf /test</span></span>
<span>#强制删除，一了百了
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 <code>-rf</code> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <code>-rf</code> 选项。</p>
<h2 id="mv-命令"> mv 命令</h2>
<p>mv 命令(move 的缩写)，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> 【选项】 源文件 目标文件</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>选项:</p>
<ul>
<li>-f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)；</li>
<li>-n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v: 显示文件或目录的移动过程；</li>
<li>-u: 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
<h3 id="移动文件或目录"> 移动文件或目录</h3>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>#移动之后，源文件会被删除，类似剪切
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> movie/ /tmp</span></span>
<span>#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 "-r" 选项
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 <code>mv -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>mv:县否覆盖"tmp/cangls"? y
#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="强制移动"> 强制移动</h3>
<p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 <code>-f</code> 选项进行强制移动，这就不再需要用户手工确认了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -f cangls /tmp</span></span>
<span>#就算 /tmp/ 目录下已经存在同名的文件，由于"-f"选项的作用，所以会强制覆盖
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="不覆盖移动"> 不覆盖移动</h3>
<p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 <code>-n</code> 选项的帮助了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> /tmp</span></span>
<span>/tmp/bols /tmp/cangls
#在/tmp/目录下已经存在bols、cangls文件了
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -vn bols cangls lmls /tmp/、</span></span>
<span>"lmls"->"/tmp/lmls"
#再向 /tmp/ 目录中移动同名文件，如果使用了 "-n" 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动("-v" 选项用于显示移动过程)
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="改名"> 改名</h3>
<p>如果源文件和目标文件在同一目录中，那就是改名。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> bols lmls</span></span>
<span>#把 bols 改名为 lmls
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>目录也可以按照同样的方法改名。</p>
<h3 id="显示移动过程"> 显示移动过程</h3>
<p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 <code>-v</code> 选项来查看详细的移动信息。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> test1.txt test2.txt test3.txt</span></span>
<span>#建立三个测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -v *.txt /tmp</span></span>
<span>"test1.txt" -> "/tmp/test1.txt"
"test2.txt" -> "/tmp/test2.txt"
"test3.txt" -> "/tmp/test3.txt"
#加入"-v"选项，可以看到有哪些文件进行了移
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-19T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">链接</title>
    <id>https://list-jiang.github.io/linux/command/ln/</id>
    <link href="https://list-jiang.github.io/linux/command/ln/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <summary type="html"><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>
]]></summary>
    <content type="html"><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>

<h2 id="ln-创建硬链接"> ln 创建硬链接</h2>
<p>我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>test</span></span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> /root/test /tmp/test-hard</span></span>
<span>#给源文件建立硬链接文件 /tmp/test-hard
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /root/test /tmp/test-hard</span></span>
<span>262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/test
hard
262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard
#查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，"ll"等同于"ls -l"。
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢? 我们来画一张示意图，如图 2 所示。</p>
<p><img src="./../assets/hardlink.jpg" alt="Hardlink" loading="lazy"></p>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 <code>/root/test</code> 时，要经过以下步骤:</p>
<ul>
<li>首先找到根目录的 inode(根目录的 inode 是系统已知的，inode 号是 2)，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 <code>/root</code> 的文件名及对应的 inode 号。</li>
<li>通过 <code>/root/</code> 目录的 inode 号，可以查找到 <code>/root/</code> 目录的 inode 信息，接着判断用户是否有权限访问 <code>/root/</code> 目录的 block。</li>
<li>如果有权限，则可以从 <code>/root/</code> 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 <code>/root/test</code> 文件的读取与访问。</li>
</ul>
<p>按照这个步骤，在给源文件 <code>/root/test</code> 建立了硬链接文件 <code>/tmp/test-hard</code> 之后，在 <code>/root/</code> 目录和 <code>/tmp/</code> 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。硬链接的特点如下:</p>
<ul>
<li>不论是修改源文件(test 文件)，还是修改硬链接文件(test-hard 文件)，另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件(inode 号是 262147 的文件)都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统(分区)建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<h2 id="ln-创建软链接"> ln 创建软链接</h2>
<p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> check</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/check /tmp/check-soft</span></span>
<span>#建立软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -id /root/check /tmp/check-soft</span></span>
<span>262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check
917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -> /root/check
#软链接和源文件的 inode 号不一致，软链接通过 -> 明显地标识出源文件的位置
#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中&quot;l&quot;表示这是一个软链接文件；其次，在文件的后面通过 &quot;-&gt;&quot; 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问: Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢?</p>
<p>软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 <code>/etc/rc.local</code> 放置在 <code>/etc</code> 目录中，而有些系统却将其放置在 <code>/etc/rc.d/rc.local</code> 中，那么干脆对这两个文件建立软链接，不论您习惯操作哪一个文件，结果都是一样的。</p>
<p>如果您比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。</p>
<p><img src="./../assets/softlink.jpg" alt="软链接示意图" loading="lazy"></p>
<p>软链接和硬链接在原理上最主要的不同在于: 硬链接不会建立自己的 inode 索引和 block(数据块)，而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<ul>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 <code>/tmp/</code> 目录的 inode 号。</li>
<li>接着访问 <code>/tmp/</code> 目录的 inode 信息，判断用户是否有权限访问 <code>/tmp/</code> 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ul>
<p>通过这个过程，我们就可以总结出软链接的特点(软链接的特点和 Windows 中的快捷方式完全一致)。</p>
<ul>
<li>不论是修改源文件(check)，还是修改硬链接文件(check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">环境变量</title>
    <id>https://list-jiang.github.io/linux/command/path/</id>
    <link href="https://list-jiang.github.io/linux/command/path/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="环境变量"> 环境变量</h1>
<h2 id="变量"> 变量</h2>
<p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录 (HOME)、邮件存放位置 (MAIL)等。
值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
<p>我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>env</span></span></span>
<span>ORBIT_SOCKETDIR=/tmp/orbit-root
HOSTNAME=livecd.centos
GIO_LAUNCHED_DESKTOP_FILE_PID=2065
TERM=xterm
SHELL=/bin/bash
......
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量。常见变量见下表:</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录(也称家目录)</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash 解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody>
</table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看 <code>HOME</code> 变量在不同用户身份下都有哪些值:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>su</span> - user1  <span>&lt;</span>--切换到 user1 用户身份</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/home/user1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里的 <code>su</code> 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。</p>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 <code>WORKDIR</code> 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> /home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>WORKDIR</span><span>=</span>/home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了:</p>
<div><pre><code><span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1  <span>&lt;</span>-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$WORKDIR</span></span></span>

<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>exit</span> <span>&lt;</span>--退出user1身份</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>export</span> WORKDIR</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost work1]</span></span><span>$</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="path"> path</h2>
<p>在讲解 PATH 环境变量之前，首先介绍一下 <code>which</code> 命令，它用于查找某个命令所在的绝对路径。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rm</span></span></span>
<span>/bin/rm
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rmdir</span></span></span>
<span>/bin/rmdir
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>ls</span></span></span>
<span>alias ls='ls --color=auto'
        /bin/ls
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>注意，<code>ls</code> 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 <code>ls</code> 实际上执行的是 <code>ls --color=auto</code>。</p>
<p>通过使用 <code>which</code> 命令，可以查找各个外部命令(和 Shell 内置命令相对)所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置 (绝对路径) 呢? 其实，这是 PATH 环境变量在起作用。</p>
<p>首先，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
</span></code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里的 <code>echo</code> 命令用来输出 PATH 环境变量的值(这里的 <code>$</code> 是 PATH 的前缀符号)，PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号 <code>:</code> 隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。
如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
<p>从执行结果中可以看到，<code>/bin</code> 目录已经包含在 PATH 环境变量中，因此在使用类似 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
<p>为了印证以上观点，下面举个反例，如果我们将 <code>ls</code> 命令移动到 <code>/root</code> 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 <code>ls</code> 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 <code>No such file or directory</code>，示例命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /bin/ls /root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>bash: /bin/ls: No such file or directory
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>此时，如果仍想使用 <code>ls</code> 命令，有 2 种方法，一种是直接将 <code>/root</code> 添加到 PATH 环境变量中，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span><span>PATH</span></span><span>=</span><span>$PATH</span>:/root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，<code>$PATH</code> 就恢复成了默认值。</p>
<p>另一种方法是以绝对路径的方式使用此命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>/root/ls</span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了不影响系统的正常使用，强烈建议大家将移动后的 <code>ls</code> 文件还原，命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /root/ls /bin</span></span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-20T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 命令格式</title>
    <id>https://list-jiang.github.io/linux/command/</id>
    <link href="https://list-jiang.github.io/linux/command/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="./dir.html">目录相关</a></p>
</li>
<li>
<p><a href="./file.html">文件相关</a></p>
</li>
<li>
<p><a href="./other.html">其他命令</a></p>
</li>
<li>
<p><a href="./add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="./excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="./path.html">环境变量</a></p>
</li>
<li>
<p><a href="./ln.html">创建链接</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-18T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">其他指令</title>
    <id>https://list-jiang.github.io/linux/command/temp/</id>
    <link href="https://list-jiang.github.io/linux/command/temp/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="其他指令"> 其他指令</h1>
<h2 id="文件"> 文件</h2>
<h3 id="创建文件"> 创建文件</h3>
<ul>
<li>touch</li>
<li>vi</li>
</ul>
<h3 id="编辑文件"> 编辑文件</h3>
<ul>
<li>vi</li>
</ul>
<div><p>提示</p>
<p>使用 vi 命令后，默认进入浏览模式。</p>
<p>按 <code>i</code> 进入 insert 模式， 按 <code>ESC</code> 退出。</p>
<ol>
<li>
<p>命令模式下，输入: <code>/</code> 字符串</p>
<p>比如搜索 user, 输入 <code>/user</code></p>
<p>按下回车之后，可以看到 vim 已经把光标移动到该字符处和高亮了匹配的字符串</p>
</li>
<li>
<p>查看下一个匹配，按下 n(小写 n)</p>
</li>
<li>
<p>跳转到上一个匹配，按下 N(大写 N)</p>
</li>
<li>
<p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮?</p>
</li>
</ol>
<p>命令模式下，输入 <code>:nohlsearch</code> 也可以 <code>:set nohlsearch</code>；当然，可以简写，<code>noh</code> 或者 <code>set noh</code>。</p>
</div>
<h3 id="重命名文件"> 重命名文件</h3>
<ul>
<li>rename</li>
</ul>
<h3 id="移动文件"> 移动文件</h3>
<ul>
<li>mv</li>
</ul>
<div><p>提示</p>
<p>该命令也可用于重命名</p>
</div>
<h3 id="文件浏览"> 文件浏览</h3>
<ul>
<li>pwd: 查看当前目录</li>
<li>cd: 移动当前目录</li>
<li>ls: 列出当前目录
<ul>
<li><code>-l</code>: 以表格列出当前目录详情</li>
<li><code>-a</code>: 包括隐藏文件</li>
</ul>
</li>
</ul>
<h2 id="权限"> 权限</h2>
<ul>
<li>chmod: 查看/更改文件或文件夹权限</li>
</ul>
<p><code>chmod</code> 是权限管理命令 <code>change the permissions mode of a file</code> 的缩写。</p>
<p><code>u</code> 代表所有者，<code>x</code> 代表执行权限。<code>+</code> 表示增加权限。</p>
<div><pre><code><span>chmod</span> u+x file.sh
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>chmod</span> 权限数字 文件名
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p>r 读权限 read 4</p>
</li>
<li>
<p>w 写权限 write 2</p>
</li>
<li>
<p>x 操作权限 execute 1</p>
</li>
</ul>
<div><pre><code><span>chmod</span> <span>600</span> id_rsa
</code></pre>
<div><span>1</span><br></div></div><h2 id="用户组"> 用户组</h2>
<h3 id="管理用户组"> 管理用户组</h3>
<p>groupadd groupname 　　添加用户组</p>
<p>groupdel groupname 　　删除用户组</p>
<p>##　添加用户到用户组
将一个用户添加到用户组中，千万不能直接用:</p>
<div><pre><code><span>usermod</span> -G groupA
</code></pre>
<div><span>1</span><br></div></div><p>这样做会使您离开其他用户组，仅仅做为 这个用户组 groupA 的成员。</p>
<p>应该用 加上 <code>-a</code> 选项:</p>
<div><pre><code><span>usermod</span> -a -G groupA user
<span>(</span>FC4: <span>usermod</span> -G groupA,groupB,groupC user<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-a</code> 代表 <code>append</code>， 也就是 将自己添加到 用户组 groupA 中，而不必离开 其他用户组。</p>
<p>命令的所有的选项，及其含义:</p>
<div><pre><code>Options:

-c, –comment COMMENT new value of the GECOS field
-d, –home HOME_DIR new home directory for the user account
-e, –expiredate EXPIRE_DATE set account expiration date to EXPIRE_DATE
-f, –inactive INACTIVE set password inactive after expiration
to INACTIVE
-g, –gid GROUP force use GROUP as new primary group
-G, –groups GROUPS new list of supplementary GROUPS
-a, –append append the user to the supplemental GROUPS
mentioned by the -G option without removing
him/her from other groups
-h, –help display this help message and exit
-l, –login NEW_LOGIN new value of the login name
-L, –lock lock the user account
-m, –move-home move contents of the home directory to the new
location (use only with -d)
-o, –non-unique allow using duplicate (non-unique) UID
-p, –password PASSWORD use encrypted password for the new password
-s, –shell SHELL new login shell for the user account
-u, –uid UID new UID for the user account
-U, –unlock unlock the user account
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>查看用户所属的组使用命令:</p>
<div><pre><code><span>groups</span> user
</code></pre>
<div><span>1</span><br></div></div><p>或者查看文件:</p>
<div><pre><code><span>cat</span> /etc/group
</code></pre>
<div><span>1</span><br></div></div><h2 id="用户"> 用户</h2>
<p><code>cat /etc/passwd</code> 查看用户列表</p>
<h3 id="添加用户"> 添加用户</h3>
<div><pre><code><span>sudo</span> <span>useradd</span> <span>[</span>用户名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>创建新用户: useradd</p>
<p><code>-d</code> 指定目录文件夹</p>
<p><code>-m</code> 新账号名</p>
<p>如:</p>
<div><pre><code><span>useradd</span> -d /www/abc -m abc
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><code>-c</code>: comment 指定一段注释性描述。</li>
<li><code>-d</code>: 目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</li>
<li><code>-g</code>: 用户组 指定用户所属的用户组。</li>
<li><code>-G</code>: 用户组，用户组 指定用户所属的附加组。</li>
<li><code>-s</code>: Shell 文件 指定用户的登录 Shell。</li>
<li><code>-u</code>: 用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</li>
</ul>
<h3 id="设置密码"> 设置密码</h3>
<div><pre><code><span>sudo</span> <span>passwd</span> <span>[</span>用户名<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="删除用户"> 删除用户</h2>
<div><pre><code><span>userdel</span> abc
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>使用 userdel abc 命令删除该用户时，并不能删除该用户的所有信息，只是删除了/etc/passwd、/etc/shadow、/etc/group/、/etc/gshadow 四个文件里的该账户和组的信息。默认情况下创建一个用户账号，会创建一个家目录和一个用户邮箱(在/var/spool/mail 目录以用户名命名)</p>
<p>所以建议使用 <code>userdel -r abc</code> 删除用户。</p>
</div>
<h2 id="服务管理"> 服务管理</h2>
<p>Linux 服务管理两种方式 service 和 systemctl</p>
<ol>
<li>
<p>service 命令</p>
<p>service 命令其实是去 <code>/etc/init.d</code> 目录下，去执行相关程序</p>
<ul>
<li>service 命令启动 redis 脚本</li>
</ul>
<div><pre><code><span>service</span> redis start
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>直接启动 redis 脚本</li>
</ul>
<div><pre><code>/etc/init.d/redis start
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>开机自启动</li>
</ul>
<div><pre><code>update-rc.d redis defaults
</code></pre>
<div><span>1</span><br></div></div><p>其中脚本需要我们自己编写</p>
</li>
<li>
<p>systemctl 命令</p>
<p>systemd 是 Linux 系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。</p>
<p>systemd 对应的进程管理命令是 systemctl</p>
</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">目录</title>
    <id>https://list-jiang.github.io/linux/file/dir/</id>
    <link href="https://list-jiang.github.io/linux/file/dir/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="linux-文件目录结构"> Linux 文件目录结构</h2>
<p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录 (/) 下包含很多的子目录(称为一级目录)，例如 <code>bin</code>、<code>boot</code>、<code>dev</code> 等。同时，各一级目录下还含有很多子目录(称为二级目录)，比如 <code>/bin/bash</code>、<code>/bin/ed</code> 等。Linux 文件系统目录总体呈现树形结构，<code>/</code> 根目录就相当于树根。</p>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果您进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<div><p>提示</p>
<p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录(<code>/usr</code> 和 <code>/var</code>)的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</div>
<h2 id="linux-根目录"> Linux 根目录(/)</h2>
<p>FHS 认为，Linux 系统的根目录 (/) 最为重要(没有之一)，其原因有以下 2 点:</p>
<ul>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ul>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 <code>/bin</code> 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm 安装)的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录(也称为家目录)。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 <code>/home/</code> 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 <code>/home/liming</code></td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 <code>/media/</code>、<code>/mnt/</code>、<code>/misc/</code>，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 <code>/mnt/</code> 下建立不同目录挂载不同设备的习惯，如 <code>/mnt/cdrom/</code> 挂载光盘、<code>/mnt/usb/</code> 挂载 U 盘，都是可以的</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 <code>/usr/local/</code> 目录中，也就是说，<code>/usr/local/</code> 目录也可以用来安装软件</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 <code>/home/</code> 下，root 主目录直接在“/”下</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
</tbody>
</table>
<p>FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含下表中的几个一级目录。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，<code>/lost+found</code> 就是根分区的备份恢复目录，<code>/boot/lost+found</code> 就是 <code>/boot</code> 分区的备份恢复目录</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 <code>/proc/cpuinfo</code> 是保存 CPU 信息的，<code>/proc/devices</code> 是保存设备驱动的列表的，<code>/proc/filesystems</code> 是保存文件系统列表的，<code>/proc/net</code> 是保存网络协议信息的......</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和 <code>/proc/</code> 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
</tbody>
</table>
<h2 id="linux-usr-目录"> Linux /usr 目录</h2>
<p>usr(注意不是 user)，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 <code>/usr</code> 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 <code>/usr</code> 目录下，<code>/usr</code> 目录类似 Windows 系统中 <code>C:\Windows\</code> + <code>C:\Program files\</code> 两个目录的综合体。</p>
<p>FHS 建议，<code>/usr</code> 目录应具备下表所示的子目录。</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 <code>/usr/local/src/</code> 目录中，把内核源码保存到 <code>/usr/src/linux/</code> 目录中</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody>
</table>
<h2 id="linux-var-目录"> Linux /var 目录</h2>
<p><code>/var</code> 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如下表所示的这些子目录。</p>
<table>
<thead>
<tr>
<th>/var 子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 <code>/var/lib/mysql/</code> 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 <code>/var/log/messages</code>, <code>/var/log/wtmp</code> 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID(进程 ID)保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 <code>/var/spool/mail/</code> 存放新收到的邮件，<code>/var/spool/cron/</code> 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis 和/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢?</p>
<p>答案是用户的主目录或 <code>/tmp/</code> 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 <code>/proc/fn/sys/</code> 目录，因为它们是保存在内存中的，如果在这里写入数据，那么您的内存会越来越小，直至死机；<code>/boot/</code> 目录也不能保存额外数据，因为 <code>/boot/</code> 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<div><p>注意</p>
<p>目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由 <code>/</code> 来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
</div>
<h2 id="硬件设备名称"> 硬件设备名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI/SATA/U 盘</td>
<td><code>/dev/sd[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 挂载</title>
    <id>https://list-jiang.github.io/linux/file/mount/</id>
    <link href="https://list-jiang.github.io/linux/file/mount/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-挂载"> Linux 挂载</h1>
<p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统(文件目录结构)。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将 Linux 本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<p>如果不挂载，通过 Linux 系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录(最好是空目录)，访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U 盘中的数据，我们要在根目录下新建一个目录 <code>/sdb-u</code>，通过挂载命令将 U 盘文件系统挂载到此目录，</p>
<p>前面讲过，根目录下的 <code>/dev/</code> 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件(比如 sdb1)，就位于 <code>/dev/</code> 目录下 (<code>/dev/sdb1</code>)，但无法通过 <code>/dev/sdb1/</code> 直接访问 U 盘数据，访问此目录只会提供给您此设备的一些基本信息(比如容量)。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
<h2 id="linux-硬件设备文件名称"> Linux 硬件设备文件名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd\[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI / SATA / U 盘</td>
<td><code>/dev/sd\[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd\[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp\[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>https://list-jiang.github.io/linux/file/file/</id>
    <link href="https://list-jiang.github.io/linux/file/file/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="文件系统"> 文件系统</h2>
<p>目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“<code>/</code>”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含(子)目录或文件。如此反复就可以构成一个庞大的文件系统。
其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“<code>.</code>”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“<code>..</code>”表示。</p>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找(后续会讲查找命令)时，不显示该目录或文件。</p>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件(或子目录)，比如说，在 <code>/bin</code> 和 <code>/sbin</code> 目录中存放的应该是可执行文件，有关各个目录存放文件的类型，已在《Linux 文件目录结构一览表》一节中作了详解介绍，这里不再过多赘述。</p>
<h2 id="文件"> 文件</h2>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<p>和 Linux 不同，Windows 下带有 <code>&lt;DIR&gt;</code> 标记的行或使用中括号 <code>[]</code> 括起来的名称就是目录，其他的则是文件。</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 <code>/etc/DIR_COLORS</code> 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 <code>man</code> 命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>man</span> dir_colors</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>注意，有些 Linux 发行版单独使用 <code>ls</code> 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 <code>ls --color=auto</code> 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 <code>ls</code> 命令时，都显式附带 <code>--color=auto</code>，可以执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>ls</span> <span>=</span> <span>'ls --color=auto'</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>通过给 <code>ls --color==auto</code> 这个整体设置一个别名 <code>ls</code>，这样当后续使用 <code>ls</code> 命令时，就等同于执行 <code>ls --color=auto</code> 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 <code>/etc/bashrc</code> 或 <code>/home/&lt;user&gt;/.bashrc</code> 文件中，前者对所有用户有效，而后者仅对用户 <code>&lt;user&gt;</code> 有效。</p>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 <code>ls -l</code> 命令，我们就可以查看当前目录下所有文件和目录各自的属性</p>
<h2 id="命名规则"> 命名规则</h2>
<ul>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 <code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>*</code> 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
</ul>
<h2 id="不同字符对应的文件类型"> 不同字符对应的文件类型</h2>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>https://list-jiang.github.io/linux/file/</id>
    <link href="https://list-jiang.github.io/linux/file/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="./dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="./mount.html">挂载</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-17T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 的优点</title>
    <id>https://list-jiang.github.io/linux/intro/advantage/</id>
    <link href="https://list-jiang.github.io/linux/intro/advantage/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-的优点"> Linux 的优点</h1>
<p>相比 Windows 系统，Linux 系统有更好的稳定性。此外，Linux 还有如下优点:</p>
<ol>
<li>
<p>大量的可用软件及免费软件</p>
<p>Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。</p>
<p>但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。</p>
</li>
<li>
<p>良好的可移植性及灵活注
Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。</p>
<p>如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。</p>
</li>
<li>
<p>优良的稳定性和安全性</p>
<p>著名的黑客埃里克•雷蒙德(EricS.Raymond)有一句名言: “足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。</p>
<p>Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。</p>
</li>
<li>
<p>支持几乎所有的网络协议及开发语言</p>
<p>经常有初学的朋友问我，Linux 是不是对 TCP/IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP/IP 无关呢? 所以，Linux 对网络协议和开发语言的支持很好。</p>
</li>
</ol>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">桌面系统</title>
    <id>https://list-jiang.github.io/linux/intro/desktop/</id>
    <link href="https://list-jiang.github.io/linux/intro/desktop/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="桌面系统"> 桌面系统</h1>
<h2 id="kde-桌面系统"> KDE 桌面系统</h2>
<p>KDE 是 K Desktop Environment 的缩写，中文译为“K 桌面环境”。</p>
<p>KDE 是基于大名鼎鼎的 Qt 的，最初于 1996 年作为开源项目公布，并在 1998 年发布了第一个版本，现在 KDE 几乎是排名第一的桌面环境了。</p>
<p>许多流行的 Linux 发行版都提供了 KDE 桌面环境，比如 Ubuntu、Linux Mint、OpenSUSE、Fedora、Kubuntu、PC Linux OS 等。</p>
<p>KDE 和 Windows 比较类似，各位初学者相信都是 Windows 的用户，所以切换到 KDE 也不会有太大的障碍。</p>
<p>KDE 允许您把应用程序图标和文件图标放置在桌面的特定位置上。单击应用程序图标，Linux 系统就会运行该应用程序。单击文件图标，KDE 桌面就会确定使用哪种应用程序来处理该文件。</p>
<p>KDE 是所有桌面环境中最容易定制的。在其他桌面环境中，您需要几个插件、窗口组件和调整工具才可以定制环境，KDE 将所有工具和窗口组件都塞入到系统设置中。借助先进的设置管理器，可以控制一切，不需要任何第三方工具，就可以根据用户的喜好和要求来美化及调整桌面。</p>
<p>KDE 项目组还还发了大量的可运行在 KDE 环境中的应用程序，包括 Dolphin(文件管理工具)、Konsole(终端)、Kate(文本编辑工具)、Gwenview(图片查看工具)、Okular(文档及 PDF 查看工具)、Digikam(照片编辑和整理工具)、KMail(电子邮件客户软件)、Quassel(IRC 客户软件)、K3b(DVD 刻录程序)、Krunner(启动器)等，它们都是默认安装的。</p>
<p>对 KDE 优缺点的总结:</p>
<ul>
<li>优点: KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备</li>
<li>缺点: Kmail 等一些组件的配置对新手来说过于复杂。</li>
</ul>
<h2 id="gnome-桌面环境"> GNOME 桌面环境</h2>
<p>GNOME 是 the GNU Network Object Model Environment 的缩写，中文译为“GNU 网络对象模型环境”。</p>
<p>GNOME 于 1999 年首次发布，现已成为许多 Linux 发行版默认的桌面环境(不过用得最多的是 Red Hat Linux)。</p>
<p>GNOME 的特点是简洁、运行速度快，但是没有太多的定制选项，用户需要安装第三方工具来实现。</p>
<p>GNOME 甚至不包括一些简单的调整选项，比如更改主题、更改字体等，就这两种基本的调整而言，用户都需要安装第三方工具。所以，GONME 适合那些不需要高度定制界面的用户。</p>
<p>GNOME 被用作 Fedora 中的默认桌面环境，提供在几款流行的 Linux 发行版中，比如 Ubuntu、Debian、OpenSUSE 等。</p>
<p>2011 年，GNOME 3 进行了重大更新，不再采用传统的 Windows 风格的界面，而是进行了全新的设计，惊艳了很多用户。GNOME 3 的这种行为也导致部分用户和开发人员不满，他们又开发了多款其他的桌面环境，比如 MATE 和 Cinnamon。</p>
<p>对 GNOME 优缺点的总结:</p>
<ul>
<li>优点: 简单易用，可通过插件来扩展功能。</li>
<li>缺点: 对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。</li>
</ul>
<h2 id="unity"> Unity</h2>
<p>Unity 是由 Ubuntu 的母公司 Canonical 开发的一款外壳。之所以说它是外壳，是因为 Unity 运行在 GNOME 桌面环境之上，使用了所有 GNOME 的核心应用程序。</p>
<p>2010 年，Unity 第一个版本发布，此后经过数次改进，如今和其它的桌面环境一样，也可以安装到其它的 Linux 发行版上了。</p>
<p>Unity 使用了不同的界面风格，如果您用的是 Ubuntu Linux 发行版，您会注意到 Unity 与 KDE 和 GNOME 桌面环境有些不一样。</p>
<p>Unity 在左边有一个启动器，位于启动器顶部的是搜索图标，又叫“Dash”。在 Dash 上搜索文件时，不仅会给出来自硬盘的搜索结果，还会给出来自在线来源的搜索结果，比如 Google Drive、Facebook、Picasa、Flick 及其他。</p>
<p>Unity 还提供了隐藏启动器、触摸侧边栏就显示的选项，用户还可以调高/调低显示启动器菜单的灵敏度。</p>
<p>Unity 很简单、运行速度快，但 Unity 在系统设置下却没有定制桌面的太多选项，要想安装主题或者定制另外不同的选项，比如系统菜单是否应该总是可见，或者“从启动器图标一次点击最小化”，用户需要安装第三方工具。</p>
<p>CCSM 和 Unity Tweak Tool 是面向 Unity 桌面环境的非常流行的定制工具。</p>
<p>对 Unity 优缺点的总结:</p>
<ul>
<li>优点: 界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器(HUD)等新技术。</li>
<li>缺点: 默认的定制功能比较差劲，通知机制一般。</li>
</ul>
<h2 id="mate"> MATE</h2>
<p>上面我们提到，GNOME 3 进行了全新的界面设计，这招致一些用户的不满，他们推出了其它的桌面环境，MATE 就是其中之一。</p>
<p>MATE 是一种从现在无人维护的 GNOME 2 代码库派生出来的桌面环境。</p>
<p>MATE 让人觉得在使用旧的桌面环境，但是结合了历年来界面方面的诸多改进。MATE 还非常适用于低配计算机，所以如果您有一台旧的或速度较慢的计算机，可以使用 MATE。</p>
<p>MATE 还是许多流行的 Linux 发行版随带的，比如 Ubuntu、Linux Mint、Mageia、Debian 及另外更多发行版。Ubuntu MATE 头一回是官方版本。</p>
<p>“欢迎首次发布的 Ubuntu MATE 官方版本。现在，用户将更容易更新软件，因为所有组件现在都在 Ubuntu 软件库中。”</p>
<p>MATE 自带的应用程序包括 Caja(文件管理工具)、Pluma(文本编辑工具)、Atril(文档查看工具)、Eye of MATE(图像查看工具)等，如果用户不需要其他功能完备的桌面环境的所有额外功能，那么 MATE 对他们来说是一款简单的轻量级桌面环境。</p>
<p>对 META 优缺点的总结:</p>
<ul>
<li>优点: 轻量级的桌面环境，能够兼容教旧的硬件设备。</li>
<li>缺点: 我也不知道有什么明显的缺点，欢迎读者留言告知。</li>
</ul>
<h2 id="cinnamon"> Cinnamon</h2>
<p>与 MATE 类似，Cinnamon 是由 Linux Mint 团队因为不满 Gnome 3 的改进而开发的另一种桌面环境。但 Cinnamon 与 MATE 不同之处在于，Cinnamon 建立在 Gnome 3 的基础上。Cinnamon 是新的，而且在积极开发之中，但这款出色的桌面环境没有因新颖而在功能方面有所减弱。</p>
<p>Cinnamon 拥有 GNOME 和 Unity 等其它桌面环境所没有的种种功能。Cinnamon 是高度可定制的桌面环境，不需要任何外部插件、窗口组件和调整工具来定制桌面。Cinnamon 甚至可以通过设置管理器本身来下载并安装主题，甚至不需要打开互联网浏览器。</p>
<p>由于种种出色的所需功能，Cinnamon 对任何刚接触 Linux 的新用户来说都非常方便。许多用户放弃使用 Linux，是因为他们并不了解 Linux 的工作方式，但是我强烈建议新手应从 Cinnamon 桌面环境开始入手。</p>
<p>许多流行的 Linux 发行版提供了各自版本的 Cinnamon，比如 Ubuntu、Fedora、OpenSUSE、Gentoo、Arch Linux 等。Cinnamon 还是 Linux Mint 的默认桌面环境。</p>
<p>对 Cinnamon 优缺点的总结:</p>
<ul>
<li>优点: 成熟完美，高度可性质，适合 Linux 新手。</li>
<li>缺点: 有时候可能会有软件错误。</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 和 UNIX</title>
    <id>https://list-jiang.github.io/linux/intro/history/</id>
    <link href="https://list-jiang.github.io/linux/intro/history/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-和-unix"> Linux 和 UNIX</h1>
<p>UNIX 与 Linux 之间的关系是一个很有意思的话题。在目前主流的服务器端操作系统中，UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 UNIX 是操作系统中的&quot;老大哥&quot;，后来的 Windows 和 Linux 都参考了 UNIX。</p>
<div><p>提示</p>
<p>现代的 Windows 系统已经朝着“图形界面”的方向发展了，和 UNIX 系统有了巨大的差异，从表面上甚至看不出两者的关联。</p>
</div>
<h2 id="unix-的坎坷历史"> UNIX 的坎坷历史</h2>
<p>UNIX 操作系统由肯·汤普森(Ken Thompson)和丹尼斯·里奇(Dennis Ritchie)发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。</p>
<div><p>提示</p>
<p>分时操作系统使一台计算机可以同时为多个用户服务，连接计算机的终端用户交互式发出命令，操作系统采用时间片轮转的方式处理用户的服务请求并在终端上显示结果(操作系统将 CPU 的时间划分成若干个片段，称为时间片)。操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片。</p>
</div>
<p>可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。</p>
<p>以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。</p>
<p>想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。</p>
<p>有意思的是，肯•汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。</p>
<p>自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯•汤普森的同事丹尼斯•里奇发明了传说中的 C 语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。</p>
<p>到了 1973 年，UNIX 系统的绝大部分源代码都用 C 语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础(之前操作系统多采用汇编语言，对硬件依赖性强)，也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与 C 语言是一对孪生兄弟，具有密不可分的关系。</p>
<p>20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C 语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C 语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖。</p>
<p>随后出现了各种版本的 UNIX 系统，目前常见的有 Sun Solaris、FreeBSD、IBM AIX、HP-UX 等。</p>
<h2 id="solaris-和-freebsd"> Solaris 和 FreeBSD</h2>
<p>我们重点介绍一下 Solaris，它是 UNIX 系统的一个重要分支。Solaris 除可以运行在 SPARC CPU 平台上外，还可以运行在 x86 CPU 平台上。在服务器市场上，Sun 的硬件平台具有高可用性和高可靠性，是市场上处于支配地位的 UNIX 系统。</p>
<p>对于难以接触到 Sun SPARC 架构计算机的用户来说，可以通过使用 Solaris x86 来体验世界知名大厂的商业 UNIX 风采。当然，Solaris x86 也可以用于实际生产应用的服务器，在遵守 Sun 的有关许可条款的情况下，Solaris x86 可以免费用于学习研究或商业应用。</p>
<p>FreeBSD 源于美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。FreeBSD 在 BSD 许可协议下发布，允许任何人在保留版权和许可协议信息的前提下随意使用和发行，并不限制将 FreeBSD 的代码在另一协议下发行，因此商业公司可以自由地将 FreeBSD 代码融入它们的产品中。苹果公司的 macOS 就是基于 FreeBSD 的操作系统。</p>
<p>FreeBSD 与 Linux 的用户群有相当一部分是重合的，二者支持的硬件环境也比较一致，所采用的软件也比较类似。FreeBSD 的最大特点就是稳定和高效，是作为服务器操作系统的不错选择；但其对硬件的支持没有 Linux 完备，所以并不适合作为桌面系统。</p>
<p>其他 UNIX 版本因应用范围相对有限，在此不做过多介绍。</p>
<h2 id="linux-的那些往事"> Linux 的那些往事</h2>
<p>Linux 内核最初是由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷您版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10 000 行代码。</p>
<p>李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。</p>
<p>据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核(操作系统的核心部分)，并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。</p>
<p>李纳斯•托瓦兹无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub (开源代码库及版本控制系统)。</p>
<p>关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅。企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是: 开放源代码的 Linux 为全人类共同所有，任何公司无权将其私有。</p>
<h2 id="unix-与-linux-的关系"> UNIX 与 Linux 的关系</h2>
<p>二者的关系，不是大哥和小弟，&quot;UNIX 是 Linux 的父亲&quot;这个说法更怡当。之所以要介绍它们的关系，是因为要告诉读者，在学习的时候，其实 Linux 与 UNIX 有很多的共通之处，简单地说，如果您已经熟练掌握了 Linux，那么再上手使用 UNIX 会非常容易。</p>
<p>二者也有两个大的区别:</p>
<ul>
<li>
<p>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上；</p>
</li>
<li>
<p>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。</p>
</li>
</ul>
<p>Linux 受至旷大计算机爱好者的喜爱，主要原因也有两个:</p>
<ul>
<li>
<p>它属于开源软件，用户不用支付可费用就可以获得它和它的源代码，并且可以根据自己的需要对它进行必要的修改，无偿使用，无约束地继续传播；</p>
</li>
<li>
<p>它具有 UNIX 的全部功能，任何使用 UNIX 操作系统或想要学习 UNIX 操作系统的人都可以从 Linux 中获益。</p>
</li>
</ul>
<p>开源软件是不同于商业软件的一种模式，从字面上理解，就是开放源代码，大家不用担心里面会搞什么猫腻，这会带来软件的革新和安全。</p>
<p>另外，开源其实并不等同于免费，而是一种新的软件盈利模式。目前很多软件都是开源软件，对计算机行业与互联网影响深远。</p>
<p>近年来，Linux 已经青出于蓝而胜于蓝，以超常的速度发展，从一个丑小鸭变成了一个拥有庞大用户群的真正优秀的、值得信赖的操作系统。历史的车轮让 Linux 成为 UNIX 最优秀的传承者。</p>
<div><p>总结</p>
<p>Linux 是一个类似 Unix 的操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX(但并没有抄袭 UNIX 的源码)，使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
</div>
<p>相比于 UNIX，Linux 最大的创新是开源免费，这是它能够蓬勃发展的最重要原因；而目前的 UNIX 大部分都是收费的，小公司和个人都难以承受。</p>
<p>正是由于 Linux 和 UNIX 有着千丝万缕的联系，所以人们把 Linux 叫做“类 UNIX 系统”。</p>
<h2 id="unix-linux-系统结构"> UNIX/Linux 系统结构</h2>
<p>UNIX/Linux 系统可以粗糙地抽象为 3 个层次(所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解)，如图 3 所示。底层是 UNIX/Linux 操作系统，即系统内核(Kernel)；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<p><img src="./../assets/structure.jpg" alt="Structrure" loading="lazy"></p>
<ol>
<li>
<p>内核层</p>
<p>内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。</p>
</li>
<li>
<p>Shell 层</p>
<p>Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
</li>
<li>
<p>应用层</p>
<p>应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能(就如同 TCP/IP 是一个协议，定义软件所应具备的功能)，可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</p>
</li>
</ol>
<p>现在大多数的 UNIX 系统上(包括 Solaris、HP-UX、AIX 等)都可以运行 CDE (Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境) 的用户界面；而在 Linux 上广泛应用的有 Gnome、KDE 等。</p>
<h2 id="协议"> 协议</h2>
<p>早在 20 世纪 70 年代，UNIX 系统是开源而且免费的，但是在 1979 年时，AT&amp;T 公司宣布了对 UNIX 系统的商业化计划，随之开源软件业转变成了版权式软件产业，源代码被当作商业机密，成为专利产品，人们再也不能自由地享受科技成果。</p>
<p>于是在 1984 年，Richard Stallman 面对于如此封闭的软件创作环境，发起了 GNU 源代码开放计划并制定了著名的 GPL 许可协议。</p>
<p>1987 年时，GNU 计划获得了一项重大突破，即发布了 gcc 编译器，这使得程序员可以基于该编译器编写出属于自己的开源软件。随之，在 1991 年 10 月，芬兰赫尔辛基大学的在校生 Linus Torvalds 编写了一款名为 Linux 的操作系统，该系统因其较高的代码质量且基于 GNU GPL 许可协议的开放源代码特性，迅速得到了 GNU 计划和一大批黑客程序员的支持，随后 Linux 系统便进入了如火如荼的发展阶段。</p>
<p>1994 年 1 月，Bob Young(红帽创始人)在 Linux 系统内核的基础之上，集成了众多的源代码和程序软件，发布了红帽系统并开始出售技术服务，这进一步推动了 Linux 系统的普及。</p>
<p>1998 年以后，随着 GNU 源代码开放计划和 Linux 系统的继续火热，以 IBM 和 Intel 为首的多家 IT 企业巨头开始大力推动开放源代码软件的发展。</p>
<p>到了 2017 年年底，Linux 内核已经发展到了 4.13 版本，并且 Linux 系统版本也有数百个之多，但它们依然都使用 Linus Torvalds 开发、维护的 Linux 系统内核。RedHat 公司也成为了开源行业及 Linux 系统的带头公司。</p>
<p>初步接触 Linux 的读者，或者有这样一个疑问，Windows 系统也很好用，也能满足日常工作需求，为什么要学习 Linux 系统呢?</p>
<p>有些初学者会将“Linxu 系统是开源的”作为这个问题的答案，其实不然。开源的操作系统少说有 100 个，开源的软件至少也有十万个，为什么不去逐个学习? Linux 的开源特性只是一部分优势，并不是学习 Linux 的主要原因。</p>
<p>对于用户来讲，开源精神仅具备锦上添花的效果，真正的原因在于，Linux 系统是一款优秀的软件产品，具有类似 UNIX 的程序界面，而且继承了 UNIX 的稳定性，能够较好地满足工作需求。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 简介</title>
    <id>https://list-jiang.github.io/linux/intro/intro/</id>
    <link href="https://list-jiang.github.io/linux/intro/intro/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-简介"> Linux 简介</h1>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹 (Linus Torvalds) 在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p>Linux 让开展各种实际有用且具有创造性的事情成为可能。例如，您可以在一个 U 盘上装载 Linux 的自生系统引导映像 (live boot image)，启动一台硬盘已经崩溃的计算机，之后査找并解决该问题。或者，因为 Linux 是一个真正的多用户操作系统，它具有非常好的私密性和稳定性，整个团队可以同时从本地或远程登录进行工作。</p>
<p>Linux 的构建采用了一些与 UNIX 操作系统相同的技术，并带有大多数与深度成熟的 UNIX 操作系统相一致的工具，这极大地增加了稳定性与安全性。</p>
<p>Linux 的发行版还提供了复杂的软件包管理系统，可以可靠地安装和维护每一个在线资源库中成千上万的免费软件应用。</p>
<p>Linux 不仅是免费的，更是开源的(open source)，这意味着任何人都可以获得其代码并根据自己的需求进行修改。</p>
<h2 id="linux-的发行版"> Linux 的发行版</h2>
<p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><img src="./../assets/intro.jpg" alt="intro" loading="lazy"></p>
<p>事实上，已经孵化出专属 Linux 各发行版的巨大生态系统。一个发行版(distribution ，有时缩写为 distro)是一个定制的软件包，它将 Linux 内核以及用户计算机 Linux 运行版的安装工具一起发布。</p>
<p>在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以 Linux 为核心的操作系统软件包”。</p>
<p>Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层(由发行商整合开发的应用)才有所体现。</p>
<p>目前市面上较知名的发行版有: Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p>
<p>Linux 的发行版本可以大体分为两类:</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表；</li>
<li>社区组织维护的发行版本，以 Debian 为代表。</li>
</ul>
<p>很难说大量 Linux 版本中哪一款更好，每个版本都有自己的特点。</p>
<h3 id="red-hat-linux"> Red Hat Linux</h3>
<p>Red Hat(红帽公司)创建于 1993 年，是目前世界上资深的 Linux 厂商，也是最获认可的 Linux 品牌。</p>
<p>Red Hat 公司的产品主要包括 RHEL(Red Hat Enterprise Linux，收费版本)和 CentOS(RHEL 的社区克隆版本，免费版本)、Fedora Core(由 Red Hat 桌面版发展而来，免费版本)。</p>
<p>Red Hat 是在我国国内使用人群最多的 Linux 版本，资料丰富，如果您有什么不明白的地方，则容易找到人来请教，而且大多数 Linux 教程是以 Red Hat 为例来讲解的(包括本教程)。</p>
<p>CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任。</p>
<h3 id="ubuntu-linux"> Ubuntu Linux</h3>
<p>Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。</p>
<p>Ubuntu 的创始人 Mark Shuttleworth 是非常具有传奇色彩的人物。他在大学毕业后创建了一家安全咨询公司，1999 年以 5.75 亿美元被收购，由此一跃成为南非最年轻有为的本土富翁。作为一名狂热的天文爱好者，Mark Shuttleworth 于 2002 年自费乘坐俄罗斯联盟号飞船，在国际空间站中度过了 8 天的时光。之后，Mark Shuttleworth 创立了 Ubuntu 社区，2005 年 7 月 1 日建立了 Ubuntu 基金会，并为该基金会投资 1000 万美元。他说，太空的所见正是他创立 Ubuntu 的精神之所在。如今，他最热衷的事情就是到处为自由开源的 Ubuntu 进行宣传演讲。</p>
<h3 id="suse-linux"> SuSE Linux</h3>
<p>SuSE Linux 以 Slackware Linux 为基础，原来是德国的 SuSE Linux AG 公司发布的 Linux 版本，1994 年发行了第一版，早期只有商业版本，2004 年被 Novell 公司收购后，成立了 OpenSUSE 社区，推出了自己的社区版本 OpenSUSE。</p>
<p>SuSE Linux 在欧洲较为流行，在我国国内也有较多应用。值得一提的是，它吸取了 Red Hat Linux 的很多特质。</p>
<p>SuSE Linux 可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便。</p>
<h3 id="gentoo"> Gentoo</h3>
<p>Gentoo 最初由 Daniel Robbins(FreeBSD 的开发者之一)创建，首个稳定版本发布于 2002 年。Gentoo 是所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。</p>
<p>不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。自从 Gentoo 1.0 面世后，它就像一场风暴，给 Linux 世界带来了巨大的惊喜，同时也吸引了大量的用户和开发者投入 Gentoo Linux 的怀抱。</p>
<p>有人这样评价 Gentoo: 快速、设计干净而有弹性，它的出名是因为其高度的自定制性(基于源代码的发行版)。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译。这也是为什么 Gentoo 适合比较有 Linux 使用经验的老手使用。</p>
<h3 id="发行版选择"> 发行版选择</h3>
<p>Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议:</p>
<ul>
<li>
<p>如果您需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议您选择 CentOS 或 RHEL。</p>
</li>
<li>
<p>如果您只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。</p>
</li>
<li>
<p>如果您想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。</p>
</li>
<li>
<p>如果您对系统稳定性要求很高，则可以考虑 FreeBSD。</p>
</li>
<li>
<p>如果您需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。</p>
</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">语言</title>
    <id>https://list-jiang.github.io/linux/intro/language/</id>
    <link href="https://list-jiang.github.io/linux/intro/language/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <summary type="html"><![CDATA[<p>Linux 中大量使用脚本语言，而不是 C 语言!</p>
]]></summary>
    <content type="html"><![CDATA[<p>Linux 中大量使用脚本语言，而不是 C 语言!</p>

<p>说到在 Linux 下的编程，很多人会想到用 C 语言，Linux 的内核、shell、基础命令程序，也的确是用 C 语言编写的，这首先证明了一点，C 语言很强很通用。</p>
<p>到目前为止，C 语言依然垄断着计算机工业中几乎所有的系统编程，而且也正因为是 C 语言，才使得 Unix 以及后来的 Linux 能够这么广泛地被人们去研究、去改进、去制作自己的分支，以至于我们能在各种硬件平台上使用它们。</p>
<p>但是细心的人会发现，Linux 启动过程中所涉及的各种程序，很少有 C 语言的痕迹。它们大多是脚本程序。不单单在启动过程中是这样，那些用于安装软件的工具 yum、apt-get，甚至是 configure 和 Makefile 也都是脚本程序。而且您可能还没注意到，那些用于系统管理的工具，如配置 ADSL 拨号上网的工具、配置守护进程的工具等，很多也都是脚本程序。</p>
<p>大量使用脚本程序，是所有类 Unix 系统不同于其他系统的一个显著特征，催生人们在 Linux 中大量使用脚本来编写程序，并不仅仅是因为脚本对人直观、容易修改这种显著特性所决定的。另外一个主要的原因就是 Linux 所支持的脚本语言种类十分丰富。</p>
<p>所有类 Unix 系统所必备的 shell，其本身就是一个强大的脚本解释器。所以从 shell 诞生的那一天起，shell 就是那些不懂 C 语言，又必须在 Unix 上编写程序的用户们的首选工具。</p>
<p>这就给了人们一种新的选择，使用 shell 编程不用去理会让人头晕的指针；shell 程序可以直接利用系统命令来完成一些需要用大量 C 代码的功能；shell 编程不用去理会数据类型，不用考虑烦人的数值和字符数据的转换问题；shell 程序同样提供顺序、选择分支和循环这三种能够构建任意算法的基础设施。因此，shell 很快就能够被非专业用户所接受、掌握，并编写出非常实用的程序。</p>
<p>随着时间的推移，这些非专业用户想往更高的方向发展，遇到了一些 shell 处理起来会很“蹩脚”的问题，比如分析文本和修改文本(别忘了“万般皆文本”)。这个时候他们会发现 有 awk 和 sed。也只需要写几行脚本就能将这些问题处理得很好。而且它们也跟 shell 配合得天衣无缝。或许这个时候会觉得加入了 awk 和 sed 的 shell 脚本有些难看，不过没关系，还有 Perl 和 TCL。Perl 天生就是为处理文本而存在的，TCL 也不含糊。</p>
<p>如果觉得这些语言都太老气了，有些过时了，不要紧，还有 Python、Ruby 等这些现代脚本语言，它们除了不能写操作系统内核之外，几乎什么都能干，而且还是面向对象的。</p>
<p>不管怎样，在 Linux 下能够选择的脚本语言都是极其丰富的。它们最大的特点就是简单、好学且资料丰富。简单就意味着容易维护，好学就容易吸引用户，资料丰富就不会在解决 bug 上出现障碍。即便是专业的程序员，也会因为这些特点而特别偏好脚本语言，导致的一个结果就是脚本程序在 Linux 中的大爆发。</p>
<p>为什么不选择 C 语言呢?</p>
<h2 id="c-语言并不是最佳选择"> C 语言并不是最佳选择</h2>
<p>C 语言是 Unix 的母语，这是毋庸罝疑的。前面也说过，正是因为有了 C 语言，才使得 Unix 有了今天的成就。但为什么在 Linux 中有这么多程序，甚至是关键程序，不用 C 语言编写呢?</p>
<p>脚本程序由于是解释执行的，在执行效率上自然是会有很大损失的。并且大家都知道，C 语言所编写的程序又是以效率著称的。但是 C 语言是一种编译型语言，要想让 C 语言的程序能够运行，必须经过编译和链接这两个步骤。</p>
<p>要知道，能够将由几十个源代码文件构成的 C 语言程序，有条不紊地编译完成并能最终链接成一个可执行程序，本身就是一件费时又费力的事情，如果一旦程序有问题，还必须使用专门的调试工具一点点地去跟踪判断，修正之后再重复那些复杂的编译和链接步骤，这又是一个极需技巧的事情。积累并掌握技巧又是一件费时又费力的事情。</p>
<p>在早些年，计算机性能不佳的时候，这些付出或许是值得的。但是放到现在，处理器的速度至少快了几千倍，内存大了几千倍，硬盘甚至大了几万倍，而价格却更低了。从经济角度分析，机器的时间成本早己远远低于人的时间成本了。那么 C 语言在机器效率上的优势根本没有任何意义。脚本程序能够给人节省下来的时间成本，则更具经济效益。
要论机器效率，汇编语言比 C 语言要好上几十倍，但是目前还有谁在用汇编语言编程呢?</p>
<p>C 语言在设计的时候，最主要的一个目标就是能够让程序员自己处理内存管理的问题。这使得 C 语言很强大但又太过于灵活，导致了很多陷阱的出现。稍微一不注意，程序中就会存在难以发觉的 Bug，甚至是严重的安全漏洞。程序员们大多是要以时间或失败为代价去积累经验，才能尽量避免这些问题的发生。而且效率在大多数应用中根本就不是问题，首要的是正确。脚本程序的简单和直观正是正确的起点，C 语言的灵活却是错误的根源。</p>
<p>但是，C 语言并不是一无是处，也是 Unix 的精华。C 语言作为通用程序设计语言是所向无敌的。C 语言本身也非常简洁和紧凑，资料丰富且容易学习。C 语言之后的少数语言设计，为了不被 C 语言所吞并，不得不进行大的改动，比如引进垃圾回收机制等，以和 C 语言能够在功能上保持足够距离。也正是因为这样，C 语言始终没有消失，只是它的光辉在 Linux 中稍稍地被脚本程序所遮挡了一下。</p>
<h2 id="脚本语言也有不足"> 脚本语言也有不足</h2>
<p>虽然效率并不是脚本程序的缺点，但是种类过于丰富却是一个极大不足。编写一个复杂的应用，往往很难使用一种脚本语言包杆到底，因为脚本语言都有自己适用的场景，为了能够快速有效地完成某个应用，就需扬长避短，利用多种脚本语言混合编程。</p>
<p>多脚本语言的混合编程是一种知识密集型的编程方法，但不是编码密集型的(这是能够被普遍接受的原因)。为了能够良好地使用这种方法，就要求程序员不仅仅要具备相当数量的多种语言知识，还必须具备能够判断这些语言的适用场景、以及如何将它们有效地组合在一起的经验。</p>
<p>实际上，混合编程并不是脚本语言的专利，任何编程语言都行，只要您能找准那些语言的特点。比如笔者就曾经使用过 Basic 和 C 进行混合编程，去完成一个 DOS 版万年历程序。为了支持鼠标点击操作，用 C 完成了鼠标中断的处理。余下的部分都用 Basic 来完成。</p>
<p>在 Linux 中大量应用脚本程序的场景，好多都是这种混合编程的典范。比如 Linux 的启动过程，主程序 init 是用 C 语言写的，具体到启动流程的各个环节则是 shell 脚本程序。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-16T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux 简介</title>
    <id>https://list-jiang.github.io/linux/intro/</id>
    <link href="https://list-jiang.github.io/linux/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-简介"> Linux 简介</h1>
<ul>
<li>
<p><a href="./intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="./history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="./language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="./advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="./desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Linux 系统启动过程</title>
    <id>https://list-jiang.github.io/linux/intro/startup/</id>
    <link href="https://list-jiang.github.io/linux/intro/startup/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux-系统启动过程"> Linux 系统启动过程</h1>
<div><p>提示</p>
<p>本篇教程以 CentOS 为例介绍系统的启动过程。</p>
</div>
<p>Linux 启动时我们会看到许多启动信息。</p>
<p>Linux 系统的启动过程并不是大家想象中的那么复杂，其过程可以分为 5 个阶段:</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<div><p>提示</p>
<p>init 程序的类型:</p>
<ul>
<li>SysV: init, CentOS 5 之前, 配置文件: /etc/inittab。</li>
<li>Upstart: init,CentOS 6, 配置文件: /etc/inittab, /etc/init/*.conf。</li>
<li>Systemd: systemd, CentOS 7,配置文件: /usr/lib/systemd/system、 /etc/systemd/system。</li>
</ul>
</div>
<h2 id="内核引导"> 内核引导</h2>
<p>当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备(通常是硬盘)来启动。</p>
<p>操作系统接管硬件以后，首先读入 <code>/boot</code> 目录下的内核文件。</p>
<p><img src="./../assets/boot.png" alt="boot" loading="lazy"></p>
<h2 id="运行-init"> 运行 init</h2>
<p>init 进程是系统所有进程的起点，您可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 <code>/etc/inittab</code>。</p>
<p><img src="./../assets/init.png" alt="init" loading="lazy"></p>
<h3 id="运行级别"> 运行级别</h3>
<p>许多程序需要开机启动。它们在 Windows 叫做&quot;服务&quot;(service)，在 Linux 就叫做&quot;守护进程&quot;(daemon)。</p>
<p>init 进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。</p>
<p>Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;(runlevel)。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</p>
<p><img src="./../assets/runlevel.png" alt="runlevel" loading="lazy"></p>
<p>Linux 系统有 7 个运行级别(runlevel):</p>
<ul>
<li>运行级别 0: 系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</li>
<li>运行级别 1: 单用户工作状态，root 权限，用于系统维护，禁止远程登陆</li>
<li>运行级别 2: 多用户状态(没有 NFS)</li>
<li>运行级别 3: 完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别 4: 系统未使用，保留</li>
<li>运行级别 5: X11 控制台，登陆后进入图形 GUI 模式</li>
<li>运行级别 6: 系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</li>
</ul>
<h2 id="系统初始化"> 系统初始化</h2>
<p>在 init 的配置文件中有这么一行: <code>si::sysinit:/etc/rc.d/rc.sysinit</code>　它调用执行了 <code>/etc/rc.d/rc.sysinit</code>，而 <code>rc.sysinit</code> 是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作，rc.sysinit 是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有: 激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<div><pre><code>l5:5:wait:/etc/rc.d/rc <span>5</span>
</code></pre>
<div><span>1</span><br></div></div><p>这一行表示以 5 为参数运行 <code>/etc/rc.d/rc</code>，<code>/etc/rc.d/rc</code> 是一个 Shell 脚本，它接受 5 作为参数，去执行 <code>/etc/rc.d/rc5.d/</code> 目录下的所有的 rc 启动脚本，<code>/etc/rc.d/rc5.d/</code> 目录中的这些启动脚本实际上都是一些连接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在 <code>/etc/rc.d/init.d/</code>目录下。</p>
<p>而这些 rc 启动脚本有着类似的用法，它们一般能接受 start、stop、restart、status 等参数。</p>
<p><code>/etc/rc.d/rc5.d/</code> 中的 rc 启动脚本通常是 K 或 S 开头的连接文件，对于以 S 开头的启动脚本，将以 start 参数来运行。</p>
<p>而如果发现存在相应的脚本也存在 K 打头的连接，而且已经处于运行态了(以 <code>/var/lock/subsys/</code> 下的文件作为标志)，则将首先以 stop 为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当 init 改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过 chkconfig 或 setup 中的 &quot;System Services&quot; 来自行设定。</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">ssh</title>
    <id>https://list-jiang.github.io/linux/ssh/</id>
    <link href="https://list-jiang.github.io/linux/ssh/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用密码登录"> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2 id="使用密钥登录"> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2 id="断开链接"> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="基础"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-23T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Linux</title>
    <id>https://list-jiang.github.io/linux/</id>
    <link href="https://list-jiang.github.io/linux/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="linux-教程"> Linux 教程</h2>
<ul>
<li>
<p><a href="./intro/">Linux 介绍</a></p>
<ul>
<li>
<p><a href="./intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="./intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="./intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="./intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="./intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./file/">Linux 文件</a></p>
<ul>
<li>
<p><a href="./file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="./file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="./file/mount.html">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./command/">Linux 命令</a></p>
<ul>
<li>
<p><a href="./command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="./command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="./command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="./command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="./command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="./command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="./command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="./command/ln.html">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ubuntu"> ubuntu</h2>
<ul>
<li><a href="./ubuntu/">点击前往</a></li>
</ul>
<h2 id="centos"> CentOS</h2>
<ul>
<li><a href="./centos.html">点击前往</a></li>
</ul>
<h2 id="wsl"> WSL</h2>
<ul>
<li><a href="./WSL.html">点击前往</a></li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-15T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">开发软件</title>
    <id>https://list-jiang.github.io/linux/ubuntu/debug/</id>
    <link href="https://list-jiang.github.io/linux/ubuntu/debug/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="开发软件"> 开发软件</h1>
<h2 id="安装-vs-code"> 安装 VS Code</h2>
<ul>
<li>
<p>使用 snap</p>
<div><pre><code><span>sudo</span> snap <span>install</span> --classic code
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>在 WSL 环境下 snap 无法使用，则使用以下命令安装 code 库。</p>
<div><pre><code><span>curl</span> https://packages.microsoft.com/keys/microsoft.asc <span>|</span> gpg --dearmor <span>></span> packages.microsoft.gpg
<span>sudo</span> <span>install</span> -o root -g root -m <span>644</span> packages.microsoft.gpg /usr/share/keyrings/
<span>sudo</span> <span>sh</span> -c <span>'echo "deb [arch=amd64 signed-by=/usr/share/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main" > /etc/apt/sources.list.d/vscode.list'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后正常安装:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> apt-transport-https
<span>sudo</span> <span>apt-get</span> update
<span>sudo</span> <span>apt-get</span> <span>install</span> code <span># or code-insiders</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p>可能还需要安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> libx11-xcb1 libasound2
</code></pre>
<div><span>1</span><br></div></div><h3 id="remote-插件安装"> remote 插件安装</h3>
<div><pre><code>code --install-extension ms-vscode-remote.vscode-remote-extensionpack
</code></pre>
<div><span>1</span><br></div></div><h2 id="nvm"> nvm</h2>
<div><pre><code><span>curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh <span>|</span> <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>在 Linux 上可能需要重新链接终端，命令才可用。</p>
<p>测试命令，输入 <code>nvm</code> 即安装成功:</p>
<div><pre><code><span>command</span> -v nvm
</code></pre>
<div><span>1</span><br></div></div><p>安装命令:</p>
<div><pre><code>nvm <span>install</span> <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><p>切换命令:</p>
<div><pre><code>nvm use <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="安装-git"> 安装 Git</h2>
<div><pre><code><span>sudo</span> add-apt-repository ppa:git-core/ppa

<span>sudo</span> <span>apt-get</span> update

<span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="yarn"> yarn</h2>
<div><pre><code><span>curl</span> -sS https://dl.yarnpkg.com/debian/pubkey.gpg <span>|</span> <span>sudo</span> apt-key <span>add</span> -
<span>echo</span> <span>"deb https://dl.yarnpkg.com/debian/ stable main"</span> <span>|</span> <span>sudo</span> <span>tee</span> /etc/apt/sources.list.d/yarn.list
<span>sudo</span> <span>apt-get</span> update <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> <span>install</span> <span>yarn</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">语言切换</title>
    <id>https://list-jiang.github.io/linux/ubuntu/lang/</id>
    <link href="https://list-jiang.github.io/linux/ubuntu/lang/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="语言切换"> 语言切换</h1>
<p>查看当前语言包: <code>locale -a</code></p>
<p>中文语言是: <code>zh_CN.utf8</code></p>
<h2 id="安装中文语言包"> 安装中文语言包</h2>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> language-pack-zh-hans
</code></pre>
<div><span>1</span><br></div></div><p>之后修改 <code>/etc/default/locale</code>，将 <code>LANG</code> 改为 <code>zh_CN.utf8</code></p>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-22T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">管理工具</title>
    <id>https://list-jiang.github.io/linux/ubuntu/manage/</id>
    <link href="https://list-jiang.github.io/linux/ubuntu/manage/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="管理工具"> 管理工具</h1>
<h2 id="apt-get"> apt-get</h2>
<p><code>apt-get</code> 命令默认的源在国内访问很慢，可以考虑换源。</p>
<ul>
<li>
<p>获取软件包更新:</p>
<div><pre><code><span>apt-get</span> update
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>更新软件包:</p>
<div><pre><code><span>apt-get</span> update
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>其他命令<sup></sup></p>
</li>
</ul>
<h2 id="snap"> Snap</h2>
<p>已经预装。</p>
<p>在中国大陆不建议使用 Snap</p>
<hr>
<section>
<ol>
<li id="footnote1"><p>其他命令</p>
<div><pre><code><span>apt-cache</span> search <span># ------(package 搜索包)</span>

<span>apt-cache</span> show <span>#------(package 获取包的相关信息，如说明、大小、版本等)</span>

<span>sudo</span> <span>apt-get</span> <span>install</span> <span># ------(package 安装包)sudo apt-get install # -----(package - - reinstall 重新安装包)</span>

<span>sudo</span> <span>apt-get</span> -f <span>install</span> <span># -----(强制安装?#"-f = --fix-missing"当是修复安装吧...)</span>

<span>sudo</span> <span>apt-get</span> remove <span>#-----(package 删除包)</span>

<span>sudo</span> <span>apt-get</span> remove - - purge <span># ------(package 删除包，包括删除配置文件等)</span>

<span>sudo</span> <span>apt-get</span> autoremove --purge <span># ----(package 删除包及其依赖的软件包+配置文件等(只对6.10有效，强烈推荐))</span>

<span>sudo</span> <span>apt-get</span> update <span>#------更新源</span>

<span>sudo</span> <span>apt-get</span> upgrade <span>#------更新已安装的包</span>

<span>sudo</span> <span>apt-get</span> dist-upgrade <span># ---------升级系统</span>

<span>sudo</span> <span>apt-get</span> dselect-upgrade <span>#------使用 dselect 升级</span>

<span>apt-cache</span> depends <span>#-------(package 了解使用依赖)</span>

<span>apt-cache</span> rdepends <span># ------(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧...)</span>

<span>sudo</span> <span>apt-get</span> build-dep <span># ------(package 安装相关的编译环境)</span>

<span>apt-get</span> <span>source</span> <span>#------(package 下载该包的源代码)</span>

<span>sudo</span> <span>apt-get</span> clean <span>&amp;&amp;</span> <span>sudo</span> <span>apt-get</span> autoclean <span># --------清理下载文件的存档 &amp;&amp; 只清理过时的包</span>

<span>sudo</span> <span>apt-get</span> check <span>#-------检查是否有损坏的依赖</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div> </li>
</ol>
</section>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">ubuntu</title>
    <id>https://list-jiang.github.io/linux/ubuntu/</id>
    <link href="https://list-jiang.github.io/linux/ubuntu/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ubuntu"> ubuntu</h1>
<ul>
<li>
<p><a href="./manage.html">管理包</a></p>
</li>
<li>
<p><a href="./debug.html">开发软件</a></p>
</li>
<li>
<p><a href="./webserver.html">网络服务器相关</a></p>
</li>
<li>
<p><a href="./lang.html">语言切换</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <category term="Linux"/>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-21T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">网络服务器相关</title>
    <id>https://list-jiang.github.io/linux/ubuntu/webserver/</id>
    <link href="https://list-jiang.github.io/linux/ubuntu/webserver/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="网络服务器相关"> 网络服务器相关</h1>
<h2 id="ftp"> ftp</h2>
<h3 id="vsftpd"> vsftpd</h3>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>apt-get</span> <span>install</span> vsftpd <span>ftp</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>配置</p>
<div><pre><code><span>vim</span> /etc/vsftpd.conf
</code></pre>
<div><span>1</span><br></div></div><p>至少要更改:</p>
<div><pre><code><span>write_enable</span><span>=</span><span>YES</span>
<span>utf8_filesystem</span><span>=</span><span>YES</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="nginx"> Nginx</h2>
<ul>
<li>
<p>安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> nginx
</code></pre>
<div><span>1</span><br></div></div><p>Nginx 默认安装在 <code>/etc/nginx</code> 目录下</p>
</li>
<li>
<p>配置</p>
<p>配置文件为 <code>nginx.conf</code>。</p>
<p>默认站点配置文件在 <code>/etc/nginx/sites-available/default</code></p>
<p>为了使得 Nginx 能使用 PHP，需要配置</p>
<div><pre><code>
<span><span>location</span> ~ \.php$</span> <span>{</span>
    <span><span>root</span>           /var/www/html</span><span>;</span>
    <span># 配置给 socks 应该可行，还在研究中</span>
    <span><span>fastcgi_pass</span>   127.0.0.1:9000</span><span>;</span>
    <span><span>fastcgi_index</span>  index.php</span><span>;</span>
    <span><span>fastcgi_param</span>  SCRIPT_FILENAME  <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>include</span>        fastcgi_params</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<h2 id="php"> PHP</h2>
<div><pre><code><span># Apache</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php

<span># Ngnix</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-fpm

<span># MySQL</span>
<span>sudo</span> <span>apt-get</span> <span>install</span> php-mysql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="mysql"> MySQL</h2>
<h3 id="安装"> 安装</h3>
<div><pre><code><span>wget</span> https://dev.mysql.com/get/mysql-apt-config_0.8.14-1_all.deb
<span>sudo</span> dpkg -i mysql-apt-config_0.8.14-1_all.deb
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>配置版本(一般是 5.7)后安装</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> mysql-server
</code></pre>
<div><span>1</span><br></div></div><p>之后重启，完成配置</p>
<div><pre><code><span>sudo</span> <span>service</span> mysql restart
mysql -u root -p
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="nmp"> NMP</h2>
<p>需要对 Nginx 的配置文件进行修改: 主要改动的目标是把 Nginx 代理端口转发给 php-fpm。</p>
<p>首先配置 index:</p>
<div><pre><code><span><span>index</span> index.php index.html</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>需要注意的是，Nginx 将端口转发给 php 默认的 9000 端口。而通过 apt-get 安装的 php 默认使用本地 sock 文件通信，需要对 php 的配置进行修改。要修改的文件位于: <code>/etc/php/7.2/fpm/pool.d/www.conf</code>，将</p>
<div><pre><code><span>listen</span> <span>=</span> <span>/run/php/php7.0-fpm.sock</span>
</code></pre>
<div><span>1</span><br></div></div><p>改成:</p>
<div><pre><code><span>listen</span> <span>=</span> <span>127.0.0.1:9000</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>如果报了 permission limitted 的错误，说明 php 没法访问 html 文件夹，修改配置的 html 文件夹权限即可。</p>
</div>
]]></content>
    <author>
      <name>Mr.Hope</name>
    </author>
    <contributor>
      <name>Mr.Hope</name>
    </contributor>
    <published>2019-11-22T00:00:00.000Z</published>
    <rights>Copyright by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">自我介绍</title>
    <id>https://list-jiang.github.io/note/job/interview/</id>
    <link href="https://list-jiang.github.io/note/job/interview/"/>
    <updated>2022-02-17T08:32:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="自我介绍"> 自我介绍</h3>
<p>原文：<a href="https://www.yoodb.com/quotation/detail/1134" target="_blank" rel="noopener noreferrer">素文宅博客</a></p>
<div><p>提示</p>
<p>在企业面试环节中“自我介绍”这个老生常谈的话题就不用多说什么了，面试官必定会问的。那么如何在自我介绍的时候就能够打动面试官，吸引面试官对面试者的兴趣？如何进行自我介绍比较好？有没有什么方式方法呢？当然是有的。</p>
</div>
<h4 id="为什么面试官让面试者自我介绍"> 为什么面试官让面试者自我介绍</h4>
<ol>
<li>面试官想对面试者有个初步的了解；</li>
<li>面试官争取在仅有的时间内快速浏览简历；</li>
<li>面试官通过让面试者自我介绍来缓冲一下面试气氛，使面试者不过于太紧张影响其发挥能力。</li>
</ol>
<h4 id="自我介绍套话"> 自我介绍套话</h4>
<ol>
<li>面试官您好，我叫素文宅博客网站（面试者姓名），本科毕业（211或985重点突出一下），来自于Java精选公众号（省份、市区）。从网上看到公司招聘的这个职位，觉得自己比较适合公司的岗位，对自己的发展也有帮助，所以来这里争取下这份工作。</li>
<li>核心竞争力（最擅长的技能、最深入研究的知识领域、最积极的部分）和闪光点（做过最成功的事，主要的成就）。核心就是要体现自己胜任这份工作（介绍时候要自然有底气，合情合理，面试前要充分准备好）。
<ul>
<li><strong>初级Java工程师</strong>:
面试初级Java工程师岗位时，首先应该重点突出一下自身的知识结构，因为面试初级岗位的应聘者往往没有实际工作经验，因此要强调自身的知识结构体系。如果是计算机相关专业的应届生，那么一定要首先突出描述自己的学历背景；因为学历背景是自身知识结构一个有力的<code>敲门砖</code>，如果是非计算机专业的毕业生，则要重点突出说一下自身的学习经历，强调自己的学习能力，与此同时突出一下自己的动手和实践能力。最后不管是计算机专业还是非计算机专业都要重点描述一下掌握了哪些Java技术，比如开源框架、数据库、大数据、消息队列、缓存等等。
总的来说，初级Java工程师岗位的面试需要在自我介绍中突出三点内容，其一是自身的知识结构；其二是独立开发能力；其三是学习能力，这三个方面的表述往往能够决定最终的面试结果。</li>
<li><strong>中高级Java工程师</strong>:
面试中高级Java工程师岗位时，首先应该重点强调一下自己的项目开发经验，从技术选型、方案设计到具体编码都要有一个清晰的思路来描述，在描述过程中要把自己的开发经验突出一下，比如经历了哪些不同的开发场景，解决了哪些疑难问题等，如果具有较多的行业经验，也一定要突出一下（多行业经验有时未必是好事，建议挑重点行业或者面试企业对口行业）。
面试中高级Java工程师岗位时虽然比较看重经验，但同时也比较看重应聘者的沟通交流能力，因为不少开发问题说到底就是沟通不清楚导致的问题，沟通能力较强的程序员往往能够更高效地完成工作任务。</li>
</ul>
</li>
<li>先介绍到这里，面试官看看您还有什么问题，我可以再补充。</li>
<li>在最后自我介绍结束时要说谢谢，任何面试官都喜欢有礼貌的人！
注意：切记不要自曝其短（说自己的缺点），在进行自我介绍的时候千万不要和简历有冲突！（有的会说简历未更新，那也是面试者自身问题）</li>
</ol>
<h3 id="面试官必问"> 面试官必问</h3>
<h4 id="你有什么优劣势"> 你有什么优劣势？</h4>
<ol>
<li>优点方面尽量突出一些的（技术痴迷、学习能力强、为人谦和），但要注意不要浮夸吹嘘，那样反而把优点变成了缺点。</li>
<li>劣势方面不是计算机专业可以（非计算机专业人员），但是对技术很是痴迷。关注公众号“Java精选”更多关于面试技巧、面试经验分享。</li>
</ol>
<div><p>注意事项</p>
<p>面试时面试官谈及个人缺点，最好的办法还是坦然地承认它，为自己的缺点辩驳也无济于事，重要的是如何让别人在感情上认同你谈及自身缺点的态度。</p>
</div>
<h4 id="你为什么选择我们公司"> 你为什么选择我们公司？</h4>
<ol>
<li>面试前，应对应聘公司各方面，要了解详尽！至少要了解到行业、企业、岗位这三方面！最好要准备一些具体的数据和实例！</li>
<li>面试时，可以将之前对公司的了解（行业、企业、数据、实例）结合自己的JAVA岗位，大略的说一遍，然后强调自己“觉得这个工作合适”即可。</li>
<li>面试者如果对面试公司所属行业确实很喜欢，要说出自身对这个行业的认知程度。</li>
</ol>
<h3 id="面试者必问"> 面试者必问</h3>
<div><p>提示</p>
<p>面试是个双向选择，公司发布岗位招聘，标明工资福利。通过一系列面试来筛选出符合自己要求的员工。工人选择岗位招聘，通过一系列面试来获得工作进入职场，上班拿薪水生活。当公司通过一系列的一轮、二轮、...n轮面试来选择员工的时候，我们作为应聘者也应该考量这份工作除了表明的薪水还能给我们带来什么？</p>
</div>
<ol>
<li><strong>薪资组成</strong>
极少的基础工资加上极高的绩效这种最好慎重、因为加班费大多是按照基础工资算的。五险一金也是按照基础工资为基数，在从当地的可选比例里面选一个缴纳的。</li>
<li><strong>五险一金比例</strong>
不同的地区缴纳比例大多不一样，没有定死的。大多是一个区间，比如公积金缴纳比例 5%-12% 这种，如果你的公司给你缴纳的公积金比例是取 5% 的话，那么你应该慎重选择了。像这么抠的，进去后绝对还能刷新你的下线。</li>
<li><strong>技术架构</strong>
这点对于从事技术线发展的人而言，尤其重要。技术尽管并不是越新越好，一切的技术最终都是落于业务产生经济效益才是有意义的，但是如果对方的公司目前技术方案落后于主流十几二十年，直接就意味着工作上的技术出了这家公司是没人看的上的。此时个人的技术成长基本上就必须是抛开上班时间了。java招聘一般工作经验与工资是成正比例关系的，但有个前提，技术得达标。</li>
<li><strong>成长体系</strong>
不同公司职位划分，职称评定都不一样。一样的是，如果面试官都说不清的公司成长体系，那么不用想，公司的人事变动基本上就全是离职、入职。甚少有职位上升。</li>
<li><strong>入职负责业务方向</strong>
以上都满意了，此时就要考虑将来工作做什么？如果此时入职所接触的业务与上家的差不多，那么自然入职顺畅许多，甚至关系处理的好的话可以申请提前转正。但是如果接触的是全新的业务的话，此时就要做好心里准备，必定需要花大量的时间来学习，免不了要不停的询问公司的老员工。</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2022-02-17T08:32:06.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">note</title>
    <id>https://list-jiang.github.io/note/</id>
    <link href="https://list-jiang.github.io/note/"/>
    <updated>2022-02-17T08:32:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="随笔集合"> 随笔集合</h2>
<blockquote>
<p>记录工作中的小经验</p>
</blockquote>
<h3 id="spring-随笔"> Spring 随笔</h3>
<ul>
<li><a href="./spring/square.html">Spring Cloud Square</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-01-20T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">随笔一</title>
    <id>https://list-jiang.github.io/note/spring/note1/</id>
    <link href="https://list-jiang.github.io/note/spring/note1/"/>
    <updated>2022-02-17T08:32:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="随笔一"> 随笔一</h1>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2022-02-17T08:32:06.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Spring Cloud Square</title>
    <id>https://list-jiang.github.io/note/spring/square/</id>
    <link href="https://list-jiang.github.io/note/spring/square/"/>
    <updated>2022-02-17T08:37:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-cloud-square-retrofit-定义"> spring-cloud-square-retrofit 定义</h1>
<p>微服务远程调用框架，用于弥补 OpenFeign 对于响应式调用的缺失</p>
<h1 id="场景"> 场景</h1>
<p>响应式微服务之间的调用，例如基于 Spring WebFlux 提供的 http 接口服务。尽管可以通过 WebClient 手动配置 ReactorLoadBalancerExchangeFilterFunction 实例来实现负载。如下案例，但无法像 OpenFeign 那样通过调用方法的方式调用远程服务，而且无法兼容非响应式的 http 接口服务。</p>
<div><pre><code>    <span>private</span> <span>final</span> <span>WebClient<span>.</span>Builder</span> loadBalancedWebClientBuilder<span>;</span>

    <span>public</span> <span>DemoConsumerController</span><span>(</span><span>WebClient<span>.</span>Builder</span> loadBalancedWebClientBuilder<span>)</span> <span>{</span>
        <span>this</span><span>.</span>loadBalancedWebClientBuilder <span>=</span> loadBalancedWebClientBuilder<span>;</span>
    <span>}</span>

    <span>@LoadBalanced</span>
    <span>@Bean</span>
    <span>WebClient<span>.</span>Builder</span> <span>webClientBuilder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>WebClient</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// http://服务名</span>
    <span>private</span> <span>final</span> <span>String</span> SERVICE <span>=</span> <span>"http://silky-demo-webflux"</span><span>;</span>
    <span>@RequestMapping</span><span>(</span><span>"/mono"</span><span>)</span>
    <span>public</span> <span>Mono</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>mono</span><span>(</span><span>@RequestParam</span><span>(</span>value <span>=</span> <span>"name"</span><span>,</span> defaultValue <span>=</span> <span>"Mary"</span><span>)</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>return</span> loadBalancedWebClientBuilder<span>.</span><span>build</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>uri</span><span>(</span>SERVICE <span>+</span> <span>"/producer/mono"</span><span>)</span>
                <span>.</span><span>retrieve</span><span>(</span><span>)</span><span>.</span><span>bodyToMono</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span>
                <span>.</span><span>map</span><span>(</span>greeting <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"%s, %s!"</span><span>,</span> greeting<span>,</span> name<span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="使用案例"> 使用案例</h1>
<h2 id="web-案例"> web 案例</h2>
<div><pre><code><span>/**
 * 启动类声明开启 EnableRetrofitClients
 */</span>
<span>@SpringBootApplication</span>
<span>@EnableEurekaClient</span>
<span>@EnableRetrofitClients</span>
<span>public</span> <span>class</span> <span>SquareWebServer</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>SquareWebServer</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>// OkHttpConfig.java</span>
<span>@Configuration</span>
<span>public</span> <span>class</span> <span>OkHttpConfig</span> <span>{</span>

    <span>@Bean</span>
    <span>@LoadBalanced</span>
    <span>public</span> <span>OkHttpClient<span>.</span>Builder</span> <span>builder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>OkHttpClient<span>.</span>Builder</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
<span>// SilkyWebClient.java</span>
<span>@RetrofitClient</span><span>(</span><span>"silky-demo-web"</span><span>)</span>
<span>public</span> <span>interface</span> <span>SilkyWebClient</span> <span>{</span>
    <span>@GET</span><span>(</span><span>"/producer/sleep/{seconds}"</span><span>)</span>
    <span>Call</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>sleep</span><span>(</span><span>@Path</span><span>(</span><span>"seconds"</span><span>)</span> <span>int</span> seconds<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>// build.gradle</span>
dependencies <span>{</span>
    implementation <span>'org.springframework.boot:spring-boot-starter-web'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-bootstrap'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-config'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-loadbalancer'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>
    <span>// 添加 spring-cloud-square 依赖</span>
    implementation <span>'org.springframework.cloud:spring-cloud-square-okhttp:0.4.0'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-square-retrofit:0.4.0'</span>
    implementation <span>'org.projectlombok:lombok'</span>
    annotationProcessor <span>'org.projectlombok:lombok'</span>
    testImplementation <span>'org.springframework.boot:spring-boot-starter-test'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="web-flux-案例"> web flux 案例</h2>
<div><pre><code><span>/**
 * 启动类声明开启 EnableRetrofitClients
 */</span>
<span>@SpringBootApplication</span>
<span>@EnableEurekaClient</span>
<span>@EnableRetrofitClients</span>
<span>public</span> <span>class</span> <span>SquareWebServer</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>SquareWebServer</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>// WebClientConfig.java</span>
<span>@Configuration</span>
<span>public</span> <span>class</span> <span>WebClientConfig</span> <span>{</span>

    <span>@Bean</span>
    <span>@LoadBalanced</span>
    <span>public</span> <span>WebClient<span>.</span>Builder</span> <span>builder</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>WebClientConfig</span><span>(</span><span>)</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
<span>// SilkyWebFluxClient.java</span>
<span>@RetrofitClient</span><span>(</span><span>"silky-demo-webflux"</span><span>)</span>
<span>public</span> <span>interface</span> <span>SilkyWebFluxClient</span> <span>{</span>
    <span>@GET</span><span>(</span><span>"/port/{name}"</span><span>)</span>
    <span>Mono</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>port</span><span>(</span><span>@Path</span><span>(</span><span>"name"</span><span>)</span> <span>int</span> name<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>// build.gradle</span>
dependencies <span>{</span>
    implementation <span>'org.springframework.boot:spring-boot-starter-web'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-bootstrap'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-config'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-loadbalancer'</span>
    implementation <span>'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'</span>
    <span>// 添加 spring-cloud-square-retrofit-webclient 依赖</span>
    implementation <span>'org.springframework.cloud:spring-cloud-square-retrofit-webclient:0.4.0'</span>
    implementation <span>'org.projectlombok:lombok'</span>
    annotationProcessor <span>'org.projectlombok:lombok'</span>
    testImplementation <span>'org.springframework.boot:spring-boot-starter-test'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="完整项目源码地址"> 完整项目源码地址</h2>
<p>gitee: <a href="https://gitee.com/jdw-silky/silky-parent.git" target="_blank" rel="noopener noreferrer"></a></p>
<h3 id="基础启动说明"> 基础启动说明</h3>
<ol>
<li>以 native 环境启动 silky-eureka-server</li>
<li>以 native 环境启动 silky-config</li>
<li>以 native 环境启动两个 silky-demo-web ，由于配置文件端口写的 0，所以无需专门配置端口</li>
<li>以 native 环境启动两个 silky-demo-webflux ，由于配置文件端口写的 0，所以无需专门配置端口</li>
</ol>
<h3 id="测试"> 测试</h3>
<p>在 silky-demo-square-web 与 silky-demo-square-webflux 都写了响应的单元测试，可直接验证</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Spring"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2022-02-17T08:32:06.000Z</published>
    <rights>本教程采用&lt;a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh"&gt;知识共享 署名-相同方式共享 3.0协议&lt;/a&gt;</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>https://list-jiang.github.io/</id>
    <link href="https://list-jiang.github.io/"/>
    <updated>2022-02-11T09:03:30.000Z</updated>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Chrome</title>
    <id>https://list-jiang.github.io/software/chrome/</id>
    <link href="https://list-jiang.github.io/software/chrome/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Chrome 是谷歌出品的浏览器。其内核使用 Chromium，基于 JavaScript V8，是全球比例最大的浏览器内核。</p>

<h2 id="简介"> 简介</h2>
<p>Chrome 如今可以说是一家独大。很多国内浏览器都是基于 Chromium 内核的套壳浏览器。</p>
<p>Chrome 内核更新频繁，速度和安全性高，对新特性支持非常良好。另外谷歌具有十分强大的开发者工具，是前端开发使用的首选浏览器。目前最新的版本是 85。</p>
<h2 id="配置"> 配置</h2>
<p>由于 Chrome 是谷歌出品的浏览器，所以搜索栏默认使用 Google 搜索，而在中国无法访问 Google 服务，所以需要在右上角的菜单中选择设置，在搜索引擎设置中改为百度即可正常使用。</p>
<p><img src="./assets/searchEngine.png" alt="更改页面" loading="lazy"></p>
<h2 id="快捷键"> 快捷键</h2>
<p>Chrome 具有很多快捷键，熟练掌握后可以大幅减少时间。</p>
<ul>
<li><code>Ctrl + J</code>: 打开下载页面；</li>
<li><code>Ctrl + H</code>: 打开历史页面；</li>
<li><code>Ctrl + T</code>: 打开新标签页；</li>
<li><code>Ctrl + Shift + T</code>: 恢复上一个关闭的标签页；</li>
<li><code>Ctrl + N</code>: 打开新的窗口；</li>
<li><code>Ctrl + W</code>: 关闭当前标签页；</li>
<li><code>Ctrl + Tab</code>: 切换标签页；</li>
<li><code>Ctrl + Shift + Tab</code>: 反向切换标签页；</li>
<li><code>Ctrl + F</code>: 反向切换标签页；</li>
<li><code>Ctrl + Shift + I</code> 或 <code>F12</code>: 打开开发者工具；</li>
</ul>
<h2 id="开发者工具"> 开发者工具</h2>
<p><img src="./assets/devTool.png" alt="开发者工具" loading="lazy"></p>
<p>使用 <code>Ctrl + Shift + I</code> 或 <code>F12</code> 即可打开开发者工具，在开发者工具里，您可以自由的对任何网页进行调试。</p>
<h2 id="chrome-推荐扩展"> Chrome 推荐扩展</h2>
<ul>
<li>AdGuard: 广告屏蔽；</li>
<li>Adobe Acrobat: 将当前网页转为 Adobe PDF 文件；</li>
<li>Betternet Unlimited Free VPN Proxy: 免费的 VPN 代理；</li>
<li>Checker Plus for Gmail™: Gmail 邮件管理；</li>
<li>Convertio: 非常强大的文件在线转换；</li>
<li>Dark Reader: 为网页启用夜间模式；</li>
<li>Enhanced GitHub: 能够展示仓库大小，文件大小和快速下载按钮；</li>
<li>Evernote Web Clipper: 印象笔记剪藏，非常好用的保存工具；</li>
<li>Google 翻译: 谷歌翻译软件；</li>
<li>ImTranslator: 翻译，字典，声音</li>
<li>Infinity: 一款非常好的标签页软件；</li>
<li>Office Online: 在线查看并编辑 Office 文件；</li>
<li>React Developer Tools: React 开发者工具</li>
<li>Save to Pocket: 离线网页的最佳插件；</li>
<li>VPN Free - Betternet Unlimited VPN Proxy: 一款免费的 VPN 插件；</li>
<li>Vue.js Devtools: Vue.js 的开发者工具；</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="软件"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-13T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">查看容器当前日志</title>
    <id>https://list-jiang.github.io/software/command/docker/</id>
    <link href="https://list-jiang.github.io/software/command/docker/"/>
    <updated>2021-12-07T13:06:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="查看容器当前日志"> 查看容器当前日志</h3>
<div><pre><code><span>## 查看容器 gitlab 自 2021-12-06 后的当前最新50条日志</span>
 docker logs -f -t --since<span>=</span><span>"2021-12-06"</span> --tail<span>=</span><span>50</span> gitlab
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">window10环境</title>
    <id>https://list-jiang.github.io/software/command/dos/</id>
    <link href="https://list-jiang.github.io/software/command/dos/"/>
    <updated>2021-12-07T13:06:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="window10环境"> window10环境</h3>
<h4 id="刷新dns"> 刷新dns</h4>
<div><pre><code>ipconfig /flushdns
</code></pre>
<div><span>1</span><br></div></div><h4 id="打印环境变量"> 打印环境变量</h4>
<div><pre><code><span># 该指令在 power shell 内无效</span>
<span>echo</span> %JAVA_HOME%
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">代码编辑器</title>
    <id>https://list-jiang.github.io/software/editor/</id>
    <link href="https://list-jiang.github.io/software/editor/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>
<p><a href="./vscode/">VS Code</a></p>
<p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。</p>
<p>VS Code 具有最大的编辑器社区，插件是所有编辑器里最全的。可以通过安装扩展实现几乎所有的功能，但扩展设置界面对新手不够友好，适合有一定经验的开发者。</p>
<div><p>提示</p>
<p>推荐使用轻量的 Visual Studio Code。</p>
</div>
</li>
<li>
<p>其他代码编辑器</p>
<p>在不同领域的开发者可能会偏向不同种类的开发工具。下面列举其他常见的代码编辑器。</p>
<ul>
<li>WebStorm 是专业的 web 开发工具，提供格式化、代码补全等选项。</li>
<li>PhpStorm 是专业的 php 开发工具，提供格式化、代码补全等选项。</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener noreferrer">notepad++</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener noreferrer">atom</a></li>
<li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener noreferrer">sublime text</a></li>
</ul>
</li>
</ul>
<div><p>IDE 与编辑器</p>
<p>IDE 和编辑器是有区别的:</p>
<ul>
<li>
<p>IDE: 对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</p>
</li>
<li>
<p>编辑器: 要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</p>
</li>
</ul>
<p>需要注意的是，VS Code 的定位是编辑器，而非 IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="软件"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">分支管理</title>
    <id>https://list-jiang.github.io/software/git/branch/</id>
    <link href="https://list-jiang.github.io/software/git/branch/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述"> 概述</h2>
<p>分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN!</p>
<p><img src="./assets/learn-branches.png" alt="Learn branches" loading="lazy"></p>
<p>分支在实际中有什么用呢? 假设您准备开发一个新功能，但是需要两周才能完成，第一周您写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。您创建了一个属于您自己的分支，别人看不到，还继续在原来的分支上正常工作，而您在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后您会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成! 无论您的版本库是 1 个文件还是 1 万个文件。</p>
<h2 id="创建与合并分支"> 创建与合并分支</h2>
<p>在版本回退里，您已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 <code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点:</p>
<p><img src="./assets/git6.png" alt="示意图" loading="lazy"></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着您不断提交，<code>master</code> 分支的线也越来越长:</p>
<p>当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 dev 上:</p>
<p><img src="./assets/git7.png" alt="示意图" loading="lazy"></p>
<p>您看，Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改改 <code>HEAD</code> 的指向，工作区的文件都没有任何变化!</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，<code>dev</code> 指针往前移动一步，而 <code>master</code> 指针不变:</p>
<p><img src="./assets/git8.png" alt="示意图" loading="lazy"></p>
<p>假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢? 最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并:</p>
<p><img src="./assets/git9.png" alt="示意图" loading="lazy"></p>
<p>所以 Git 合并分支也很快! 就改改指针，工作区内容也不变!</p>
<p>合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支:</p>
<p><img src="./assets/git10.png" alt="示意图" loading="lazy"></p>
<p>下面开始实战。首先，我们创建 dev 分支，然后切换到 dev 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令:</p>
<div><pre><code>$ <span>git</span> branch dev
<span># nothing</span>
$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，用 <code>git branch</code> 命令查看当前分支:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p>
<p>然后，我们就可以在 dev 分支上正常提交，比如对 <code>readme.txt</code> 做个修改，加上一行:</p>
<div><pre><code>Creating a new branch is quick.
</code></pre>
<div><span>1</span><br></div></div><p>然后提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"branch test"</span>
<span>[</span>dev b17d20e<span>]</span> branch <span>test</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在，dev 分支的工作完成，我们就可以切换回 master 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>切换回 master 分支后，再查看一个 <code>readme.txt</code> 文件，刚才添加的内容不见了! 因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变:</p>
<p><img src="./assets/git11.png" alt="示例图" loading="lazy"></p>
<p>现在，我们把 dev 分支的工作成果合并到 master 分支上:</p>
<div><pre><code>$ <span>git</span> merge dev
Updating d46f35e<span>..</span>b17d20e
Fast-forward
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>git merge</code> 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。</p>
<p>注意到上面的 <code>Fast-forward</code> 信息，Git 告诉我们，这次合并是 “快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 <code>Fast-forward</code>。合并完成后，就可以放心地删除 dev 分支了:</p>
<div><pre><code>$ <span>git</span> branch -d dev
Deleted branch dev <span>(</span>was b17d20e<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>删除后，查看 <code>branch</code>，就只剩下 <code>master</code> 分支了:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为创建、合并和删除分支非常快，所以 Git 鼓励您使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>
<h3 id="分支小结"> 分支小结</h3>
<ul>
<li>
<p>查看分支: <code>git branch</code></p>
</li>
<li>
<p>创建分支: <code>git branch &lt;name&gt;</code></p>
</li>
<li>
<p>切换分支: <code>git checkout &lt;name&gt;</code></p>
</li>
<li>
<p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p>
</li>
<li>
<p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p>
</li>
<li>
<p>删除分支: <code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<hr>
<h2 id="冲突"> 冲突</h2>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的 <code>feature1</code> 分支，继续我们的新分支开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature1
Switched to a new branch <span>'feature1'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改 readme.txt 最后一行，改为:</p>
<div><pre><code>Creating a new branch is quick AND simple.
</code></pre>
<div><span>1</span><br></div></div><p>在 <code>feature1</code> 分支上提交:</p>
<div><pre><code>git add readme.txt

\$ git commit -m "AND simple"
[feature1 14096d0] AND simple
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>切换到 <code>master</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>1</span> commit.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Git 还会自动提示我们当前 <code>master</code> 分支比远程的 <code>master</code> 分支要超前 1 个提交。</p>
<p>在 <code>master</code> 分支上把 readme.txt 文件的最后一行改为:</p>
<div><pre><code>Creating a new branch is quick &amp; simple.
</code></pre>
<div><span>1</span><br></div></div><p>提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"&amp; simple"</span>
<span>[</span>master 5dc6824<span>]</span> <span>&amp;</span> simple
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支各自都分别有新的提交，变成了这样:</p>
<p><img src="./assets/git12.png" alt="示例图" loading="lazy"></p>
<p>这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看:</p>
<div><pre><code>$ <span>git</span> merge feature1
Auto-merging readme.txt
CONFLICT <span>(</span>content<span>)</span>: Merge conflict <span>in</span> readme.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>果然冲突了! Git 告诉我们，<code>readme.txt</code> 文件存在冲突，必须手动解决冲突后再提交。<code>git status</code> 也可以告诉我们冲突的文件:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>2</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

You have unmerged paths.
  <span>(</span>fix conflicts and run <span>"git commit"</span><span>)</span>
  <span>(</span>use <span>"git merge --abort"</span> to abort the merge<span>)</span>

Unmerged paths:
  <span>(</span>use <span>"git add &lt;file>..."</span> to mark resolution<span>)</span>

    both modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>我们可以直接查看 readme.txt 的内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<span><span>&lt;</span><span>&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</span></span>Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
<span><span>></span><span>>>>>>> feature1
</span></span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Git 用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，我们修改如下后保存:</p>
<div><pre><code>Creating a new branch is quick and simple.
</code></pre>
<div><span>1</span><br></div></div><p>再提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"conflict fixed"</span>
<span>[</span>master cf810e4<span>]</span> conflict fixed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支变成了下图所示:</p>
<p><img src="./assets/git13.png" alt="示例图" loading="lazy"></p>
<p>用带参数的 <code>git log</code> 也可以看到分支的合并情况:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   cf810e4 <span>(</span>HEAD -<span>></span> master<span>)</span> conflict fixed
<span>|</span><span>\</span>
<span>|</span> * 14096d0 <span>(</span>feature1<span>)</span> AND simple
* <span>|</span> 5dc6824 <span>&amp;</span> simple
<span>|</span>/
* b17d20e branch <span>test</span>
* d46f35e <span>(</span>origin/master<span>)</span> remove test.txt
* b84166e <span>add</span> test.txt
* 519219b <span>git</span> tracks changes
* e43a48b understand how stage works
* 1094adb append GPL
* e475afc <span>add</span> distributed
* eaadf4e wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>最后，删除 feature1 分支:</p>
<div><pre><code>$ <span>git</span> branch -d feature1
Deleted branch feature1 <span>(</span>was 14096d0<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="冲突小结"> 冲突小结</h3>
<ul>
<li>
<p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p>
</li>
<li>
<p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p>
</li>
</ul>
<h2 id="分支管理策略"> 分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>实战一下 <code>--no-ff</code> 方式的 <code>git merge</code>。首先，仍然创建并切换 <code>dev</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>修改 readme.txt 文件，并提交一个新的 <code>commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"add merge"</span>
<span>[</span>dev f52c633<span>]</span> <span>add</span> merge
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>现在，我们切换回 <code>master</code>:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>准备合并 <code>dev</code> 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>:</p>
<div><pre><code>$ <span>git</span> merge --no-ff -m <span>"merge with no-ff"</span> dev
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>因为本次合并要创建一个新的 <code>commit</code>，所以加上 <code>-m</code> 参数，把 <code>commit</code> 描述写进去。</p>
<p>合并后，我们用 <code>git log</code> 看看分支历史:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e1e9c68 <span>(</span>HEAD -<span>></span> master<span>)</span> merge with no-ff
<span>|</span><span>\</span>
<span>|</span> * f52c633 <span>(</span>dev<span>)</span> <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到，不使用 <code>Fast forward</code> 模式，<code>merge</code> 后就像这样:</p>
<p><img src="./assets/git14.png" alt="示例图" loading="lazy"></p>
<h3 id="分支管理惯例"> 分支管理惯例</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理:</p>
<p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢? 干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 <code>1.0</code> 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布 <code>1.0</code> 版本；</p>
<p>您和您的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样:</p>
<p><img src="./assets/git15.png" alt="示例图" loading="lazy"></p>
<h3 id="分支管理小结"> 分支管理小结</h3>
<ul>
<li>
<p>Git 分支十分强大，在团队开发中应该充分应用。</p>
</li>
<li>
<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</p>
</li>
</ul>
<hr>
<h2 id="bug-分支"> Bug 分支</h2>
<p>软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当您接到一个修复一个代号 101 的 bug 的任务时，很自然地，您想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 dev 上进行的工作还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>并不是您不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办?</p>
<p>幸好，Git 还提供了一个 <code>stash</code> 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作:</p>
<div><pre><code>$ <span>git</span> stash
Saved working directory and index state WIP on dev: f52c633 <span>add</span> merge
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，用 <code>git status</code> 查看工作区，就是干净的(除非有没有被 Git 管理的文件)，因此可以放心地创建分支来修复 bug。</p>
<p>首先确定要在哪个分支上修复 bug，假定需要在 master 分支上修复，就从 master 创建临时分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> checkout -b issue-101
Switched to a new branch <span>'issue-101'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"fix bug 101"</span>
<span>[</span>issue-101 4c805e2<span>]</span> fix bug <span>101</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>修复完成后，切换到 <code>master</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> merge --no-ff -m <span>"merged bug fix 101"</span> issue-101
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>2</span> +-
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>太棒了，原计划两个小时的 bug 修复只花了 5 分钟! 现在，是时候接着回到 <code>dev</code> 分支干活了!</p>
<div><pre><code>$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>

$ <span>git</span> status
On branch dev
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>工作区是干净的，刚才的工作现场存到哪去了? 用 <code>git stash list</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> stash list
stash@<span>{</span><span>0</span><span>}</span>: WIP on dev: f52c633 <span>add</span> merge
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法:</p>
<p>一是用 <code>git stash apply</code> 恢复，但是恢复后，<code>stash</code> 内容并不删除，您需要用 <code>git stash drop</code> 来删除；</p>
<p>另一种方式是用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了:</p>
<div><pre><code>$ <span>git</span> stash pop
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Dropped refs/stash@<span>{</span><span>0</span><span>}</span> <span>(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>再用 <code>git stash list</code> 查看，就看不到任何 stash 内容了。您可以多次 stash，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令:</p>
<div><pre><code><span>git</span> stash apply stash@<span>{</span><span>0</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="暂存小结"> 暂存小结</h3>
<ul>
<li>
<p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p>
</li>
<li>
<p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场。</p>
</li>
</ul>
<hr>
<h2 id="feature-分支"> Feature 分支</h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，您肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 <code>feature</code> 分支，在上面开发，完成后，合并，最后，删除该 <code>feature</code> 分支。</p>
<p>现在，您终于接到了一个新任务: 开发代号为 <code>Vulcan</code> 的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature-vulcan
Switched to a new branch <span>'feature-vulcan'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>5 分钟后，开发完毕:</p>
<div><pre><code><span>git</span> <span>add</span> vulcan.py

$ <span>git</span> status
On branch feature-vulcan
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   vulcan.py

$ <span>git</span> commit -m <span>"add feature vulcan"</span>
<span>[</span>feature-vulcan 287773e<span>]</span> <span>add</span> feature vulcan
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> vulcan.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>切回 <code>dev</code>，准备合并:</p>
<div><pre><code><span>git</span> checkout dev
</code></pre>
<div><span>1</span><br></div></div><p>一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。</p>
<p>但是!</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消!</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁:</p>
<div><pre><code>$ <span>git</span> branch -d feature-vulcan
error: The branch <span>'feature-vulcan'</span> is not fully merged.
If you are sure you want to delete it, run <span>'git branch -D feature-vulcan'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>销毁失败。Git 友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 <code>-D</code> 参数。。</p>
<p>现在我们强行删除:</p>
<div><pre><code>$ <span>git</span> branch -D feature-vulcan
Deleted branch feature-vulcan <span>(</span>was 287773e<span>)</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>终于删除成功!</p>
<h3 id="删除小结"> 删除小结</h3>
<ul>
<li>
<p>开发一个新 feature，最好新建一个分支；</p>
</li>
<li>
<p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p>
</li>
</ul>
<hr>
<h2 id="多人协作"> 多人协作</h2>
<p>当您从远程仓库克隆时，实际上 Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了，并且，远程仓库的默认名称是 <code>origin</code>。</p>
<p>要查看远程库的信息，用 <code>git remote</code>:</p>
<div><pre><code>$ <span>git</span> remote
origin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者，用 <code>git remote -v</code> 显示更详细的信息:</p>
<div><pre><code>$ <span>git</span> remote -v
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>fetch<span>)</span>
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>push<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p>
<h3 id="推送分支"> 推送分支</h3>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成:</p>
<div><pre><code><span>git</span> push origin dev
</code></pre>
<div><span>1</span><br></div></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢?</p>
<p><code>master</code> 分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看您每周到底修复了几个 bug；</p>
<p><code>feature</code> 分支是否推到远程，取决于您是否和您的小伙伴合作在上面开发。</p>
<p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视您的心情而定!</p>
<h3 id="抓取分支"> 抓取分支</h3>
<p>多人协作时，大家都会往 <code>master</code> 和 <code>dev</code> 分支上推送各自的修改。</p>
<p>现在，模拟一个您的小伙伴，可以在另一台电脑 (注意要把 SSH Key 添加到 GitHub) 或者同一台电脑的另一个目录下克隆:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/learngit.git
Cloning into <span>'learngit'</span><span>..</span>.
remote: Counting objects: <span>40</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>21</span>/21<span>)</span>, done.
remote: Total <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, reused <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, pack-reused <span>0</span>
Receiving objects: <span>100</span>% <span>(</span><span>40</span>/40<span>)</span>, done.
Resolving deltas: <span>100</span>% <span>(</span><span>14</span>/14<span>)</span>, done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>当您的小伙伴从远程库 clone 时，默认情况下，您的小伙伴只能看到本地的 <code>master</code> 分支。不信可以用 <code>git branch</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，您的小伙伴要在 <code>dev</code> 分支上开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地 <code>dev</code> 分支:</p>
<div><pre><code><span>git</span> checkout -b dev origin/dev
</code></pre>
<div><span>1</span><br></div></div><p>现在，他就可以在 <code>dev</code> 上继续修改，然后，时不时地把 <code>dev</code> 分支 push 到远程:</p>
<div><pre><code><span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add env"</span>
<span>[</span>dev 7a5e5dd<span>]</span> <span>add</span> <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
Counting objects: <span>3</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, <span>308</span> bytes <span>|</span> <span>308.00</span> KiB/s, done.
Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   f52c633<span>..</span>7a5e5dd  dev -<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>您的小伙伴已经向 <code>origin/dev</code> 分支推送了他的提交，想要获取他的工作，您可以执行 <code>git fetch origin dev</code>。</p>
<p>如果这时碰巧您也对同样的文件作了修改，并试图推送:</p>
<div><pre><code>$ <span>cat</span> env.txt
<span>env</span>

<span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add new env"</span>
<span>[</span>dev 7bd91f1<span>]</span> <span>add</span> new <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        dev -<span>></span> dev <span>(</span>non-fast-forward<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes <span>(</span>e.g.
hint: <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>推送失败，因为您的小伙伴的最新提交和您试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用 <code>git pull</code> 把最新的提交从 <code>origin/dev</code> 抓下来，然后，在本地合并，解决冲突，再推送:</p>
<div><pre><code>$ <span>git</span> pull
There is no tracking information <span>for</span> the current branch.
Please specify <span>which</span> branch you want to merge with.
See git-pull<span>(</span><span>1</span><span>)</span> <span>for</span> details.

    <span>git</span> pull <span>&lt;</span>remote<span>></span> <span>&lt;</span>branch<span>></span>

If you wish to <span>set</span> tracking information <span>for</span> this branch you can <span>do</span> so with:

    <span>git</span> branch --set-upstream-to<span>=</span>origin/<span>&lt;</span>branch<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><code>git pull</code> 也失败了，原因是没有指定本地 <code>dev</code> 分支与远程 <code>origin/dev</code> 分支的链接，根据提示，设置 <code>dev</code> 和 <code>origin/dev</code> 的链接:</p>
<div><pre><code>$ <span>git</span> branch --set-upstream-to<span>=</span>origin/dev dev
Branch <span>'dev'</span> <span>set</span> up to track remote branch <span>'dev'</span> from <span>'origin'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再 pull:</p>
<div><pre><code>$ <span>git</span> pull
Auto-merging env.txt
CONFLICT <span>(</span>add/add<span>)</span>: Merge conflict <span>in</span> env.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这回 <code>git pull</code> 成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"fix env conflict"</span>
<span>[</span>dev 57c53ab<span>]</span> fix <span>env</span> conflict

$ <span>git</span> push origin dev
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>4</span>/4<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>621</span> bytes <span>|</span> <span>621.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   7a5e5dd<span>..</span>57c53ab  dev -<span>></span> dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因此，多人协作的工作模式通常是这样:</p>
<p>首先，可以试图用 <code>git push origin &lt;branch-name&gt;</code> 推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比您的本地更新，需要先用 <code>git pull</code> 试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用 <code>git push origin &lt;branch-name&gt;</code> 推送就能成功!</p>
<p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="多人协作小结"> 多人协作小结</h3>
<ul>
<li>
<p>查看远程库信息，使用 <code>git remote -v</code>；</p>
</li>
<li>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
</li>
<li>
<p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p>
</li>
<li>
<p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
</li>
<li>
<p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
</li>
<li>
<p>从远程拉取分支，使用 <code>git fetch</code>。</p>
</li>
<li>
<p><code>git pull</code>，相当于 <code>git fetch</code> + <code>git merge</code>，如果您的修改并没有和远程的修改发生冲突，两者会自动合并到您的本地，您可以直接推送上去。如果有冲突，要先处理冲突。</p>
</li>
</ul>
<hr>
<h2 id="rebase"> Rebase</h2>
<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后 <code>push</code> 的童鞋不得不先 <code>pull</code>，在本地合并，然后才能 <code>push</code> 成功。</p>
<p>每次合并再 <code>push</code> 后，分支变成了这样:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* d1be385 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>|</span> <span>|</span>/
* <span>|</span>   12a631b merged bug fix <span>101</span>
<span>|</span><span>\</span> <span>\</span>
<span>|</span> * <span>|</span> 4c805e2 fix bug <span>101</span>
<span>|</span>/ /
* <span>|</span>   e1e9c68 merge with no-ff
<span>|</span><span>\</span> <span>\</span>
<span>|</span> <span>|</span>/
<span>|</span> * f52c633 <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>总之看上去很乱，有强迫症的童鞋会问: 为什么 Git 的提交历史不能是一条干净的直线? 其实是可以做到的!</p>
<p>Git 有一种称为 <code>rebase</code> 的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对 <code>hello.py</code> 这个文件做了两次提交。用 <code>git log</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 582d922 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* <span>8875536</span> <span>add</span> comment
* d1be385 <span>(</span>origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意到 Git 用 <code>(HEAD -&gt; master)</code> 和 <code>(origin/master)</code> 标识出当前分支的 <code>HEAD</code> 和远程 <code>origin</code> 的位置分别是 <code>582d922 add author</code> 和 <code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支:</p>
<div><pre><code>$ <span>git</span> push origin master
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        master -<span>></span> master <span>(</span>fetch first<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the remote contains work that you <span>do</span>
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: <span>(</span>e.g., <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先 pull 一下:</p>
<div><pre><code>$ <span>git</span> pull
remote: Counting objects: <span>3</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>1</span>/1<span>)</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, reused <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, pack-reused <span>0</span>
Unpacking objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
From github.com:Hope-Studio/learngit
   d1be385<span>..</span>f005ed4  master     -<span>></span> origin/master
 * <span>[</span>new tag<span>]</span>         v1.0       -<span>></span> v1.0
Auto-merging hello.py
Merge made by the <span>'recursive'</span> strategy.
 hello.py <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>再用 <code>git status</code> 看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>3</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>加上刚才合并的提交，现在我们本地分支比远程分支超前 3 个提交。</p>
<p>用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e0ea545 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'master'</span> of github.com:Hope-Studio/learngit
<span>|</span><span>\</span>
<span>|</span> * f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* <span>|</span> 582d922 <span>add</span> author
* <span>|</span> <span>8875536</span> <span>add</span> comment
<span>|</span>/
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支 <code>push</code> 到远程，有没有问题?</p>
<p>有!</p>
<p>什么问题?</p>
<p>不好看!</p>
<p>有没有解决方法?</p>
<p>有!</p>
<p>这个时候，rebase 就派上了用场。我们输入命令 <code>git rebase</code> 试试:</p>
<div><pre><code>$ <span>git</span> rebase
First, rewinding <span>head</span> to replay your work on <span>top</span> of it<span>..</span>.
Applying: <span>add</span> comment
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
Applying: <span>add</span> author
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>输出了一大堆操作，到底是啥效果? 再用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>原本分叉的提交现在变成一条直线了! 这种神奇的操作是怎么实现的? 其实原理非常简单。我们注意观察，发现 Git 把我们本地的提交“挪动”了位置，放到了 <code>f005ed4 (origin/master) set exit=1</code> 之后，这样，整个提交历史就成了一条直线。<code>rebase</code> 操作前后，最终的提交内容是一致的，但是，我们本地的 commit 修改内容已经变化了，它们的修改不再基于 <code>d1be385 init hello</code>，而是基于 <code>f005ed4 (origin/master) set exit=1</code>，但最后的提交 <code>7e61ed4</code> 内容是一致的。</p>
<p>这就是 <code>rebase</code> 操作的特点: 把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过 <code>push</code> 操作把本地分支推送到远程:</p>
<div><pre><code>Mac:~/learngit michael$ <span>git</span> push origin master
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>576</span> bytes <span>|</span> <span>576.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>2</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, completed with <span>1</span> <span>local</span> object.
To github.com:Hope-Studio/learngit.git
   f005ed4<span>..</span>7e61ed4  master -<span>></span> master
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>再用 <code>git log</code> 看看效果:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>远程分支的提交历史也是一条直线。</p>
<h2 id="rebase-小结"> Rebase 小结</h2>
<ul>
<li>
<p><code>rebase</code> 操作可以把本地未 <code>push</code> 的分叉提交历史整理成直线；</p>
</li>
<li>
<p><code>rebase</code> 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">修改管理</title>
    <id>https://list-jiang.github.io/software/git/change/</id>
    <link href="https://list-jiang.github.io/software/git/change/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="管理修改"> 管理修改</h2>
<p>Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。</p>
<p>您会问，什么是修改? 比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说 Git 管理的是修改，而不是文件呢? 我们还是做实验。第一步，对 readme.txt 做一个修改，比如加一行内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后，添加:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> status
  On branch master
  Changes to be committed:
    <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>
        modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，再修改 readme.txt:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>提交:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"git tracks changes"</span>
<span>[</span>master 519219b<span>]</span> <span>git</span> tracks changes
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>提交后，再看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>怎么第二次的修改没有被提交? 我们回顾一下操作过程:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git commit</code></p>
<p>您看，我们前面讲了，Git 管理的是修改，当您用 <code>git add</code> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code> 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> HEAD -- readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 76d770f<span>..</span>a9c5755 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is <span>free</span> software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢? 您可以继续 <code>git add</code> 再 <code>git commit</code>，也可以别着急提交第一次修改，先 <code>git add</code> 第二次修改，再 <code>git commit</code>，就相当于把两次修改合并后一块提交了:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git add</code> → <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="管理小结"> 管理小结</h3>
<p>现在，您又理解了 Git 是如何跟踪修改的，每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到 <code>commit</code> 中。</p>
<h2 id="撤消对文件的修改"> 撤消对文件的修改</h2>
<p>自然，您是不会犯错的。不过现在是凌晨两点，您正在赶一份工作报告，您在 readme.txt 中添加了一行:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在您准备提交前，一杯咖啡起了作用，您猛然发现了 <code>'stupid boss'</code> 可能会让您丢掉这个月的奖金!</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。您可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用 <code>git status</code> 查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>您可以发现，Git 会告诉您，<code>git checkout -- &lt;file&gt;</code> 可以丢弃工作区的修改:</p>
<div><pre><code><span>git</span> checkout -- readme.txt
</code></pre>
<div><span>1</span><br></div></div><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况:</p>
<p>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>
<p>现在，看看 readme.txt 的文件内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有 <code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到 <code>git checkout</code> 命令。</p>
<div><p>注意</p>
<p>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。您对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</p>
<p>除非您确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p>
</div>
<h2 id="取消暂存的文件"> 取消暂存的文件</h2>
<p>现在假定是凌晨 3 点，您不但写了一些胡话，还 <code>git add</code> 到暂存区了:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

<span>git</span> <span>add</span> readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>庆幸的是，在 <code>commit</code> 之前，您发现了这个问题。用 <code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Git 同样告诉我们，用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区:</p>
<div><pre><code>$ <span>git</span> reset HEAD readme.txt
Unstaged changes after reset:
M    readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 <code>HEAD</code> 时，表示当前的指针(最新的版本)。</p>
<p>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>还记得如何丢弃工作区的修改吗?</p>
<div><pre><code><span>git</span> checkout -- readme.txt

$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>整个世界终于清静了!</p>
<div><p>提示</p>
<p>那么如果您想要丢弃工作区和暂存区全部更改呢? 不要忘了 <code>HEAD</code> 就是当前指针，所以</p>
<div><pre><code><span>git</span> reset --hard HEAD
</code></pre>
<div><span>1</span><br></div></div><p>就是丢弃工作区与暂存区的全部文件啦。</p>
</div>
<p>现在，假设您不但改错了东西，还从暂存区提交到了版本库，怎么办呢? 还记得版本回退一节吗? 可以回退到上一个版本。不过，这是有条件的，就是您还没有把自己的本地版本库推送到远程。还记得 Git 是分布式版本控制系统吗? 我们后面会讲到远程版本库，一旦您把 <code>stupid boss</code> 提交推送到远程版本库，您就真的惨了……</p>
<h3 id="撤销小结"> 撤销小结</h3>
<p>场景 1: 当您改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p>
<p>场景 2: 当您不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p>
<p>场景 3: 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<hr>
<h2 id="删除文件"> 删除文件</h2>
<h3 id="如何删除文件"> 如何删除文件</h3>
<p>在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件 test.txt 到 Git 并且提交:</p>
<div><pre><code><span>git</span> <span>add</span> test.txt

$ <span>git</span> commit -m <span>"add test.txt"</span>
<span>[</span>master b84166e<span>]</span> <span>add</span> test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>一般情况下，您通常直接在文件管理器中把没用的文件删了，或者用 <code>rm</code> 命令删了:</p>
<div><pre><code><span>rm</span> test.txt
</code></pre>
<div><span>1</span><br></div></div><p>这个时候，Git 知道您删除了文件，因此，工作区和版本库就不一致了，<code>git status</code> 命令会立刻告诉您哪些文件被删除了:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add/rm &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    deleted:    test.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>现在您有两个选择，一是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>rm</span> test.txt
<span>rm</span> <span>'test.txt'</span>

$ <span>git</span> commit -m <span>"remove test.txt"</span>
<span>[</span>master d46f35e<span>]</span> remove test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 delete mode <span>100644</span> test.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在，文件就从版本库中被删除了。</p>
<h3 id="撤销删除"> 撤销删除</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本:</p>
<div><pre><code><span>git</span> checkout -- test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="删除小结"> 删除小结</h3>
<p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么您永远不用担心误删，但是要小心，您只能恢复文件到最新版本，您会丢失最近一次提交后您修改的内容。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git 仓库</title>
    <id>https://list-jiang.github.io/software/git/create-repo/</id>
    <link href="https://list-jiang.github.io/software/git/create-repo/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
]]></summary>
    <content type="html"><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>

<h2 id="初始化仓库"> 初始化仓库</h2>
<p>创建一个仓库非常简单，首先，选择一个合适的地方，创建一个空目录:</p>
<div><pre><code><span># open shell (PowerShell on Windows) in a proper directory</span>
$ <span>mkdir</span> learngit
$ <span>cd</span> learngit
$ <span>pwd</span>
/users/hope-studio/learngit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>pwd</code> 命令用于显示当前目录。</p>
<div><p>提示</p>
<ul>
<li>使用 Windows 系统时，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。</li>
<li>为了确保能够执行跨平台的命令，请在 Windows 上安装 PowerShell 并设置为 VS Code 的默认终端。</li>
</ul>
</div>
<p>第二步，通过 <code>git init</code> 命令把这个目录变成 Git 可以管理的仓库:</p>
<div><pre><code>$ <span>git</span> init
Initialized empty Git repository <span>in</span> /users/hope-studio/learngit/.git/
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>瞬间 Git 就把仓库建好了，而且告诉您是一个空的仓库(empty Git repository)，可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理仓库的，如果这个目录里面的文件破坏了，Git 仓库也破坏了。</p>
<p>如果您没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p>
<p>也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。</p>
<div><p>警告</p>
<p>请不要用已经在使用的项目练习 Git!</p>
</div>
<h2 id="把文件添加到仓库"> 把文件添加到仓库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉您每次的改动，比如在第 5 行加了一个单词“Linux”，在第 8 行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。(Microsoft 的 Word 格式是二进制格式，所以很不幸) 所以要使用版本控制系统，就要以纯文本方式编写文件。</p>
<div><p>提示</p>
<p>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<ul>
<li>具体详情请见 <a href="./../../code/basic/encoding.html">文件编码</a></li>
</ul>
</div>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="./../../code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>现在编写一个 readme.txt 文件，内容如下:</p>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>一定要放到 <code>learngit</code> 目录下(子目录也行)，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。</p>
<p>把一个文件放到 Git 仓库只需要两步:</p>
<ol>
<li>
<p>用命令 <code>git add</code> 告诉 Git，把文件添加到仓库:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。</p>
</li>
<li>
<p>用命令 <code>git commit</code> 告诉 Git，把文件提交到仓库:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"wrote a readme file"</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> eaadf4e<span>]</span> wrote a readme <span>file</span>
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>git commit</code> 命令，<code>-m</code> 后面输入的是本次提交的说明，这样您就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code> 命令执行成功后会告诉您，<code>1 file changed</code>: 1 个文件被改动(我们新添加的 readme.txt 文件)；<code>2 insertions</code>: 插入了两行内容(readme.txt 有两行内容)。</p>
</li>
</ol>
<p>为什么 Git 添加文件需要 <code>add</code>，<code>commit</code> 一共两步呢? 因为 <code>commit</code> 可以一次提交很多文件，所以您可以多次 <code>add</code> 不同的文件，比如:</p>
<div><pre><code><span>git</span> <span>add</span> file1.txt
<span>git</span> <span>add</span> file2.txt file3.txt
<span>git</span> commit -m <span>"add 3 files."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="小结"> 小结</h2>
<ul>
<li>
<p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p>
</li>
<li>
<p>添加文件到 Git 仓库，分两步:</p>
<ol>
<li>使用命令 <code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</li>
<li>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">自定义 Git</title>
    <id>https://list-jiang.github.io/software/git/custom/</id>
    <link href="https://list-jiang.github.io/software/git/custom/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在安装 Git 一节中，我们已经配置了 <code>user.name</code> 和 <code>user.email</code>，实际上，Git 还有很多可配置项。</p>
<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目:</p>
<div><pre><code><span>git</span> config --global color.ui <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样，Git 会适当地显示不同的颜色，比如 <code>git status</code> 命令，文件名就会标上颜色。</p>
<h2 id="配置别名"> 配置别名</h2>
<p>有没有经常敲错命令? 比如 <code>git status</code>? <code>status</code> 这个单词真心不好记。</p>
<p>如果敲 <code>git st</code> 就表示 <code>git status</code> 那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉 Git，以后 <code>st</code> 就表示 <code>status</code>:</p>
<div><pre><code><span>git</span> config --global alias.st status
</code></pre>
<div><span>1</span><br></div></div><p>好了，现在敲 <code>git st</code> 看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用 <code>co</code> 表示 <code>checkout</code>，<code>ci</code> 表示 <code>commit</code>，<code>br</code> 表示 <code>branch</code>:</p>
<div><pre><code><span>git</span> config --global alias.co checkout
<span>git</span> config --global alias.ci commit
<span>git</span> config --global alias.br branch
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以后提交就可以简写成:</p>
<div><pre><code><span>git</span> ci -m <span>"bala bala bala..."</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>--global</code> 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。既然是一个 <code>unstage</code> 操作，就可以配置一个 <code>unstage</code> 别名:</p>
<div><pre><code><span>git</span> config --global alias.unstage <span>'reset HEAD'</span>
</code></pre>
<div><span>1</span><br></div></div><p>当您敲入命令:</p>
<div><pre><code><span>git</span> unstage test.py
</code></pre>
<div><span>1</span><br></div></div><p>实际上 Git 执行的是:</p>
<div><pre><code><span>git</span> reset HEAD test.py
</code></pre>
<div><span>1</span><br></div></div><p>配置一个 <code>git last</code>，让其显示最后一次提交信息:</p>
<div><pre><code><span>git</span> config --global alias.last <span>'log -1'</span>
</code></pre>
<div><span>1</span><br></div></div><p>这样，用 <code>git last</code> 就能显示最近一次的提交:</p>
<div><pre><code>$ <span>git</span> last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Mr-Hope <span>&lt;</span>zhangbowang1998@gmail.com<span>></span>
Date:   Thu Aug <span>22</span> <span>22</span>:49:22 <span>2013</span> +0800

    merge <span>&amp;</span> fix hello.py
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>甚至还有人丧心病狂地把 <code>lg</code> 配置成了:</p>
<div><pre><code><span>git</span> config --global alias.lg <span>"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span>
</code></pre>
<div><span>1</span><br></div></div><p>来看看 <code>git lg</code> 的效果:</p>
<p><img src="./assets/git16.png" alt="命令 git lg 示例图" loading="lazy"></p>
<p>为什么不早点告诉我? 别激动，咱不是为了多记几个英文单词嘛!</p>
<h2 id="配置文件"> 配置文件</h2>
<p>配置 Git 的时候，加上 <code>--global</code> 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了? 每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中:</p>
<div><pre><code>$ <span>cat</span> .git/config
<span>[</span>core<span>]</span>
    repositoryformatversion <span>=</span> <span>0</span>
    filemode <span>=</span> <span>true</span>
    bare <span>=</span> <span>false</span>
    logallrefupdates <span>=</span> <span>true</span>
    ignorecase <span>=</span> <span>true</span>
    precomposeunicode <span>=</span> <span>true</span>
<span>[</span>remote <span>"origin"</span><span>]</span>
    url <span>=</span> git@github.com:michaelliao/learngit.git
    fetch <span>=</span> +refs/heads/*:refs/remotes/origin/*
<span>[</span>branch <span>"master"</span><span>]</span>
    remote <span>=</span> origin
    merge <span>=</span> refs/heads/master
<span>[</span>alias<span>]</span>
    last <span>=</span> log -1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>别名就在 <code>[alias]</code> 后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中:</p>
<div><pre><code>$ <span>cat</span> .gitconfig
<span>[</span>alias<span>]</span>
    co <span>=</span> checkout
    ci <span>=</span> commit
    br <span>=</span> branch
    st <span>=</span> status
<span>[</span>user<span>]</span>
    name <span>=</span> Your Name
    email <span>=</span> your@email.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h3 id="别名小结"> 别名小结</h3>
<ul>
<li>给 Git 配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git Large File Storage</title>
    <id>https://list-jiang.github.io/software/git/gitLFS/</id>
    <link href="https://list-jiang.github.io/software/git/gitLFS/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="git-large-file-storage"> Git Large File Storage</h1>
<p>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p>
<h2 id="getting-started"> Getting Started</h2>
<ol>
<li>
<p>Download and install the Git command-line extension. Once downloaded and installed, set up Git LFS and its respective hooks by running:</p>
<div><pre><code><span>git</span> lfs <span>install</span>
</code></pre>
<div><span>1</span><br></div></div><p>You’ll need to run this in your repository directory, once per repository.</p>
</li>
<li>
<p>Select the file types you’d like Git LFS to manage (or directly edit your .gitattributes). You can configure file extensions at anytime.</p>
<div><pre><code><span>git</span> lfs track <span>"*.psd"</span>
</code></pre>
<div><span>1</span><br></div></div><p>Make sure to track <code>.gitattributes</code></p>
<div><pre><code><span>git</span> <span>add</span> .gitattributes
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">忽略特殊文件</title>
    <id>https://list-jiang.github.io/software/git/ignore/</id>
    <link href="https://list-jiang.github.io/software/git/ignore/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次 <code>git status</code> 都会显示 <code>Untracked files</code> ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</p>
<p>忽略文件的原则是:</p>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 <code>.class</code> 文件；</li>
<li>忽略您自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
<p>举个例子:</p>
<p>假设您在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 <code>Desktop.ini</code> 文件，因此您需要忽略 Windows 自动生成的垃圾文件:</p>
<div><pre><code><span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，继续忽略 Python 编译产生的 <code>.pyc</code>、<code>.pyo</code>、<code>dist</code> 等文件或目录:</p>
<div><pre><code><span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>加上您自己定义的文件，最终得到一个完整的 <code>.gitignore</code> 文件，内容如下:</p>
<div><pre><code><span># Windows:</span>

<span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>

<span># Python:</span>

<span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>

<span># My configurations:</span>

<span>db.ini</span>
<span>deploy_key_rsa</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>最后一步就是把 <code>.gitignore</code> 也提交到 Git，就完成了! 当然检验 <code>.gitignore</code> 的标准是 <code>git status</code> 命令是不是说 <code>working directory clean</code>。</p>
<p>使用 Windows 的童鞋注意了，如果您在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示您必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p>
<p>有些时候，您想添加一个文件到 Git，但发现添加不了，原因是这个文件被 <code>.gitignore</code> 忽略了:</p>
<div><pre><code>$ <span>git</span> <span>add</span> App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f <span>if</span> you really want to <span>add</span> them.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果您确实想添加该文件，可以用 <code>-f</code> 强制添加到 Git:</p>
<div><pre><code><span>git</span> <span>add</span> -f App.class
</code></pre>
<div><span>1</span><br></div></div><p>或者您发现，可能是 <code>.gitignore</code> 写得有问题，需要找出来到底哪个规则写错了，可以用 <code>git check-ignore</code> 命令检查:</p>
<div><pre><code>$ <span>git</span> check-ignore -v App.class
.gitignore:3:*.class    App.class
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Git 会告诉我们，<code>.gitignore</code> 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2 id="格式规范"> 格式规范</h2>
<ul>
<li>
<p>所有空行或者以 # 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上叹号(<code>!</code>)取反。</p>
</li>
</ul>
<div><p>glob 模式</p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号(<code>*</code>)匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 (这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)； 问号(<code>?</code>)只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配(比如 <code>[0-9]</code> 表示匹配所有 <code>0</code> 到 <code>9</code> 的数字)。使用两个星号(<code>**</code>)表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、<code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
</div>
<p>一个具体的例子:</p>
<div><pre><code><span># 忽略所有的 .a 文件</span>
<span><span>*</span>.a</span>

<span># 但跟踪所有的 lib.a，即便您在前面忽略了 .a 文件</span>
<span><span>!</span>lib.a</span>

<span># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span>
<span><span>/</span>TODO</span>

<span># 忽略任何目录下名为 build 的文件夹</span>
<span>build<span>/</span></span>

<span># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span>
<span>doc<span>/</span><span>*</span>.txt</span>

<span># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span>
<span>doc<span>/</span><span>**</span><span>/</span><span>*</span>.pdf</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>提示</p>
<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 您可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a> 找到它。</p>
</div>
<div><p>多个 .gitignore</p>
<p>在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。(Linux 内核的源码库拥有 206 个 .gitignore 文件。)</p>
</div>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p>忽略某些文件时，需要编写 <code>.gitignore</code>；</p>
</li>
<li>
<p><code>.gitignore</code> 文件本身要放到版本库里，并且可以对 <code>.gitignore</code> 做版本管理!</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">安装与配置</title>
    <id>https://list-jiang.github.io/software/git/install/</id>
    <link href="https://list-jiang.github.io/software/git/install/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git-下载"> Git 下载</h2>
<p>官网在国外，网速较慢。在安装 Git 前推荐安装好 <a href="./../vscode/">VS Code</a>。</p>
<ul>
<li><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener noreferrer">官网下载</a></li>
</ul>
<h2 id="git-的安装"> Git 的安装</h2>
<ol>
<li>
<p>同意协议并选择安装位置 (不建议更改安装位置)</p>
<p><img src="./assets/install1.png" alt="安装协议" loading="lazy"></p>
<p><img src="./assets/install2.png" alt="安装位置" loading="lazy"></p>
</li>
<li>
<p>启用 LFS 支持，其他随意 (影响不大)</p>
<p><img src="./assets/install3.png" alt="组件选择" loading="lazy"></p>
</li>
<li>
<p>自行决定是否创建启动菜单</p>
<p><img src="./assets/install4.png" alt="是否创建启动菜" loading="lazy"></p>
</li>
<li>
<p>选择使用 VS Code 作为 git 的默认编辑器。</p>
<p><img src="./assets/install5.png" alt="设置默认编辑器" loading="lazy"></p>
</li>
<li>
<p>选择 Git 使用的默认分支名，GitHub 已经将默认分支名称改为 main。</p>
<p><img src="./assets/install6.png" alt="设置默认分支名称" loading="lazy"></p>
<div><p>相关信息</p>
<p>在 2020 年的黑人运动中，部分黑人认为 master 这个词是对它们的冒犯。</p>
</div>
</li>
<li>
<p>选择第二项，这将允许您在第三方工具中使用 Git，同时不会覆盖默认的 Windows 命令。</p>
<p><img src="./assets/install7.png" alt="Git 命令行" loading="lazy"></p>
</li>
<li>
<p>使用 OpenSSL Library</p>
<p><img src="./assets/install8.png" alt="Git SSL" loading="lazy"></p>
<div><p>提示</p>
<p>如果自己公司有 CA，或者在开发中需要 Git 承认某些自签 CA，则需要选择第二项。</p>
</div>
</li>
<li>
<p>务必选择最后一项 “原样检出与提交”</p>
<p><img src="./assets/install9.png" alt="Git 行尾设置" loading="lazy"></p>
</li>
<li>
<p>选择 Git 终端</p>
<p><img src="./assets/install10.png" alt="Git 终端" loading="lazy"></p>
<div><p>提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，建议选择 MinTTY，以方便您接下来在学习中对 Git Bash 的临时使用。</p>
</div>
</li>
<li>
<p>选择 <code>git pull</code> 的默认行为，保持默认不要改动</p>
<p><img src="./assets/install11.png" alt="Git Pull Action" loading="lazy"></p>
</li>
<li>
<p>选择凭据储存管理器，请选择第一个跨平台管理器</p>
<p><img src="./assets/install12.png" alt="凭据储存管理器设置" loading="lazy"></p>
</li>
<li>
<p>额外的选项确认，均勾选即可</p>
<p><img src="./assets/install13.png" alt="额外选项" loading="lazy"></p>
</li>
<li>
<p>一些实验性的功能，通常不太稳定或有 bug，不同 Git 版本会有差异，可根据自身情况确定</p>
<p><img src="./assets/install14.png" alt="实验性功能" loading="lazy"></p>
</li>
</ol>
<h2 id="git-bash"> Git Bash</h2>
<p>安装完成后，您可以通过搜索找到“Git Bash” (Mac 上叫 Git Shell)，这是一个 Git 提供的命令窗口，您可以在这里运行 Git 命令。</p>
<p><img src="./assets/shell.png" alt="Git Bash" loading="lazy"></p>
<div><p>提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，您可以在接下来的学习与操作中使用 Git Bash。</p>
</div>
<h2 id="git-的初次配置"> Git 的初次配置</h2>
<ol>
<li>
<p>为 Git 全局配置用户名和邮箱。</p>
<div><pre><code><span>git</span> config --global user.name <span>"Your Name"</span>
<span>git</span> config --global user.email <span>"email@example.com"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将上方的字符串换成您自己的名字和邮箱。</p>
<p>如:</p>
<div><pre><code><span>git</span> config --global user.name <span>"Mr.Hope"</span>
<span>git</span> config --global user.email <span>"zhangbowang1998@gmail.com"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>相关信息</p>
<p>由于 Git 是一个多人协作的版本控制系统，首先您应当设置您的身份。</p>
</div>
</li>
<li>
<p>创建 SSH Key。打开 Shell (Windows 下打开 cmd)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
<div><p>提示</p>
<ul>
<li>
<p>ssh-keygen 用来生成一堆密钥，作为您的身份识别信息，您可以放心的把公钥交给别人，留下自己的私钥。</p>
</li>
<li>
<p><code>.ssh</code> 目录是默认隐藏的。Win10 查看隐藏文件详见 <a href="./../../code/windows/hidden-file.html">显示隐藏的文件</a></p>
</li>
</ul>
</div>
<div><p>RSA</p>
<p>RSA 是一种不对称加密，公钥的加密只能通过私钥解开，反之私钥的加密只能由公钥解开。也就是说当您给别人自己的公钥的时候，他们也无法冒充您。</p>
</div>
</li>
<li>
<p>打开 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub</a> 并选择 &quot;Sign in&quot; 注册自己的账号。</p>
<p><img src="./assets/github.png" alt="GitHub 界面简介" loading="lazy"></p>
<p>登陆 GitHub 后，点击右上角头像，进入设置。</p>
<p>进入 &quot;安全设置&quot; 下的 &quot;SSH 公钥&quot; 界面。</p>
<p><img src="./assets/githubSSH.png" alt="GitHub 界面简介" loading="lazy"></p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中，设置一个标识此电脑的备注。</p>
</li>
</ol>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Git 介绍</title>
    <id>https://list-jiang.github.io/software/git/intro/</id>
    <link href="https://list-jiang.github.io/software/git/intro/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>

<h2 id="版本控制系统"> 版本控制系统</h2>
<p>什么是“版本控制”? 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。您可以对任何类型的文件进行版本控制。</p>
<ul>
<li>如果您是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本(这或许是您非常渴望拥有的功能)</li>
<li>如果您是一名作家，您可能需要保存您对作品的每一次修改以便将来如果随着情节发展需要变动可以撤销它们。</li>
<li>甚至您是一名学生，您的论文也可以进行版本控制。</li>
<li>哪怕您工作了，保存各种报表的各种版本也是没有坏处的。</li>
</ul>
<p>在很多情况下，采用版本控制系统(VCS)都是个明智的选择! 有了它您就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，您可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算您乱来一气把整个项目中的文件改的改删的删，您也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统"> 本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>
<p><img src="./assets/RCS.png" alt="本地版本控制系统" loading="lazy"></p>
<blockquote>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。RCS 的工作原理是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
</blockquote>
<h3 id="集中化的版本控制系统"> 集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作? 于是，集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>集中式版本控制系统版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，您要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p><img src="./assets/intro.jpg" alt="Git示例图" loading="lazy"></p>
<p>CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>事分两面，有好有坏。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个 10M 的文件就需要 5 分钟。另外若中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统"> 分布式版本控制系统</h3>
<p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。</p>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，您工作的时候，就不需要联网了，因为版本库就在您自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢? 比方说您在自己电脑上改了文件 A，您的同事也在他的电脑上改了文件 A，这时，您们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p><img src="./assets/DVCS.png" alt="分布式版本控制系统" loading="lazy"></p>
<div><p>提示</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能您们俩不在一个局域网内，两台电脑互相访问不了，也可能今天您的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</div>
<p>在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，您就可以在同一个项目中，分别和不同工作小组的人相互协作。您可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
]]></content>
    <author>
      <name>Mr.Hope &amp; 廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>Mr.Hope &amp; 廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git</title>
    <id>https://list-jiang.github.io/software/git/</id>
    <link href="https://list-jiang.github.io/software/git/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div><p>交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>
]]></summary>
    <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div><p>交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>

<h2 id="git-安装"> Git 安装</h2>
<ul>
<li><a href="./install.html">安装教程</a></li>
</ul>
<h2 id="git-教程"> Git 教程</h2>
<ul>
<li>
<p><a href="./intro.html">Git 介绍</a></p>
</li>
<li>
<p><a href="./create-repo.html">创建版本库</a></p>
</li>
<li>
<p><a href="./status.html">纵向查看</a></p>
</li>
<li>
<p><a href="./recall.html">撤销操作</a></p>
</li>
<li>
<p><a href="./reset.html">版本回退</a></p>
</li>
<li>
<p><a href="./working-directory.html">工作区和暂存区</a></p>
</li>
<li>
<p><a href="./change.html">修改管理</a></p>
</li>
<li>
<p><a href="./remote.html">远程仓库</a></p>
</li>
<li>
<p><a href="./branch.html">分支管理</a></p>
</li>
<li>
<p><a href="./tag.html">标签管理</a></p>
</li>
<li>
<p><a href="./ignore.html">忽略特殊文件</a></p>
</li>
</ul>
<h2 id="深入-git"> 深入 Git</h2>
<ul>
<li>
<p><a href="./working.html">Git 原理</a></p>
</li>
<li>
<p><a href="./custom.html">自定义 Git</a></p>
</li>
<li>
<p><a href="./gitLFS.html">大文件管理存储</a></p>
</li>
<li>
<p><a href="./server.html">搭建 Git 服务器</a></p>
</li>
</ul>
<h2 id="扩展阅读"> 扩展阅读</h2>
<ul>
<li>
<p><a href="https://git-scm.com/doc" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/gitCheatSheet.pdf" target="_blank" rel="noopener noreferrer">Git-cheatSheet</a> (PDF)</p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/progit_v2.1.45.pdf" target="_blank" rel="noopener noreferrer">Pro Git</a> (PDF)</p>
</li>
</ul>
<div><p>TODO</p>
<ol>
<li>完善分支合并部分，加入更多命令介绍。如 <code>cherry-pick</code> <code>squash-merge</code>。</li>
<li>介绍 Git Hook</li>
</ol>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">撤销操作</title>
    <id>https://list-jiang.github.io/software/git/recall/</id>
    <link href="https://list-jiang.github.io/software/git/recall/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>在任何一个阶段，您都有可能想要撤消某些操作。这里，我们将会学习几个撤消您所做修改的基本工具。注
意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个
地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选
项的提交命令来重新提交:</p>
<div><pre><code><span>git</span> commit --amend
</code></pre>
<div><span>1</span><br></div></div><p>这个命令会将暂存区中的文件提交。如果自上次提交以来您还未做任何修改(例如，在上次提交后马上执行了
此命令)， 那么快照会保持不变，而您所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p>
<p>例如，您提交后发现忘记了暂存某些需要的修改，可以像下面这样操作:</p>
<div><pre><code><span>git</span> commit -m <span>'initial commit'</span>
<span>git</span> <span>add</span> forgotten_file
<span>git</span> commit --amend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最终您只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<div><p>提示</p>
<p>当您在修补最后的提交时，并不是通过用改进后的提交 原位替换 掉旧有提交的方式来修复
的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出
现在仓库的历史中。</p>
<p>修补提交最明显的价值是可以稍微改进您最后的提交，而不会让“啊，忘了添加一个文件”或
者 “小修补，修正笔误”这种提交信息弄乱您的仓库历史。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">远程仓库</title>
    <id>https://list-jiang.github.io/software/git/remote/</id>
    <link href="https://list-jiang.github.io/software/git/remote/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是远程仓库"> 什么是远程仓库</h2>
<p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢? 最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行 Git 的服务器，不过现阶段，为了学 Git 先搭个服务器绝对是小题大作。好在这个世界上有个叫 GitHub 的神奇的网站，从名字就可以看出，这个网站就是提供 Git 仓库托管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册 GitHub 账号。由于您的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置:</p>
<ul>
<li>
<p>第 1 步: 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell (Windows 下打开 Git Bash)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
</li>
<li>
<p>第 2 步: 登陆 GitHub，点击右上角头像，进入设置。</p>
<p>进入安全设置下的 SSH 公钥界面。</p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中。</p>
</li>
</ul>
<p>为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出您推送的提交确实是您推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了您的公钥，就可以确认只有您自己才能推送。</p>
<p>当然，GitHub 允许您添加多个 Key。假定您有若干电脑，您一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。</p>
<p>最后友情提示，在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔(但只有您自己才能改)。所以，不要把敏感信息放进去。</p>
<p>如果您不想让别人看到 Git 库，一是让 GitHub 把公开的仓库变成私有的，这样别人就看不见了(不可读更不可写)。另一个办法是自己动手，搭一个 Git 服务器，因为是您自己的 Git 服务器，所以别人也是看不见的。</p>
<p>确保您拥有一个 GitHub 账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="添加远程库"> 添加远程库</h2>
<p>现在的情景是，您已经在本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆 GitHub，然后，在右上角找到 “+” 按钮，点击 &quot;New Repository&quot;。</p>
<p>在项目填入 learngit，其他保持默认设置，点击“创建”按钮，就成功地创建了一个新的 Git 仓库:</p>
<p>目前，在 GitHub 上的这个 learngit 仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的 learngit 仓库下运行命令:</p>
<div><pre><code><span>git</span> remote <span>add</span> origin git@github.com:Hope-Studio/learngit.git
</code></pre>
<div><span>1</span><br></div></div><p>请千万注意，把上面的 Hope-Studio 替换成您自己的 GitHub 账户名，否则，您在本地关联的就是希望工作室的远程库，关联没有问题，但是推送是推不上去的，因为您的 SSH Key 公钥不在希望工作室的账户列表中。</p>
<p>添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上:</p>
<div><pre><code>$ <span>git</span> push -u origin master
Counting objects: <span>20</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>15</span>/15<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>20</span>/20<span>)</span>, <span>1.64</span> KiB <span>|</span> <span>560.00</span> KiB/s, done.
Total <span>20</span> <span>(</span>delta <span>5</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new branch<span>]</span>      master -<span>></span> master
Branch <span>'master'</span> <span>set</span> up to track remote branch <span>'master'</span> from <span>'origin'</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>把本地库的内容推送到远程，用 <code>git push</code> 命令，实际上是把当前分支 <code>master</code> 推送到远程。</p>
<p>由于远程库是空的，我们第一次推送 <code>master</code> 分支时，加上了 <code>-u</code> 参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样:</p>
<p>从现在起，只要本地作了提交，就可以通过命令:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>把本地 <code>master</code> 分支的最新修改推送至 GitHub，现在，您就拥有了真正的分布式版本库!</p>
<h2 id="ssh-警告"> SSH 警告</h2>
<p>当您第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告:</p>
<div><pre><code>The authenticity of <span>host</span> <span>'github.com (xx.xx.xx.xx)'</span> can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to <span>continue</span> connecting <span>(</span>yes/no<span>)</span>?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要您确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 <code>yes</code> 回车即可。</p>
<p>Git 会输出一个警告，告诉您已经把 GitHub 的 Key 添加到本机的一个信任列表里了:</p>
<div><pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre>
<div><span>1</span><br></div></div><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果您实在担心有人冒充 GitHub 服务器，输入 <code>yes</code> 前可以对照 GitHub 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。</p>
<h3 id="关联小结"> 关联小结</h3>
<p>要关联一个远程库，使用命令 <code>git remote add origin git@&lt;server-name&gt;:&lt;path&gt;/&lt;repo-name&gt;.git</code>；</p>
<p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的! 当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了!</p>
<h2 id="从远程库克隆"> 从远程库克隆</h2>
<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆 GitHub，创建一个新的仓库，名字叫 <code>gitskills</code>:</p>
<p>我们勾选使用 “readme 初始化项目”，这样 GitHub 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令 <code>git clone</code> 克隆一个本地库:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/gitskills.git
Cloning into <span>'gitskills'</span><span>..</span>.
remote: Counting objects: <span>3</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>3</span>
Receiving objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>
<p>如果您使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p>
</div>
<p>注意把 Git 库的地址换成您自己的，然后进入 <code>gitskills</code> 目录看看，已经有 README.md 文件了:</p>
<div><pre><code>$ <span>cd</span> gitskills
$ <span>ls</span>
README.md
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>您也许还注意到，GitHub 给出的地址不止一个，还可以用 <a href="https://github.com/Hope-Studio/gitskills.git" target="_blank" rel="noopener noreferrer">https://github.com/Hope-Studio/gitskills.git</a> 这样的地址。实际上，Git 支持多种协议，默认的 <code>git://</code> 使用 ssh，但也可以使用 HTTPS 等其他协议。</p>
<p>使用 HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>
<h3 id="克隆小结"> 克隆小结</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p>
<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快。</p>
<h2 id="从远程仓库中抓取"> 从远程仓库中抓取</h2>
<p>从远程仓库中获得数据，可以执行:</p>
<div><pre><code><span>git</span> fetch <span>&lt;</span>remote<span>></span>
</code></pre>
<div><span>1</span><br></div></div><p>这个命令会访问远程仓库，从中拉取所有您还没有的数据。执行完成后，您将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p><code>git fetch origin</code> 会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 <code>git fetch</code> 命令只会将数据下载到您的本地仓库——它并不会自动合并或修改您当前的工作。当准备好时您必须手动将其合并入您的工作。</p>
<h2 id="推送到远程仓库"> 推送到远程仓库</h2>
<p>当您想分享您的项目时，必须将其推送到上游。这个命令很简单: <code>git push &lt;remote&gt; &lt;branch&gt;</code>。当您
想要将 master 分支推送到 origin 服务器时(再次说明，克隆时通常会自动帮您设置好那两个名字)， 那么
运行这个命令就可以将您所做的备份到服务器:</p>
<div><pre><code><span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><p>只有当您有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当您和其他人在同一时间克隆，他们先推送到上游然后您再推送到上游，您的推送就会毫无疑问地被拒绝。您必须先抓取他们的工作并将其合并进您的工作后才能推送。</p>
<h2 id="查看某个远程仓库"> 查看某个远程仓库</h2>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。如果想以一个特
定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息:</p>
<div><pre><code>$ <span>git</span> remote show origin
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured <span>for</span> <span>'git pull'</span><span>:</span>
master merges with remote master
Local ref configured <span>for</span> <span>'git push'</span><span>:</span>
master pushes to master <span>(</span>up to <span>date</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。这些信息非常有用，它告诉您正处于 master 分支，并且如果运行 <code>git pull</code>，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。它也会列出拉取到的所有远程引用。</p>
<h2 id="远程仓库的重命名与移除"> 远程仓库的重命名与移除</h2>
<p>您可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。例如，想要将 pb 重命名为 paul，可以用 <code>git remote rename</code> 这样做:</p>
<div><pre><code>$ <span>git</span> remote <span>rename</span> pb paul
$ <span>git</span> remote
origin
paul
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>值得注意的是这同样也会修改您所有远程跟踪的分支名字。那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——您已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code>:</p>
<div><pre><code>$ <span>git</span> remote remove paul
$ <span>git</span> remote
origin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一旦您使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">服务器搭建</title>
    <id>https://list-jiang.github.io/software/git/server/</id>
    <link href="https://list-jiang.github.io/software/git/server/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>
]]></summary>
    <content type="html"><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>

<p>搭建 Git 服务器需要准备一台运行 Linux 的机器，强烈推荐用 Ubuntu 或 Debian，这样，通过几条简单的 <code>apt</code> 命令就可以完成安装。</p>
<ul>
<li>
<p><strong>Ubuntu</strong> 或 <strong>Debian</strong></p>
<p>假设您已经有 sudo 权限的用户账号，下面，正式开始安装。</p>
<ul>
<li>
<p>第一步，安装 git:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第二步，创建一个 git 用户，用来运行 git 服务:</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第三步，创建证书登录:</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的 <code>id_rsa.pub</code> 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
</li>
<li>
<p>第四步，初始化 Git 仓库:</p>
<p>先选定一个目录作为 Git 仓库，假定是 <code>/srv/sample.git</code>，在 <code>/srv</code> 目录下输入命令:</p>
<div><pre><code><span>sudo</span> <span>git</span> init --bare sample.git
</code></pre>
<div><span>1</span><br></div></div><p>Git 就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把 owner 改为 git:</p>
<div><pre><code><span>sudo</span> <span>chown</span> -R git:git sample.git
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>第五步，禁用 shell 登录:</p>
<p>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑 <code>/etc/passwd</code> 文件完成。找到类似下面的一行:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre>
<div><span>1</span><br></div></div><p>改为:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre>
<div><span>1</span><br></div></div><p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
</li>
<li>
<p>第六步，克隆远程仓库:</p>
<p>现在，可以通过 <code>git clone</code> 命令克隆远程仓库了，在各自的电脑上运行:</p>
<div><pre><code>$ <span>git</span> clone git@server:/srv/sample.git
Cloning into <span>'sample'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>剩下的推送就简单了。</p>
</li>
</ul>
</li>
<li>
<p><strong>Centos</strong></p>
<ol>
<li>
<p>安装 Git</p>
<div><pre><code>yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
yum <span>install</span> <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>接下来创建一个 git 用户组和用户，用来运行 git 服务:</p>
<div><pre><code><span>groupadd</span> <span>git</span>
<span>useradd</span> <span>git</span> -g <span>git</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>创建证书登录</p>
<p>收集所有需要登录的用户的公钥，公钥位于 <code>id_rsa.pub</code> 文件中，将公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
<p>如果没有该文件创建它:</p>
<div><pre><code><span>cd</span> /home/git/
<span>mkdir</span> .ssh
<span>chmod</span> <span>755</span> .ssh
<span>touch</span> .ssh/authorized_keys
<span>chmod</span> <span>644</span> .ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>初始化 Git 仓库</p>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/test.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令:</p>
<div><pre><code>$ <span>cd</span> /home
$ <span>mkdir</span> gitrepo
$ <span>chown</span> git:git gitrepo/
$ <span>cd</span> gitrepo

$ <span>git</span> init --bare test.git
Initialized empty Git repository <span>in</span> /home/gitrepo/runoob.git/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把仓库所属用户改为 git:</p>
<div><pre><code><span>chown</span> -R git:git runoob.git
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>克隆仓库</p>
</li>
</ol>
<div><pre><code>$ <span>git</span> clone git@192.168.45.4:/home/gitrepo/runoob.git
Cloning into <span>'runoob'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
Checking connectivity<span>..</span>. done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，您需要将其修改为您自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">版本回退</title>
    <id>https://list-jiang.github.io/software/git/reset/</id>
    <link href="https://list-jiang.github.io/software/git/reset/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>修改 readme.txt 文件如下:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后尝试提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing displayed</span>
$ <span>git</span> commit -m <span>"append GPL"</span>
<span>[</span>master 1094adb<span>]</span> append GPL
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 <code>commit</code>。如果把文件改乱了，或者误删了文件，还可以从最近的一个 <code>commit</code> 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下 <code>readme.txt</code> 文件一共有几个版本被提交到 Git 仓库里了:</p>
<ul>
<li>版本 1: wrote a readme file</li>
</ul>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>版本 2: add distributed</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>版本 3: append GPL</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="查看版本信息"> 查看版本信息</h2>
<p>版本控制系统用 <code>git log</code> 命令可以告诉我们历史记录，在 Git 中，我们查看:</p>
<div><pre><code>$ <span>git</span> log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><code>git log</code> 命令显示从最近到最远的提交日志，我们可以看到 3 次提交，最近的一次是 <code>append GPL</code>，上一次是 <code>add distributed</code>，最早的一次是 <code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code> 参数:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span> append GPL
e475afc93c209a690c39c13a46716e8fa000c366 <span>add</span> distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一大串类似 <code>1094adb...</code> 的是 commit id (版本号)，和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，为什么 commit id 需要用这么一大串数字表示呢? 因为 Git 是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Git 历史，就可以更清楚地看到提交历史的时间线:</p>
<p><img src="./assets/timeline.jpg" alt="Git 时间线" loading="lazy"></p>
<div><p>更多选项</p>
<p>关于 <code>git log</code> 的更多选项，请见 <a href="/file/git/progit_v2.1.45.pdf">ProGit 书籍</a> 的 P43。</p>
</div>
<h2 id="回退版本"> 回退版本</h2>
<p>好了，现在准备把 readme.txt 回退到上一个版本，也就是 <code>add distributed</code> 的那个版本，怎么做呢?</p>
<p>首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 <code>HEAD</code> 表示当前版本，也就是最新的提交 <code>1094adb...</code> (注意我的提交 ID 和您的肯定不一样)，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，当然往上 100 个版本写 100 个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p>
<p>现在，要把当前版本 <code>append GPL</code> 回退到上一个版本 <code>add distributed</code>，就可以使用 <code>git reset</code> 命令:</p>
<div><pre><code>$ <span>git</span> reset --hard HEAD^
HEAD is now at e475afc <span>add</span> distributed
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>看看 readme.txt 的内容是不是版本 add distributed:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>果然被还原了。</p>
<p>还可以继续回退到上一个版本 wrote a readme file，不过且慢，然我们用 <code>git log</code> 再看看现在版本库的状态:</p>
<div><pre><code>$ <span>git</span> log
commit e475afc93c209a690c39c13a46716e8fa000c366 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>最新的那个版本 append GPL 已经看不到了! 肿么办?</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，您就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是 1094adb...，于是就可以指定回到未来的某个版本:</p>
<div><pre><code>$ <span>git</span> reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看 readme.txt 的内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>果然，我胡汉三又回来了。</p>
<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 <code>HEAD</code> 指针，当您回退版本的时候，Git 仅仅是把 <code>HEAD</code> 从指向 append GPL:</p>
<p><img src="./assets/git1.jpg" alt="示例图4" loading="lazy"></p>
<p>改为指向 <code>add distributed</code>:</p>
<p><img src="./assets/git2.jpg" alt="示例图5" loading="lazy"></p>
<p>然后顺便把工作区的文件更新了。所以您让 <code>HEAD</code> 指向哪个版本号，您就把当前版本定位在哪。</p>
<h2 id="找回-commit-id"> 找回 commit id</h2>
<p>如果回退到了某个版本找不到新版本的 <code>commit id</code>，在 Git 中，就无法用 <code>$ git reset --hard HEAD^</code> 回退。</p>
<p>所以 Git 提供了一个命令 <code>git reflog</code> 用来记录您的每一次命令:</p>
<div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>终于舒了口气，从输出可知，append GPL 的 commit id 是 1094adb，现在，您又可以乘坐时光机回到未来了。</p>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p><code>HEAD</code> 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p>
</li>
<li>
<p>用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">纵向查看</title>
    <id>https://list-jiang.github.io/software/git/status/</id>
    <link href="https://list-jiang.github.io/software/git/status/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>现在，运行 <code>git status</code> 命令看看结果:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>git status</code> 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p>
<div><p>简介输出</p>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。Git 有一个选项可以帮您缩短状态命令的输出，这样可以以简洁的方式查看更改。如果您使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，您将得到一种格式更为紧凑的输出。</p>
<p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。</p>
<details><summary>案例</summary>
<div><pre><code>$ <span>git</span> status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的状态报告显示: <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。<code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
</details>
</div>
<p>Git 现在只告诉我们 readme.txt 被修改了，我们用 <code>git diff</code> 这个命令能看看具体修改了什么内容:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 46d49bf<span>..</span>9247db6 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is <span>free</span> software.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>git diff</code> 顾名思义就是查看 difference，显示的格式正是 Unix 通用的 diff 格式，可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。</p>
<p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是 <code>git add</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>同样没有任何输出。在执行第二步 <code>git commit</code> 之前，我们再运行 <code>git status</code> 看看当前仓库的状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>git status</code> 告诉我们，将要被提交的修改包括 readme.txt，下一步，就可以放心地提交了:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"add distributed"</span>
<span>[</span>master e475afc<span>]</span> <span>add</span> distributed
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>提交后，我们再用 <code>git status</code> 命令看看仓库的当前状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Git 告诉我们当前没有需要提交的修改，而且，工作目录是干净(working tree clean)的。</p>
<h2 id="小结"> 小结</h2>
<ul>
<li>
<p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p>
</li>
<li>
<p>如果 <code>git status</code> 告诉您有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">标签管理</title>
    <id>https://list-jiang.github.io/software/git/tag/</id>
    <link href="https://list-jiang.github.io/software/git/tag/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要有-tag"> 为什么要有 tag</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签 (<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 <code>commit</code> 的指针(跟分支很像对不对? 但是分支可以移动，标签不能移动)，所以，创建和删除标签都是瞬间完成的。</p>
<p>Git 有 <code>commit</code>，为什么还要引入 <code>tag</code>?</p>
<p>“请把上周一的那个版本打包发布，<code>commit</code> 号是 6a5819e...”</p>
<p>“一串乱七八糟的数字不好找! ”</p>
<p>如果换一个办法:</p>
<p>“请把上周一的那个版本打包发布，版本号是 <code>v1.2</code>”</p>
<p>“好的，按照 <code>tag v1.2</code> 查找 <code>commit</code> 就行! ”</p>
<p>所以，<code>tag</code> 就是一个让人容易记住的有意义的名字，它跟某个 <code>commit</code> 绑在一起。</p>
<div><p>提示</p>
<p>推荐的标签规范是以小写字母 <code>v</code> 开头，后接 <code>x.x</code> 或 <code>x.x.x</code> 等若干位版本号。</p>
</div>
<h2 id="创建轻量标签"> 创建轻量标签</h2>
<p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后，敲命令 <code>git tag &lt;name&gt;</code> 就可以打一个新标签:</p>
<div><pre><code>$ <span>git</span> tag v1.0
-- no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以用命令 <code>git tag</code> 查看所有标签:</p>
<div><pre><code>$ <span>git</span> tag
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>默认标签是打在最新提交的 <code>commit</code> 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办?</p>
<p>方法是找到历史提交的 <code>commit id</code>，然后打上就可以了:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline --abbrev-commit
12a631b <span>(</span>HEAD -<span>></span> master, tag: v1.0, origin/master<span>)</span> merged bug fix <span>101</span>
4c805e2 fix bug <span>101</span>
e1e9c68 merge with no-ff
f52c633 <span>add</span> merge
cf810e4 conflict fixed
5dc6824 <span>&amp;</span> simple
14096d0 AND simple
b17d20e branch <span>test</span>
d46f35e remove test.txt
b84166e <span>add</span> test.txt
519219b <span>git</span> tracks changes
e43a48b understand how stage works
1094adb append GPL
e475afc <span>add</span> distributed
eaadf4e wrote a readme <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>比方说要对 <code>add merge</code> 这次提交打标签，它对应的 <code>commit id</code> 是 <code>f52c633</code>，敲入命令:</p>
<div><pre><code>$ <span>git</span> tag v0.9 f52c633
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>再用命令 <code>git tag</code> 查看标签:</p>
<div><pre><code>$ <span>git</span> tag
v0.9
v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息:</p>
<div><pre><code>$ <span>git</span> show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span>(</span>tag: v0.9<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:56:54 <span>2018</span> +0800

    <span>add</span> merge

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，<code>v0.9</code> 确实打在 <code>add merge</code> 这次提交上。</p>
<h2 id="附注标签"> 附注标签</h2>
<p>Git 还可以创建带有说明的标签，用 <code>-a</code> 指定标签名，<code>-m</code> 指定说明文字:</p>
<div><pre><code>$ <span>git</span> tag -a v0.1 -m <span>"version 0.1 released"</span> 1094adb
--no output --
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>用命令 <code>git show &lt;tagname&gt;</code> 可以看到说明文字:</p>
<div><pre><code>$ <span>git</span> show v0.1
tag v0.1
Tagger: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>22</span>:48:43 <span>2018</span> +0800

version <span>0.1</span> released

commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>tag: v0.1<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>提示</p>
<p>标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>
</div>
<h3 id="添加小结"> 添加小结</h3>
<p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 <code>HEAD</code>，也可以指定一个 <code>commit id</code>；</p>
<p>命令 <code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以指定标签信息；</p>
<p>命令 <code>git tag</code> 可以查看所有标签。</p>
<h2 id="操作标签"> 操作标签</h2>
<p>如果标签打错了，也可以删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.1
Deleted tag <span>'v0.1'</span> <span>(</span>was f15b0dd<span>)</span><span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code>:</p>
<div><pre><code>$ <span>git</span> push origin v1.0
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v1.0 -<span>></span> v1.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>或者，一次性推送全部尚未推送到远程的本地标签:</p>
<div><pre><code>$ <span>git</span> push origin --tags
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v0.9 -<span>></span> v0.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.9
Deleted tag <span>'v0.9'</span> <span>(</span>was f52c633<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>然后，从远程删除。删除命令也是 push，但是格式如下:</p>
<div><pre><code>$ <span>git</span> push origin :refs/tags/v0.9
To github.com:Hope-Studio/learngit.git
 - <span>[</span>deleted<span>]</span>         v0.9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。</p>
<h3 id="管理标签小结"> 管理标签小结</h3>
<ul>
<li>
<p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p>
</li>
<li>
<p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</p>
</li>
</ul>
]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">工作区和暂存区</title>
    <id>https://list-jiang.github.io/software/git/working-directory/</id>
    <link href="https://list-jiang.github.io/software/git/working-directory/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>

<h2 id="工作区-working-directory"> 工作区(Working Directory)</h2>
<p>就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区:</p>
<h2 id="版本库-repository"> 版本库(Repository)</h2>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。</p>
<p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage(或者叫 index)的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code>，以及指向 master 的一个指针叫 <code>HEAD</code>。</p>
<p><img src="./assets/git3.jpg" alt="版本库图例" loading="lazy"></p>
<p>前面讲了我们把文件往 Git 版本库里添加的时候，提交更改，实际上就是把暂存区的所有内容提交到当前分支。我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 <code>master</code> 分支，所以，现在，<code>git commit</code> 就是往 master 分支上提交更改。</p>
<p>您可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>先对 readme.txt 做个修改，比如加上一行内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>然后，在工作区新增一个 LICENSE 文本文件(内容随便写)。</p>
<p>先用 <code>git status</code> 查看一下状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Untracked files:
  <span>(</span>use <span>"git add &lt;file>..."</span> to include <span>in</span> what will be committed<span>)</span>

    LICENSE

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>Git 非常清楚地告诉我们，readme.txt 被修改了，而 LICENSE 还从来没有被添加过，所以它的状态是 <code>Untracked</code>。</p>
<p>现在，使用两次命令 <code>git add</code>，把 readme.txt 和 LICENSE 都添加后，用 <code>git status</code> 再查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   LICENSE
    modified:   readme.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>现在，暂存区的状态就变成这样了:</p>
<p><img src="./assets/git4.jpg" alt="状态示意图" loading="lazy"></p>
<p>所以，<code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区(Stage)，然后，执行 <code>git commit</code> 就可以一次性把暂存区的所有修改提交到分支。</p>
<div><pre><code>$ <span>git</span> commit -m <span>"understand how stage works"</span>
<span>[</span>master e43a48b<span>]</span> understand how stage works
 <span>2</span> files changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> LICENSE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一旦提交后，如果您又没有对工作区做任何修改，那么工作区就是“干净”的:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>廖雪峰</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>廖雪峰</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by 廖雪峰 Edited by Mr.Hope</rights>
  </entry>
  <entry>
    <title type="html">Git 原理</title>
    <id>https://list-jiang.github.io/software/git/working/</id>
    <link href="https://list-jiang.github.io/software/git/working/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>Git 究竟是怎样的一个系统呢? 尽管 Git 用起来与其它的版本控制系统非常相似，但它在对信息的存储和认知方式上却有很大差异。</p>
<h2 id="直接记录快照-而非差异比较"> 直接记录快照，而非差异比较</h2>
<p>Git 和其它版本控制系统(包括 Subversion 和近似工具)的主要差别在于 Git 对待数据的方法。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统(CVS、Subversion、Perforce、Bazaar 等等)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 (它们通常称作 基于差异(delta-based) 的版本控制)。</p>
<p><img src="./assets/delta-based.png" alt="基于差异" loading="lazy"></p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。在 Git 中，每当您提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p><img src="./assets/snapshot.png" alt="基于快照" loading="lazy"></p>
<h2 id="近乎所有操作都是本地执行"> 近乎所有操作都是本地执行</h2>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果您习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让您感到速度之神赐给了 Git 超凡的能量。因为您在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。您能立即看到项目历史。如果您想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<h2 id="git-保证完整性"> Git 保证完整性</h2>
<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若您在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列(hash，哈希)。这是一个由 40 个十六进制字符(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容或目录结构计算出来。Git 中使用这种哈希值的情况很多，您将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h2 id="git-一般只添加数据"> Git 一般只添加数据</h2>
<p>您执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。您很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦您提交快照到 Git 中， 就难以再丢失数据，特别是如果您定期的推送数据库到其它仓库的话。</p>
<p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h2 id="三种状态"> 三种状态</h2>
<p>Git 有三种状态，您的文件可能处于其中之一: 已提交(committed)、已修改(modified) 和 已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段: 工作区、暂存区以及 Git 目录。</p>
<p>工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供您使用或修改。
暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。
基本的 Git 工作流程如下:</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将您想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。如果文件已修改并放入暂存区，就属于 已暂存 状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="Git"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Nginx</title>
    <id>https://list-jiang.github.io/software/nginx/</id>
    <link href="https://list-jiang.github.io/software/nginx/"/>
    <updated>2021-11-30T10:52:02.000Z</updated>
    <summary type="html"><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>
]]></summary>
    <content type="html"><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>

<h2 id="启动-停止和重新加载配置"> 启动，停止和重新加载配置</h2>
<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>
<div><pre><code>nginx -s signal 
</code></pre>
<div><span>1</span><br></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>
<ul>
<li>stop - 快速关机</li>
<li>quit — 正常关机</li>
<li>reload — 重新加载配置文件</li>
<li>reopen — 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构"> 配置文件的结构</h2>
<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>
<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>
<p><code>#</code> 号后的其余行被视为注释。</p>
<h2 id="提供静态内容"> 提供静态内容</h2>
<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>
<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>
<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>
<div><pre><code><span><span>http</span></span> <span>{</span>
  <span><span>server</span></span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>
<p>将以下位置块添加到服务器块:</p>
<div><pre><code><span><span>location</span> /</span> <span>{</span>
  <span><span>root</span> /data/www</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>
<p>接下来，添加第二个位置块:</p>
<div><pre><code><span><span>location</span> /images/</span> <span>{</span>
  <span><span>root</span> /data</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>
<p>服务器块的最终配置应如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>root</span> /data/www</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>
<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>
<div><pre><code>nginx -s reload
</code></pre>
<div><span>1</span><br></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>
<h2 id="设置简单的代理服务器"> 设置简单的代理服务器</h2>
<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>
<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>
<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>listen</span> <span>8080</span></span><span>;</span>
  <span><span>root</span> /data/up1</span><span>;</span>

  <span><span>location</span> /</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>
<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>
<div><pre><code><span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
  <span><span>root</span> /data/images</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>
<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>
<p>代理服务器的最终配置如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>
<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>
<p>还有许多其他指令可用于进一步配置代理连接。</p>
<h2 id="设置-fastcgi-代理"> 设置 FastCGI 代理</h2>
<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>
<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>
    <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">点击此处</a></li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="服务器"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2019-12-13T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">软件教程</title>
    <id>https://list-jiang.github.io/software/</id>
    <link href="https://list-jiang.github.io/software/"/>
    <updated>2021-12-05T09:35:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="代码编辑器"> 代码编辑器</h2>
<ul>
<li><a href="./editor.html">编辑器介绍</a></li>
</ul>
<h2 id="团队协作"> 团队协作</h2>
<p>开发项目的代码版本管理以及多人协作使用 Git 软件</p>
<ul>
<li>
<p><a href="./git/">Git 教程</a></p>
</li>
<li>
<p><a href="./../code/github/">GitHub 介绍</a></p>
</li>
</ul>
<h2 id="浏览器"> 浏览器</h2>
<p>在开发中，调试网页推荐使用 Chrome。</p>
<ul>
<li><a href="./Chrome/">Chrome 介绍</a></li>
</ul>
<h2 id="后端"> 后端</h2>
<h3 id="http-server"> Http Server</h3>
<ul>
<li><a href="./nginx.html">Nginx</a></li>
</ul>
<h3 id="抓包与-api-调试"> 抓包与 API 调试</h3>
<ul>
<li><a href="./postman.html">Postman</a></li>
</ul>
<h2 id="工具软件"> 工具软件</h2>
<ul>
<li><a href="./tool/">查看详情</a></li>
</ul>
<h2 id="手机-app"> 手机 APP</h2>
<h3 id="sololearn"> soloLearn</h3>
<p>一个代码在线学习社区，只有英文版。由于代码语义贴近英文原生逻辑，十分建议在编辑代码时 “think in English”。</p>
<p>软件中的 code playground 可以在线运行大部分代码，大家在手机上就可以进行练习与尝试。</p>
<h2 id="adobe-软件"> Adobe 软件</h2>
<p>Adobe 全系软件的获取，请见 <a href="https://www.weibo.com/vposy" target="_blank" rel="noopener noreferrer">vposy 的微博</a> 的置顶帖。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">工具软件</title>
    <id>https://list-jiang.github.io/software/tool/</id>
    <link href="https://list-jiang.github.io/software/tool/"/>
    <updated>2022-01-20T07:46:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="https://github.com/huiyadanli/PasteEx" target="_blank" rel="noopener noreferrer">PasteEx</a>: Paste As File 把剪贴板的内容直接粘贴为文件</p>
</li>
<li>
<p><a href="https://www.typora.io/" target="_blank" rel="noopener noreferrer">typora</a>: 一个页面很漂亮的 Markdown 编辑器</p>
</li>
<li>
<p><a href="https://potplayer.daum.net/?lang=zh_CN" target="_blank" rel="noopener noreferrer">Potplayer</a>: 心目中最 NB 的视频播放器，没有之一</p>
</li>
<li>
<p><a href="">PostMan</a>: Postman 是一个用于构建和使用 API 的 API 平台。支持 Http、WebSocket 协议</p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">快速上手</title>
    <id>https://list-jiang.github.io/software/vscode/get-started/</id>
    <link href="https://list-jiang.github.io/software/vscode/get-started/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="vs-code-界面"> VS Code 界面</h2>
<div><p>提示</p>
<p>在完成 VS Code 安装并首次打开 VS Code 的时候，右下角会提示安装简体中文扩展，请点击安装。</p>
<p>如果忘记点击或没有弹窗，请到侧边栏扩展搜索找到 &quot;Chinese (Simplified) Language Pack for Visual Studio Code&quot; 扩展进行安装，即可将 VS Code 改为中文页面。</p>
</div>
<p><img src="./assets/layout.png" alt="VS Code UI 页面" loading="lazy"></p>
<p>VS Code 最上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>
<p>最左侧是选项卡切换，从上至下依次是、、、和。</p>
<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈和通知。</p>
<h3 id="资源管理器"> 资源管理器</h3>
<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。资源管理器会列出当前项目内的所有文档，支持大纲展示。</p>
<h3 id="搜索"> 搜索</h3>
<p>搜索界面可以方便的对打开文件夹内的所有文本型文件进行关键字的搜索。搜索结果会详细的列出来，快捷键为 <code>Ctrl + Shift + F</code>。</p>
<p>搜索内容支持大小写敏感/不敏感、全字匹配、指定目录/文件搜索、正则表达式等高级功能。</p>
<h3 id="源代码管理"> 源代码管理</h3>
<p>源代码管理提供快速暂存、提交并同步更改的功能，快捷键为 <code>Ctrl + Shift + G</code>。源代码可以快速对当前项目文件进行暂存、打包与推送。</p>
<p>使用源代码需要安装 Git，详情请见请见 <a href="./../git/">Git 使用说明</a>。</p>
<h3 id="调试"> 调试</h3>
<p>在这里可以调试代码，快捷键为 <code>Ctrl + Shift + D</code>。针对不同的语言，您可能需要安装不同的扩展。</p>
<p>按下 F5 开始进行调试。在初次调试前，您可能要选择当前的环境与调试的内容。</p>
<h3 id="扩展组件"> 扩展组件</h3>
<p>VS Code 强大就强大在其丰富的扩展。尽管 VS Code 在安装后是一个轻量的编辑器，但是如果您安装了您所需的合适扩展，您完全可以将其配置成 IDE。</p>
<p>在商店中可以找到大量的扩展，快捷键为 <code>Ctrl + Shift + X</code>。对于功能相近的插件，尽量选择一些 star 数比较高的插件安装。</p>
<p>每个插件的主页通常会有对应的说明文件，安装插件后请仔细阅读说明文档以了解插件的用法。</p>
<h2 id="强大的扩展内容"> 强大的扩展内容</h2>
<p>VS Code 扩展允许第三方添加对以下内容的支持:</p>
<ul>
<li>语言: 如 C++，C＃，Go，Java，Python，PHP，dart</li>
<li>工具: 如 ESLint，JSHint，PowerShell</li>
<li>调试器: Chrome，PHP XDebug，dart，Java</li>
<li>键盘映射: Vim，Sublime Text，IntelliJ，Emacs，Atom，Visual Studio，Eclipse</li>
</ul>
<p>扩展集成到 VS Code 的 UI，命令和任务运行系统中，因此您将发现通过 VS Code 的共享界面可以轻松使用不同的技术。</p>
<p>扩展可以通过按 <code>F1</code> 或者 <code>Ctrl + Shift + P</code> 来打开命令行窗口，并输入 <code>ext install 扩展名称</code> 来进行安装</p>
<div><p>提示</p>
<p>一些非常有用的扩展请见 <a href="./guide/extension.html#推荐扩展">VS Code 推荐扩展</a></p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">基础内容介绍</title>
    <id>https://list-jiang.github.io/software/vscode/guide/basic/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/basic/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="入门"> 入门</h2>
<p>打开 <strong>欢迎使用</strong> 页面，开始使用 VS Code 的基础知识。<strong>帮助 &gt; 欢迎</strong></p>
<p><img src="./assets/welcome.png" alt="欢迎使用" loading="lazy"></p>
<p>在 <strong>欢迎</strong> 页面的右下角，有一个指向 <strong>交互式游乐场</strong> 的链接，您可以在其中交互式地试用 VS Code 的功能。<strong>帮助 &gt; 交互式游乐场</strong></p>
<p><img src="./assets/interactive-playground.png" alt="交互式游乐场" loading="lazy"></p>
<h2 id="命令面板"> 命令面板</h2>
<p>根据您的当前上下文访问所有可用命令。</p>
<p>键盘快捷键: <code>Ctrl + Shift + P</code></p>
<p><img src="./assets/command-palette.png" alt="命令面板" loading="lazy"></p>
<h2 id="默认键盘快捷键"> 默认键盘快捷键</h2>
<p>所有命令都在命令面板中，并带有关联的键绑定(如果存在)。如果您忘记了键盘快捷键，请使用 <strong>命令面板</strong> 来帮助您。</p>
<p><img src="./assets/command-check.png" alt="查看命令与对应快捷键" loading="lazy"></p>
<h2 id="错误和警告"> 错误和警告</h2>
<p>键盘快捷键: <code>Ctrl + Shift + M</code></p>
<p><img src="./assets/error.png" alt="错误和警告" loading="lazy"></p>
<p>快速跳转到项目中的错误和警告。</p>
<p>通过 <code>F8</code> 或 <code>Shift + F8</code> 在错误中循环</p>
<p>您可以在问题面板右上角的筛选器中按类型 (errors, warnings) 或文本匹配来过滤问题。</p>
<h2 id="集成终端"> 集成终端</h2>
<p>键盘快捷键: <code>Ctrl + `</code></p>
<div><p>深入了解</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/editor/integrated-terminal" target="_blank" rel="noopener noreferrer">集成终端文档</a></li>
<li><a href="https://www.growingwiththeweb.com/2017/03/mastering-vscodes-terminal.html" target="_blank" rel="noopener noreferrer">精通 VS Code 终端的文章</a></li>
</ul>
</div>
<h2 id="键盘参考表"> 键盘参考表</h2>
<p><a href="./assets/vscodeKeyboardShortcutsWindows.pdf">Windows 下 VS Code 快捷键指南</a> (英文)</p>
<h2 id="快速打开"> 快速打开</h2>
<p>快速打开文件。</p>
<p>键盘快捷键: <code>Ctrl + P</code></p>
<p><img src="./assets/quick-open.png" alt="快速打开" loading="lazy"></p>
<div><p>提示</p>
<p>键入 <code>?</code> 查看命令建议。</p>
<p><img src="./assets/suggestions.png" alt="命令建议" loading="lazy"></p>
<p>键入命令，例如 <code>edt</code> 和 <code>term</code> 后跟一个空格，将显示下拉列表。</p>
</div>
<h2 id="最近打开的文件之间的浏览"> 最近打开的文件之间的浏览</h2>
<p>重复快速打开键盘快捷键，以在最近打开的文件之间快速循环。</p>
<h2 id="从快速打开打开多个文件"> 从快速打开打开多个文件</h2>
<p>您可以通过按向鼠标右键从 <strong>快速打开</strong> 中打开多个文件。这将在后台打开当前选择的文件，您可以继续从 <strong>快速打开</strong> 中选择文件。</p>
<h2 id="最近打开的文件夹和工作区之间导航"> 最近打开的文件夹和工作区之间导航</h2>
<p>键盘快捷键: <code>Ctrl + R</code></p>
<p>显示快速挑选下拉从列表 <code>文件 &gt; 打开最近</code>。优先使用最近打开的文件夹和工作空间，然后是文件。</p>
<p><img src="./assets/recent-open.png" alt="最近打开" loading="lazy"></p>
<h2 id="更改语言模式"> 更改语言模式</h2>
<p>键盘快捷键: <code>Ctrl + K M</code></p>
<p><img src="./assets/ext-assosiate.png" alt="语言关联" loading="lazy"></p>
<p>如果要保留特定文件类型的语言模式，则可以使用 <strong>XX 的配置文件关联</strong> 命令将当前文件扩展名与安装的语言相关联。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">命令行</title>
    <id>https://list-jiang.github.io/software/vscode/guide/command/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/command/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>VS Code 具有强大的命令行界面(CLI)，可让您自定义启动编辑器以支持各种情况的方式。</p>
<p>确保 VS Code 可执行文件已经添加到您的环境变量。只需键入 <code>code</code> 即可启动 VS Code。</p>
<div><pre><code><span># 使用 code 打开当前文件夹</span>
code <span>.</span>

<span># 在最近使用面板</span>
code -r <span>.</span>

<span># 打开新窗口</span>
code -n

<span># 改编当前语言</span>
code --locale<span>=</span>es

<span># 打开文件比较器</span>
code --diff <span>&lt;</span>file<span><span>1</span>></span> <span>&lt;</span>file<span><span>2</span>></span>

<span># 打开文件并跳转到指定的行(和列)</span>
code --goto package.json:10:5

<span># 查看帮助选项</span>
code --help

<span># 禁用所有扩展</span>
code --disable-extensions <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="vscode-文件夹"> .vscode 文件夹</h2>
<p>基于工作区的 <code>.vscode</code> 文件夹位于根目录下。例如任务运行对应的 <code>tasks.json</code> 配置文件和调试器对应的 <code>launch.json</code> 文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">调试</title>
    <id>https://list-jiang.github.io/software/vscode/guide/debug/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/debug/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="配置调试器"> 配置调试器</h2>
<p>打开命令面板(<code>Ctrl + Shift + P</code>)，然后选择 <strong>调试: 打开 launch.json</strong>，这将提示您选择与项目(Node.js，Python，C ++等)匹配的环境。这将生成一个 <code>launch.json</code> 文件。Node.js 支持是内置的，其他环境要求安装适当的语言扩展。有关更多详细信息，请参见 <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener noreferrer">调试文档</a>。</p>
<p><img src="./assets/configure-debug.gif" alt="配置调试" loading="lazy"></p>
<h2 id="断点并逐步执行"> 断点并逐步执行</h2>
<p>在行号旁边放置断点。使用 <strong>调试</strong> 小部件向前导航。</p>
<p><img src="./assets/node-debug.gif" alt="调试" loading="lazy"></p>
<h2 id="数据检查"> 数据检查</h2>
<p>在 <strong>运行</strong> 面板和控制台中检查变量。</p>
<p><img src="./assets/debug-data-inspection.gif" alt="数据检查" loading="lazy"></p>
<h2 id="内嵌值"> 内嵌值</h2>
<p>您可以设置 <code>&quot;debug.inlineValues&quot;: true</code> 在调试器中内联查看变量值。此功能开销很大，并且可能会减慢步进速度，因此默认情况下禁用此功能。</p>
<h2 id="logpoints"> Logpoints</h2>
<p>日志点的行为很像断点，但它们不会在命中时暂停调试器，而是在控制台中记录一条消息。日志点对于调试无法修改或暂停的生产服务器时注入日志特别有用。</p>
<p>使用左侧编辑器装订线中的 <strong>添加日志点</strong> 命令添加日志点，该日志点将显示为 🔸 形状的图标。日志消息是纯文本，但可以包含要在花括号('{}')中计算的表达式。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">编辑技巧</title>
    <id>https://list-jiang.github.io/software/vscode/guide/edit/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/edit/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>这是编辑代码的一些常用功能。如果您不喜欢键盘快捷键，请考虑为旧的编辑器安装键盘映射扩展名。</p>
<h2 id="多光标选择"> 多光标选择</h2>
<p>要在任意位置添加光标，请用鼠标选择一个位置，然后使用 <code>Alt + Click</code>。</p>
<p>要将光标设置在当前位置之上或之下，请使用:</p>
<p>键盘快捷键: <code>Ctrl + Alt + ↑</code> 或 <code>Ctrl + Alt + ↓</code></p>
<p>您可以使用 <code>Ctrl + Shift + L</code> 将附加光标添加到当前选择的所有实例中。</p>
<p>如果不想添加所有当前选中项，则可以使用 <code>Ctrl + D</code> 代替。这只会选择您选择的选中项之后的下一个选中项，因此您可以一个一个地添加选择。</p>
<h2 id="列-盒-选择"> 列(盒)选择</h2>
<p>您可以在拖动鼠标时按住 <code>Shift + Alt</code>(在 macOS 上为 <code>Shift + Option</code>)来选择文本块。一个单独的光标将被添加到每一行的末尾。</p>
<p><img src="./assets/column-select.gif" alt="列文字选择" loading="lazy"></p>
<p>您也可以使用键盘快捷键来触发列选择。</p>
<h2 id="直标尺"> 直标尺</h2>
<p>您可以使用该 <code>editor.rulers</code> 设置将垂直列标尺添加到编辑器中。</p>
<div><pre><code><span>{</span>
  <span>"editor.rulers"</span><span>:</span> <span>[</span><span>20</span><span>,</span> <span>40</span><span>,</span> <span>60</span><span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="快速滚动"> 快速滚动</h2>
<p>按 <code>Alt</code> 键可在编辑器和资源管理器中快速滚动。默认情况下，快速滚动使用 5 倍速倍增器，但是您可以使用 <code>editor.fastScrollSensitivity</code> 设置来控制倍增器。</p>
<h2 id="向上-向下复制行"> 向上 / 向下复制行</h2>
<p>键盘快捷键: <code>Shift + Alt + ↑</code> 或 <code>Shift + Alt + ↓</code></p>
<div><p>相关信息</p>
<p>由于按键冲突，在 Linux 上，向上 / 向下复制行没有默认的快捷键，您可以自行通过 <code>editor.action.copyLinesUpAction</code> 和 <code>editor.action.copyLinesDownAction</code> 设置自己的首选键盘快捷键。</p>
</div>
<h2 id="上下移动行号"> 上下移动行号</h2>
<p>键盘快捷键: <code>Alt + ↑</code> 或 <code>Alt + ↓</code></p>
<h2 id="缩小-扩大选择"> 缩小/扩大选择</h2>
<p>键盘快捷键: <code>Shift + Alt + ←</code> 或 <code>Shift + Alt + →</code></p>
<h2 id="转到文件中的符号"> 转到文件中的符号</h2>
<p>键盘快捷键: <code>Ctrl + Shift + O</code></p>
<p><img src="./assets/goto-file-symbol.png" alt="按符号查找" loading="lazy"></p>
<p>您可以通过添加冒号将符号按种类分组 <code>@:</code>。</p>
<h2 id="转到工作区中的符号"> 转到工作区中的符号</h2>
<p>键盘快捷键: <code>Ctrl + T</code></p>
<p><img src="./assets/goto-workspace-symbol.png" alt="转到工作区中的符号" loading="lazy"></p>
<h2 id="大纲视图"> 大纲视图</h2>
<p><strong>文件资源管理器</strong> 中的 <strong>大纲</strong> 视图(默认折叠在底部)显示了当前打开文件的符号。</p>
<p><img src="./assets/outlilne-view.png" alt="轮廓图" loading="lazy"></p>
<p>您可以按符号名称，类别和文件中的位置进行排序，并可以快速导航到符号位置。</p>
<h2 id="导航到特定行"> 导航到特定行</h2>
<p>键盘快捷键: <code>Ctrl + G</code></p>
<h2 id="恢复光标位置"> 恢复光标位置</h2>
<p>键盘快捷键: <code>Ctrl + U</code></p>
<h2 id="修剪尾随空格"> 修剪尾随空格</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + X</code></p>
<h2 id="转换文本命令"> 转换文本命令</h2>
<p>您可以使用 <strong>命令面板</strong> 中的 <strong>转换</strong> 命令将选定的文本更改为大写，小写和标题。</p>
<p><img src="./assets/transform.png" alt="转换文字指令" loading="lazy"></p>
<h2 id="代码格式化"> 代码格式化</h2>
<p>当前选择的源代码: <code>Ctrl + K Ctrl + F</code></p>
<p>整个文档: <code>Shift + Alt + F</code></p>
<h2 id="代码折叠"> 代码折叠</h2>
<p>键盘快捷键: <code>Ctrl + Shift + [</code> 和 <code>Ctrl + Shift +]</code></p>
<p>您还可以使用全部折叠(<code>Ctrl + K Ctrl + 0</code>)和全部展开(<code>Ctrl + K Ctrl + J</code>)来折叠/展开编辑器中的所有区域。</p>
<p>您可以使用 <strong>折叠所有块注释</strong>(<code>Ctrl + K Ctrl + /</code>)折叠所有块注释。</p>
<h2 id="选择当前行"> 选择当前行</h2>
<p>键盘快捷键: <code>Ctrl + L</code></p>
<h2 id="导航到文件的开头和结尾"> 导航到文件的开头和结尾</h2>
<p>键盘快捷键: <code>Ctrl + Home</code> 和 <code>Ctrl + End</code></p>
<h2 id="打开-markdown-预览"> 打开 Markdown 预览</h2>
<p>在 Markdown 文件中，使用</p>
<p>键盘快捷键: <code>Ctrl + Shift + V</code></p>
<p><img src="./assets/markdown-preview.png" alt="Markdown 预览" loading="lazy"></p>
<h2 id="并排-markdown-编辑和预览"> 并排 Markdown 编辑和预览</h2>
<p>在 Markdown 文件中，使用</p>
<p>键盘快捷键: <code>Ctrl + K V</code></p>
<p>预览和编辑器将与您在任一视图中的滚动同步。</p>
<p><img src="./assets/markdown-side-preview.png" alt="并排 Markdown 预览" loading="lazy"></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">个性化</title>
    <id>https://list-jiang.github.io/software/vscode/guide/customization/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/customization/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>您可以做很多事情来个性化 VS Code。</p>
<ul>
<li>改变您的主题</li>
<li>改变您的文件图标</li>
<li>更改键盘快捷键</li>
<li>调整设置</li>
<li>安装扩展</li>
</ul>
<h2 id="更改主题"> 更改主题</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + T</code></p>
<p>您可以从 VS Code 扩展市场中安装更多主题。</p>
<p>此外，您可以安装和更改文件图标主题。</p>
<div><p>提示</p>
<p>Mr.Hope 个人推荐 <code>One Dark Pro</code> 主题和 <code>Material Icon Theme</code> 文件图标主题。</p>
<p>您需要从扩展应用应用商店中安装它们。</p>
</div>
<h2 id="自定义键盘快捷键"> 自定义键盘快捷键</h2>
<p>键盘快捷键: <code>Ctrl + K Ctrl + S</code></p>
<p>您可以搜索快捷方式并将自己的键绑定添加到 <code>keybindings.json</code> 文件中。</p>
<p>有关更多信息，请参见 <a href="./../shortcut-key.html#快捷键编辑器">快捷键键绑定</a>。</p>
<h2 id="调整您的设置"> 调整您的设置</h2>
<p>默认情况下，VS Code 显示 <strong>设置</strong> 编辑器，您还可以通过使用 <strong>打开设置(JSON)</strong> 命令打开 <code>settings.json</code>。</p>
<p>键盘快捷键: <code>Ctrl + ,</code></p>
<p><strong>示例</strong>:</p>
<ul>
<li>
<p>更改各种 UI 元素的字体大小</p>
<div><pre><code><span>// Main editor</span>
<span>"editor.fontSize"</span><span>:</span> <span>18</span><span>,</span>
<span>// Terminal panel</span>
<span>"terminal.integrated.fontSize"</span><span>:</span> <span>14</span><span>,</span>
<span>// Output panel</span>
<span>"[Log]"</span><span>:</span> <span>{</span>
    <span>"editor.fontSize"</span><span>:</span> <span>15</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>更改缩放等级</p>
<div><pre><code><span>"window.zoomLevel"</span><span>:</span> <span>5</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>字体连字</p>
<div><pre><code><span>"editor.fontFamily"</span><span>:</span> <span>"Fira Code"</span><span>,</span>
<span>"editor.fontLigatures"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>提示</p>
<p>这需要安装支持字体连字的字体。FiraCode 是 VS Code 团队中流行的字体。</p>
<p>Mr.Hope 也强力推荐安装并使用这一字体 (字体详见云文档共享文件)</p>
</div>
</li>
<li>
<p>自动保存</p>
<div><pre><code><span>"files.autoSave"</span><span>:</span> <span>"afterDelay"</span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以使用 <code>文件 &gt; 自动保存</code> 从顶层菜单切换自动保存。</p>
</li>
<li>
<p>保存时格式化</p>
<div><pre><code><span>"editor.formatOnSave"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>粘贴格式</p>
<div><pre><code><span>"editor.formatOnPaste"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>更改制表符的大小</p>
<div><pre><code><span>"editor.tabSize"</span><span>:</span> <span>4</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>空格或制表符</p>
<div><pre><code><span>"editor.insertSpaces"</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>渲染空白</p>
<div><pre><code><span>"editor.renderWhitespace"</span><span>:</span> <span>"all"</span>
</code></pre>
<div><span>1</span><br></div></div><p>默认情况下，在文本选择中呈现空白字符。</p>
</li>
<li>
<p>忽略文件/文件夹</p>
<p>从编辑器窗口中删除这些文件/文件夹。</p>
<div><pre><code><span>"files.exclude"</span><span>:</span> <span>{</span>
    <span>"somefolder/"</span><span>:</span> <span>true</span><span>,</span>
    <span>"somefile"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>从搜索结果中删除这些文件/文件夹。</p>
<div><pre><code><span>"search.exclude"</span><span>:</span> <span>{</span>
    <span>"someFolder/"</span><span>:</span> <span>true</span><span>,</span>
    <span>"somefile"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<p>以及许多其他定制。</p>
<h2 id="语言特定的设置"> 语言特定的设置</h2>
<p>您可以通过语言标识符来确定只需要特定语言的设置的范围。您可以在 <a href="https://code.visualstudio.com/docs/languages/identifiers" target="_blank" rel="noopener noreferrer">语言标识符</a> 参考中找到常用语言 ID 的列表。</p>
<div><pre><code><span>"[languageid]"</span><span>:</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>提示</p>
<p>您还可以使用 <strong>配置语言特定的设置</strong> 命令来创建特定于语言的设置。</p>
</div>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">扩展</title>
    <id>https://list-jiang.github.io/software/vscode/guide/extension/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/extension/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>键盘快捷键: <code>Ctrl + Shift + X</code></p>
<h2 id="查找扩展"> 查找扩展</h2>
<ol>
<li>在 VS Code 应用商店</li>
<li>在 VS Code 侧边栏中的 <strong>扩展</strong> 选项卡</li>
<li>查看扩展建议</li>
<li>社区策划的扩展列表，例如 awesome-vscode。</li>
</ol>
<p><img src="./assets/extension.png" alt="扩展选项卡" loading="lazy"></p>
<h2 id="安装扩展"> 安装扩展</h2>
<p>在扩展视图中，您可以通过搜索栏进行搜索，或单击 <strong>更多(...)</strong> 按钮以按安装数量进行过滤和排序。</p>
<h2 id="扩展建议"> 扩展建议</h2>
<p>在 <strong>扩展</strong> 视图中，单击 <strong>更多(...)</strong> 按钮菜单中的 <strong>显示推荐的扩展</strong>。</p>
<h2 id="推荐扩展"> 推荐扩展</h2>
<p>以下是推荐的 VS Code 扩展:</p>
<h3 id="语言包"> 语言包</h3>
<h4 id="chinese-simplified-language-pack-for-visual-studio-code"> Chinese (Simplified) Language Pack for Visual Studio Code</h4>
<p>VS Code 原生为英文，本插件为 VS Code 提供简体中文支持，会更改页面为简体中文</p>
<h3 id="外观"> 外观</h3>
<h4 id="indent-rainbow"> indent-rainbow</h4>
<p>为代码中的缩进上色，更容易判断缩进层数</p>
<h4 id="material-icon-theme"> Material Icon Theme</h4>
<p>为 VS Code 文件图标应用安卓的 Material 主题</p>
<h4 id="one-dark-pro"> One Dark Pro</h4>
<p>为添加一款类 Atom 的一款暗色风格主题，配色会比 VS Code 默认风格好看一些</p>
<h4 id="todo-highlight"> TODO Highlight</h4>
<p>高光显示特定注释，如 <code>TODO:</code> 等</p>
<h3 id="工具"> 工具</h3>
<h4 id="bookmarks"> Bookmarks</h4>
<p>在代码中添加书签并支持快速跳转</p>
<h4 id="filesize"> filesize</h4>
<p>在 VS Code 底部状态栏显示文件大小</p>
<h4 id="project-manager"> Project Manager</h4>
<p>快速打开特定项目或在多个项目之间切换</p>
<h4 id="svg-preview"> SVG Preview</h4>
<p>提供在 VS Code 直接打开 SVG 预览</p>
<h4 id="visual-studio-intellicode"> Visual Studio IntelliCode</h4>
<p>基于 AI 的智能提示</p>
<h3 id="版本管理与多人协作"> 版本管理与多人协作</h3>
<div><p>提示</p>
<p>VS Code 不包含 Git，请自行安装 Git 并添加到 path 以实现版本管理。</p>
</div>
<h4 id="gitlens"> GitLens</h4>
<p>在文件中提供 Git 版本增强功能，包括但不限于行历史、文件历史、分支查看、本地与远程库提交查看与对比分析等</p>
<h4 id="live-share"> Live Share</h4>
<p>官方实时分享功能，可多人同时协作一份文件，也可做在线演示</p>
<h4 id="live-share-audio"> Live Share Audio</h4>
<p>官方实时语音通话，可在多人协作或演示中使用</p>
<h4 id="remote-development"> Remote Development</h4>
<p>远程链接与控制</p>
<h3 id="网页"> 网页</h3>
<h4 id="color-info"> Color Info</h4>
<p>为 CSS 颜色详情显示更多信息</p>
<h4 id="eslint"> ESLint</h4>
<p>需要 <code>eslint</code> 模块，进行 JS、TS 等文件的的错误检查、格式化</p>
<h4 id="javascript-es6-code-snippets"> JavaScript (ES6) code snippets</h4>
<p>ES6 快速补全，提升代码编写利器</p>
<h4 id="language-stylus"> language-stylus</h4>
<p>Stylus 格式化，高亮支持</p>
<h4 id="live-server"> Live Server</h4>
<p>快速启动本地开发服务器</p>
<h4 id="manta-s-stylus-supremacy"> Manta’s Stylus Supremacy</h4>
<p>Stylus 格式化支持</p>
<h4 id="quokka-js"> Quokka.js</h4>
<p>JavaScript TypeScript 及时运行与结果显示</p>
<h4 id="scss-intellisence"> SCSS IntelliSence</h4>
<p>SCSS 格式化、补全支持</p>
<h4 id="stylelint"> stylelint</h4>
<p>CSS / SCSS / Less 格式化</p>
<h4 id="vetur"> Vetur</h4>
<p>为 VS Code 添加 <code>.vue</code> 文件的支持</p>
<h3 id="小程序"> 小程序</h3>
<h4 id="minapp"> minapp</h4>
<p>小程序标签属性补全</p>
<h3 id="xml-与-json"> XML 与 JSON</h3>
<h4 id="json-organizer"> JSON Organizer</h4>
<p>提供 json 到 js object 的相互转换</p>
<h4 id="xml-tools"> XML Tools</h4>
<p>提供 XML 补全、格式化等</p>
<h3 id="php"> PHP</h3>
<h4 id="php-debug"> PHP Debug</h4>
<p>PHP 逐行调试，需要提前在 PHP 中配置好 XDebug</p>
<h4 id="php-intelephense"> PHP Intelephense</h4>
<p>提供 PHP 函数补全</p>
<h4 id="phpcs"> phpcs</h4>
<p>PHP 错误检查与修复</p>
<h3 id="app-开发"> APP 开发</h3>
<h4 id="dart"> Dart</h4>
<p>提供 dart 语言支持与调试</p>
<h4 id="flutter"> Flutter</h4>
<p>提供 Flutter 支持与调试</p>
<h4 id="gradle-language-support"> Gradle Language Support</h4>
<p>Gradle 语言支持</p>
<h3 id="编程"> 编程</h3>
<h4 id="c-c"> C/C++</h4>
<p>提供代码格式化、自动完成、逐行调试等功能等</p>
<h4 id="code-runner"> Code Runner</h4>
<p>提供多种编程语言的运行</p>
<h4 id="java-extension-pack"> Java Extension Pack</h4>
<p>Java 调试包</p>
<h4 id="python"> Python</h4>
<p>Python 格式化、调试支持</p>
<h3 id="markdown"> Markdown</h3>
<h4 id="markdown-all-in-one"> Markdown All in One</h4>
<p>提供快速添加 Markdown 标记的支持</p>
<h4 id="markdown-emoji"> Markdown Emoji</h4>
<p>为 Markdown 添加表情支持</p>
<h4 id="markdown-preview-github-styling"> Markdown Preview GitHub Styling</h4>
<p>为 Markdown 预览应用 GitHub 风格</p>
<h4 id="markdownlint"> markdownlint</h4>
<p>检查 Markdown 文法错误</p>
<h3 id="node-js"> Node.js</h3>
<h4 id="node-js-modules-intellisense"> Node.js Modules Intellisense</h4>
<p>提供 Node.js 模块智能提示</p>
<h4 id="npm-intellisense"> npm Intellisense</h4>
<p>为 VS Code 添加 npm 模块导入补全</p>
<h3 id="latex"> LaTeX</h3>
<h4 id="latex-workshop"> LaTeX Workshop</h4>
<p>LaTeX 插件，支持常见功能与编译</p>
<h4 id="latex-formatter"> latex-formatter</h4>
<p>提供 LaTeX 格式化</p>
<h3 id="其他"> 其他</h3>
<h4 id="yaml"> YAML</h4>
<p>提供 YAML 格式化，高亮支持</p>
<h4 id="leetcode"> LeetCode</h4>
<p>代码学习练习软件</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">文件</title>
    <id>https://list-jiang.github.io/software/vscode/guide/file/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/file/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="切换侧边栏"> 切换侧边栏</h2>
<p>键盘快捷键: <code>Ctrl + B</code></p>
<h2 id="切换面板"> 切换面板</h2>
<p>键盘快捷键: <code>Ctrl + J</code></p>
<h2 id="zen-模式"> Zen 模式</h2>
<p>键盘快捷键: <code>Ctrl + K Z</code></p>
<p>进入无干扰禅宗模式。</p>
<p>按两次 <code>Esc</code> 键退出 Zen 模式。</p>
<h2 id="并排编辑"> 并排编辑</h2>
<p>键盘快捷键: <code>Ctrl + \</code></p>
<p>您还可以拖放编辑器以创建新的编辑器组，并在组之间移动编辑器。</p>
<h2 id="编辑之间切换"> 编辑之间切换</h2>
<p>键盘快捷键: <code>Ctrl + 1</code>，<code>Ctrl + 2</code>，<code>Ctrl + 3</code></p>
<h2 id="移至资源管理器窗口"> 移至资源管理器窗口</h2>
<p>键盘快捷键: <code>Ctrl + Shift + E</code></p>
<h2 id="创建或打开一个文件"> 创建或打开一个文件</h2>
<p>键盘快捷键: <code>Ctrl + click</code></p>
<p>您可以通过将光标移动到文件链接并使用 <code>Ctrl + click</code> 来快速打开文件或图像或创建新文件。</p>
<h2 id="关闭当前打开的文件夹"> 关闭当前打开的文件夹</h2>
<p>键盘快捷键: <code>Ctrl + F4</code></p>
<h2 id="导航历史"> 导航历史</h2>
<p>浏览整个历史记录: <code>Ctrl + Tab</code></p>
<p>向后导航: <code>Alt + ←</code></p>
<p>向前导航: <code>Alt + →</code></p>
<h2 id="文件关联"> 文件关联</h2>
<p>为未正确检测到的文件创建语言关联。例如，许多带有自定义文件扩展名的配置文件实际上是 JSON。</p>
<div><pre><code><span>"files.associations"</span><span>:</span> <span>{</span>
  <span>".database"</span><span>:</span> <span>"json"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="防止脏写入"> 防止脏写入</h2>
<p>当您尝试保存已经再打开后再度在磁盘上发生更改的文件时，VS Code 将显示一条错误消息。VS Code 阻止保存文件，以防止覆盖在编辑器之外进行的更改。</p>
<p>为了解决保存冲突，请在错误消息中单击 <strong>比较</strong> 操作以打开差异编辑器，该差异编辑器将向您显示磁盘上文件的内容(左侧)，与 VS Code 中的内容(右侧)相比:</p>
<p>使用编辑器工具栏中的操作来解决保存冲突。您可以接受更改并覆盖磁盘上的所有更改，也可以还原为磁盘上的版本。还原意味着您的更改将丢失。</p>
<p>注意: 该文件将保持 <code>dirty</code> 状态，直到您选择两个解决冲突的操作之一后才能保存。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">智能提示</title>
    <id>https://list-jiang.github.io/software/vscode/guide/intellisense/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/intellisense/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>使用 <code>Ctrl + Space</code> 触发智能提示组件。</p>
<p><img src="./assets/intellisense.gif" alt="智能提示组件" loading="lazy"></p>
<p>您可以查看可用的方法，参数提示，简短文档等。</p>
<h2 id="跳转"> 跳转</h2>
<p>选择一个符号然后输入 <code>Alt + F12</code>，您就可以使用上下文菜单了。</p>
<p><img src="./assets/context-menu.gif" alt="上下文菜单" loading="lazy"></p>
<h2 id="跳转到定义"> 跳转到定义</h2>
<p>选择一个符号然后输入 <code>F12</code>，您也可以使用上下文菜单或 <code>Ctrl + Click</code></p>
<p><img src="./assets/goto-definition.gif" alt="跳转到定义" loading="lazy"></p>
<p>您可以使用 <strong>转到 &gt; 返回</strong> 命令或快捷键 <code>Alt + ←</code> 来返回您的上个位置。</p>
<h2 id="跳转到引用"> 跳转到引用</h2>
<p>选择一个符号输入 <code>Shift + F12</code>，即可打开上下文菜单查看所有引用。</p>
<h2 id="查看所有引用"> 查看所有引用</h2>
<p>选择一个符号，然后按 <code>Shift + Alt + F12</code> 打开 <strong>引用</strong> 视图，在专用视图中显示文件的所有符号。</p>
<h2 id="重命名符号"> 重命名符号</h2>
<p>选择一个符号，然后按下 <code>F2</code>。或者，您可以使用上下文菜单。</p>
<p><img src="./assets/rename.gif" alt="重命名符号" loading="lazy"></p>
<h2 id="搜索和修改"> 搜索和修改</h2>
<p>除了搜索和替换表达式之外，您还可以使用带有捕获组的正则表达式搜索和重用匹配的部分。通过单击 <strong>使用正则表达式</strong> <code>.*</code> 按钮(<code>Alt + R</code>)在搜索框中启用正则表达式，然后编写正则表达式并使用括号定义组。然后，您可以在替换字段使用 <code>$1</code>，<code>$2</code> 等来输入每个组中匹配的内容。</p>
<p><img src="./assets/replace.png" alt="搜索和修改" loading="lazy"></p>
<h2 id="eslintrc-json"> .eslintrc.json</h2>
<p>安装 ESLint 扩展，并根据您的需要配置。请查阅 ESLint 规范以获取有关其格式化规则和选项的详细信息。</p>
<p>这是使用 ES6 的配置。</p>
<div><pre><code><span>{</span>
  <span>"env"</span><span>:</span> <span>{</span>
    <span>"browser"</span><span>:</span> <span>true</span><span>,</span>
    <span>"commonjs"</span><span>:</span> <span>true</span><span>,</span>
    <span>"es6"</span><span>:</span> <span>true</span><span>,</span>
    <span>"node"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"parserOptions"</span><span>:</span> <span>{</span>
    <span>"ecmaVersion"</span><span>:</span> <span>6</span><span>,</span>
    <span>"sourceType"</span><span>:</span> <span>"module"</span><span>,</span>
    <span>"ecmaFeatures"</span><span>:</span> <span>{</span>
      <span>"jsx"</span><span>:</span> <span>true</span><span>,</span>
      <span>"classes"</span><span>:</span> <span>true</span><span>,</span>
      <span>"defaultParams"</span><span>:</span> <span>true</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>"rules"</span><span>:</span> <span>{</span>
    <span>"no-const-assign"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-extra-semi"</span><span>:</span> <span>0</span><span>,</span>
    <span>"semi"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-fallthrough"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-empty"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-mixed-spaces-and-tabs"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-redeclare"</span><span>:</span> <span>0</span><span>,</span>
    <span>"no-this-before-super"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-undef"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-unreachable"</span><span>:</span> <span>1</span><span>,</span>
    <span>"no-use-before-define"</span><span>:</span> <span>0</span><span>,</span>
    <span>"constructor-super"</span><span>:</span> <span>1</span><span>,</span>
    <span>"curly"</span><span>:</span> <span>0</span><span>,</span>
    <span>"eqeqeq"</span><span>:</span> <span>0</span><span>,</span>
    <span>"func-names"</span><span>:</span> <span>0</span><span>,</span>
    <span>"valid-typeof"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="package-json"> package.json</h2>
<p>IntelliSense 会为 package.json 文件提供智能提示。</p>
<h2 id="emmet-语法"> Emmet 语法</h2>
<p>支持 <a href="./../../../code/website/emmet/">Emmet 语法</a>。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">Git 集成</title>
    <id>https://list-jiang.github.io/software/vscode/guide/git/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/git/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>键盘快捷键: <code>Ctrl + Shift + G</code></p>
<p>VS Code 有开箱即用的 Git 集成。您可以从扩展市场中安装其他 SCM 提供程序。本节描述了 Git 集成。</p>
<h2 id="差异"> 差异</h2>
<p>从 <strong>源代码管理</strong> 视图中，选择一个文件以打开差异。</p>
<p><img src="./assets/git-diff.png" alt="来自源代码管理的 git diff" loading="lazy"></p>
<h3 id="视图布局"> 视图布局</h3>
<p>差异的默认视图是并排视图。</p>
<p>切换内嵌视图: 点击更多操作右上角(...)按钮，然后选择切换内嵌视图。</p>
<p>如果您喜欢嵌入式视图，可以设置 <code>&quot;diffEditor.renderSideBySide&quot;: false</code>。</p>
<h3 id="审查窗格"> 审查窗格</h3>
<p>使用 <code>F7</code> 和 <code>Shift + F7</code> 浏览差异。这将以统一的补丁格式显示它们。可以使用箭头键浏览行，然后按 Enter 键将在差异编辑器和所选行中跳回。</p>
<h3 id="编辑待处理的更改"> 编辑待处理的更改</h3>
<p>您可以直接在 diff 视图的等待更改试图中进行编辑。</p>
<h2 id="分支"> 分支</h2>
<p>通过状态栏轻松在 Git 分支之间切换。</p>
<p>切换分支</p>
<h2 id="暂存"> 暂存</h2>
<h3 id="暂存文件更改"> 暂存文件更改</h3>
<ul>
<li>
<p>将鼠标悬停在文件上，然后单击加号按钮。</p>
</li>
<li>
<p>单击减号按钮可以取消更改。</p>
</li>
</ul>
<h3 id="撤消最后提交"> 撤消最后提交</h3>
<p>单击(...)按钮，然后选择 <strong>提交 &gt; 撤消上一次提交</strong> 以撤消上一次提交。所做的更改将添加到 <strong>暂存的更改</strong> 部分。</p>
<p><img src="./assets/undo-last-commit.png" alt="撤消上一次提交" loading="lazy"></p>
<h2 id="查看-git-输出"> 查看 Git 输出</h2>
<p>VS Code 使得查看实际运行的 Git 命令变得容易。在学习 Git 或调试困难的源代码管理问题时，这很有用。</p>
<p>使用 <strong>切换输出命令</strong> (<code>Ctrl + Shift + U</code>)，然后在下拉菜单中选择 Git。</p>
<h2 id="增删指示"> 增删指示</h2>
<p>在编辑器中查看差异提示。有关更多详细信息，请参见文档。</p>
<p><img src="./assets/gutter.png" alt="增删指示" loading="lazy"></p>
<h2 id="解决合并冲突"> 解决合并冲突</h2>
<p>在合并过程中，转到 <strong>源代码管理</strong> 视图(<code>Ctrl + Shift + G</code>)，然后在 diff 视图中进行更改。</p>
<p>您可以使用内联 CodeLens 解决合并冲突，内联 CodeLens 允许您 <strong>接受当前更改</strong>，<strong>接受传入更改</strong>，<strong>接受两个更改</strong> 以及 <strong>比较更改</strong>。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">VS Code 指南</title>
    <id>https://list-jiang.github.io/software/vscode/guide/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>
<p><a href="./basic.html">基础常识</a></p>
</li>
<li>
<p><a href="./customization.html">个性化介绍</a></p>
</li>
<li>
<p><a href="./extension.html">扩展介绍</a></p>
</li>
<li>
<p><a href="./file.html">文件介绍</a></p>
</li>
<li>
<p><a href="./edit.html">编辑技巧</a></p>
</li>
<li>
<p><a href="./intellisense.html">智能补全</a></p>
</li>
<li>
<p><a href="./git.html">Git 支持</a></p>
</li>
<li>
<p><a href="./debug.html">调试介绍</a></p>
</li>
<li>
<p><a href="./task.html">任务介绍</a></p>
</li>
<li>
<p><a href="./command.html">命令行介绍</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">任务执行器</title>
    <id>https://list-jiang.github.io/software/vscode/guide/task/</id>
    <link href="https://list-jiang.github.io/software/vscode/guide/task/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="自动检测任务"> 自动检测任务</h2>
<p>从顶层菜单中选择<strong>终端</strong>，运行命令<strong>配置任务</strong>，然后选择您要运行的任务类型。这将生成一个 <code>tasks.json</code> 文件。有关更多详细信息，请参见 <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener noreferrer">任务文档</a>。</p>
<div><pre><code><span>{</span>
  <span>// See &lt;https://go.microsoft.com/fwlink/?LinkId=733558></span>
  <span>// for the documentation about the tasks.json format</span>
  <span>"version"</span><span>:</span> <span>"2.0.0"</span><span>,</span>
  <span>"tasks"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"type"</span><span>:</span> <span>"npm"</span><span>,</span>
      <span>"script"</span><span>:</span> <span>"install"</span><span>,</span>
      <span>"group"</span><span>:</span> <span>{</span>
        <span>"kind"</span><span>:</span> <span>"build"</span><span>,</span>
        <span>"isDefault"</span><span>:</span> <span>true</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>自动生成有时会出现问题。请查阅文档，以确保一切正常。</p>
<h2 id="从终端菜单运行任务"> 从终端菜单运行任务</h2>
<p>从顶层菜单中选择 <strong>终端 &gt; 运行任务</strong>，然后选择要运行的任务。通过运行命令 <strong>终止任务</strong> 终止正在运行的任务</p>
<p><img src="./assets/task-runner.gif" alt="任务执行器" loading="lazy"></p>
<h2 id="定义任务的键盘快捷键"> 定义任务的键盘快捷键</h2>
<p>您可以为任何任务定义键盘快捷键。从命令面板(<code>Ctrl + Shift + P</code>)中，选择 <strong>首选项: 打开键盘快捷方式文件</strong>，将所需的快捷方式绑定到 <code>workbench.action.tasks.runTask</code> 命令，然后将 任务 定义为 <code>args</code>。</p>
<p>例如，要将 <code>Ctrl + H</code> 绑定到 <strong>运行任务</strong>，请添加以下内容:</p>
<div><pre><code><span>{</span>
  <span>"key"</span><span>:</span> <span>"ctrl+h"</span><span>,</span>
  <span>"command"</span><span>:</span> <span>"workbench.action.tasks.runTask"</span><span>,</span>
  <span>"args"</span><span>:</span> <span>"Run tests"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="从资源管理器中将-npm-脚本作为任务运行"> 从资源管理器中将 npm 脚本作为任务运行</h2>
<p>使用该设置 <code>npm.enableScriptExplorer</code>，您可以启用一个浏览器，该浏览器显示在工作空间中定义的脚本。</p>
<p>在资源管理器中，您可以在编辑器中打开脚本，将其作为任务运行，然后使用节点调试器启动它(当脚本定义了诸如 <code>--inspect-brk</code> 的调试选项时)。单击时的默认操作是打开脚本。要单击运行脚本，请设置 <code>npm.scriptExplorerAction</code> 为 <strong>运行</strong>。使用 <code>npm.exclude</code> 设置可以排除 <code>package.json</code> 特定文件夹中包含的文件中的脚本。</p>
<p>通过设置 <code>npm.enableRunFromFolder</code>，您可以启用从文件资源管理器的上下文菜单中为文件夹运行 npm 脚本的功能。选择文件夹后，该设置将启用命令 <strong>在文件夹中运行 npm 脚本...</strong>。该命令显示此文件夹中包含的 npm 脚本的快速选择列表，您可以选择要作为任务执行的脚本。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">VS Code 安装</title>
    <id>https://list-jiang.github.io/software/vscode/install/</id>
    <link href="https://list-jiang.github.io/software/vscode/install/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="vs-code-安装"> VS Code 安装</h1>
<h2 id="下载"> 下载</h2>
<p>在 <a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener noreferrer">官网下载地址</a> 下载最新版安装包(Window User 64bit, 那个大的蓝色按钮就是)。</p>
<h2 id="安装"> 安装</h2>
<ul>
<li>
<p>双击安装包打开</p>
</li>
<li>
<p>同意用户协议。</p>
</li>
<li>
<p>安装选项中，请务必 <strong>全选</strong> 以下选项:</p>
<p><img src="./assets/install.png" alt="安装 VS Code" loading="lazy"></p>
<p>勾选 <strong>添加到目录上下文菜单</strong>、<strong>添加到文件上下文菜单</strong>、<strong>将 code 注册为受支持的文件编辑器</strong>、<strong>添加到 path</strong>。</p>
</li>
<li>
<p>在 VS Code 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可</p>
</li>
<li>
<p>推荐立即执行简体中文扩展安装以保证界面语言为简体中文。</p>
<div><p>提示</p>
<p>当您安装 VS Code 并第一次打开的时候，VS Code 会自动检测当前系统语言并在右下角推荐您安装对应语言的扩展，点击按钮即可自动安装。</p>
</div>
</li>
</ul>
<h2 id="更新频率"> 更新频率</h2>
<p>VS Code 每月发布一个具有新功能和重要错误修复的新版本。大多数平台都支持自动更新，并且会在新版本发布时提示您安装新版本。您还可以通过运行左下角 <strong>管理 → 检查更新</strong> 来手动检查更新。</p>
<h2 id="用-vs-code-打开文件和文件夹"> 用 VS Code 打开文件和文件夹</h2>
<p>VS Code 支持打开文件和文件夹。</p>
<ul>
<li>
<p>打开文件时请在文件图标上单击右键—选择 <strong>使用 VS Code 打开</strong>；</p>
</li>
<li>
<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择 <strong>用 VS Code 打开</strong>。</p>
</li>
</ul>
<h3 id="mac-添加-通过-code-打开"> Mac 添加 <strong>通过 Code 打开</strong></h3>
<p>在 Mac 系统上，Finder 选中一个目录，右键菜单并没有 <strong>通过 Code 打开</strong> 这个操作。不过我们可以通过 Automator 自己添加这个操作。</p>
<p>先运行 Automator，选择 <strong>服务</strong>:</p>
<p><img src="./assets/automator-service.png" alt="Automator Service" loading="lazy"></p>
<p>然后，执行以下操作:</p>
<p><img src="./assets/automator.jpg" alt="Automator" loading="lazy"></p>
<ol>
<li>
<p>在右侧面板选择 <strong>服务</strong> 收到选定的 <strong>文件夹</strong>，位于 “Finder.app”，该选项是为了从 Finder 中接收一个文件夹；</p>
</li>
<li>
<p>在左侧面板选择 <strong>实用工具</strong>，然后找到 <strong>运行 Shell 脚本</strong>，把它拽到右侧面板里；</p>
</li>
<li>
<p>在右侧 <strong>运行 Shell 脚本</strong> 的面板里，选择 Shell <strong>/bin/bash</strong>，传递输入 <strong>作为自变量</strong>，然后修改 Shell 脚本如下:</p>
</li>
</ol>
<div><pre><code><span>for</span> <span>f</span> <span>in</span> <span>"<span>$@</span>"</span>
<span>do</span>
    <span>open</span> -a <span>"Visual Studio Code"</span> <span>"<span>$f</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>保存为 <strong>Open With VS Code</strong> 后，打开 Finder，选中一个文件夹，点击右键， <strong>服务</strong>，就可以看到 <strong>Open With VS Code</strong> 菜单:</p>
<p><img src="./assets/open-with-vscode.png" alt="Open with VS Code" loading="lazy"></p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">VS Code</title>
    <id>https://list-jiang.github.io/software/vscode/</id>
    <link href="https://list-jiang.github.io/software/vscode/"/>
    <updated>2021-12-11T15:10:07.000Z</updated>
    <content type="html"><![CDATA[<p>Visual Studio Code 是一个轻量级但功能强大的源代码编辑器，可在您的桌面上运行，并且可用于 Windows，macOS 和 Linux。它具有对 JavaScript，TypeScript 和 Node.js 的内置支持，并具有丰富的其他语言 (例如 C ++，C＃，Java，Python，PHP，Go) 和运行时 (例如 .NET 和 Unity) 扩展的生态系统。由微软出品，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>
<h2 id="特点"> 特点</h2>
<ul>
<li>
<p>智能代码补全</p>
<p>使用 IntelliSense 可以更智能地编写代码、变量，方法和导入模块的完成。</p>
</li>
<li>
<p>热门扩展</p>
<p>启用其他语言，主题，调试器，命令等。</p>
</li>
</ul>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./install.html">安装</a></p>
</li>
<li>
<p><a href="./get-started.html">快速上手</a></p>
</li>
<li>
<p><a href="./guide/">指南</a></p>
<ul>
<li>
<p><a href="./guide/basic.html">基础常识</a></p>
</li>
<li>
<p><a href="./guide/customization.html">个性化介绍</a></p>
</li>
<li>
<p><a href="./guide/extension.html">扩展介绍</a></p>
</li>
<li>
<p><a href="./guide/file.html">文件介绍</a></p>
</li>
<li>
<p><a href="./guide/edit.html">编辑技巧</a></p>
</li>
<li>
<p><a href="./guide/intellisense.html">智能补全</a></p>
</li>
<li>
<p><a href="./guide/git.html">Git 支持</a></p>
</li>
<li>
<p><a href="./guide/debug.html">调试介绍</a></p>
</li>
<li>
<p><a href="./guide/task.html">任务介绍</a></p>
</li>
<li>
<p><a href="./guide/command.html">命令行介绍</a></p>
</li>
</ul>
</li>
<li>
<p><a href="./ui.html">VS Code 用户界面</a></p>
</li>
<li>
<p><a href="./shortcut-key.html">VS Code 快捷键</a></p>
</li>
<li>
<p><a href="./settings.html">VS Code 设置</a></p>
</li>
<li>
<p><a href="./extension.html">VS Code 推荐扩展</a></p>
</li>
</ul>
<h2 id="官方文档"> 官方文档</h2>
<ul>
<li>
<p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">VS Code 官网</a></p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs/getstarted/introvideos" target="_blank" rel="noopener noreferrer">官方视频</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-12-07T13:06:21.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">配置 VS Code</title>
    <id>https://list-jiang.github.io/software/vscode/settings/</id>
    <link href="https://list-jiang.github.io/software/vscode/settings/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>这是 Mr.Hope 个人使用的 VS Code 设置，部分设置是<a href="./extension.html">这里</a>的插件配置</p>
<p>将下面内容拷贝至 setting.json 以更改 VS Code 设置</p>
<div><pre><code><span>{</span>
  <span>// 编辑器配置</span>
  <span>"editor.cursorSmoothCaretAnimation"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.detectIndentation"</span><span>:</span> <span>false</span><span>,</span>
  <span>"editor.fontFamily"</span><span>:</span> <span>"'Fira Code', Consolas, 'Courier New', monospace"</span><span>,</span>
  <span>"editor.fontLigatures"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.formatOnSave"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.formatOnPaste"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.mouseWheelZoom"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.rulers"</span><span>:</span> <span>[</span><span>80</span><span>]</span><span>,</span>
  <span>"editor.quickSuggestions"</span><span>:</span> <span>{</span>
    <span>"comments"</span><span>:</span> <span>true</span><span>,</span>
    <span>"strings"</span><span>:</span> <span>true</span><span>,</span>
    <span>"other"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"editor.renderControlCharacters"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.renderWhitespace"</span><span>:</span> <span>"boundary"</span><span>,</span>
  <span>"editor.smoothScrolling"</span><span>:</span> <span>true</span><span>,</span>
  <span>"editor.suggestSelection"</span><span>:</span> <span>"first"</span><span>,</span>
  <span>"editor.tabSize"</span><span>:</span> <span>2</span><span>,</span>
  <span>"editor.wordWrap"</span><span>:</span> <span>"on"</span><span>,</span>
  <span>// emmet 包含 wxml 视为 html</span>
  <span>"emmet.includeLanguages"</span><span>:</span> <span>{</span>
    <span>"wxml"</span><span>:</span> <span>"html"</span> <span>// 为 wxml 开启 HTML emmet 支持</span>
  <span>}</span><span>,</span>
  <span>"emmet.variables"</span><span>:</span> <span>{</span>
    <span>"lang"</span><span>:</span> <span>"zh-CN"</span><span>,</span>
    <span>"charset"</span><span>:</span> <span>"UTF-8"</span>
  <span>}</span><span>,</span>
  <span>// 文件相关</span>
  <span>"explorer.confirmDelete"</span><span>:</span> <span>false</span><span>,</span>
  <span>"explorer.confirmDragAndDrop"</span><span>:</span> <span>false</span><span>,</span>
  <span>"files.associations"</span><span>:</span> <span>{</span>
    <span>"*.cjson"</span><span>:</span> <span>"jsonc"</span><span>,</span>
    <span>"*.wxss"</span><span>:</span> <span>"css"</span><span>,</span>
    <span>"*.wxs"</span><span>:</span> <span>"javascript"</span><span>,</span>
    <span>"*.wxml"</span><span>:</span> <span>"wxml"</span>
  <span>}</span><span>,</span>
  <span>"files.autoSave"</span><span>:</span> <span>"off"</span><span>,</span>
  <span>"files.eol"</span><span>:</span> <span>"\n"</span><span>,</span>
  <span>"files.exclude"</span><span>:</span> <span>{</span>
    <span>"**/.classpath"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.project"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.settings"</span><span>:</span> <span>true</span><span>,</span>
    <span>"**/.factorypath"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"files.maxMemoryForLargeFilesMB"</span><span>:</span> <span>4096</span><span>,</span>
  <span>// 编辑器窗口设置</span>
  <span>"window.closeWhenEmpty"</span><span>:</span> <span>true</span><span>,</span>
  <span>"window.dialogStyle"</span><span>:</span> <span>"custom"</span><span>,</span>
  <span>"window.newWindowDimensions"</span><span>:</span> <span>"inherit"</span><span>,</span>
  <span>"breadcrumbs.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 工作台设置</span>
  <span>"workbench.activityBar.visible"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.colorTheme"</span><span>:</span> <span>"One Dark Pro"</span><span>,</span>
  <span>"workbench.commandPalette.preserveInput"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.enableExperiments"</span><span>:</span> <span>false</span><span>,</span>
  <span>"workbench.editor.scrollToSwitchTabs"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.editor.untitled.experimentalLanguageDetection"</span><span>:</span> <span>true</span><span>,</span>
  <span>"workbench.iconTheme"</span><span>:</span> <span>"material-icon-theme"</span><span>,</span>
  <span>"workbench.startupEditor"</span><span>:</span> <span>"none"</span><span>,</span>
  <span>"material-icon-theme.folders.associations"</span><span>:</span> <span>{</span>
    <span>"global-components"</span><span>:</span> <span>"Global"</span><span>,</span>
    <span>"node"</span><span>:</span> <span>"Node"</span><span>,</span>
    <span>"about"</span><span>:</span> <span>"Command"</span><span>,</span>
    <span>"intro"</span><span>:</span> <span>"Command"</span><span>,</span>
    <span>"file"</span><span>:</span> <span>"Public"</span><span>,</span>
    <span>"github"</span><span>:</span> <span>"GitHub"</span><span>,</span>
    <span>"composables"</span><span>:</span> <span>"Include"</span><span>,</span>
    <span>"service-worker"</span><span>:</span> <span>"config"</span><span>,</span>
    <span>"store"</span><span>:</span> <span>"Vuex-store"</span><span>,</span>
    <span>"demo"</span><span>:</span> <span>"Examples"</span><span>,</span>
    <span>"basic"</span><span>:</span> <span>"Helper"</span><span>,</span>
    <span>"vuex"</span><span>:</span> <span>"Vuex-store"</span><span>,</span>
    <span>"module"</span><span>:</span> <span>"plugin"</span><span>,</span>
    <span>"router"</span><span>:</span> <span>"Routes"</span><span>,</span>
    <span>".vuepress"</span><span>:</span> <span>"vue"</span><span>,</span>
    <span>"vuepress"</span><span>:</span> <span>"vue"</span><span>,</span>
    <span>"node-js"</span><span>:</span> <span>"Node"</span><span>,</span>
    <span>"react"</span><span>:</span> <span>"React-components"</span><span>,</span>
    <span>"workflows"</span><span>:</span> <span>"Ci"</span><span>,</span>
    <span>"guide"</span><span>:</span> <span>"content"</span><span>,</span>
    <span>"git"</span><span>:</span> <span>"Git"</span><span>,</span>
    <span>"mysql"</span><span>:</span> <span>"DataBase"</span><span>,</span>
    <span>"software"</span><span>:</span> <span>"App"</span><span>,</span>
    <span>"tool"</span><span>:</span> <span>"Tools"</span><span>,</span>
    <span>"vscode"</span><span>:</span> <span>"VSCode"</span><span>,</span>
    <span>"en"</span><span>:</span> <span>"I18n"</span><span>,</span>
    <span>"zh"</span><span>:</span> <span>"I18n"</span><span>,</span>
    <span>"types"</span><span>:</span> <span>"typescript"</span>
  <span>}</span><span>,</span>
  <span>// 提示设置</span>
  <span>"vsintellicode.modify.editor.suggestSelection"</span><span>:</span> <span>"automaticallyOverrodeDefaultValue"</span><span>,</span>
  <span>"problems.showCurrentInStatus"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 在线服务设置</span>
  <span>"telemetry.enableCrashReporter"</span><span>:</span> <span>false</span><span>,</span>
  <span>"telemetry.enableTelemetry"</span><span>:</span> <span>false</span><span>,</span>
  <span>// 终端设置</span>
  <span>"terminal.integrated.confirmOnExit"</span><span>:</span> <span>"hasChildProcesses"</span><span>,</span>
  <span>"terminal.integrated.copyOnSelection"</span><span>:</span> <span>true</span><span>,</span>
  <span>"terminal.integrated.enableBell"</span><span>:</span> <span>true</span><span>,</span>
  <span>"terminal.integrated.defaultProfile.windows"</span><span>:</span> <span>"PowerShell"</span><span>,</span>
  <span>"terminal.integrated.defaultProfile.linux"</span><span>:</span> <span>"/bin/bash"</span><span>,</span>
  <span>"terminal.integrated.profiles.windows"</span><span>:</span> <span>{</span>
    <span>"PowerShell"</span><span>:</span> <span>{</span>
      <span>"source"</span><span>:</span> <span>"PowerShell"</span><span>,</span>
      <span>"overrideName"</span><span>:</span> <span>true</span><span>,</span>
      <span>"icon"</span><span>:</span> <span>"terminal-powershell"</span><span>,</span>
      <span>"args"</span><span>:</span> <span>[</span><span>"-NoLogo"</span><span>]</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>"terminal.integrated.tabs.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"terminal.external.linuxExec"</span><span>:</span> <span>"bash"</span><span>,</span>
  <span>// git</span>
  <span>"diffEditor.ignoreTrimWhitespace"</span><span>:</span> <span>false</span><span>,</span>
  <span>"diffEditor.renderSideBySide"</span><span>:</span> <span>true</span><span>,</span>
  <span>"git.autofetch"</span><span>:</span> <span>true</span><span>,</span>
  <span>"git.confirmSync"</span><span>:</span> <span>false</span><span>,</span>
  <span>"git.enableSmartCommit"</span><span>:</span> <span>true</span><span>,</span>
  <span>"merge-conflict.autoNavigateNextConflict.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>// npm 设置</span>
  <span>"npm.enableRunFromFolder"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm.scriptExplorerAction"</span><span>:</span> <span>"run"</span><span>,</span>
  <span>"npm-intellisense.importQuotes"</span><span>:</span> <span>"\""</span><span>,</span>
  <span>"npm-intellisense.packageSubfoldersIntellisense"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm-intellisense.scanDevDependencies"</span><span>:</span> <span>true</span><span>,</span>
  <span>"npm-intellisense.showBuildInLibs"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 远程连接</span>
  <span>"remote.SSH.remotePlatform"</span><span>:</span> <span>{</span>
    <span>"codeserver"</span><span>:</span> <span>"linux"</span>
  <span>}</span><span>,</span>
  <span>// 特定格式文件设置</span>
  <span>"[cpp]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"ms-vscode.cpptools"</span>
  <span>}</span><span>,</span>
  <span>"[dart]"</span><span>:</span> <span>{</span>
    <span>"editor.formatOnType"</span><span>:</span> <span>true</span><span>,</span>
    <span>"editor.selectionHighlight"</span><span>:</span> <span>false</span><span>,</span>
    <span>"editor.suggest.snippetsPreventQuickSuggestions"</span><span>:</span> <span>true</span><span>,</span>
    <span>"editor.suggestSelection"</span><span>:</span> <span>"recentlyUsed"</span><span>,</span>
    <span>"editor.tabCompletion"</span><span>:</span> <span>"on"</span><span>,</span>
    <span>"editor.wordBasedSuggestions"</span><span>:</span> <span>true</span>
  <span>}</span><span>,</span>
  <span>"[html]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[javascript]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[json]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[jsonc]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[matlab]"</span><span>:</span> <span>{</span>
    <span>"files.encoding"</span><span>:</span> <span>"gb2312"</span>
  <span>}</span><span>,</span>
  <span>"[markdown]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[svelte]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"svelte.svelte-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[typescript]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[typescriptreact]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[vue]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"octref.vetur"</span>
  <span>}</span><span>,</span>
  <span>"[xml]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>
  <span>"[yaml]"</span><span>:</span> <span>{</span>
    <span>"editor.defaultFormatter"</span><span>:</span> <span>"esbenp.prettier-vscode"</span>
  <span>}</span><span>,</span>

  <span>// typescript 配置</span>
  <span>"javascript.format.semicolons"</span><span>:</span> <span>"insert"</span><span>,</span>
  <span>"javascript.referencesCodeLens.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.suggest.completeFunctionCalls"</span><span>:</span> <span>true</span><span>,</span>
  <span>"javascript.preferences.quoteStyle"</span><span>:</span> <span>"double"</span><span>,</span>
  <span>"javascript.updateImportsOnFileMove.enabled"</span><span>:</span> <span>"always"</span><span>,</span>
  <span>"typescript.locale"</span><span>:</span> <span>"zh-CN"</span><span>,</span>
  <span>"typescript.enablePromptUseWorkspaceTsdk"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.format.semicolons"</span><span>:</span> <span>"insert"</span><span>,</span>
  <span>"typescript.preferences.quoteStyle"</span><span>:</span> <span>"double"</span><span>,</span>
  <span>"typescript.referencesCodeLens.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.suggest.completeFunctionCalls"</span><span>:</span> <span>true</span><span>,</span>
  <span>"typescript.updateImportsOnFileMove.enabled"</span><span>:</span> <span>"always"</span><span>,</span>
  <span>// php 设置</span>
  <span>"php.validate.enable"</span><span>:</span> <span>true</span><span>,</span>
  <span>"php.validate.run"</span><span>:</span> <span>"onType"</span><span>,</span>
  <span>// c++ 设置</span>
  <span>"C_Cpp.default.cppStandard"</span><span>:</span> <span>"c++20"</span><span>,</span>
  <span>"C_Cpp.default.includePath"</span><span>:</span> <span>[</span>
    <span>"C:/Program Files/mingw-w64/lib/gcc/x86_64-w64-mingw32/8.1.0/include"</span><span>,</span>
    <span>"C:/Program Files/mingw-w64/lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed"</span><span>,</span>
    <span>"C:/Program Files/mingw-w64/x86_64-w64-mingw32/include"</span>
  <span>]</span><span>,</span>
  <span>"C_Cpp.clang_format_fallbackStyle"</span><span>:</span> <span>"Google"</span><span>,</span>
  <span>// dart</span>
  <span>"dart.debugExternalLibraries"</span><span>:</span> <span>false</span><span>,</span>
  <span>"dart.debugSdkLibraries"</span><span>:</span> <span>false</span><span>,</span>
  <span>"dart.previewLsp"</span><span>:</span> <span>true</span><span>,</span>
  <span>"dart.openDevTools"</span><span>:</span> <span>"flutter"</span><span>,</span>
  <span>// java</span>
  <span>"java.home"</span><span>:</span> <span>"C:/Program Files/Java/jdk-16.0.1"</span><span>,</span>
  <span>"java.semanticHighlighting.enabled"</span><span>:</span> <span>true</span><span>,</span>
  <span>// python</span>
  <span>"python.pythonPath"</span><span>:</span> <span>"C:/Users/zhang/AppData/Local/Programs/Python/Python39/python.exe"</span><span>,</span>
  <span>"python.languageServer"</span><span>:</span> <span>"Pylance"</span><span>,</span>
  <span>// css颜色提示配置</span>
  <span>"colorInfo.fields"</span><span>:</span> <span>[</span><span>"hex"</span><span>,</span> <span>"rgb"</span><span>,</span> <span>"alpha"</span><span>,</span> <span>"css-color-name"</span><span>,</span> <span>"preview"</span><span>]</span><span>,</span>
  <span>"colorInfo.languages"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"vue"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"css"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"sass"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"scss"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>"selector"</span><span>:</span> <span>"less"</span><span>,</span>
      <span>"colors"</span><span>:</span> <span>"css"</span>
    <span>}</span>
  <span>]</span><span>,</span>
  <span>// eslint</span>
  <span>"eslint.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>
  <span>"eslint.validate"</span><span>:</span> <span>[</span>
    <span>"javascript"</span><span>,</span>
    <span>"javascriptreact"</span><span>,</span>
    <span>"vue"</span><span>,</span>
    <span>"typescript"</span><span>,</span>
    <span>"typescriptreact"</span>
  <span>]</span><span>,</span>
  <span>// Git Lens 设置</span>
  <span>"gitlens.gitCommands.closeOnFocusOut"</span><span>:</span> <span>true</span><span>,</span>
  <span>"gitlens.views.repositories.branches.layout"</span><span>:</span> <span>"list"</span><span>,</span>
  <span>// live server</span>
  <span>"liveServer.settings.donotShowInfoMsg"</span><span>:</span> <span>true</span><span>,</span>
  <span>// markdown 设置</span>
  <span>"markdown.extension.orderedList.marker"</span><span>:</span> <span>"one"</span><span>,</span>
  <span>"markdown.extension.print.imgToBase64"</span><span>:</span> <span>true</span><span>,</span>
  <span>// markdownlint 设置</span>
  <span>"markdownlint.config"</span><span>:</span> <span>{</span>
    <span>"default"</span><span>:</span> <span>true</span><span>,</span>
    <span>"MD003"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"atx"</span>
    <span>}</span><span>,</span>
    <span>"MD004"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"dash"</span>
    <span>}</span><span>,</span>
    <span>"MD013"</span><span>:</span> <span>false</span><span>,</span>
    <span>"MD024"</span><span>:</span> <span>{</span>
      <span>"allow_different_nesting"</span><span>:</span> <span>true</span>
    <span>}</span><span>,</span>
    <span>"MD035"</span><span>:</span> <span>{</span>
      <span>"style"</span><span>:</span> <span>"---"</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>"markdown-pdf.executablePath"</span><span>:</span> <span>"C:/Users/zhang/AppData/Local/Google/Chrome/Application/chrome.exe"</span><span>,</span>
  <span>// vetur 设置</span>
  <span>"vetur.completion.tagCasing"</span><span>:</span> <span>"initial"</span><span>,</span>
  <span>"vetur.validation.templateProps"</span><span>:</span> <span>true</span><span>,</span>
  <span>"vetur.useWorkspaceDependencies"</span><span>:</span> <span>true</span><span>,</span>
  <span>// stylus 设置</span>
  <span>"stylusSupremacy.insertColons"</span><span>:</span> <span>false</span><span>,</span>
  <span>"stylusSupremacy.insertSemicolons"</span><span>:</span> <span>false</span><span>,</span>
  <span>"stylusSupremacy.insertBraces"</span><span>:</span> <span>false</span><span>,</span>
  <span>// XML工具设置</span>
  <span>"xmlTools.enforcePrettySelfClosingTagOnFormat"</span><span>:</span> <span>true</span><span>,</span>
  <span>"xmlTools.removeCommentsOnMinify"</span><span>:</span> <span>true</span><span>,</span>
  <span>// 微信小程序</span>
  <span>"minapp-vscode.disableAutoConfig"</span><span>:</span> <span>true</span><span>,</span>
  <span>"minapp-vscode.wxmlFormatter"</span><span>:</span> <span>"prettier"</span><span>,</span>
  <span>"minapp-vscode.prettier"</span><span>:</span> <span>{</span>
    <span>"parser"</span><span>:</span> <span>"html"</span><span>,</span>
    <span>"printWidth"</span><span>:</span> <span>80</span>
  <span>}</span><span>,</span>
  <span>// liveshare 设置</span>
  <span>"liveshare.audio.joinCallBehavior"</span><span>:</span> <span>"accept"</span><span>,</span>
  <span>// 项目管理器</span>
  <span>"projectManager.sortList"</span><span>:</span> <span>"Saved"</span><span>,</span>
  <span>"projectManager.ignoreProjectsWithinProjects"</span><span>:</span> <span>true</span><span>,</span>
  <span>"projectManager.any.ignoredFolders"</span><span>:</span> <span>[</span>
    <span>"dist"</span><span>,</span>
    <span>"node_modules"</span><span>,</span>
    <span>"out"</span><span>,</span>
    <span>"typings"</span><span>,</span>
    <span>"test"</span><span>,</span>
    <span>"__tests__"</span>
  <span>]</span><span>,</span>
  <span>// TODO Highlight 配置</span>
  <span>"todohighlight.keywords"</span><span>:</span> <span>[</span><span>"WARNING: "</span><span>]</span><span>,</span>
  <span>// leetcode</span>
  <span>"leetcode.hint.commentDescription"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.commandShortcut"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.configWebviewMarkdown"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.hint.setDefaultLanguage"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.enableStatusBar"</span><span>:</span> <span>false</span><span>,</span>
  <span>"leetcode.endpoint"</span><span>:</span> <span>"leetcode"</span><span>,</span>
  <span>"leetcode.showDescription"</span><span>:</span> <span>"In Webview"</span><span>,</span>
  <span>"leetcode.workspaceFolder"</span><span>:</span> <span>"C:/Users/zhang/.leetcode"</span><span>,</span>
  <span>// stylelint 设置</span>
  <span>"stylelint.packageManager"</span><span>:</span> <span>"yarn"</span><span>,</span>
  <span>"stylelint.validate"</span><span>:</span> <span>[</span>
    <span>"css"</span><span>,</span>
    <span>"html"</span><span>,</span>
    <span>"javascript"</span><span>,</span>
    <span>"javascriptreact"</span><span>,</span>
    <span>"less"</span><span>,</span>
    <span>"markdown"</span><span>,</span>
    <span>"postcss"</span><span>,</span>
    <span>"sass"</span><span>,</span>
    <span>"scss"</span><span>,</span>
    <span>"source.css.styled"</span><span>,</span>
    <span>"source.markdown.math"</span><span>,</span>
    <span>"styled-css"</span><span>,</span>
    <span>"sugarss"</span><span>,</span>
    <span>"svelte"</span><span>,</span>
    <span>"typescript"</span><span>,</span>
    <span>"typescriptreact"</span><span>,</span>
    <span>// "vue",</span>
    <span>"vue-html"</span><span>,</span>
    <span>"vue-postcss"</span><span>,</span>
    <span>"xml"</span><span>,</span>
    <span>"xsl"</span><span>,</span>
    <span>"wxss"</span>
  <span>]</span><span>,</span>
  <span>// Java</span>
  <span>"redhat.telemetry.enabled"</span><span>:</span> <span>false</span><span>,</span>
  <span>// matlab</span>
  <span>"matlab.matlabpath"</span><span>:</span> <span>"C:/Program Files/Polyspace/R2021a/bin/win64/matlab.exe"</span><span>,</span>
  <span>"matlab.mlintpath"</span><span>:</span> <span>"C:/Program Files/Polyspace/R2021a/bin/win64/mlint.exe"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br></div></div><p>用鼠标在对应属性值上悬停时，VS Code 会自动给出属性的说明。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">VS Code 的简单介绍</title>
    <id>https://list-jiang.github.io/software/vscode/simple/</id>
    <link href="https://list-jiang.github.io/software/vscode/simple/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介"> 简介</h2>
<p>这是一款微软的代码编辑器，因其开源，可扩展和众多插件成为全球最受欢迎的代码编辑器。</p>
<h2 id="vs-code-的安装"> VS Code 的安装</h2>
<p>在<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener noreferrer">官网下载地址</a>下载最新版 Win64User 安装包，双击安装包打开同意用户协议，一直下一步即可。</p>
<p>在 VS Code 初次启动后，若未提前安装 Git 可能会提示未找到 Git 软件，忽略即可；若提示安装简体中文扩展，请点击安装以保证界面语言为简体中文。</p>
<h2 id="关于-vs-code-界面"> 关于 VS Code 界面</h2>
<p>VS Code 上方有一排菜单栏，其中有大量的快捷操作，对应的组合键会标于快捷操作旁。如果不能记忆快捷键可以到最上方的菜单栏处查看。</p>
<p>最左侧是选项卡切换，从上至下依次是、搜索、源代码管理、调试和扩展。</p>
<p>最下方的一条是状态栏。从左到右依次是分支名称、同步状态、错误和警告个数、光标位置、缩进大小、编码格式、行尾序列、文件格式、反馈(没用)和通知。</p>
<h3 id="资源管理器"> 资源管理器</h3>
<p>资源管理器是最常使用的界面，快捷键为 <code>Ctrl + Shift + E</code>。</p>
<h2 id="用-vs-code-打开文件和文件夹"> 用 VS Code 打开文件和文件夹</h2>
<p>VS Code 支持打开文件和文件夹。</p>
<p>打开文件时请在文件图标上单击右键—选择使用 VS Code 打开；</p>
<p>打开文件夹请双击打开文件夹，在空白处单击右键——选择用 VS Code 打开。</p>
<h2 id="vs-code-快捷键"> VS Code 快捷键</h2>
<h3 id="快速选中"> 快速选中</h3>
<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>
<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>
<h3 id="移动文字"> 移动文字</h3>
<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>
<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>
<h3 id="复制文字"> 复制文字</h3>
<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>
<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>
<h3 id="格式化代码"> 格式化代码</h3>
<p><code>Alt + shift + F</code></p>
<h3 id="其他-windows-快捷键"> 其他 Windows 快捷键</h3>
<p><code>Ctrl + X</code>: 剪切；</p>
<p><code>Ctrl + C</code>: 复制；</p>
<p><code>Ctrl + V</code>: 粘贴；</p>
<p><code>Ctrl + A</code>: 全选；</p>
<p><code>Ctrl + Z</code>: 撤销；</p>
<p><code>Ctrl + Y</code>: 恢复；</p>
<p><code>Ctrl + F</code>: 查找；</p>
<p><code>Ctrl + H</code>: 替换。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">用户界面</title>
    <id>https://list-jiang.github.io/software/vscode/ui/</id>
    <link href="https://list-jiang.github.io/software/vscode/ui/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>本质上，Visual Studio Code 是代码编辑器。像许多其他代码编辑器一样，VS Code 在左边采用通用的用户界面和资源管理器布局，以显示您有权访问的所有文件和文件夹，而在右边的编辑器则显示您已打开文件的内容。</p>
<h2 id="基本布局"> 基本布局</h2>
<p>VS Code 具有简单直观的布局，可最大程度地为编辑器提供空间，同时为浏览和访问文件夹或项目的整个上下文留出足够的空间。用户界面分为五个区域:</p>
<ul>
<li><strong>编辑器</strong>: 用于编辑文件的主要区域。您可以在垂直和水平方向上并排打开任意多个编辑器。</li>
<li><strong>侧边栏</strong>: 包含诸如资源管理器之类的不同视图，可在您处理项目时为您提供帮助。</li>
<li><strong>状态栏</strong>: 有关打开的项目和您编辑的文件的信息。</li>
<li><strong>任务栏</strong>: 位于最左侧，可让您在视图之间进行切换，并为您提供特定于上下文的其他指示符，例如启用 Git 时传出更改的数量。</li>
<li><strong>面板</strong>: 您可以在编辑器区域下方显示不同的面板，以获取输出或调试信息，错误和警告或集成终端。面板也可以向右移动以获得更多垂直空间。</li>
</ul>
<p>每次启动 VS Code 时，它的打开状态与上次关闭时的状态相同。文件夹，布局和打开的文件将保留。</p>
<p>在每个编辑器中打开的文件都显示在编辑器区域顶部，带有选项卡式标题(Tab)。要了解有关选项卡式标题的更多信息，请参见下面的  部分。</p>
<div><p>提示</p>
<p>您可以将侧栏移至右侧(<strong>查看 &gt; 外观 &gt; 向右移动侧边栏</strong>)或切换其可见性(<code>Ctrl + B</code>)。</p>
</div>
<h2 id="并排编辑"> 并排编辑</h2>
<p>您可以在垂直和水平方向上并排打开任意多个编辑器。如果您已经打开了一个编辑器，则可以通过多种方式在现有编辑器的一侧打开另一个编辑器:</p>
<ul>
<li><code>Alt</code>: 在资源管理器中单击一个文件。</li>
<li><code>Ctrl + \</code>: 将活动编辑器一分为二。</li>
<li>从文件的资源管理器上下文菜单中选择 <strong>在侧边打开</strong>(<code>Ctrl + Enter</code>)。</li>
<li>单击编辑器右上方的 <strong>向右拆分编辑器</strong> 按钮。</li>
<li>将文件拖放到编辑器区域的任何一侧。</li>
<li>在 <strong>快速打开</strong> (<code>Ctrl + P</code>)文件列表中，按 <code>Ctrl + Enter</code>(macOS: <code>Cmd + Enter</code>)。</li>
</ul>
<p>每当您打开另一个文件时，处于活动状态的编辑器都会显示该文件的内容。因此，如果您有两个并排的编辑器，并且想要将文件打开到右侧编辑器中，请在打开文件之前，确保该编辑器处于活动状态(通过在其中单击)。</p>
<p>默认情况下，编辑器将打开到活动窗口的右侧。您可以通过设置更改此行为，<code>workbench.editor.openSideBySideDirection</code> 并配置为在活动编辑器的底部打开新编辑器。</p>
<p>当您有一个以上的编辑器打开您可以按住 Ctrl 键的同时按 1、2、3 在它们之间迅速切换。</p>
<div><p>提示</p>
<p>您可以调整编辑器的大小并重新排序。拖放编辑器标题区域以重新定位编辑器或调整其大小。</p>
</div>
<h2 id="小地图"> 小地图</h2>
<p>Minimap(代码大纲)为您提供了源代码的高级概述，这对于快速导航和理解代码很有用。文件的小地图显示在编辑器的右侧。您可以单击或拖动阴影区域以快速跳转到文件的不同部分。</p>
<p><img src="./assets/minimap.png" alt="小地图" loading="lazy"></p>
<div><p>提示</p>
<p>您可以通过分别设置 <code>&quot;editor.minimap.side&quot;: &quot;left&quot;</code> 或 <code>&quot;editor.minimap.enabled&quot;: false</code> 在用户或工作空间设置中将小地图移到左侧或完全禁用它。</p>
</div>
<h3 id="缩进指南"> 缩进指南</h3>
<p><img src="./assets/indent-raindow.png" alt="缩进提示" loading="lazy"></p>
<p>上图还显示了压痕指南(垂直线)，可帮助您快速查看匹配的压痕级别。如果您要禁用缩进指南，则可以 <code>&quot;editor.renderIndentGuides&quot;: false</code> 在用户或工作空间设置中进行设置。</p>
<div><p>提示</p>
<p>请安装 <strong>Bracket Pair Colorizer 2</strong> 扩展来启用彩虹缩进</p>
</div>
<h2 id="导航痕迹"> 导航痕迹</h2>
<p>编辑器在其内容上方有一个导航栏，称为 <strong>导航痕迹</strong>。它显示当前位置，并允许您在文件夹，文件和符号之间快速导航。</p>
<p><img src="./assets/breadcrumb.png" alt="导航痕迹" loading="lazy"></p>
<p>导航痕迹始终显示文件路径，如果当前文件类型支持符号的语言，则符号路径直至光标位置。您可以使用 <strong>查看 &gt; 显示导航痕迹</strong> 切换命令禁用导航痕迹。有关导航痕迹功能的更多信息，例如如何自定义其外观，请参见 <a href="https://code.visualstudio.com/docs/editor/editingevolved#_breadcrumbs" target="_blank" rel="noopener noreferrer">导航痕迹</a> 部分。</p>
<h2 id="资源管理器"> 资源管理器</h2>
<p>资源管理器用于浏览，打开和管理项目中的所有文件和文件夹。VS Code 基于文件和文件夹-您可以直接在 VS Code 中打开文件或文件夹并开始使用。</p>
<p>在 VS Code 中打开文件夹后，该文件夹的内容将显示在资源管理器中。您可以从这里做很多事情:</p>
<ul>
<li>创建，删除和重命名文件和文件夹。</li>
<li>通过拖放移动文件和文件夹。</li>
<li>使用上下文菜单浏览所有选项。</li>
</ul>
<div><p>提示</p>
<p>您可以从 VS Code 外部将文件拖放到资源管理器中以进行复制(如果资源管理器为空，则 VS Code 将打开它们)</p>
</div>
<p>VS Code 与您可能会使用的其他工具(特别是命令行工具)配合得很好。如果要在当前已在 VS Code 中打开的文件夹的上下文中运行命令行工具，请右键单击该文件夹，然后选择在命令提示符下打开(或在 macOS 或 Linux 上在终端中打开)。</p>
<p>您还可以通过右键单击本机资源管理器中的文件或文件夹，然后选择 <strong>在文件资源管理器中显示</strong> 来导航到文件或文件夹的位置。</p>
<div><p>提示</p>
<p>键入 <code>Ctrl + P</code>(快速打开)可按文件名快速搜索和打开文件。</p>
</div>
<p>默认情况下，VS Code 从资源管理器中排除某些文件夹(例如 .git)。使用 <code>files.exclude</code> 设置可配置用于从资源管理器隐藏文件和文件夹的规则。</p>
<div><p>提示</p>
<p>这对于隐藏派生的资源文件非常有用，例如 Unity 中的 <code>*.meta</code> 、TypeScript 项目中的 <code>*.js</code>。为了使 Unity 排除 <code>*.cs.meta</code> 文件，要选择的模式是: <code>&quot;**/*.cs.meta&quot;: true</code>。对于 TypeScript，可以使用以下命令排除为 TypeScript 文件生成的 JavaScript: <code>&quot;**/*.js&quot;: {&quot;when&quot;: &quot;$(basename).ts&quot;}</code>。</p>
</div>
<h3 id="多选"> 多选</h3>
<p>您可以在 <strong>文件资源管理器</strong> 和 <strong>打开的编辑器</strong> 视图中选择多个文件，以对多个项目运行动作( <strong>删除</strong>，<strong>拖放</strong>，<strong>在侧边打开</strong>)。使用 Ctrl / Cmd 键和单击选择单个文件，使用 <code>Shift + click</code> 选择范围。如果选择两个项目，则现在可以使用上下文菜单 <strong>将已选项进行比较</strong> 来快速比较两个文件。</p>
<h3 id="过滤文档树"> 过滤文档树</h3>
<p>您可以在文件资源管理器中键入以过滤当前可见的文件。以 <strong>文件资源管理器</strong> 为重点，开始键入要匹配的文件名的一部分。您将在文件资源管理器的右上方看到一个过滤器框，其中显示了您到目前为止所键入的内容，并且匹配的文件名将突出显示。当您按下光标键上下移动文件列表时，它将在匹配的文件或文件夹之间跳转。</p>
<p>将鼠标悬停在过滤器框上并选择 <strong>启用输入时筛选</strong> 将仅显示匹配的文件/文件夹。使用 <strong>X</strong> 清除按钮清除过滤器。</p>
<p><img src="./assets/filter-files.png" alt="在文件资源管理器中过滤文件" loading="lazy"></p>
<h3 id="大纲视图"> 大纲视图</h3>
<p>大纲视图是文件资源管理器底部的单独部分。展开后，它将显示当前活动的编辑器的符号树。</p>
<p><img src="./assets/outline-view.png" alt="大纲视图" loading="lazy"></p>
<p>大纲视图具有不同的 <strong>排序依据</strong> 模式，可选的光标跟踪，并支持通常的打开手势。它还包括一个输入框，可在您键入时查找或过滤符号。错误和警告也显示在 <strong>大纲</strong> 视图中，使您可以快速查看问题的位置。</p>
<p>该视图依赖于已安装的扩展针对不同文件类型计算出的信息来显示符号。例如，内置的 Markdown 支持会返回 Markdown 标题层次结构。</p>
<p>有几种 <strong>大纲</strong> 视图设置，可用于启用/禁用图标以及控制错误和警告显示(默认情况下全部启用):</p>
<ul>
<li><code>outline.icons</code>: 切换带有图标的渲染轮廓元素。</li>
<li><code>outline.problems.enabled</code>: 在大纲元素上显示错误和警告。</li>
<li><code>outline.problems.badges</code>: 切换使用徽章的错误和警告。</li>
<li><code>outline.problems.colors</code>: 切换颜色使用错误和警告。</li>
</ul>
<h2 id="打开的编辑器"> 打开的编辑器</h2>
<p>在资源管理器的顶部是一个标记为 <strong>打开的编辑器</strong> 的视图。这是活动文件或预览的列表。这些是您以前使用 VS Code 打开的文件。例如，如果您执行以下操作，文件将在 <strong>打开的编辑器</strong> 视图中列出:</p>
<ul>
<li>更改文件。</li>
<li>双击文件的标题。</li>
<li>在资源管理器中双击一个文件。</li>
<li>打开一个不属于当前文件夹的文件。</li>
</ul>
<p>只需在 <strong>打开的编辑器</strong> 中单击一个项目，该项目就会在 VS Code 中变为活动状态。</p>
<p>完成任务后，可以从 <strong>打开的编辑器</strong> 中单独删除文件，也可以使用 <strong>关闭所有编辑器</strong> 按钮来关闭所有文件。</p>
<h2 id="查看"> 查看</h2>
<p>文件浏览器只是 VS Code 中可用的视图之一。也有以下视图:</p>
<ul>
<li>搜索: 提供全局搜索并在打开的文件夹中进行替换。</li>
<li>源代码控制: VS Code 默认包含 Git 源代码控制。</li>
<li>运行: VS Code 的运行和调试视图显示变量，调用堆栈和断点。</li>
<li>扩展: 在 VS Code 中安装和管理扩展。</li>
<li>自定义视图: 扩展贡献的视图。</li>
</ul>
<div><p>提示</p>
<p>您可以使用 <strong>查看 &gt; 打开视图</strong> 命令打开任何视图。</p>
</div>
<p><img src="./assets/outline-view.png" alt="打开视图" loading="lazy"></p>
<p>您可以在主视图中显示或隐藏视图，也可以通过拖放对其进行重新排序。</p>
<h3 id="任务栏"> 任务栏</h3>
<p>左侧的任务栏使您可以在视图之间快速切换。您还可以通过将视图拖放到任务栏上来重新排列视图，或完全删除视图(右键单击 &gt; 隐藏)。</p>
<p><img src="./assets/activity-bar.png" alt="任务栏" loading="lazy"></p>
<h2 id="命令面板"> 命令面板</h2>
<p>同样可以从键盘访问 VS Code。要知道的最重要的组合键是 <code>Ctrl + Shift + P</code>，它会弹出 Command Palette。从这里，您可以访问 VS Code 的所有功能，包括最常用操作的键盘快捷键。</p>
<p><img src="./assets/command-palette.png" alt="命令面板" loading="lazy"></p>
<p>该命令面板提供了访问很多命令。您可以使用相同的交互式窗口执行编辑器命令，打开文件，搜索符号以及查看文件的快速轮廓。这里有一些提示:</p>
<ul>
<li><code>Ctrl + P</code> 将允许您通过键入文件或符号的名称来导航到任何文件或符号</li>
<li><code>Ctrl + Tab</code> 将使您循环浏览打开的最后一组文件</li>
<li><code>Ctrl + Shift + P</code> 将直接带您进入编辑器命令</li>
<li><code>Ctrl + Shift + O</code> 将让您导航到文件中的特定符号</li>
<li><code>Ctrl + G</code> 将允许您导航到文件中的特定行</li>
</ul>
<p>在输入字段中键入 <code>?</code> 以获取可以从此处执行的可用命令的列表:</p>
<p><img src="./assets/help.png" alt="快速打开帮助" loading="lazy"></p>
<h2 id="配置编辑器"> 配置编辑器</h2>
<p>VS Code 提供了许多用于配置编辑器的选项。在 <strong>查看</strong> 菜单中，您可以隐藏或切换用户界面的各个部分，例如侧栏，状态栏和任务栏。</p>
<h3 id="隐藏菜单栏-windows-和-linux"> 隐藏菜单栏(Windows 和 Linux)</h3>
<p>您可以使用 <strong>查看 &gt; 外观</strong> 命令隐藏 Windows 和 Linux 上的菜单栏。您仍然可以通过按 Alt 键(<code>window.menuBarVisibility</code> 设置)来访问菜单栏。</p>
<h3 id="设置"> 设置</h3>
<p>大多数编辑器配置保留在可以直接修改的设置中。您可以通过用户设置全局设置选项，也可以通过工作区设置针对每个项目/文件夹设置选项。设置值保存在 <code>settings.json</code> 文件中。</p>
<ul>
<li>选择 <strong>文件 &gt; 首选项 &gt; 设置</strong>(或按 <code>Ctrl + ,</code>) 来编辑用户 settings.json 文件。</li>
<li>要编辑工作区的设置，请选择 <strong>工作区设置</strong> 选项卡以编辑工作空间 settings.json 文件。</li>
</ul>
<p>您将在左侧窗口中看到 <strong>VS Code 默认设置</strong>，而 settings.json 在右侧则可编辑。您可以使用顶部的搜索框轻松过滤设置。<code>settings.json</code> 通过单击设置左侧的编辑图标，将设置复制到右侧的可编辑内容。具有固定值集的设置允许您选择一个值作为其编辑图标菜单的一部分。</p>
<p>编辑设置后，键入 <code>Ctrl + S</code> 保存更改。所做的更改将立即生效。</p>
<div><p>提示</p>
<p>工作区设置将覆盖用户设置，对于在团队中共享项目特定的设置很有用。</p>
</div>
<h3 id="禅模式"> 禅模式</h3>
<p>通过 Zen 模式，您可以隐藏除编辑器之外的所有 UI(没有任务栏，状态栏，侧边栏和面板)，然后全屏显示并集中编辑器布局，从而专注于代码。可以使用 <strong>查看</strong> 菜单，<strong>命令面板</strong> 或快捷键 <code>Ctrl + K Z</code> 来切换 Zen 模式。双击 <code>Esc</code> 退出 Zen 模式。可以通过 <code>zenMode.fullScreen</code> 禁用向全屏过渡。禅模式可以通过下面的设置来进一步调整: <code>zenMode.hideStatusBar</code>，<code>zenMode.hideTabs</code>，<code>zenMode.fullScreen</code>，<code>zenMode.restore</code> 和 <code>zenMode.centerLayout</code>。</p>
<h3 id="中心编辑布局"> 中心编辑布局</h3>
<p>居中的编辑器布局使您可以居中对齐编辑器区域。在大型监视器上使用单个编辑器时，这特别有用。您可以使用侧面的窗框调整视图的大小(按住 Alt 键以独立移动窗框)。</p>
<h2 id="选项卡"> 选项卡</h2>
<p>Visual Studio Code 在编辑器上方的标题区域中显示带有选项卡(带选项卡的标题)的打开的项目。</p>
<p>当您打开文件时，将为该文件添加一个新的选项卡。</p>
<p>选项卡使您可以在项目之间快速导航，并且可以拖放选项卡来重新排序它们。</p>
<p>如果打开的项目超出标题区域的容纳范围，则可以使用 <strong>显示打开的编辑器</strong> 命令(可通过 <code>...</code> 更多按钮使用)来显示选项卡式项目的下拉列表。</p>
<h3 id="tab-顺序"> tab 顺序</h3>
<p>默认情况下，新标签页会添加到现有标签页的右侧，但是您可以在设置中使用 <code>workbench.editor.openPositioning</code> 控制新标签页的显示位置。</p>
<p>例如，您可能希望新的选项卡式项目显示在左侧:</p>
<div><pre><code>    <span>"workbench.editor.openPositioning"</span><span>:</span> <span>"left"</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="预览模式"> 预览模式</h2>
<p>在资源管理器中单击或选择一个文件时，该文件以预览模式显示，并重复使用现有的选项卡。如果您正在快速浏览文件并且不希望每个访问的文件都有其自己的选项卡，则此功能很有用。当您开始编辑文件或使用双击从资源管理器中打开文件时，新的选项卡将专用于该文件。</p>
<p>预览模式在选项卡标题中以斜体表示:</p>
<p><img src="./assets/preview-mode.png" alt="预览模式" loading="lazy"></p>
<p>如果您不想使用预览模式而总是创建一个新的选项卡，则可以使用以下设置来控制行为:</p>
<ul>
<li><code>workbench.editor.enablePreview</code>: 全局启用或禁用预览编辑器</li>
<li><code>workbench.editor.enablePreviewFromQuickOpen</code>: 从快速打开中启用或禁用预览编辑器</li>
</ul>
<h2 id="编辑器组"> 编辑器组</h2>
<p>拆分编辑器时(使用 <strong>拆分编辑器</strong> 或 <strong>在侧边打开</strong> 命令)，将创建一个新的编辑器区域，该区域可以容纳一组项目。您可以在垂直和水平方向上并排打开任意多个编辑器区域。</p>
<p>您可以在资源管理器视图顶部的 <strong>打开的编辑器</strong> 部分中清楚地看到这些内容:</p>
<p><img src="./assets/editor-group.png" alt="标签编辑器组" loading="lazy"></p>
<p>您可以在工作台上拖放编辑器组，在组之间移动单个 Tab，然后快速关闭整个组( <strong>全部关闭</strong>)。</p>
<div><p>提示</p>
<p>无论您是否启用了选项卡，VS Code 都会使用编辑器组。如果没有选项卡，则编辑器组是您打开的项目的堆栈，在编辑器窗格中可见最近选择的项目。</p>
</div>
<h2 id="网格编辑器布局"> 网格编辑器布局</h2>
<p>默认情况下，编辑器组以垂直列布局(例如，当您拆分一个编辑器以将其打开到侧面时)。您可以轻松按自己喜欢的任何布局(垂直和水平)排列编辑器组:</p>
<p>为了支持灵活的布局，您可以创建空的编辑器组。默认情况下，关闭编辑器组的最后一个编辑器也会关闭该组本身，但是您可以使用新设置 <code>workbench.editor.closeEmptyGroups: false</code> 更改此行为。</p>
<p>在 <strong>查看 &gt; 编辑器布局</strong> 菜单中有一组预定义的编辑器布局。</p>
<p>默认情况下，打开到一侧的编辑器(例如，通过单击编辑器工具栏的 <strong>向右拆分编辑器</strong> 操作)将打开到活动编辑器的右侧。如果您希望在活动的编辑器下面打开编辑器，请配置新设置 <code>workbench.editor.openSideBySideDirection: down</code>。</p>
<p>有许多键盘命令可用于仅使用键盘来调整编辑器布局，但是如果您更喜欢使用鼠标，则拖放是将编辑器按任何方向划分的快速方法:</p>
<p><img src="./assets/drag-editor.gif" alt="网格编辑器拖放" loading="lazy"></p>
<div><p>提示</p>
<p>如果在将鼠标悬停在工具栏上以拆分编辑器时按住 Alt 键，它将提供拆分为其他方向的功能。这是在右侧或底部拆分的快速方法。</p>
</div>
<h3 id="键盘快捷键"> 键盘快捷键</h3>
<p>这是一些方便的键盘快捷键，可在编辑器和编辑器组之间快速导航。</p>
<ul>
<li><code>Ctrl + PageDown</code>: 转到右侧的编辑器。</li>
<li><code>Ctrl + PageUp</code>: 转到左侧的编辑器。</li>
<li><code>Ctrl + Tab</code>: 打开编辑器组 MRU 列表中的上一个编辑器。</li>
<li><code>Ctrl + 1</code>: 转到最左边的编辑器组。</li>
<li><code>Ctrl + 2</code>: 转到中心编辑器组。</li>
<li><code>Ctrl + 3</code>: 转到最右边的编辑器组。</li>
<li><code>Ctrl + F4</code>: 关闭活动的编辑器。</li>
<li><code>Ctrl + K W</code>: 关闭编辑器组中的所有编辑器。</li>
<li><code>Ctrl + K Ctrl + W</code>: 关闭所有编辑器。</li>
</ul>
<h2 id="窗口管理"> 窗口管理</h2>
<p>VS Code 提供了一些选项来控制在会话之间应如何打开或还原窗口(实例)。</p>
<p><code>window.openFoldersInNewWindow</code> 和 <code>window.openFilesInNewWindow</code> 设置提供在打开新的窗口或者是在最后一个活动的窗口中打开文件或文件夹，可能得值有 <code>default</code>，<code>on</code> 和 <code>off</code>。</p>
<p>如果配置为 <code>default</code>，我们将根据发出打开请求的上下文来对是否重用窗口进行最佳猜测。将此设置为 <code>on</code> 或 <code>off</code> 始终表现相同。例如，如果您认为从 <strong>文件</strong> 菜单中选择文件或文件夹应始终打开到新窗口，请将其设置为 <code>on</code>。</p>
<p><code>window.restoreWindows</code> 设置告诉 VS Code 如何还原上一个会话的打开的窗口。默认情况下，VS Code 将还原您在上一个会话中使用过的所有窗口(设置为 <code>all</code> )。将此设置更改 <code>none</code> 为从不重新打开任何窗口，并始终以空的 VS Code 实例开头。更改为 <code>one</code> 则重新打开您上次打开的窗口的最后一个。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-09-17T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">快捷键</title>
    <id>https://list-jiang.github.io/software/vscode/shortcut-key/</id>
    <link href="https://list-jiang.github.io/software/vscode/shortcut-key/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <content type="html"><![CDATA[<p>通过快捷键，Visual Studio Code 可让您直接从键盘执行大多数任务。</p>
<h2 id="常用的快捷键"> 常用的快捷键</h2>
<div><p>提示</p>
<p>以下这些快捷键建议大家熟练掌握，能够很大程度提高开发效率。</p>
</div>
<h3 id="鼠标操作"> 鼠标操作</h3>
<ul>
<li>
<p>在当前行的位置，鼠标三击，可以选中当前行。</p>
</li>
<li>
<p>用鼠标单击文件的行号，可以选中当前行。</p>
</li>
<li>
<p>在某个行号的位置，上下移动鼠标，可以选中多行。</p>
</li>
</ul>
<h3 id="移动光标"> 移动光标</h3>
<ul>
<li>
<p>「方向键」: 在<strong>单个字符</strong>之间移动光标</p>
</li>
<li>
<p>「Ctrl + 左右方向键」: 在<strong>单词</strong>之间移动光标(很常用)。</p>
</li>
</ul>
<h3 id="快速选中"> 快速选中</h3>
<p>在任意位置单击放置光标，按住 <code>shift</code> 在第二个位置单击，即可选中两光标位置间的所有文字。</p>
<ul>
<li>
<p><code>Ctrl + Alt + ↑/↓</code>: 向方向键方向的相邻行放置一个光标；</p>
</li>
<li>
<p><code>Alt + Click</code>: 放置辅助游标；</p>
</li>
<li>
<p><code>Shift + Alt + ←/→</code>: 收缩/扩展选择；</p>
</li>
<li>
<p><code>Shift + Alt</code> 同时拖动到对角: 列(框)选择；</p>
</li>
</ul>
<h3 id="删除"> 删除</h3>
<ul>
<li>
<p><code>Ctrl + Backspace</code>: 删除光标之前的一个单词</p>
</li>
<li>
<p><code>Ctrl + delete</code>: 　删除光标之后的一个单词</p>
</li>
<li>
<p><code>Ctrl + Shift + K</code>: 删除整行</p>
</li>
</ul>
<h3 id="移动文字"> 移动文字</h3>
<ul>
<li>
<p><code>Alt + ↑</code>: 光标所在行或选中的文字的所有行整体上移一行；</p>
</li>
<li>
<p><code>Alt + ↓</code>: 光标所在行或选中文字的所有行整体下移一行</p>
</li>
</ul>
<h3 id="复制文字"> 复制文字</h3>
<ul>
<li>
<p><code>Alt + shift + ↑</code>: 光标所在行或选中的文字的所有行整体向下复制一行(如果选中了多行就是复制多行)；</p>
</li>
<li>
<p><code>Alt + shift + ↓</code>: 光标所在行或选中文字的所有行整体向上复制一行(如果选中了多行就是复制多行)；</p>
</li>
<li>
<p><code>Ctrl + D</code>: 选择光标处的单词，或下一次出现的当前选择；</p>
</li>
</ul>
<h3 id="代码操作"> 代码操作</h3>
<ul>
<li>
<p><code>Ctrl + /</code>: 添加单行注释</p>
</li>
<li>
<p><code>Alt + shift + F</code>: 代码格式化</p>
</li>
<li>
<p><code>Ctrl + U</code>: 将光标的移动回退到上一个位置、撤销光标的移动和选择</p>
</li>
<li>
<p><code>Ctrl + Enter</code>: 在当前行下面新增一行，然后跳至该行 (即使光标不在行尾，也能快速向下插入一行)</p>
</li>
<li>
<p><code>Ctrl + P</code>: 在当前的项目工程里，<strong>全局</strong>搜索文件</p>
</li>
<li>
<p><code>Ctrl + G</code>: 跳转到指定行</p>
</li>
<li>
<p><code>Ctrl + shift + O</code>: 在当前文件的各种<strong>方法之间</strong>进行跳转</p>
</li>
</ul>
<h4 id="搜索"> 搜索</h4>
<ul>
<li>
<p><code>Ctrl + F</code>: 查找，光标在搜索框里；</p>
</li>
<li>
<p><code>F3</code>: 在当前文件中搜索，光标仍在编辑器里</p>
</li>
<li>
<p><code>Ctrl + Shift +F</code>: 全局搜索</p>
</li>
<li>
<p><code>Ctrl + H</code>: 替换。</p>
</li>
</ul>
<h4 id="多光标的使用"> 多光标的使用</h4>
<ol>
<li>
<p>按住 Alt 键，然后在页面中希望中现光标的位置点击鼠标。</p>
</li>
<li>
<p>选中某个文本，然后反复按住快捷键 <code>Ctrl + D</code> 键， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。</p>
</li>
<li>
<p>选中一堆文本后，按住 <code>Alt + Shift + I</code> 键，既可在<strong>每一行的末尾</strong>都创建一个光标。</p>
</li>
</ol>
<h4 id="工作区快捷键"> 工作区快捷键</h4>
<ul>
<li>
<p><code>Ctrl + B</code>: 显示/隐藏侧边栏</p>
</li>
<li>
<p><code>Ctrl + \</code>: 创建多个编辑器</p>
</li>
<li>
<p><code>Ctrl + Pagedown/Pageup</code>: 在已经打开的文件之间进行<strong>切换</strong></p>
</li>
<li>
<p><code>Ctrl + `</code>: 打开终端</p>
</li>
</ul>
<h3 id="代码折叠"> 代码折叠</h3>
<p><code>Ctrl + Shift + [</code>: 折叠光标处最内部的未折叠区域；</p>
<p><code>Ctrl + Shift +]</code>: 展开光标处的折叠区域；</p>
<p><code>Ctrl + K Ctrl + [</code>: 折叠光标处最内部的未折叠区域以及该区域内的所有区域；</p>
<p><code>Ctrl + K Ctrl +]</code>: 展开光标处的区域以及该区域内的所有区域；</p>
<p><code>Ctrl + K Ctrl + 0</code>: 折叠编辑器中的所有区域；</p>
<p><code>Ctrl + K Ctrl + J</code>: 展开编辑器中的所有区域；</p>
<p><code>Ctrl + K</code> <code>Ctrl</code> + <code>X</code>: 折叠级别 <code>X</code> 的所有区域，但当前光标位置的区域除外；</p>
<p><code>Ctrl + K Ctrl + /</code>: 折叠以块注释标记开头的所有区域；</p>
<div><p>官方文档</p>
<p><a href="./assets/vscodeKeyboardShortcutsWindows.pdf">Windows 下 VS Code 快捷键指南</a> (英文)</p>
</div>
<h3 id="windows-快捷键"> Windows 快捷键</h3>
<p><code>Ctrl + X</code>: 剪切；</p>
<p><code>Ctrl + C</code>: 复制；</p>
<p><code>Ctrl + V</code>: 粘贴；</p>
<p><code>Ctrl + A</code>: 全选；</p>
<p><code>Ctrl + Z</code>: 撤销；</p>
<p><code>Ctrl + Y</code>: 恢复；</p>
<div><p>相关信息</p>
<p>更多请见 <a href="./../../code/windows/shortcut-key.html">Windows 快捷键介绍</a></p>
</div>
<hr>
<p>以下是一些高级内容</p>
<h2 id="快捷键编辑器"> 快捷键编辑器</h2>
<p>Visual Studio Code 使用 <strong>键盘快捷键编辑器</strong> 提供了丰富而便捷的键盘快捷键编辑体验。它列出了所有可用命令(无论是否已有快捷键绑定)，您可以轻松 更改 / 删除 / 重置 其键绑定。它还在顶部有一个搜索框，可帮助您查找命令或快捷键。您可以通过转到 <code>文件 &gt; 首选项 &gt; 键盘快捷方式</code> 下的菜单来打开此编辑器。(macOS 上为 <code>代码 &gt; 首选项 &gt; 键盘快捷键</code>)</p>
<h3 id="检测键绑定冲突"> 检测键绑定冲突</h3>
<p>如果您安装了许多扩展程序或自定义了键盘快捷键，则有时会将同一键盘快捷键映射到多个命令时会发生键绑定冲突。这可能导致混乱的行为，尤其是当您在编辑器中移动时，不同的键绑定进入和超出范围时。</p>
<p>该键盘快捷键编辑器有一个上下文菜单命令显示相同的按键组合，这将筛选基于键盘快捷键来显示冲突的键绑定。</p>
<p>选择一个您认为被覆盖掉的键绑定命令，您可以查看是否定义了多个命令，键绑定的来源以及它们何时处于活动状态。</p>
<h3 id="查看修改键绑定"> 查看修改键绑定</h3>
<p>您可以使用 <strong>更多操作(...)</strong> 菜单中的 <strong>显示用户按键绑定</strong>命令。</p>
<h3 id="高级定制"> 高级定制</h3>
<p>VS Code 中的所有键盘快捷键都可以通过该 <code>keybindings.json</code> 文件进行自定义。</p>
<ul>
<li>要通过 JSON 文件配置键盘快捷键，请打开 <strong>键盘快捷键</strong> 编辑器，然后选择编辑器标题栏右侧的 **打开键盘快捷键 (JSON)**按钮。</li>
<li>这将打开您的 <code>keybindings.json</code> 文件，您可以在其中覆盖默认的案件绑定。</li>
</ul>
<p>您也可以使用从命令面板(Ctrl + Shift + P)中选择 <strong>首选项: 打开键盘快捷方式 (JSON)</strong> 命令打开 <code>keybindings.json</code> 文件。</p>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="VS Code"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2020-09-17T00:00:00.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">类型推论</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/type-inference/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/type-inference/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论(Type Inference)的规则推断出一个类型。</p>
]]></summary>
    <content type="html"><![CDATA[<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论(Type Inference)的规则推断出一个类型。</p>

<h2 id="什么是类型推论"> 什么是类型推论</h2>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错:</p>
<div><pre><code><span>let</span> myFavoriteNumber <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>

<span>// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>事实上，它等价于:</p>
<div><pre><code><span>let</span> myFavoriteNumber<span>:</span> <span>string</span> <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>

<span>// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>:</p>
<div><pre><code><span>let</span> myFavoriteNumber<span>;</span>
myFavoriteNumber <span>=</span> <span>"seven"</span><span>;</span>
myFavoriteNumber <span>=</span> <span>7</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="noopener noreferrer">Type Inference</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type%20Inference.html" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
  <entry>
    <title type="html">类型断言</title>
    <id>https://list-jiang.github.io/code/language/typescript/basics/type-assertion/</id>
    <link href="https://list-jiang.github.io/code/language/typescript/basics/type-assertion/"/>
    <updated>2021-11-30T08:33:41.000Z</updated>
    <summary type="html"><![CDATA[<p>类型断言(Type Assertion)可以用来手动指定一个值的类型。</p>
]]></summary>
    <content type="html"><![CDATA[<p>类型断言(Type Assertion)可以用来手动指定一个值的类型。</p>

<h2 id="语法"> 语法</h2>
<div><pre><code><span>&lt;</span>类型<span>></span>值<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>或</p>
<div><pre><code>值 <span>as</span> 类型<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在 tsx 语法(React 的 jsx 语法的 ts 版)中必须用后一种。</p>
<h2 id="例子-将一个联合类型的变量指定为一个更加具体的类型"> 例子: 将一个联合类型的变量指定为一个更加具体的类型</h2>
<p><a href="./union-types.html#访问联合类型的属性或方法">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>:</p>
<div><pre><code><span>function</span> <span>getLength</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> something<span>.</span>length<span>;</span>
<span>}</span>

<span>// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span>
<span>//   Property 'length' does not exist on type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如:</p>
<div><pre><code><span>function</span> <span>getLength</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>if</span> <span>(</span>something<span>.</span>length<span>)</span> <span>{</span>
    <span>return</span> something<span>.</span>length<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> something<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span>length<span>;</span>
  <span>}</span>
<span>}</span>

<span>// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.</span>
<span>//   Property 'length' does not exist on type 'number'.</span>
<span>// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.</span>
<span>//   Property 'length' does not exist on type 'number'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上例中，获取 <code>something.length</code> 的时候会报错。</p>
<p>此时可以使用类型断言，将 <code>something</code> 断言成 <code>string</code>:</p>
<div><pre><code><span>function</span> <span>getLength</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>if</span> <span>(</span><span>(</span><span>&lt;</span><span>string</span><span>></span>something<span>)</span><span>.</span>length<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>&lt;</span><span>string</span><span>></span>something<span>)</span><span>.</span>length<span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> something<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span>length<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>类型断言的用法如上，在需要断言的变量前加上 <code>&lt;Type&gt;</code> 即可。</p>
<p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong>:</p>
<div><pre><code><span>function</span> <span>toBoolean</span><span>(</span>something<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>return</span> <span>&lt;</span><span>boolean</span><span>></span>something<span>;</span>
<span>}</span>

<span>// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.</span>
<span>//   Type 'number' is not comparable to type 'boolean'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html" target="_blank" rel="noopener noreferrer">TypeScript Deep Dive / Type Assertion</a></li>
<li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types" target="_blank" rel="noopener noreferrer">Advanced Types # Type Guards and Differentiating Types</a>(<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B(type-guards-and-differentiating-types)" target="_blank" rel="noopener noreferrer">中文版</a>)</li>
</ul>
]]></content>
    <author>
      <name>List Jiang</name>
    </author>
    <category term="TypeScript"/>
    <contributor>
      <name>List Jiang</name>
    </contributor>
    <published>2021-11-30T08:33:41.000Z</published>
    <rights>Copyright by List Jiang</rights>
  </entry>
</feed>