<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://list-jiang.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>𝓛𝓲𝓼𝓽·𝓙𝓲𝓪𝓷𝓰</title>
    <link>https://list-jiang.github.io/</link>
    <description>远方无限 砥砺前行</description>
    <language>zh-CN</language>
    <pubDate>Mon, 09 Jan 2023 05:03:49 GMT</pubDate>
    <lastBuildDate>Mon, 09 Jan 2023 05:03:49 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright © 2021-present List Jiang</copyright>
    <category>Redis</category>
    <category>链路跟踪</category>
    <category>mq</category>
    <category>database</category>
    <category>Resilience4j</category>
    <category>Spring</category>
    <category>Linux</category>
    <item>
      <title>CompletableFuture</title>
      <link>https://list-jiang.github.io/note/java/completable-future/</link>
      <guid>https://list-jiang.github.io/note/java/completable-future/</guid>
      <source url="https://list-jiang.github.io/rss.xml">CompletableFuture</source>
      <pubDate>Thu, 10 Mar 2022 07:21:56 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>jdk 1.8 新增的用于处理并发任务的一个工具类，jdk9 做了增强。
他实现 CompletionStage 接口定义的所有动作 api ，使得我们可以直接通过这些 api 对任意动作根据实际场景进行组合。
他实现 Future 接口的相关 api ，使得我们可以直接通过这些 api 后去异步任务的结果。</p>
<p><strong>经典下单场景</strong></p>
<ul>
<li>库存减</li>
<li>订单增</li>
</ul>
<div><pre><code>    <span>// 案例代码</span>
    <span>@GlobalTransactional</span>
    <span>public</span> <span>void</span> <span>purchase</span><span>(</span><span>String</span> userId<span>,</span> <span>String</span> commodityCode<span>,</span> <span>int</span> orderCount<span>)</span> <span>{</span>
        <span>// 采用并行方式触发任务</span>
        <span>CompletableFuture</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> exceptionally <span>=</span> <span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                    <span>// 库存减</span>
                    stockFeignClient<span>.</span><span>deduct</span><span>(</span>commodityCode<span>,</span> orderCount<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span><span>)</span><span>.</span><span>thenCombine</span><span>(</span><span>CompletableFuture</span><span>.</span><span>supplyAsync</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
                    <span>// 订单增</span>
                    orderFeignClient<span>.</span><span>create</span><span>(</span>userId<span>,</span> commodityCode<span>,</span> orderCount<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span><span>)</span><span>,</span> <span>(</span>state1<span>,</span> state2<span>)</span> <span>-></span> state1 <span>&amp;&amp;</span> state2 <span>&amp;&amp;</span> <span>validData</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>exceptionally</span><span>(</span>throwable <span>-></span> <span>false</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span><span>!</span>exceptionally<span>.</span><span>join</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"账户或库存不足,执行回滚"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="常用-api"> 常用 API</h2>
<h3 id="准备运行一个异步任务"> 准备运行一个异步任务</h3>
<table>
<thead>
<tr>
<th>api</th>
<th>功能</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>runAsync(Runnable)</code></td>
<td>塞入一个没有返回值的异步任务</td>
<td></td>
</tr>
<tr>
<td><code>runAsync(Runnable,Executor)</code></td>
<td>指定线程池塞入一个没有返回值的异步任务</td>
<td></td>
</tr>
<tr>
<td><code>supplyAsync(Supplier&lt;U&gt;)</code></td>
<td>塞入一个有返回值的异步任务</td>
<td></td>
</tr>
<tr>
<td><code>supplyAsync(Supplier&lt;U&gt;,Executor)</code></td>
<td>指定线程池塞入一个有返回值的异步任务</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="构建任务链"> 构建任务链</h3>
<table>
<thead>
<tr>
<th>api</th>
<th>功能</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenAcceptBoth(CompletionStage&lt;U&gt; c, BiConsumer&lt;T, U&gt;)</code></td>
<td>将上一个任务与入参任务 c 并行处理，得到两个结果进行消费</td>
<td>用于组合两个并行任务，无返回值</td>
</tr>
<tr>
<td><code>thenCombine(CompletionStage&lt;U&gt; c, BiFunction&lt;T, U, R&gt; b)</code></td>
<td>将上一个任务与入参任务 c 并行处理，得到两个的结果后执行 b 函数并返回一个值</td>
<td>用于组合两个并行任务，有返回值</td>
</tr>
<tr>
<td><code>runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)</code></td>
<td>将上一个任务与入参任务 other 并行处理，两个执行完后执行 action</td>
<td>不管上两个的结果，无返回值</td>
</tr>
<tr>
<td><code>thenCompose(Function&lt;T, CompletionStage&lt;U&gt;&gt;)</code></td>
<td>基于上个任务的结果进行下一个任务</td>
<td>用户组合两个具有先后顺序的串行任务</td>
</tr>
<tr>
<td><code>thenAccept(Consumer&lt;T&gt;)</code></td>
<td>消费上一个任务的结果</td>
<td>中间消费</td>
</tr>
<tr>
<td><code>thenRun(Runnable action)</code></td>
<td>上个任务执行，执行下个任务</td>
<td>连续任务处理，都没有返回值</td>
</tr>
<tr>
<td><code>thenApply(Function&lt;T, U&gt;)</code></td>
<td>基于上一个任务的结果进行处理再返回</td>
<td>也可以返回一个 CompletableFuture 那么效果和 thenCompose 一样</td>
</tr>
<tr>
<td><code>applyToEither(CompletionStage&lt;T&gt;, Function&lt;T, U&gt;)</code></td>
<td>两个任务并行执行，先得到的结果进行转换</td>
<td>等公交，谁先到做谁的公交回家</td>
</tr>
<tr>
<td><code>acceptEither(CompletionStage&lt;T&gt;, Consumer&lt;T&gt;)</code></td>
<td>两个任务并行执行，先得到的结果进行消费</td>
<td>卖包子，猪肉白菜陷的与猪肉胡萝卜馅的，哪个先熟吃哪个</td>
</tr>
<tr>
<td><code>allOf(CompletableFuture&lt;?&gt;... cfs)</code></td>
<td>当所有给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture。</td>
<td>所有的都完成结束，不返回值</td>
</tr>
<tr>
<td><code>anyOf(CompletableFuture&lt;?&gt;... cfs)</code></td>
<td>当任意一个给定的 CompletableFuture 完成时，返回一个新的 CompletableFuture。</td>
<td>任意一个完成时结束，返回这个完成的返回的值</td>
</tr>
</tbody>
</table>
<h3 id="获取结果"> 获取结果</h3>
<table>
<thead>
<tr>
<th>api</th>
<th>功能</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>join()</code></td>
<td>获得最终结果</td>
<td>不抛出异常</td>
</tr>
<tr>
<td><code>get() throws InterruptedException, ExecutionException</code></td>
<td>获得最终结果</td>
<td>可能抛出 取消异常、执行异常或者中断异常</td>
</tr>
<tr>
<td><code>get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</code></td>
<td>获得最终结果</td>
<td>除了上面的三个异常还有可能抛出超时异常</td>
</tr>
<tr>
<td><code>getNow(T valueIfAbsent)</code></td>
<td>该方法不阻塞，如果任务尚未完成，则返回默认值。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="设定默认值、默认抛出异常"> 设定默认值、默认抛出异常</h3>
<table>
<thead>
<tr>
<th>api</th>
<th>功能</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>complete(T valueIfAbsent)</code></td>
<td>如果此时任务没执行完成就设置一个默认值</td>
<td>如果调用该方法时，任务已经执行完成，返回 false。未执行完成则返回 true，并将其状态设置为完成状态</td>
</tr>
<tr>
<td><code>completeExceptionally(Throwable)</code></td>
<td>如果此时任务没执行完成就定义一个抛出异常</td>
<td>如果调用该方法时，任务已经执行完成，返回 false。未执行完成则返回 true，并将其状态设置为完成状态，获取结果时会抛出该设置的异常</td>
</tr>
<tr>
<td><code>obtrudeValue(T value)</code></td>
<td>强行设置返回值</td>
<td>不管任务此时是否完成都设置一个返回值</td>
</tr>
<tr>
<td><code>obtrudeException(Throwable ex)</code></td>
<td>强行设置抛出异常</td>
<td>不管任务此时是否完成都定义一个抛出异常</td>
</tr>
<tr>
<td><code>CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; )</code></td>
<td>设置任务出异常后应该返回什么</td>
<td>当前面的任务出了异常时，就会返回T值；否则还是返回原先前面任务应该返回的值。</td>
</tr>
<tr>
<td><code>handle(BiFunction&lt;T, Throwable, U&gt;)</code></td>
<td>类似于 thenApply 和 exceptionally 的结合</td>
<td>任务成功则 T 为正常值， Throwable 为 null 。任务失败则 T 为 null ， Throwable 为抛出的异常</td>
</tr>
<tr>
<td><code>whenComplete(BiConsumer&lt;T, Throwable&gt;)</code></td>
<td>执行过程中获取结果与异常</td>
<td>任务成功则 T 为正常值， Throwable 为 null 。任务失败则 T 为 null ， Throwable 为抛出的异常</td>
</tr>
</tbody>
</table>
<h3 id="总结"> 总结</h3>
<p>基本能够覆盖生活中的所有并行、串行处理流程组合。
所有的 API 都是围绕着 Future 之间的运行关系(先后、并行)，然后针对每个 Future 执行可能得到的结果或者抛出的异常提供相应情景下的 API。
使用的话，我们可以直接构思一个操作就是一个 CompletableFuture 实例，而我们的所有业务的操作流程就是一个个 CompletableFuture 组合而成的，至于之间的关系是 并行 还是 串行，每个任务执行的结果，异常处理。我们都可以通过提供的 api 进行自由的组合设置。有个前提就是使用这个，必须先真正理解 jdk 的函数式接口抽象。需要有面向过程 <strong><code>动作/过程</code></strong> 的思维。</p>
<p>CompletableFuture 大致 API 笼统含义</p>
<ul>
<li><code>then</code> 围绕 Future 关系组合。只有 thenCombine 相关的三个是并行，别的都是串行。</li>
<li><code>handle</code> 中间处理流程，类似于 stream 的 map API</li>
<li><code>Either</code> 围绕谁先到谁说了算</li>
<li><code>complete</code> 与任务完成状态相关。要么中途临时插手完成任务，要么设置任务完成时需要进行的操作</li>
<li><code>exceptionally**</code> 围绕异常相关处理</li>
<li><code>get</code> 与 <code>join</code> 都是获取结果， get 多几个异常，并且可以设置等待时间</li>
<li><code>run</code> 不接收上次的运行结果，直接往下继续</li>
<li><code>failed</code> 异常失败情景处理</li>
<li><code>allOf</code> 和 <code>anyOf</code> 这两个一个是全部完成返回，一个是任意一个完成返回。具体的返回值判定可以看下文档</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Redis 常见面试问题总结和答案。</title>
      <link>https://list-jiang.github.io/db/redis/interview/</link>
      <guid>https://list-jiang.github.io/db/redis/interview/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Redis 常见面试问题总结和答案。</source>
      <category>Redis</category>
      <pubDate>Mon, 07 Mar 2022 07:53:32 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="redis-常见面试问题总结和答案。"> Redis 常见面试问题总结和答案。</h1>
<div><p>什么是Redis？</p>
<p>Redis(Remote Dictionary Server) Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的非关系型数据库。</p>
<p>传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式，而分布式一般遵循 CAP 定理。</p>
<p>Github 源码：<a href="https://github.com/antirez/redis" target="_blank" rel="noopener noreferrer">https://github.com/antirez/redis<i>Content not supported</i></a></p>
<p>Redis 官网：<a href="https://redis.io/" target="_blank" rel="noopener noreferrer">https://redis.io/<i>Content not supported</i></a></p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p>
</div>
<div><p>Redis支持的数据类型？</p>
<p>Redis 可以存储键和不同类型的值之间的映射。键的类型只能为字符串，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p><strong>String字符串：</strong></p>
<div><pre><code><span>set</span> key value
</code></pre>
<div><span>1</span><br></div></div><p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p><strong>Hash（哈希）</strong></p>
<div><pre><code>hmset name key1 value1 key2 value2
</code></pre>
<div><span>1</span><br></div></div><p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>List（列表）</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<div><pre><code>lpush name value
</code></pre>
<div><span>1</span><br></div></div><p>在 key 对应 list 的头部添加字符串元素</p>
<div><pre><code>rpush name value
</code></pre>
<div><span>1</span><br></div></div><p>在 key 对应 list 的尾部添加字符串元素</p>
<div><pre><code>lrem name index
</code></pre>
<div><span>1</span><br></div></div><p>key 对应 list 中删除 count 个和 value 相同的元素</p>
<div><pre><code>llen name
</code></pre>
<div><span>1</span><br></div></div><p>返回 key 对应 list 的长度</p>
<p>Set（集合）</p>
<div><pre><code>sadd name value
</code></pre>
<div><span>1</span><br></div></div><p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>zset(sorted set：有序集合)</p>
<div><pre><code>zadd name score value
</code></pre>
<div><span>1</span><br></div></div><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
</div>
<div><p>什么是 Redis 持久化？ Redis 有哪几种持久化方式？优缺点是什么？</p>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis 提供了两种持久化方式: <code>RDB</code>（默认）和 <code>AOF</code></p>
<p><strong>RDB：</strong></p>
<p>RDB 是 Redis DataBase 缩写</p>
<p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p>
<p><img src="./img/rdb1.png" alt=""></p>
<p><strong>AOF:</strong></p>
<p>AOF 是 Append-only file 缩写</p>
<p><img src="./img/aof1.png" alt=""></p>
<p>每当执行服务器(定时)任务或者函数时 flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p>
<p><strong>aof 写入保存：</strong></p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><strong>存储结构:</strong></p>
<p>内容是redis通讯协议(RESP )格式的命令文本存储。</p>
<p><strong>比较：</strong></p>
<p>1、AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</p>
<p>2、AOF 比 RDB 更安全也更大</p>
<p>3、RDB 性能比 AOF 好</p>
<p>4、如果两个都配了优先加载 AOF</p>
<p><strong>刚刚上面你有提到 redis 通讯协议(RESP )，能解释下什么是 RESP ？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）
RESP 是redis客户端和服务端之前使用的一种通讯协议；</strong></p>
<p>RESP 的特点：实现简单、快速解析、可读性好</p>
<p>For Simple Strings the first byte of the reply is &quot;+&quot; 回复</p>
<p>For Errors the first byte of the reply is &quot;-&quot; 错误</p>
<p>For Integers the first byte of the reply is &quot;:&quot; 整数</p>
<p>For Bulk Strings the first byte of the reply is &quot;$&quot; 字符串</p>
<p>For Arrays the first byte of the reply is &quot;*&quot; 数组</p>
</div>
<div><p>Redis 有哪些架构模式？讲讲各自的特点</p>
<p><strong>单机版</strong></p>
<p><img src="./img/stand-alone.png" alt=""></p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>简单</li>
</ul>
</li>
<li>
<p>问题：</p>
<ol>
<li>内存容量有限</li>
<li>处理能力有限</li>
<li>无法高可用。</li>
</ol>
</li>
</ul>
<p><strong>主从复制</strong></p>
<p><img src="./img/master-slave.png" alt=""></p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<ul>
<li>
<p>特点：</p>
<ol>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master 读压力在转交从库</li>
</ol>
</li>
<li>
<p>问题：</p>
<ul>
<li>无法保证高可用</li>
<li>没有解决 master 写的压力</li>
</ul>
</li>
</ul>
<p><strong>哨兵</strong></p>
<p><img src="./img/sentinel.png" alt=""></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<p>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>主从模式，切换需要时间丢数据</li>
<li>没有解决 master 写的压力</li>
</ul>
</li>
</ul>
<p><strong>集群（proxy 型）：</strong></p>
<p><img src="./img/cluster-proxy.png" alt=""></p>
<p><code>Twemproxy</code> 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins</li>
<li>支持失败节点自动删除</li>
<li>后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>增加了新的 proxy，需要维护其高可用。</li>
<li>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</li>
</ul>
</li>
</ul>
<p><strong>集群（直连型）：</strong></p>
<p><img src="./img/cluster.png" alt=""></p>
<p>从 redis 3.0 之后版本支持 redis-cluster 集群，Redis-Cluster 采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<ul>
<li>
<p>特点：</p>
<ul>
<li>无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>资源隔离性较差，容易出现相互影响的情况。</li>
<li>数据通过异步复制,不保证数据的强一致性</li>
</ul>
</li>
</ul>
<div><p>什么是一致性哈希算法？什么是哈希槽？</p>
<p>这两个问题篇幅过长 网上找了两个解锁的不错的文章</p>
<p>https://www.cnblogs.com/lpfuture/p/5796398.html</p>
<p>http://www.jasontec.cn/articles/2020/04/11/1586586130767.html</p>
</div>
</div>
<div><p>Redis常用命令？</p>
<div><pre><code><span># 列出所有key，*表示区配所有。</span>
Keys pattern

<span># 设置 key 对应的值为 string 类型的 value。</span>
Set
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>设置 key 对应的值为 string 类型的 value。如果 key 已经存在，返回 0，nx 是 not exist 的意思。
setnx</p>
<p>删除某个key，第一次返回1 删除了 第二次返回0
Del</p>
<p>设置过期时间（单位秒）
Expire</p>
<p>查看剩下多少时间，返回负数则key失效，key不存在了
TTL</p>
<p>设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。
Setex</p>
<p>一次设置多个 key 的值，成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。
Mset</p>
<p>设置 key 的值，并返回 key 的旧值。
Getset</p>
<p>一次获取多个 key 的值，如果对应 key 不存在，则对应返回 nil。
Mget</p>
<p>对 key 的值做加加操作,并返回新的值。注意 incr 一个不是 int 的 value 会返回错误，incr 一个不存在的 key，则设置 key 为 1
Incr</p>
<p>同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0
incrby</p>
<p>对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1
Decr</p>
<p>同 decr，减指定值。
Decrby</p>
<p>给指定 key 的字符串值追加 value,返回新字符串值的长度。
Append</p>
<p>取指定 key 的 value 值的长度。
Strlen</p>
<p>persist xxx(取消过期时间)</p>
<p>选择数据库（0-15库）
Select 0</p>
<p>把age 移动到1库
move age 1</p>
<p>随机返回一个key
Randomkey</p>
<p>重命名
Rename</p>
<p>返回数据类型
Type</p>
<div><p>使用过Redis分布式锁么，它是怎么实现的？</p>
<p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>
<p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p>
<p>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p>
</div>
</div>
<div><p>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</p>
<p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<ul>
<li>缺点：
<ul>
<li>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</li>
</ul>
</li>
</ul>
<p>能不能生产一次消费多次呢？</p>
<p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
</div>
<div><p>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</p>
<p><strong>缓存穿透</strong></p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p><strong>如何避免？</strong></p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<p><strong>缓存雪崩</strong></p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p><strong>如何避免？</strong></p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
<p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>http://jasontec.cn/articles/2019/12/20/1576826633007.html</p>
</div>
<div><p>Redis的用途是什么？</p>
<p><strong>计数器</strong> 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p><strong>缓存</strong> 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<p><strong>会话缓存</strong> 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p><strong>全页缓存（FPC）</strong> 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p><strong>查找表</strong> 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<p><strong>消息队列(发布/订阅功能)</strong> List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<p><strong>分布式锁实现</strong> 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<p>其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。</p>
</div>
<div><p>如何与Redis连接？</p>
<p>安装服务器后，可以运行 redis 安装时提供的 Redis 客户端，也可以打开命令提示符并使用以下命令：</p>
<div><pre><code> redis-cli
</code></pre>
<div><span>1</span><br></div></div><p>通过使用其中任何一个，您可以与 Redis 交互。</p>
</div>
<div><p>Redis的主要特点是什么？</p>
<p><strong>以下是 Redis 的主要功能：</strong></p>
<ul>
<li>读写性能优异， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</li>
<li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li>
<li>支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
<li>解释Redis的复制功能？</li>
<li>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
</div>
<div><p>Redis 和 RDBMS 有什么区别？</p>
<p>Redis 是 NoSQL 数据库，而 RDBMS 是 SQL 数据库。
Redis 遵循键值结构，而 RDBMS 遵循表结构。
Redis 非常快，而 RDBMS 相对较慢。
Redis 将所有数据集存储在主存储器中，而 RDBMS 将其数据集存储在辅助存储器中。
Redis 通常用于存储小型和常用文件，而 RDBMS 用于存储大文件。
Redis 仅为 Linux，BSD，Mac OS X，Solaris 提供官方支持。它目前没有为 Windows 提供官方支持，而 RDBMS 提供对两者的支持。</p>
</div>
<div><p>为什么 Redis 不同于其他的键值存储数据库？</p>
<p>有两个主要原因：</p>
<p>Redis 发展方向不同与其他键值数据库，它能包含很多复杂数据类型，对这些数据类型操作都是原子的。 Redis 数据类型与基本数据结构强相关，直接暴露给程序员，没有增加抽象层。
Redis 是一个基于内存的，能够持久化到硬盘的数据库，因此为了实现高速读写，数据集大小不能超过内存。内存数据库另一个优点是，内存数据库相对于硬盘数据库非常容易操作复杂数据结构，因此 Redis 可以做很多事情，内部复杂性低。与此同时两款磁盘存储格式（ RDB 和 AOF ）不需要支持随机访问，因此他们是紧凑的，而且总是以追加形式生成（甚至 AOF 日志轮换也是一个追加操作，因为新版本是由内存中的副本生成）。比起基于磁盘的数据存储， Redis 用来处理重要数据时需要确保数据集及时落盘刷新。</p>
</div>
<div><p>Redis内存使用情况？</p>
<p>举几个例子（所有数据基于64位实例）</p>
<p>一个空实例大约占用3M内存
1百万简单字符串键值对大约占用 85M 内存
1百万哈希表键值对，每个对象有 5 个属性，大约占用 160M 内存
为了测试你的用例，使用 redis-benchmark 工具生成随机数据集，使用 INFO memory 命令检查使用内存空间。</p>
<p>存储相同的键，64位系统比32位系统使用更多的内存，键值很小情况下更明显。这是因为64位系统指针占用 8 字节。但是64位系统优点是可以配置更多内存（校对注：32位操作系统支持的内存最多为2的32次方，就是 4G ），因此为了运行大型Redis服务器，64位系统尤佳。另一种方案是使用分片。</p>
<p>我喜欢 Redis 的高性能操作和特性，但是不喜欢所有内容都在内存中，我不能创建一个比内存更大数据集。有计划改变吗？
过去为了允许数据集超过 RAM 大小， Redis 开发人员尝试使用虚拟内存和其他系统，但是我们非常高兴可以把一件事情做好：数据服务由内存提供，磁盘用于存储数据。所以现在没有计划为 Redis 创建磁盘后端，毕竟 Redis 大部分特性都是基于其当前架构设计的。</p>
<p>你的真正问题并不是所需的总内存，而是你需要划分你的数据集到多个 Redis 实例上，为了获取更多信息请阅读本文档中的分区页面。</p>
</div>
<div><p>同时使用 Redis 和磁盘数据库，是不是一个好想法？</p>
<p>是的，一个通用的设计方案是，在非常频繁的写小的数据时采用 Redis （并且你需要使用Redis数据结构给你的问题建立高效模型），以及将大数据存储到SQL数据库或者最终一致性磁盘数据库中。</p>
</div>
<div><p>有没有方法降低 Redis 内存使用率？</p>
<p>如果可以的话使用Redis 32位实例。另外，还要善于使用哈希表，列表，有序集合和整数集，因为在特殊情况下Redis使用这些数据类型可以更紧凑存储一些元素。可以 <a href="https://www.redis.com.cn/topics/memory-optimization.html" target="_blank" rel="noopener noreferrer">在内存优化页面<i>Content not supported</i></a> 获取更多信息。</p>
</div>
<div><p>Redis 内存不足时会发生什么？</p>
<p>Redis 要么被 Linux 内核 OOM 杀掉，抛出错误崩溃，要么开始变得卡顿。随着现代操作系统 malloc 方法通常都不返回 NULL ，而是服务器开始交换，因此 Redis 性能降低，因此你可能会观察到一些错误现象。</p>
<p>INFO 命令返回 Redis 使用内存总量，因此你可以编写脚本监控 Redis 服务器内存临界值。</p>
<p>Redis 内置保护措施允许用户在配置文件中使用 maxmemory 选项，设置 Redis 最大占用内存。如果达到此限制， Redis 将开始返回错误给写命令（但是将继续接受只读命令），或者当最大内存限制达到时也可以配置为键淘汰，在这种情况下 Redis 作为缓存使用。</p>
<p>我们有 <a href="https://www.redis.com.cn/topics/lru-cache.html" target="_blank" rel="noopener noreferrer">描述 Redis 作为 LRU 缓存使用的文档<i>Content not supported</i></a>。</p>
</div>
<div><p>在 Linux 系统中，即使我有很多空闲内存，后台保存失败报fork()错误！</p>
<p>精简回答：echo 1 &gt; /proc/sys/vm/overcommit_memory</p>
<p>详细回答：
Redis后台保存模式依赖现代操作系统的写时拷贝技术。Redis fork（创建一个子进程）是父进程精确拷贝。子进程存储数据到磁盘并且最终退出。从理论上讲，子进程应该和父进程使用同样多内存，作为父进程副本，但是得益于多数现代操作系统实现的写时复制技术，父进程和子进程共享内存页。内存页在父进程或子进程改变时将被复制。当子进程保存时，理论上所有页面都可能改变，Linux无法提前告知子进程需要多少内存，因此如果overcommit_memory设置为0，fork将会失败除非有足够的空闲RAM真正复制父进程内存页.结果是，如果你有3G Redis数据集，只有2G可用内存将会失败。</p>
<p>overcommit_memory 设置为1，意味着 Linux 使用更乐观方式 fork，这确实是你所期望的Redis。</p>
<p><a href="http://www.redhat.com/magazine/001nov04/features/vm/" target="_blank" rel="noopener noreferrer">理解虚拟机内存<i>Content not supported</i></a> 是红帽经典文章，可以了解 Linux 虚拟内存怎么工作， overcommitmemory 和 overcommitratio 的替代品。这篇文章校正了 <a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener noreferrer">proc(5)<i>Content not supported</i></a> 用户手册对 overcommit_memory 1和2 配置正确含义。</p>
</div>
<div><p>Redis 磁盘快照是不是原子操作？</p>
<p>是的，当服务器不在执行命令时，Redis 后台保存进程总是被创建，因此每个命令在 RAM 中是原子的，并且在磁盘快照过程也是原子的。</p>
</div>
<div><p>Redis是单线程的，我怎么利用多CPU/核?</p>
<p>CPU 基本不可能成为 Redis 的性能瓶颈，因为通常 Redis 受限于内存或网络。例如使用 Pipelining ， Redis 运行在普通的 Linux 系统上，每秒可以处理 50万 请求，所以如果你的应用程序主要使用O(N) 或者 O(log(N))命令，几乎不会使用太多的CPU。</p>
<p>然而为了最大限度利用CPU，你可以在一台机器上启动多个Redis实例，并把它们设置为不同服务器。某些时候单个机器是不够的，所以如果你想使用多个CPU，你可以提前考虑使用分片。</p>
<p>关于使用多Redis实例，你可以在 <a href="https://www.redis.com.cn/topics/partitioning.html" target="_blank" rel="noopener noreferrer">Partitioning page<i>Content not supported</i></a> 找到更多的信息</p>
</div>
<div><p>单个 Redis 实例最多可以存储多少键？哈希表、列表、集合和有序集合最大可以包含多少元素？</p>
<p>Redis 最大可以处理 2<sup>32</sup> 键，实践测试每个实例最少可以处理 2.5亿 键。</p>
<p>每个哈希表、列表、集合和有序集合可以容纳 2<sup>32</sup> 元素。</p>
<p>换句话说，Redis 极限容量就是系统可用内存。</p>
</div>
<div><p>为什么从实例与主实例拥有不同数量键？</p>
<p>如果你使用有生存周期的键，这就是正常现象。这就导致主从实例键的数量不一致原因。</p>
<ul>
<li>主实例在第一次与从实例同步时生成 RDB 文件。</li>
<li>RDB 文件不包含已经过期的键，但是已经过期的键仍然在内存中。</li>
<li>尽管这些键从逻辑上说已经过期失效，但是还在 Redis 主实例内存中，他们并不被识别为存在的，当增量或访问这些键时这些键会被回收。尽管从逻辑上说这些键不是数据集一部分，但是 INFO 和 DBSIZE 命令结果包含这些信息。</li>
<li>当从实例读取主实例生成的 RDB 文件时，过期键不会被载入。
为很多键设置过期属性，通常为用户提供了在从实例上存储更少键，但是实际上实例内容没有逻辑区别。</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Redis 使用经验</title>
      <link>https://list-jiang.github.io/db/redis/experience/</link>
      <guid>https://list-jiang.github.io/db/redis/experience/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Redis 使用经验</source>
      <category>Redis</category>
      <pubDate>Mon, 07 Mar 2022 07:53:32 GMT</pubDate>
    </item>
    <item>
      <title>Redis</title>
      <link>https://list-jiang.github.io/db/redis/</link>
      <guid>https://list-jiang.github.io/db/redis/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Redis</source>
      <category>Redis</category>
      <pubDate>Mon, 07 Mar 2022 07:53:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件. 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询. Redis 内置了 复制（replication）， LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction）， 事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel） 和自动 分区（Cluster）提供高可用性（high availability）。</p>
<h2 id="推荐网址"> 推荐网址</h2>
<ul>
<li>
<p><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">官网<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="http://www.redis.cn" target="_blank" rel="noopener noreferrer">redis 汉化中文网1<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://www.redis.com.cn/" target="_blank" rel="noopener noreferrer">redis 汉化中文网2<i>Content not supported</i></a></p>
</li>
<li>
<p>热门扩展</p>
<p>启用其他语言，主题，调试器，命令等。</p>
</li>
</ul>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./interview.html">面试题目</a></p>
</li>
<li>
<p><a href="./experience.html">使用经验</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Zipkin 使用案例</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/demo/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/demo/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin 使用案例</source>
      <category>链路跟踪</category>
      <pubDate>Thu, 24 Feb 2022 15:57:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="场景"> 场景</h2>
<p>处理慢接口，定位Spring Cloud 服务间调用，确定各个链路执行时间</p>
<h3 id="涉及所有软件"> 涉及所有软件</h3>
<ul>
<li><a href="https://gitee.com/jdw-silky/silky-parent.git" target="_blank" rel="noopener noreferrer">微服务项目地址<i>Content not supported</i></a></li>
<li><a href="https://github.com/openzipkin/zipkin.git" target="_blank" rel="noopener noreferrer">zipkin 源码地址<i>Content not supported</i></a></li>
<li><a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener noreferrer">kafka<i>Content not supported</i></a></li>
<li><a href="https://www.elastic.co/cn/elasticsearch/" target="_blank" rel="noopener noreferrer">Elastic search<i>Content not supported</i></a></li>
<li><a href="https://www.elastic.co/cn/kibana/" target="_blank" rel="noopener noreferrer">kibana<i>Content not supported</i></a></li>
</ul>
<h3 id="环境准备"> 环境准备</h3>
<ul>
<li><a href="https://jdk.java.net/17/" target="_blank" rel="noopener noreferrer">jdk17<i>Content not supported</i></a></li>
<li><a href="https://maven.apache.org/" target="_blank" rel="noopener noreferrer">maven<i>Content not supported</i></a></li>
<li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener noreferrer">Intellij IDEA<i>Content not supported</i></a></li>
</ul>
<h2 id="实现效果"> 实现效果</h2>
<p>微服务之间调用链路耗时，能在 zipkin 看到，并且能看区分长请求。链路数据入 Elastic Search 库。</p>
<h3 id="安装-es、kafka"> 安装 ES、kafka</h3>
<p>docker 对于技术学习测试真的很方便</p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/jiangdewen/p/15119574.html" target="_blank" rel="noopener noreferrer">ES 集群安装<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/jiangdewen/p/15118629.html" target="_blank" rel="noopener noreferrer">kibana 安装<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="./../../../middleware/mq/kafka/quick-start.html">kafka 安装</a></p>
</li>
</ul>
<h3 id="启动微服务项目"> 启动微服务项目</h3>
<p>提一句，微服务集成 zipkin 除了增加了两个引用与少量的环境配置，不改变任何代码。</p>
<div><pre><code>    implementation &#39;org.springframework.cloud:spring-cloud-sleuth-zipkin&#39;
    implementation &#39;org.springframework.cloud:spring-cloud-starter-sleuth&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>spring</span><span>:</span>
  <span>application</span><span>:</span>
    <span>name</span><span>:</span> silky<span>-</span>demo<span>-</span>web
  <span>zipkin</span><span>:</span>
    <span>service</span><span>:</span>
      <span>name</span><span>:</span> $<span>{</span>spring.application.name<span>}</span>
    <span>sender</span><span>:</span>
      <span>type</span><span>:</span> kafka
    <span>kafka</span><span>:</span>
      <span>topic</span><span>:</span> zipkin
  <span>kafka</span><span>:</span>
    <span>bootstrap-servers</span><span>:</span> 192.168.137.165<span>:</span><span>9091</span><span>,</span>192.168.137.165<span>:</span><span>9092</span><span>,</span>192.168.137.165<span>:</span><span>9093</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="启动-zipkin"> 启动 zipkin</h3>
<p><a href="./quick-start.html">服务器启动方式</a></p>
<h4 id="以源码启动"> 以源码启动</h4>
<p>Intellij IDEA 以源码启动 zipkin 服务，主要难的是这个。此处需要配置 <a href="https://www.cnblogs.com/jiangdewen/p/15928589.html" target="_blank" rel="noopener noreferrer">maven 跳过测试<i>Content not supported</i></a>。</p>
<p>maven 跳过测试配置： <code>-Dmaven.test.skip=true</code></p>
<p><img src="./../img/maven-skip-test1.png" alt=""></p>
<p><img src="./../img/maven-skip-test2.png" alt=""></p>
<blockquote>
<p>由于 zipkin-lens 项目用到了 <a href="https://react.docschina.org/" target="_blank" rel="noopener noreferrer">react<i>Content not supported</i></a> 。如果该 zipkin-lens 打包出错，尝试配置 node 环境。</p>
</blockquote>
<p><strong>配置文件修改</strong></p>
<p>修改项目启动配置文件 zipkin-server-shared.yml，之所以启动配置文件是这个，我们可以在启动类看到配置了 spring 启动参数 <code>spring.config.name=zipkin-server</code>。而 zipkin-server.yml 文件指定了 <code>spring.profiles.include: shared</code></p>
<p><img src="./../img/zipkin-code1.png" alt=""></p>
<div><pre><code><span># 项目实际为 yml 文件，此处用 properties 文件格式展示是为了便于笔记展示</span>
<span># 配置 kafka bootstrap servers</span>
<span>zipkin.collector.kafka.bootstrap-servers</span><span>=</span><span>${KAFKA_BOOTSTRAP_SERVERS:192.168.137.165:9092}</span>
<span># 配置 storage 类型</span>
<span>zipkin.storage.type</span><span>=</span><span>${STORAGE_TYPE:elasticsearch}</span>
<span># 配置 es 集群 url</span>
<span>zipkin.storage.elasticsearch.hosts</span><span>=</span><span>${ES_HOSTS:http://192.168.137.165:9201,http://192.168.137.165:9202,http://192.168.137.165:9203}</span>

``

<span>**启动</span> <span>zipkin 项目**</span>

<span>项目启动必须先进行</span> <span>maven 打包才行。</span>

<span>![](../img/zipkin-idea-package.jpg)</span>

<span>运行</span> <span>`zipkin.server.ZipkinServer#main` 启动项目</span>

<span>![](../img/zipkin-maven-run.png)</span>

**启动微服务项目**

便于测试可以写几个简单的脚本

<span>-</span> <span>eureka-server.bat</span>
```bash
<span>d</span><span>:</span>
<span>cd</span> <span>D:\ideaProject\gitee\jdw-silky\silky-parent\silky-eureka-server\build\libs</span>
<span>java</span> <span>-jar silky-eureka-server-1.0.1.jar --spring.profiles.active=native</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><ul>
<li>config-server.bat</li>
</ul>
<div><pre><code>d:
<span>cd</span> D:<span>\</span>ideaProject<span>\</span>gitee<span>\</span>jdw-silky<span>\</span>silky-parent<span>\</span>silky-config<span>\</span>build<span>\</span>libs
java -jar silky-config-1.0.1.jar --spring.profiles.active<span>=</span>native
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>web-server.bat</li>
</ul>
<div><pre><code>d:
<span>cd</span> D:<span>\</span>ideaProject<span>\</span>gitee<span>\</span>jdw-silky<span>\</span>silky-parent<span>\</span>silky-demo-web<span>\</span>build<span>\</span>libs
java -jar silky-demo-web-1.0.1.jar --spring.profiles.active<span>=</span>native
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>由于 web-server 服务的启动端口配置为 0 ，所以直接多点击两下就启动了几个 web-server 服务。</p>
<h4 id="验证"> 验证</h4>
<ol>
<li>调用一次 web 服务</li>
</ol>
<p><img src="./../img/test1.png" alt=""></p>
<ol start="2">
<li>在 zipkin 界面查看调用链</li>
</ol>
<p><img src="./../img/test2.png" alt=""></p>
<ol start="3">
<li>使用 kibana 查找调用链记录</li>
</ol>
<p><img src="./../img/test3.png" alt=""></p>
<p>可以看到，一个调用链在 zipkin 看到了，并且持久化到 Elastic Search 里面了</p>
]]></content:encoded>
    </item>
    <item>
      <title>Spring 家族</title>
      <link>https://list-jiang.github.io/spring/track/</link>
      <guid>https://list-jiang.github.io/spring/track/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Spring 家族</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>在分布式系统，尤其是微服务系统中，一次外部请求往往需要内部多个模块，多个中间件，多台机器的相互调用才能完成。在这一系列的调用中，可能有些是串行的，而有些是并行的。在这种情况下，我们如何才能确定这整个请求调用了哪些应用？哪些模块？哪些节点？以及它们的先后顺序和各部分的性能如何呢？</p>
<p>链路追踪是分布式系统下的一个概念，它的目的就是要解决上面所提出的问题，也就是将一次分布式请求还原成调用链路，将一次分布式请求的调用情况集中展示，比如，各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p>
<h3 id="zipkin"> <a href="./zipkin/">zipkin</a></h3>
]]></content:encoded>
    </item>
    <item>
      <title>Zipkin 快速入门</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/quick-start/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/quick-start/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin 快速入门</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="启动方式"> 启动方式</h2>
<div><p>Docker</p>
<div><pre><code>
docker run -d -p <span>9411</span>:9411 openzipkin/zipkin

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></div>
<div><p>Java8+</p>
<div><pre><code><span>curl</span> -sSL https://zipkin.io/quickstart.sh <span>|</span> <span>bash</span> -s
java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<div><p>源码编译运行</p>
<div><pre><code><span># git 拉取代码</span>
<span>git</span> clone https://github.com/openzipkin/zipkin
<span>cd</span> zipkin
<span># maven编译，此处需要 docker 、 nodeJs 环境，或者 [跳过测试](https://www.cnblogs.com/jiangdewen/p/15928589.html)</span>
./mvnw -DskipTests --also-make -pl zipkin-server clean <span>install</span>
<span># 运行服务</span>
java -jar ./zipkin-server/target/zipkin-server-*exec.jar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></div>
<p><strong>源码编译补充</strong></p>
<p>如果我们使用 Intellij IDEA 打开源码的话， maven 打包需要配置跳过测试。以父模块全项目打包，需要确保 nodeJs 环境。</p>
<p><img src="./../img/zipkin-idea-package.jpg" alt=""></p>
]]></content:encoded>
    </item>
    <item>
      <title>Zipkin 快速入门</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/info/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/info/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin 快速入门</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>Zipkin 是一个分布式追踪系统。它有助于收集解决服务架构中的延迟问题所需的时间数据。功能包括收集和查找此数据。</p>
<p>如果您在日志文件中有跟踪 ID，则可以直接跳转到它。否则，您可以根据服务、操作名称、标签和持续时间等属性进行查询。会为你总结一些有趣的数据，比如在服务中花费的时间百分比，以及操作是否失败。</p>
<p><img src="./../img/web-screenshot.png" alt=""></p>
<p>Zipkin UI 还提供了一个依赖关系图，显示有多少跟踪请求通过了每个应用程序。这有助于识别聚合行为，包括错误路径或对已弃用服务的调用。</p>
<p><img src="./../img/dependency-graph.png" alt=""></p>
<p>应用程序需要被“检测”以向 Zipkin 报告跟踪数据。这通常意味着配置 <a href="https://zipkin.io/pages/tracers_instrumentation" target="_blank" rel="noopener noreferrer">跟踪器或检测库<i>Content not supported</i></a> 。向 Zipkin 报告数据的最流行方式是通过 HTTP 或 Kafka，但也有许多其他选项，例如 Apache ActiveMQ、gRPC 和 RabbitMQ。提供给 UI 的数据存储在内存中，或者通过支持的后端（例如 Apache Cassandra 或 Elasticsearch）持久存储。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Zipkin</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./info.html">介绍</a></li>
<li><a href="./quick-start.html">快速入门</a></li>
<li><a href="./start-env.html">zipkin启动及环境配置</a></li>
<li><a href="./demo.html">生产案例</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Zipkin</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/start-env%20copy/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/start-env%20copy/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="zipkin-server"> zipkin-server</h1>
<p>Zipkin Server is a Java 1.8+ service, packaged as an executable jar.</p>
<p>Span storage and collectors are . By default, storage is in-memory,
the HTTP collector (POST /api/v2/spans endpoint) is enabled, and the server listens on port 9411.</p>
<p>Zipkin Server is implemented with <a href="https://github.com/line/armeria" target="_blank" rel="noopener noreferrer">Armeria<i>Content not supported</i></a>. While it uses <a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener noreferrer">Spring Boot<i>Content not supported</i></a>
internally, Zipkin Server should not be considered a normal Spring Boot application.</p>
<h2 id="custom-servers-are-not-supported"> Custom servers are not supported</h2>
<p>By Custom servers we mean trying to use/embed <code>zipkin</code> as part of <em>an application you package</em> (e.g. adding <code>zipkin-server</code> dependency to a Spring-boot application) instead of the packaged application we release.</p>
<p>For proper usage, see the guides below.</p>
<h2 id="quick-start"> Quick-start</h2>
<p>The quickest way to get started is to fetch the <a href="https://search.maven.org/remote_content?g=io.zipkin&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec" target="_blank" rel="noopener noreferrer">latest released server<i>Content not supported</i></a> as a self-contained executable jar. Note that the Zipkin server requires minimum JRE 8. For example:</p>
<div><pre><code>$ <span>curl</span> -sSL https://zipkin.io/quickstart.sh <span>|</span> <span>bash</span> -s
$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Once you've started, browse to http://your_host:9411 to find traces!</p>
<h2 id="endpoints"> Endpoints</h2>
<p>The following endpoints are defined under the base url http://your_host:9411</p>
<ul>
<li>/ - <a href="../zipkin-ui">UI</a></li>
<li>/config.json - </li>
<li>/api/v2 - <a href="https://zipkin.io/zipkin-api/#/" target="_blank" rel="noopener noreferrer">API<i>Content not supported</i></a></li>
<li>/health - Returns 200 status if OK</li>
<li>/info - Provides the version of the running instance</li>
<li>/metrics - Includes collector metrics broken down by transport type</li>
<li>/prometheus - Prometheus scrape endpoint</li>
</ul>
<p>The <a href="https://zipkin.io/zipkin-api/#/" target="_blank" rel="noopener noreferrer">legacy /api/v1 API<i>Content not supported</i></a> is still supported. Backends are decoupled from the
HTTP API via data conversion. This means you can still accept legacy data on new backends and visa versa. Enter
<code>https://zipkin.io/zipkin-api/zipkin-api.yaml</code> into the explore box of the Swagger UI to view the old definition</p>
<h3 id="cors-cross-origin-resource-sharing"> CORS (Cross-origin Resource Sharing)</h3>
<p>By default, all endpoints under <code>/api/v2</code> are configured to <strong>allow</strong> cross-origin requests.</p>
<p>This can be changed by modifying the property <code>zipkin.query.allowed-origins</code>.</p>
<p>For example, to allow CORS requests from <code>http://foo.bar.com</code>:</p>
<div><pre><code>ZIPKIN_QUERY_ALLOWED_ORIGINS=http://foo.bar.com
</code></pre>
<div><span>1</span><br></div></div><p>See  for more about how Zipkin is configured.</p>
<h3 id="service-and-span-names-query"> Service and Span names query</h3>
<p>The <a href="https://zipkin.io/zipkin-api/#/default/get_services" target="_blank" rel="noopener noreferrer">Zipkin API<i>Content not supported</i></a> does not include
a parameter for how far back to look for service or span names. In order
to prevent excessive load, service and span name queries are limited by
<code>QUERY_LOOKBACK</code>, which defaults to 24hrs (two daily buckets: one for
today and one for yesterday)</p>
<h2 id="logging"> Logging</h2>
<p>By default, zipkin writes log messages to the console at INFO level and above. You can adjust
categories using the <code>logging.level.XXX</code> property.</p>
<p>For example, if you want to enable debug logging for all zipkin categories, you can start the server like so:</p>
<div><pre><code>$ java -jar zipkin.jar --logging.level.zipkin2<span>=</span>DEBUG
</code></pre>
<div><span>1</span><br></div></div><p>See  for more about how Zipkin is configured.</p>
<h3 id="advanced-logging-configuration"> Advanced Logging Configuration</h3>
<p>Under the covers, the server uses <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html#howto-configure-logback-for-logging" target="_blank" rel="noopener noreferrer">Spring Boot - Logback integration<i>Content not supported</i></a>.
For example, you can add <code>--logging.exception-conversion-word=%wEx{full}</code> to dump full stack traces
instead of truncated ones.</p>
<h2 id="metrics"> Metrics</h2>
<p>Collector Metrics are exported to the path <code>/metrics</code>. These and additional metrics are exported
to the path <code>/prometheus</code>.</p>
<h3 id="example-prometheus-configuration"> Example Prometheus configuration</h3>
<p>Here's an example <code>/prometheus</code> configuration, using the Prometheus
exposition <a href="https://prometheus.io/docs/instrumenting/exposition_formats/" target="_blank" rel="noopener noreferrer">text format version 0.0.4<i>Content not supported</i></a></p>
<div><pre><code>  <span>-</span> <span>job_name</span><span>:</span> <span>'zipkin'</span>
    <span>scrape_interval</span><span>:</span> 5s
    <span>metrics_path</span><span>:</span> <span>'/prometheus'</span>
    <span>static_configs</span><span>:</span>
      <span>-</span> <span>targets</span><span>:</span> <span>[</span><span>'localhost:9411'</span><span>]</span>
    <span>metric_relabel_configs</span><span>:</span>
      <span># Response code count</span>
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'${1}'</span>
        <span>target_label</span><span>:</span> status
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'${2}'</span>
        <span>target_label</span><span>:</span> path
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'http_requests_total'</span>
        <span>target_label</span><span>:</span> __name__
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="collector"> Collector</h3>
<p>Collector metrics are broken down by transport. The following are exported to the &quot;/metrics&quot; endpoint:</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>counter.zipkin_collector.messages.$transport</td>
<td>cumulative messages received; should relate to messages reported by instrumented apps</td>
</tr>
<tr>
<td>counter.zipkin_collector.messages_dropped.$transport</td>
<td>cumulative messages dropped; reasons include client disconnects or malformed content</td>
</tr>
<tr>
<td>counter.zipkin_collector.bytes.$transport</td>
<td>cumulative message bytes</td>
</tr>
<tr>
<td>counter.zipkin_collector.spans.$transport</td>
<td>cumulative spans read; should relate to messages reported by instrumented apps</td>
</tr>
<tr>
<td>counter.zipkin_collector.spans_dropped.$transport</td>
<td>cumulative spans dropped; reasons include sampling or storage failures</td>
</tr>
<tr>
<td>gauge.zipkin_collector.message_spans.$transport</td>
<td>last count of spans in a message</td>
</tr>
<tr>
<td>gauge.zipkin_collector.message_bytes.$transport</td>
<td>last count of bytes in a message</td>
</tr>
</tbody>
</table>
<h2 id="configuration"> Configuration</h2>
<p>We support ENV variable configuration, such as <code>STORAGE_TYPE=cassandra3</code>, as they are familiar to
administrators and easy to use in runtime environments such as Docker.</p>
<p>Here are the top-level configuration of Zipkin:</p>
<ul>
<li><code>QUERY_PORT</code>: Listen port for the HTTP API and web UI; Defaults to 9411</li>
<li><code>QUERY_ENABLED</code>: <code>false</code> disables the HTTP read endpoints under '/api/v2'. This also disables the
UI, as it relies on the API. If your only goal is to restrict search, use <code>SEARCH_ENABLED</code> instead.
Defaults to true</li>
<li><code>SEARCH_ENABLED</code>: <code>false</code> disables searching in the query API and any indexing or post-processing
in the collector to support search. This does not disable the entire UI, as trace by ID and
dependency queries still operate. Disable this when you use another service (such as logs) to find
trace IDs. Defaults to true</li>
<li><code>QUERY_TIMEOUT</code>: Sets the hard timeout for query requests. Accepts any duration string (e.g., 100ms).
A value of 0 will disable the timeout completely. Defaults to 11s.</li>
<li><code>QUERY_LOG_LEVEL</code>: Log level written to the console; Defaults to INFO</li>
<li><code>QUERY_NAMES_MAX_AGE</code>: Controls the value of the <code>max-age</code> header zipkin-server responds with on
http requests for autocompleted values in the UI (service names for example). Defaults to 300 seconds.</li>
<li><code>QUERY_LOOKBACK</code>: How many milliseconds queries can look back from endTs; Defaults to 24 hours (two daily buckets: one for today and one for yesterday)</li>
<li><code>STORAGE_TYPE</code>: SpanStore implementation: one of <code>mem</code>, <code>mysql</code>, <code>cassandra3</code>, <code>elasticsearch</code></li>
<li><code>COLLECTOR_SAMPLE_RATE</code>: Percentage of traces to retain, defaults to always sample (1.0).</li>
<li><code>AUTOCOMPLETE_KEYS</code>: list of span tag keys which will be returned by the <code>/api/v2/autocompleteTags</code> endpoint; Tag keys should be comma separated e.g. &quot;instance_id,user_id,env&quot;</li>
<li><code>AUTOCOMPLETE_TTL</code>: How long in milliseconds to suppress calls to write the same autocomplete key/value pair. Default 3600000 (1 hr)</li>
</ul>
<h3 id="configuration-file-overrides"> Configuration file overrides</h3>
<p>Under the scenes, all configuration are managed by Spring Boot. This means that properties may also
be overridden by system properties or any other alternative <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" target="_blank" rel="noopener noreferrer">supported by Spring Boot<i>Content not supported</i></a>.</p>
<p>We use <a href="src/main/resources/zipkin-server-shared.yml">yaml configuration</a> to bind shorter or more
idiomatic ENV variables to the Spring properties ultimately in use. While most users should only use
environment variables, some may desire a properties file approach to override settings. For example,
knowing we set <code>spring.config.name=zipkin-server</code>, Spring Boot will automatically look for a file
named <code>zipkin-server.properties</code> in the current directory, and the same properties we set in yaml
can be overridden that way.</p>
<p>If you choose to use property-based configuration instead of ENV variables, you are choosing to
self-support your configuration. This means you'll use <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" target="_blank" rel="noopener noreferrer">Spring Boot documentation<i>Content not supported</i></a>
or <a href="https://stackoverflow.com/questions/tagged/spring-boot" target="_blank" rel="noopener noreferrer">StackOverflow<i>Content not supported</i></a> to resolve concerns
related to property resolution as opposed to raising issues or using our chat support. We have to
mention this because configuration of Spring implies vast responsibility and our resources must be
conserved for Zipkin related tasks.</p>
<h2 id="ui"> UI</h2>
<p>Zipkin has a web UI, automatically included in the exec jar, and is hosted by default on port 9411.</p>
<p>When the UI loads, it reads default configuration from the <code>/config.json</code> endpoint.</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>zipkin.ui.environment</td>
<td>The value here becomes a label in the top-right corner. Not required.</td>
</tr>
<tr>
<td>defaultLookback</td>
<td>zipkin.ui.default-lookback</td>
<td>Default duration in millis to look back when finding traces. Affects the &quot;Start time&quot; element in the UI. Defaults to 900000 (15 minutes in millis).</td>
</tr>
<tr>
<td>searchEnabled</td>
<td>zipkin.ui.search-enabled</td>
<td>If the Discover screen is enabled. Defaults to true.</td>
</tr>
<tr>
<td>queryLimit</td>
<td>zipkin.ui.query-limit</td>
<td>Default limit for Find Traces. Defaults to 10.</td>
</tr>
<tr>
<td>instrumented</td>
<td>zipkin.ui.instrumented</td>
<td>Which sites this Zipkin UI covers. Regex syntax. e.g. <code>http:\/\/example.com\/.*</code> Defaults to match all websites (<code>.*</code>).</td>
</tr>
<tr>
<td>logsUrl</td>
<td>zipkin.ui.logs-url</td>
<td>Logs query service url pattern. If specified, a button will appear on the trace page and will replace {traceId} in the url by the traceId. Not required.</td>
</tr>
<tr>
<td>supportUrl</td>
<td>zipkin.ui.support-url</td>
<td>A URL where a user can ask for support. If specified, a link will be placed in the side menu to this URL, for example a page to file support tickets. Not required.</td>
</tr>
<tr>
<td>archivePostUrl</td>
<td>zipkin.ui.archive-post-url</td>
<td>Url to POST the current trace in Zipkin v2 json format. e.g. 'https://longterm/api/v2/spans'. If specified, a button will appear on the trace page accordingly. Not required.</td>
</tr>
<tr>
<td>archiveUrl</td>
<td>zipkin.ui.archive-url</td>
<td>Url to a web application serving an archived trace, templated by '{traceId}'. e.g. https://longterm/zipkin/trace/{traceId}'. This is shown in a confirmation message after a trace is successfully POSTed to the <code>archivePostUrl</code>. Not required.</td>
</tr>
<tr>
<td>dependency.enabled</td>
<td>zipkin.ui.dependency.enabled</td>
<td>If the Dependencies screen is enabled. Defaults to true.</td>
</tr>
<tr>
<td>dependency.lowErrorRate</td>
<td>zipkin.ui.dependency.low-error-rate</td>
<td>The rate of error calls on a dependency link that turns it yellow. Defaults to 0.5 (50%) set to &gt;1 to disable.</td>
</tr>
<tr>
<td>dependency.highErrorRate</td>
<td>zipkin.ui.dependency.high-error-rate</td>
<td>The rate of error calls on a dependency link that turns it red. Defaults to 0.75 (75%) set to &gt;1 to disable.</td>
</tr>
<tr>
<td>basePath</td>
<td>zipkin.ui.basepath</td>
<td>path prefix placed into the <base> tag in the UI HTML; useful when running behind a reverse proxy. Default &quot;/zipkin&quot;</td>
</tr>
</tbody>
</table>
<p>To map properties to environment variables, change them to upper-underscore case format. For
example, if using docker you can set <code>ZIPKIN_UI_QUERY_LIMIT=100</code> to affect <code>$.queryLimit</code> in <code>/config.json</code>.</p>
<h3 id="trace-archival"> Trace archival</h3>
<p>Most production Zipkin clusters store traces with a limited TTL. This makes it a bit inconvenient to
share a trace, as the link to it will expire after a few days.</p>
<p>The &quot;archive a trace&quot; feature helps with this. Launch a second zipkin server pointing to a storage with a longer
TTL than the regular one and set the archivePostUrl and archiveUrl UI configs pointing to this second server.
Once archivePostUrl is set, a new &quot;Archive Trace&quot; button will appear on the trace view page.</p>
<h2 id="storage"> Storage</h2>
<h3 id="in-memory-storage"> In-Memory Storage</h3>
<p>Zipkin's <a href="../zipkin/src/main/java/zipkin2/storage/InMemoryStorage.java">In-Memory Storage</a> holds all
data in memory, purging older data upon a span limit. It applies when <code>STORAGE_TYPE</code> is unset or
set to the value <code>mem</code>.</p>
<div><pre><code>* `MEM_MAX_SPANS`: Oldest traces (and their spans) will be purged first when this limit is exceeded. Default 500000
</code></pre>
</div><p>Example usage:</p>
<div><pre><code>$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><p>Note: this storage component was primarily developed for testing and as a means to get Zipkin server
up and running quickly without external dependencies. It is not viable for high work loads. That
said, if you encounter out-of-memory errors, try decreasing <code>MEM_MAX_SPANS</code> or increasing the heap
size (-Xmx).</p>
<p>Exampled of doubling the amount of spans held in memory:</p>
<div><pre><code>$ <span>MEM_MAX_SPANS</span><span>=</span><span>1000000</span> java -Xmx1G -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="cassandra-storage"> Cassandra Storage</h3>
<p>Zipkin's <a href="../zipkin-storage/cassandra">Cassandra storage component</a> supports Cassandra 3.11.3+
and applies when <code>STORAGE_TYPE</code> is set to <code>cassandra3</code>:</p>
<div><pre><code>* `CASSANDRA_KEYSPACE`: The keyspace to use. Defaults to &quot;zipkin2&quot;
* `CASSANDRA_CONTACT_POINTS`: Comma separated list of host addresses part of Cassandra cluster. You can also specify a custom port with 'host:port'. Defaults to localhost on port 9042.
* `CASSANDRA_LOCAL_DC`: Name of the datacenter that will be considered &quot;local&quot; for load balancing. Defaults to &quot;datacenter1&quot;
* `CASSANDRA_ENSURE_SCHEMA`: Ensuring cassandra has the latest schema. If enabled tries to execute scripts in the classpath prefixed with `cassandra-schema-cql3`. Defaults to true
* `CASSANDRA_USERNAME` and `CASSANDRA_PASSWORD`: Cassandra authentication. Will throw an exception on startup if authentication fails. No default
* `CASSANDRA_USE_SSL`: Requires `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`, defaults to false.
</code></pre>
</div><p>The following are tuning parameters which may not concern all users:</p>
<div><pre><code>* `CASSANDRA_MAX_CONNECTIONS`: Max pooled connections per datacenter-local host. Defaults to 8
* `CASSANDRA_INDEX_CACHE_MAX`: Maximum trace index metadata entries to cache. Zero disables caching. Defaults to 100000.
* `CASSANDRA_INDEX_CACHE_TTL`: How many seconds to cache index metadata about a trace. Defaults to 60.
* `CASSANDRA_INDEX_FETCH_MULTIPLIER`: How many more index rows to fetch than the user-supplied query limit. Defaults to 3.
</code></pre>
</div><p>Example usage with Cassandra with request logging (TRACE shows query values):</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>cassandra3 java -jar zipkin.jar <span>\</span>
--logging.level.com.datastax.oss.driver.internal.core.tracker.RequestLogger<span>=</span>DEBUG
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="elasticsearch-storage"> Elasticsearch Storage</h3>
<p>Zipkin's <a href="../zipkin-storage/elasticsearch">Elasticsearch storage component</a>
supports versions 5-7.x and applies when <code>STORAGE_TYPE</code> is set to <code>elasticsearch</code></p>
<p>The following apply when <code>STORAGE_TYPE</code> is set to <code>elasticsearch</code>:</p>
<div><pre><code>* `ES_HOSTS`: A comma separated list of elasticsearch base urls to connect to ex. http://host:9200.
              Defaults to &quot;http://localhost:9200&quot;.
* `ES_PIPELINE`: Indicates the ingest pipeline used before spans are indexed. No default.
* `ES_TIMEOUT`: Controls the connect, read and write socket timeouts (in milliseconds) for
                Elasticsearch API. Defaults to 10000 (10 seconds)
* `ES_INDEX`: The index prefix to use when generating daily index names. Defaults to zipkin.
* `ES_DATE_SEPARATOR`: The date separator to use when generating daily index names. Defaults to '-'.
* `ES_INDEX_SHARDS`: The number of shards to split the index into. Each shard and its replicas
                     are assigned to a machine in the cluster. Increasing the number of shards
                     and machines in the cluster will improve read and write performance. Number
                     of shards cannot be changed for existing indices, but new daily indices
                     will pick up changes to the setting. Defaults to 5.
* `ES_INDEX_REPLICAS`: The number of replica copies of each shard in the index. Each shard and
                       its replicas are assigned to a machine in the cluster. Increasing the
                       number of replicas and machines in the cluster will improve read
                       performance, but not write performance. Number of replicas can be changed
                       for existing indices. Defaults to 1. It is highly discouraged to set this
                       to 0 as it would mean a machine failure results in data loss.
* `ES_ENSURE_TEMPLATES`: Installs Zipkin index templates when missing. Setting this to false can
                         lead to corrupted data when index templates mismatch expectations. If
                         you set this to false, you choose to troubleshoot your own data or
                         migration problems as opposed to relying on the community for this.
                         Defaults to true.
* `ES_USERNAME` and `ES_PASSWORD`: Elasticsearch basic authentication, which defaults to empty string.
                                   Use when X-Pack security (formerly Shield) is in place.
* `ES_CREDENTIALS_FILE`: The location of a file containing Elasticsearch basic authentication
                         credentials, as properties. The username property is
                         `zipkin.storage.elasticsearch.username`, password `zipkin.storage.elasticsearch.password`.
                         This file is reloaded periodically, using `ES_CREDENTIALS_REFRESH_INTERVAL`
                         as the interval. This parameter takes precedence over ES_USERNAME and
                          ES_PASSWORD when specified.
* `ES_CREDENTIALS_REFRESH_INTERVAL`: Credentials refresh interval in seconds, which defaults to
                                     1 second. This is the maximum amount of time spans will drop due to stale
                                     credentials. Any errors reading the credentials file occur in logs at this rate.
* `ES_HTTP_LOGGING`: When set, controls the volume of HTTP logging of the Elasticsearch API.
                     Options are BASIC, HEADERS, BODY
* `ES_SSL_NO_VERIFY`: When true, disables the verification of server's key certificate chain.
                      This is not appropriate for production. Defaults to false.
* `ES_TEMPLATE_PRIORITY`: The priority value of the composable index templates. This is only applicable
                          for ES version 7.8 or above. Must be set, even to 0, to use composable template
</code></pre>
</div><p>Example usage:</p>
<p>To connect normally:</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch <span>ES_HOSTS</span><span>=</span>http://myhost:9200 java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><p>To log Elasticsearch API requests:</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch <span>ES_HTTP_LOGGING</span><span>=</span>BASIC java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h4 id="using-a-custom-key-store-or-trust-store-ssl"> Using a custom Key Store or Trust Store (SSL)</h4>
<p>If your Elasticsearch endpoint customized SSL configuration (for example self-signed) certificates,
you can use any of the following <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#T6" target="_blank" rel="noopener noreferrer">subset of JSSE properties<i>Content not supported</i></a> to connect.</p>
<ul>
<li>javax.net.ssl.keyStore</li>
<li>javax.net.ssl.keyStorePassword</li>
<li>javax.net.ssl.keyStoreType</li>
<li>javax.net.ssl.trustStore</li>
<li>javax.net.ssl.trustStorePassword</li>
<li>javax.net.ssl.trustStoreType</li>
</ul>
<p>Usage example:</p>
<div><pre><code>$ <span>JAVA_OPTS</span><span>=</span><span>'-Djavax.net.ssl.keyStore=keystore.p12 -Djavax.net.ssl.keyStorePassword=keypassword -Djavax.net.ssl.keyStoreType=PKCS12 -Djavax.net.ssl.trustStore=truststore.p12 -Djavax.net.ssl.trustStorePassword=trustpassword -Djavax.net.ssl.trustStoreType=PKCS12'</span>
$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch java <span>$JAVA_OPTS</span> -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Under the scenes, these map to properties prefixed <code>zipkin.storage.elasticsearch.ssl.</code>, which affect
the Armeria client used to connect to Elasticsearch.</p>
<p>The above properties allow the most common SSL setup to work out of box. If you need more
customization, please make a comment in <a href="https://github.com/openzipkin/zipkin/issues/2774" target="_blank" rel="noopener noreferrer">this issue<i>Content not supported</i></a>.</p>
<h4 id="automatic-index-creation"> Automatic Index Creation</h4>
<p>Zipkin will automatically create new indices as needed. Elasticsearch by default <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#index-creation" target="_blank" rel="noopener noreferrer">allows<i>Content not supported</i></a> automatic creation of said indices, though your local install may have been configured to disallow it. You can verify this in the cluster settings: <code>action.auto_create_index: false</code>.</p>
<h3 id="legacy-v1-storage-components"> Legacy (v1) storage components</h3>
<p>The following components are no longer encouraged, but exist to help aid
transition to supported ones. These are indicated as &quot;v1&quot; as they use
data layouts based on Zipkin's V1 Thrift model, as opposed to the
simpler v2 data model currently used.</p>
<h4 id="mysql-storage"> MySQL Storage</h4>
<p>Zipkin's <a href="../zipkin-storage/mysql-v1">MySQL component</a> is tested against MySQL
5.7 and applies when <code>STORAGE_TYPE</code> is set to <code>mysql</code>:</p>
<div><pre><code>* `MYSQL_DB`: The database to use. Defaults to &quot;zipkin&quot;.
* `MYSQL_USER` and `MYSQL_PASS`: MySQL authentication, which defaults to empty string.
* `MYSQL_HOST`: Defaults to localhost
* `MYSQL_TCP_PORT`: Defaults to 3306
* `MYSQL_MAX_CONNECTIONS`: Maximum concurrent connections, defaults to 10
* `MYSQL_USE_SSL`: Requires `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`, defaults to false.
</code></pre>
</div><p>Note: This module is not recommended for production usage. Before using this,
you must <a href="../zipkin-storage/mysql-v1#applying-the-schema">apply the schema</a>.</p>
<p>Alternatively you can use <code>MYSQL_JDBC_URL</code> and specify the complete JDBC url yourself. Note that the URL constructed by
using the separate settings above will also include the following parameters:
<code>?autoReconnect=true&amp;useSSL=false&amp;useUnicode=yes&amp;characterEncoding=UTF-8</code>. If you specify the JDBC url yourself, add
these parameters as well.</p>
<p>Example usage:</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>mysql <span>MYSQL_USER</span><span>=</span>root java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="throttled-storage-experimental"> Throttled Storage (Experimental)</h3>
<p>These settings can be used to help tune the rate at which Zipkin flushes data to another, underlying
<code>StorageComponent</code> (such as Elasticsearch):</p>
<div><pre><code>* `STORAGE_THROTTLE_ENABLED`: Enables throttling
* `STORAGE_THROTTLE_MIN_CONCURRENCY`: Minimum number of Threads to use for writing to storage.
* `STORAGE_THROTTLE_MAX_CONCURRENCY`: Maximum number of Threads to use for writing to storage.
* `STORAGE_THROTTLE_MAX_QUEUE_SIZE`: How many messages to buffer while all Threads are writing data before abandoning a message (0 = no buffering).
</code></pre>
</div><p>As this feature is experimental, it is not recommended to run this in production environments.</p>
<h2 id="collector-2"> Collector</h2>
<h3 id="http-collector"> HTTP Collector</h3>
<p>The HTTP collector is enabled by default. It accepts spans via <code>POST /api/v1/spans</code> and <code>POST /api/v2/spans</code>.
The HTTP collector supports the following configuration:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Environment Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zipkin.collector.http.enabled</code></td>
<td><code>COLLECTOR_HTTP_ENABLED</code></td>
<td><code>false</code> disables the HTTP collector. Defaults to <code>true</code>.</td>
</tr>
</tbody>
</table>
<h3 id="scribe-legacy-collector"> Scribe (Legacy) Collector</h3>
<p>A collector supporting Scribe is enabled when <code>COLLECTOR_SCRIBE_ENABLED=true</code>. New
sites are discouraged from using this collector as Scribe is an archived
technology.</p>
<table>
<thead>
<tr>
<th>Environment Variable</th>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_PORT</code></td>
<td><code>zipkin.collector.scribe.port</code></td>
<td>The port to listen for thrift RPC scribe requests. Defaults to 9410</td>
</tr>
<tr>
<td><code>SCRIBE_CATEGORY</code></td>
<td><code>zipkin.collector.scribe.category</code></td>
<td>Category zipkin spans will be consumed from. Defaults to <code>zipkin</code></td>
</tr>
</tbody>
</table>
<h3 id="activemq-collector"> ActiveMQ Collector</h3>
<p>The <a href="../zipkin-collector/activemq">ActiveMQ Collector</a> is enabled when <code>ACTIVEMQ_URL</code> is set to a v5.x broker. The following settings apply in this case.</p>
<table>
<thead>
<tr>
<th>Environment Variable</th>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_ACTIVEMQ_ENABLED</code></td>
<td><code>zipkin.collector.activemq.enabled</code></td>
<td><code>false</code> disables the ActiveMQ collector. Defaults to <code>true</code>.</td>
</tr>
<tr>
<td><code>ACTIVEMQ_URL</code></td>
<td><code>zipkin.collector.activemq.url</code></td>
<td><a href="https://activemq.apache.org/uri-protocols" target="_blank" rel="noopener noreferrer">Connection URL<i>Content not supported</i></a> to the ActiveMQ broker, ex. <code>tcp://localhost:61616</code> or <code>failover:(tcp://localhost:61616,tcp://remotehost:61616)</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_QUEUE</code></td>
<td><code>zipkin.collector.activemq.queue</code></td>
<td>Queue from which to collect span messages. Defaults to <code>zipkin</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_CLIENT_ID_PREFIX</code></td>
<td><code>zipkin.collector.activemq.client-id-prefix</code></td>
<td>Client ID prefix for queue consumers. Defaults to <code>zipkin</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_CONCURRENCY</code></td>
<td><code>zipkin.collector.activemq.concurrency</code></td>
<td>Number of concurrent span consumers. Defaults to <code>1</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_USERNAME</code></td>
<td><code>zipkin.collector.activemq.username</code></td>
<td>Optional username to connect to the broker</td>
</tr>
<tr>
<td><code>ACTIVEMQ_PASSWORD</code></td>
<td><code>zipkin.collector.activemq.password</code></td>
<td>Optional password to connect to the broker</td>
</tr>
</tbody>
</table>
<p>Example usage:</p>
<div><pre><code>$ <span>ACTIVEMQ_URL</span><span>=</span>tcp://localhost:61616 java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="kafka-collector"> Kafka Collector</h3>
<p>The Kafka collector is enabled when <code>KAFKA_BOOTSTRAP_SERVERS</code> is set to
a v0.10+ server. The following settings apply in this case. Some settings
correspond to &quot;New Consumer Configs&quot; in <a href="https://kafka.apache.org/documentation/#newconsumerconfigs" target="_blank" rel="noopener noreferrer">Kafka documentation<i>Content not supported</i></a>.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>New Consumer Config</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_KAFKA_ENABLED</code></td>
<td>N/A</td>
<td><code>false</code> disables the Kafka collector. Defaults to <code>true</code>.</td>
</tr>
<tr>
<td><code>KAFKA_BOOTSTRAP_SERVERS</code></td>
<td>bootstrap.servers</td>
<td>Comma-separated list of brokers, ex. 127.0.0.1:9092. No default</td>
</tr>
<tr>
<td><code>KAFKA_GROUP_ID</code></td>
<td>group.id</td>
<td>The consumer group this process is consuming on behalf of. Defaults to <code>zipkin</code></td>
</tr>
<tr>
<td><code>KAFKA_TOPIC</code></td>
<td>N/A</td>
<td>Comma-separated list of topics that zipkin spans will be consumed from. Defaults to <code>zipkin</code></td>
</tr>
<tr>
<td><code>KAFKA_STREAMS</code></td>
<td>N/A</td>
<td>Count of threads consuming the topic. Defaults to <code>1</code></td>
</tr>
</tbody>
</table>
<p>Example usage:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="other-kafka-consumer-properties"> Other Kafka consumer properties</h4>
<p>You may need to set other
<a href="https://kafka.apache.org/documentation/#newconsumerconfigs" target="_blank" rel="noopener noreferrer">Kafka consumer properties<i>Content not supported</i></a>, in
addition to the ones with explicit properties defined by the collector. In this case, you need to
prefix that property name with <code>zipkin.collector.kafka.overrides</code> and pass it as a system property
argument.</p>
<p>For example, to override <code>auto.offset.reset</code>, you can set a system property named
<code>zipkin.collector.kafka.overrides.auto.offset.reset</code>:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    java -Dzipkin.collector.kafka.overrides.auto.offset.reset<span>=</span>latest -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="detailed-examples"> Detailed examples</h4>
<p>Example targeting Kafka running in Docker:</p>
<div><pre><code>$ <span>export</span> <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span><span>$(</span>docker-machine <span>ip</span> `docker-machine active`<span>)</span></span>
<span># Run Kafka in the background</span>
$ docker run -d -p <span>9092</span>:9092 <span>\</span>
    --env <span>ADVERTISED_HOST</span><span>=</span><span>$KAFKA_BOOTSTRAP_SERVERS</span> <span>\</span>
    --env <span>AUTO_CREATE_TOPICS</span><span>=</span>true <span>\</span>
    spotify/kafka
<span># Start the zipkin server, which reads $KAFKA_BOOTSTRAP_SERVERS</span>
$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Multiple bootstrap servers:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span>broker1.local:9092,broker2.local:9092 <span>\</span>
    java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Alternate topic name(s):</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    java -Dzipkin.collector.kafka.topic<span>=</span>zapkin,zipken -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Specifying bootstrap servers as a system property, instead of an environment variable:</p>
<div><pre><code>$ java -Dzipkin.collector.kafka.bootstrap-servers<span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="rabbitmq-collector"> RabbitMQ collector</h3>
<p>The <a href="../zipkin-collector/rabbitmq">RabbitMQ collector</a> will be enabled when the <code>addresses</code> or <code>uri</code> for the RabbitMQ server(s) is set.</p>
<p>Example usage:</p>
<div><pre><code>$ <span>RABBIT_ADDRESSES</span><span>=</span>localhost java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="grpc-collector-experimental"> gRPC Collector (Experimental)</h3>
<p>You can enable a gRPC span collector endpoint by setting <code>COLLECTOR_GRPC_ENABLED=true</code>. The
<code>zipkin.proto3.SpanService/Report</code> endpoint will run on the same port as normal HTTP (9411).</p>
<p>Example usage:</p>
<div><pre><code>$ <span>COLLECTOR_GRPC_ENABLED</span><span>=</span>true java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><p>As this service is experimental, it is not recommended to run this in production environments.</p>
<h2 id="self-tracing"> Self-Tracing</h2>
<p>Self tracing exists to help troubleshoot performance of the zipkin-server. Production deployments
who enable self-tracing should lower the sample rate from 1.0 (100%) to a much smaller rate, like
0.001 (0.1% or 1 out of 1000).</p>
<p>When <code>zipkin.self-tracing.enabled=true</code>, Zipkin will self-trace calls to the API under the service
name &quot;zipkin-server&quot;.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELF_TRACING_ENABLED</td>
<td>zipkin.self-tracing.enabled</td>
<td>Set to true to enable self-tracing. Defaults to false</td>
</tr>
<tr>
<td>SELF_TRACING_SAMPLE_RATE</td>
<td>zipkin.self-tracing.sample-rate</td>
<td>Percentage of self-traces to retain, defaults to always sample (1.0).</td>
</tr>
<tr>
<td>SELF_TRACING_FLUSH_INTERVAL</td>
<td>zipkin.self-tracing.flush-interval</td>
<td>Interval in seconds to flush self-tracing data to storage. Defaults to 1</td>
</tr>
</tbody>
</table>
<h3 id="_128-bit-trace-ids"> 128-bit trace IDs</h3>
<p>Zipkin supports 64 and 128-bit trace identifiers, typically serialized
as 16 or 32 character hex strings. By default, spans reported to zipkin
with the same trace ID will be considered in the same trace.</p>
<p>For example, <code>463ac35c9f6413ad48485a3953bb6124</code> is a 128-bit trace ID,
while <code>48485a3953bb6124</code> is a 64-bit one.</p>
<p>Note: Span (or parent) IDs within a trace are 64-bit regardless of the
length or value of their trace ID.</p>
<h4 id="migrating-from-64-to-128-bit-trace-ids"> Migrating from 64 to 128-bit trace IDs</h4>
<p>Unless you only issue 128-bit traces when all applications support them,
the process of updating applications from 64 to 128-bit trace IDs results
in a mixed state. This mixed state is mitigated by the setting
<code>STRICT_TRACE_ID=false</code>, explained below. Once a migration is complete,
remove the setting <code>STRICT_TRACE_ID=false</code> or set it to true.</p>
<p>Here are a few trace IDs the help what happens during this setting.</p>
<ul>
<li>Trace ID A: 463ac35c9f6413ad48485a3953bb6124</li>
<li>Trace ID B: 48485a3953bb6124</li>
<li>Trace ID C: 463ac35c9f6413adf1a48a8cff464e0e</li>
<li>Trace ID D: 463ac35c9f6413ad</li>
</ul>
<p>In a 64-bit environment, trace IDs will look like B or D above. When an
application upgrades to 128-bit instrumentation and decides to create a
128-bit trace, its trace IDs will look like A or C above.</p>
<p>Applications who aren't yet 128-bit capable typically only retain the
right-most 16 characters of the trace ID. When this happens, the same
trace could be reported as trace ID A or trace ID B.</p>
<p>By default, Zipkin will think these are different trace IDs, as they are
different strings. During a transition from 64-128 bit trace IDs, spans
would appear split across two IDs. For example, it might start as trace
ID A, but the next hop might truncate it to trace ID B. This would render
the system unusable for applications performing upgrades.</p>
<p>One way to address this problem is to not use 128-bit trace IDs until
all applications support them. This prevents a mixed scenario at the cost
of coordination. Another way is to set <code>STRICT_TRACE_ID=false</code>.</p>
<p>When <code>STRICT_TRACE_ID=false</code>, only the right-most 16 of a 32 character
trace ID are considered when grouping or retrieving traces. This setting
should only be applied when transitioning from 64 to 128-bit trace IDs
and removed once the transition is complete.</p>
<p>See https://github.com/openzipkin/b3-propagation/issues/6 for the status
of known open source libraries on 128-bit trace identifiers.</p>
<p>See <code>zipkin2.storage.StorageComponent.Builder</code> for even more details!</p>
<h2 id="tls-ssl"> TLS/SSL</h2>
<p>Zipkin-server can be made to run with TLS if needed:</p>
<div><pre><code><span># assuming you generate the key like this</span>
keytool -genkeypair -alias mysite -keyalg RSA -keysize <span>2048</span> -storetype PKCS12 -keystore zipkin.p12 -validity <span>3650</span>

java -jar zipkin.jar --armeria.ssl.key-store<span>=</span>zipkin.p12 --armeria.ssl.key-store-type<span>=</span>PKCS12 --armeria.ssl.key-store-password<span>=</span><span>123123</span> --armeria.ssl.key-alias<span>=</span>mysite  --armeria.ssl.enabled<span>=</span>true --armeria.ports<span>[</span><span>0</span><span>]</span>.port<span>=</span><span>9411</span> --armeria.ports<span>[</span><span>0</span><span>]</span>.protocols<span>[</span><span>0</span><span>]</span><span>=</span>https
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="running-with-docker"> Running with Docker</h2>
<p>Released versions of zipkin-server are published to Docker Hub as <code>openzipkin/zipkin</code>.
See <a href="https://github.com/openzipkin/docker-zipkin" target="_blank" rel="noopener noreferrer">docker-zipkin<i>Content not supported</i></a> for details.</p>
<h2 id="building-locally"> Building locally</h2>
<p>To build and run the server from the currently checked out source, enter the following.</p>
<div><pre><code><span># Build the server and also make its dependencies</span>
$ ./mvnw -T1C -q --batch-mode -DskipTests --also-make -pl zipkin-server clean package
<span># Run the server</span>
$ java -jar ./zipkin-server/target/zipkin-server-*exec.jar
<span># or Run the slim server</span>
$ java -jar ./zipkin-server/target/zipkin-server-*slim.jar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Zipkin</title>
      <link>https://list-jiang.github.io/spring/track/zipkin/start-env/</link>
      <guid>https://list-jiang.github.io/spring/track/zipkin/start-env/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Zipkin</source>
      <pubDate>Thu, 24 Feb 2022 06:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="zipkin-server"> zipkin-server</h1>
<p>Zipkin Server 是一个 Java 1.8+ 服务，打包为一个可执行的 jar。 跨度存储和收集器是可配置的。默认情况下，存储在内存中，启用 HTTP 收集器（POST /api/v2/spans 端点），服务器侦听端口 9411。 Zipkin Server 使用 <a href="https://github.com/line/armeria" target="_blank" rel="noopener noreferrer">Armeria<i>Content not supported</i></a> 实现。 虽然它在内部使用 Spring Boot  （打开新窗口）
，不应将 Zipkin Server 视为普通的 <a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener noreferrer">Spring Boot<i>Content not supported</i></a> 应用程序。</p>
<h2 id="不支持自定义服务器"> 不支持自定义服务器</h2>
<p>不支持通过类似于 spring boot 应用程序添加 <code>zipkin-server</code> 引用这种方式来构建服务。</p>
<h2 id="快速启动"> 快速启动</h2>
<p>最快的上手方式是通过 <a href="https://search.maven.org/remote_content?g=io.zipkin&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec" target="_blank" rel="noopener noreferrer">最新 jar 发布服务器<i>Content not supported</i></a> 获取一个独立的可执行jar。请注意，Zipkin 服务器需要最低 JRE 8。</p>
<div><pre><code>$ <span>curl</span> -sSL https://zipkin.io/quickstart.sh <span>|</span> <span>bash</span> -s
$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>启动后，浏览 http://your_host:9411 验证</p>
<h2 id="端点"> 端点</h2>
<p>以下端点在服务基础url http://your_host:9411 下定义</p>
<ul>
<li>/ - <a href="../zipkin-ui">UI</a></li>
<li>/config.json - UI 配置</li>
<li>/api/v2 - <a href="https://zipkin.io/zipkin-api/#/" target="_blank" rel="noopener noreferrer">API<i>Content not supported</i></a></li>
<li>/health - 如果正常则返回 200</li>
<li>/info - 提供正在运行的实例的版本</li>
<li>/metrics - 包括按传输类型细分的收集器指标</li>
<li>/prometheus - Prometheus 抓取端点</li>
</ul>
<p><a href="https://zipkin.io/zipkin-api/#/" target="_blank" rel="noopener noreferrer">旧版 /api/v1 API<i>Content not supported</i></a> 仍然支持。后端通过数据转换与 HTTP API 分离。这意味着您仍然可以在新后端接受旧数据，反之亦然。进入 <code>https://zipkin.io/zipkin-api/zipkin-api.yaml</code> Swagger UI 的探索框查看旧定义</p>
<h3 id="cors-跨域资源共享"> CORS（跨域资源共享）</h3>
<p>默认情况下，所有端点 <code>/api/v2</code> 都配置为允许跨域请求。</p>
<p>这可以通过修改 <code>zipkin.query.allowed-origins</code> 属性来改变。</p>
<p>例如，要允许来自 <code>http://foo.bar.com</code> 域名下的 CORS 请求：</p>
<div><pre><code>ZIPKIN_QUERY_ALLOWED_ORIGINS=http://foo.bar.com
</code></pre>
<div><span>1</span><br></div></div><p>更多的相关配置请看  。</p>
<h3 id="服务和跨度名称查询"> 服务和跨度名称查询</h3>
<p>Zipkin <a href="https://zipkin.io/zipkin-api/#/default/get_services" target="_blank" rel="noopener noreferrer">API<i>Content not supported</i></a> 不包括返回多远查找服务或跨度名称的参数。为了防止负载过大，服务和跨度名称查询通过配置
<code>QUERY_LOOKBACK</code> 限制，默认为24小时（每天两个桶：今天一个，昨天一个）</p>
<h2 id="日志"> 日志</h2>
<p>默认情况下， zipkin 以 INFO 或更高级别将日志写入控制台。所以可以通过配置  <code>logging.level.XXX</code> 属性调整日志级别</p>
<p>例如，如果您想为所有 zipkin 类别启用调试日志记录，您可以像这样启动服务器：</p>
<div><pre><code>$ java -jar zipkin.jar --logging.level.zipkin2<span>=</span>DEBUG
</code></pre>
<div><span>1</span><br></div></div><p>更多的相关配置请看  。</p>
<h3 id="高级日志配置"> 高级日志配置</h3>
<p>实际上，服务器使用 <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html#howto-configure-logback-for-logging" target="_blank" rel="noopener noreferrer">Spring Boot - Logback集成<i>Content not supported</i></a> 处理日志，所以可以通过配置 <code>--logging.exception-conversion-word=%wEx{full}</code> 转储完整堆栈跟踪而不是截断的跟踪。</p>
<h2 id="metrics"> Metrics</h2>
<p>收集器指标被导出到路径 <code>/metrics</code> 。这些和其他指标被导出到路径 <code>/prometheus</code> 。</p>
<h3 id="示例-prometheus-配置"> 示例 Prometheus 配置</h3>
<p>Here's an example <code>/prometheus</code> configuration, using the Prometheus
exposition [text format version 0.0.4]</p>
<p>这是一个示例 <code>/prometheus</code> 配置，使用 Prometheus exposition<a href="https://prometheus.io/docs/instrumenting/exposition_formats/" target="_blank" rel="noopener noreferrer">文本格式版本 0.0.4<i>Content not supported</i></a></p>
<div><pre><code>  <span>-</span> <span>job_name</span><span>:</span> <span>'zipkin'</span>
    <span>scrape_interval</span><span>:</span> 5s
    <span>metrics_path</span><span>:</span> <span>'/prometheus'</span>
    <span>static_configs</span><span>:</span>
      <span>-</span> <span>targets</span><span>:</span> <span>[</span><span>'localhost:9411'</span><span>]</span>
    <span>metric_relabel_configs</span><span>:</span>
      <span># Response code count</span>
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'${1}'</span>
        <span>target_label</span><span>:</span> status
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'${2}'</span>
        <span>target_label</span><span>:</span> path
      <span>-</span> <span>source_labels</span><span>:</span> <span>[</span>__name__<span>]</span>
        <span>regex</span><span>:</span> <span>'^status_(\d+)_(.*)$'</span>
        <span>replacement</span><span>:</span> <span>'http_requests_total'</span>
        <span>target_label</span><span>:</span> __name__
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="收集器"> 收集器</h3>
<p>Metric 收集器按传输细分。以下内容被导出到 <code>/metrics</code> 端点：</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>counter.zipkin_collector.messages.$transport</td>
<td>收到的累积消息；应该与检测应用程序报告的消息相关</td>
</tr>
<tr>
<td>counter.zipkin_collector.messages_dropped.$transport</td>
<td>累积消息丢弃；原因包括客户端断开连接或格式错误的内容</td>
</tr>
<tr>
<td>counter.zipkin_collector.bytes.$transport</td>
<td>累积消息字节</td>
</tr>
<tr>
<td>counter.zipkin_collector.spans.$transport</td>
<td>累积跨度读取；应该与检测应用程序报告的消息相关</td>
</tr>
<tr>
<td>counter.zipkin_collector.spans_dropped.$transport</td>
<td>累积跨度下降；原因包括采样或存储故障</td>
</tr>
<tr>
<td>gauge.zipkin_collector.message_spans.$transport</td>
<td>消息中的最后一个跨度计数</td>
</tr>
<tr>
<td>gauge.zipkin_collector.message_bytes.$transport</td>
<td>消息中的最后一个字节数</td>
</tr>
</tbody>
</table>
<h2 id="配置"> 配置</h2>
<p>我们支持 ENV 变量配置，例如 <code>STORAGE_TYPE=cassandra3</code> ，因为它们为管理员所熟悉，并且易于在 Docker 等运行时环境中使用</p>
<p>以下是 Zipkin 的顶层配置：</p>
<ul>
<li><code>QUERY_PORT</code>: HTTP API 和 Web UI 的监听端口；默认为 <code>9411</code></li>
<li><code>QUERY_ENABLED</code>: 配置 <code>false</code> 禁用 '/api/v2' 端点。这也会导致 UI 不可用，因为 UI 依赖于 API。 如果您的唯一目标是限制搜索, 请配置 <code>SEARCH_ENABLED</code> 为 <code>false</code></li>
<li><code>SEARCH_ENABLED</code>: <code>false</code> 禁用查询 API 中的搜索以及收集器中的任何索引或后处理以支持搜索。这不会禁用整个 UI ，因为按 ID 和依赖项查询的跟踪仍在运行。当您使用其他服务（例如日志）来查找跟踪 ID 时禁用此功能。默认为 true</li>
<li><code>QUERY_TIMEOUT</code>: 设置查询请求的硬超时。接受任何持续时间字符串（例如， <code>100ms</code> ）。值 <code>0</code> 将完全禁用超时。默认为 <code>11s</code> 。</li>
<li><code>QUERY_LOG_LEVEL</code>: 写入控制台的日志级别；默认为 <code>INFO</code></li>
<li><code>QUERY_NAMES_MAX_AGE</code>: 控制 zipkin-server 对 UI 请求的最大响应时间。默认为 300 秒。</li>
<li><code>QUERY_LOOKBACK</code>: 从 endTs 可以回溯多少毫秒查询；默认为 24​​ 小时（每天两个时段：今天一个，昨天一个）</li>
<li><code>STORAGE_TYPE</code>: SpanStore 实现: <code>mem</code>, <code>mysql</code>, <code>cassandra3</code>, <code>elasticsearch</code> 中取一个</li>
<li><code>COLLECTOR_SAMPLE_RATE</code>: 保留的记录道百分比，默认为“始终采样”（1.0）。</li>
<li><code>AUTOCOMPLETE_KEYS</code>: 会通过 <code>/api/v2/autocompleteTags</code> 端点返回的跨度标签键列表；标签键应以逗号分隔，例如 &quot;instance_id,user_id,env&quot;</li>
<li><code>AUTOCOMPLETE_TTL</code>: 以毫秒为单位抑制调用写入相同的自动完成键/值对的时间。默认 3600000（1 小时）</li>
</ul>
<h3 id="配置文件覆盖"> 配置文件覆盖</h3>
<p>在场景下，所有配置都由 Spring Boot 管理。这意味着属性也可能被系统属性或 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" target="_blank" rel="noopener noreferrer">Spring Boot<i>Content not supported</i></a> 支持的任何其他替代方案覆盖</p>
<p>我们使用 yaml 配置将更短或更惯用的 ENV 变量绑定到最终使用的 Spring 属性。虽然大多数用户应该只使用环境变量，但有些用户可能希望使用属性文件方法来覆盖设置。例如，知道我们设置 <code>spring.config.name=zipkin-server</code> 了 ，Spring Boot 会自动在当前目录中查找一个名为的文件 <code>zipkin-server.properties</code> ，并且可以通过这种方式覆盖我们在 yaml 中设置的相同属性。</p>
<p>如果您选择使用基于属性的配置而不是 ENV 变量，那么您就是在自定义配置。这意味着您将使用 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" target="_blank" rel="noopener noreferrer">Spring Boot 文档<i>Content not supported</i></a> 或 <a href="https://stackoverflow.com/questions/tagged/spring-boot" target="_blank" rel="noopener noreferrer">堆栈溢出<i>Content not supported</i></a> 解决参数配置问题，而不是提出问题或使用我们的聊天支持。我们必须提到这一点，因为 Spring 的配置通常消耗资源很大，我们必须为 Zipkin 相关任务尽可能节省资源。</p>
<h2 id="ui"> UI</h2>
<p>Zipkin 有一个 Web UI，自动包含在 exec jar 中，默认托管在端口 9411 上。</p>
<p>当 UI 加载时，它会从 <code>/config.json</code> 端点读取默认配置。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>zipkin.ui.environment</td>
<td>这里的值变成右上角的标签。非必填</td>
</tr>
<tr>
<td>defaultLookback</td>
<td>zipkin.ui.default-lookback</td>
<td>查找跟踪时回溯的默认持续时间（以毫秒为单位）。影响 UI 中的“开始时间”元素。默认为 900000（以毫秒为单位的 15 分钟）</td>
</tr>
<tr>
<td>searchEnabled</td>
<td>zipkin.ui.search-enabled</td>
<td>如果启用了 Discover 屏幕。默认为真</td>
</tr>
<tr>
<td>queryLimit</td>
<td>zipkin.ui.query-limit</td>
<td>查找 track 的默认限制。默认为 10</td>
</tr>
<tr>
<td>instrumented</td>
<td>zipkin.ui.instrumented</td>
<td>此 Zipkin UI 涵盖哪些站点,正则表达式语法案例 <code>http:\/\/example.com\/.*</code> ，默认 (<code>.*</code>) 包含所有站点</td>
</tr>
<tr>
<td>logsUrl</td>
<td>zipkin.ui.logs-url</td>
<td>记录查询服务 url 模式。如果指定，将在跟踪页面上显示一个按钮，并将 URL 中的 {traceId} 替换为 traceId。非必填</td>
</tr>
<tr>
<td>supportUrl</td>
<td>zipkin.ui.support-url</td>
<td>用户可以请求支持的 URL。如果指定，将在侧面菜单中放置指向此 URL 的链接，例如用于提交支持票的页面。非必填</td>
</tr>
<tr>
<td>archivePostUrl</td>
<td>zipkin.ui.archive-post-url</td>
<td>以 Zipkin v2 json 格式发布当前跟踪的 URL。例如 <code>https://longterm/api/v2/spans</code> 。如果指定，一个按钮将相应地出现在跟踪页面上。非必填</td>
</tr>
<tr>
<td>archiveUrl</td>
<td>zipkin.ui.archive-url</td>
<td>提供归档跟踪的 Web 应用程序的 URL，以“{traceId}”为模板。例如 <code>https://longterm/zipkin/trace/{traceId}</code> 。跟踪成功发布到“archivePostUrl”后，确认消息中会显示此信息.非必填</td>
</tr>
<tr>
<td>dependency.enabled</td>
<td>zipkin.ui.dependency.enabled</td>
<td>UI 依赖项展示是否启用. 默认为 true</td>
</tr>
<tr>
<td>dependency.lowErrorRate</td>
<td>zipkin.ui.dependency.low-error-rate</td>
<td>依赖项链接变黄的错误率阈值。默认值为 0.5 (50%) 设置为 &gt;1 以禁用</td>
</tr>
<tr>
<td>dependency.highErrorRate</td>
<td>zipkin.ui.dependency.high-error-rate</td>
<td>依赖项链接变红的错误率阈值。默认值为 0.75 (75%) 设置为 &gt;1 以禁用</td>
</tr>
<tr>
<td>basePath</td>
<td>zipkin.ui.basepath</td>
<td>放置在 UI HTML 标签中的路径前缀；在反向代理后面运行时很有用。默认 <code>/zipkin</code></td>
</tr>
</tbody>
</table>
<p>要将属性映射到环境变量，请将它们更改为大写下划线格式。例如，如果使用 docker，您可以设置 ZIPKIN_UI_QUERY_LIMIT=100 相当于 <code>$.queryLimit</code> 在 <code>/config.json</code></p>
<h3 id="跟踪存档"> 跟踪存档</h3>
<p>大多数生产 Zipkin 集群使用有限的 TTL 存储跟踪。这使得共享跟踪有点不方便，因为它的链接将在几天后过期。</p>
<p>&quot;跟踪归档&quot; 功能对此有所帮助。启动第二个 zipkin 服务器，指向一个比常规的 TTL 更长的存储，并设置 archivePostUrl 和 archiveUrl UI 配置指向这第二个服务器。设置 archivePostUrl 后，跟踪视图页面上将出现一个新的 &quot;Archive Trace&quot; 按钮。</p>
<h2 id="存储"> 存储</h2>
<h3 id="基于内存存储"> 基于内存存储</h3>
<p>Zipkin 的 <a href="../zipkin/src/main/java/zipkin2/storage/InMemoryStorage.java">内存存储</a> 将所有数据保存在内存中，根据跨度限制清除旧数据。它适用于 <code>STORAGE_TYPE</code> 未设置或设置为 mem</p>
<blockquote>
<ul>
<li><code>MEM_MAX_SPANS</code>: 超过此限制时，将首先清除最旧的记录道（及其跨度）。默认为 500000</li>
</ul>
</blockquote>
<p>示例用法：</p>
<div><pre><code>$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><div><p>警告</p>
<p>注意：这个存储组件主要是为测试而开发的，也是一种在没有外部依赖的情况下快速启动和运行 Zipkin 服务器的方法。它对于高工作量是不可行的。也就是说，如果您遇到内存不足错误，请尝试减少 MEM_MAX_SPANS 或增加堆大小 (-Xmx)。 将内存中保存的跨度数量加倍的示例：</p>
<p>将内存中保存的跨度数量加倍的示例：</p>
<div><pre><code>$ <span>MEM_MAX_SPANS</span><span>=</span><span>1000000</span> java -Xmx1G -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div></div>
<h3 id="cassandra-存储"> Cassandra 存储</h3>
<p>Zipkin 的 Cassandra 存储组件支持 3.11.3+ 版本</p>
<div><p>Cassandra 相关配置</p>
<p><strong>当 <code>STORAGE_TYPE</code> 设置为 <code>cassandra3</code> 时，以下配置生效：</strong></p>
<p><code>CASSANDRA_KEYSPACE</code>: 要使用的键空间，默认为： &quot;zipkin2&quot;
<code>CASSANDRA_CONTACT_POINTS</code>: 以逗号分隔的主机地址列表配置 Cassandra 集群。还可以使用 <code>host:port</code> 指定自定义端口。默认为本地主机上的 9042 端口。
<code>CASSANDRA_LOCAL_DC</code>: 将被视为负载平衡的 local 数据中心的名称。默认为 datacenter1
<code>CASSANDRA_ENSURE_SCHEMA</code>: 确保 cassandra 使用最新模式。如果启用则尝试执行以 <code>cassandra-schema-cql3</code> 的前缀的脚本. 默认为 true
<code>CASSANDRA_USERNAME</code>：Cassandra 认证账号
<code>CASSANDRA_PASSWORD</code>: Cassandra 认证密码，如果认真失败会抛出错误，未设置默认值。
<code>CASSANDRA_USE_SSL</code>: 需要 <code>javax.net.ssl.trustStore</code> 和 <code>javax.net.ssl.trustStorePassword</code>, 默认为 false.</p>
<p><strong>以下是可能不涉及所有用户的调整参数：</strong></p>
<ul>
<li><code>CASSANDRA_MAX_CONNECTIONS</code>: 每个数据中心本地主机的最大池连接数。默认为8</li>
<li><code>CASSANDRA_INDEX_CACHE_MAX</code>: 要缓存的最大跟踪索引元数据项。零禁用缓存。默认值为100000。</li>
<li><code>CASSANDRA_INDEX_CACHE_TTL</code>: 缓存跟踪的索引元数据需要多少秒。默认值为60。</li>
<li><code>CASSANDRA_INDEX_FETCH_MULTIPLIER</code>: 要获取的索引行比用户提供的查询限制多多少。默认为3。</li>
</ul>
</div>
<p>使用 Cassandra 和请求日志记录的示例用法（TRACE 显示查询值）：</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>cassandra3 java -jar zipkin.jar <span>\</span>
--logging.level.com.datastax.oss.driver.internal.core.tracker.RequestLogger<span>=</span>DEBUG
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="elasticsearch-存储"> Elasticsearch 存储</h3>
<p>Zipkin 的 Elasticsearch 存储组件支持 5-7.x 版本</p>
<div><p>Elasticsearch 相关配置</p>
<h2 id="当-storage-type-设置为-elasticsearch-时-以下配置生效"> <strong>当 <code>STORAGE_TYPE</code> 设置为 <code>elasticsearch</code> 时，以下配置生效：</strong></h2>
<ul>
<li><code>ES_HOSTS</code>: 以逗号分隔的 elasticsearch 连接 url 列表，默认值为： &quot;http://localhost:9200&quot;</li>
<li><code>ES_PIPELINE</code>: 指示为跨距编制索引之前使用的摄取管道，无默认值</li>
<li><code>ES_TIMEOUT</code>: 配置 Elasticsearch API 的连接、读写超时时间，默认值为 10000 (10秒)</li>
<li><code>ES_INDEX</code>: 生成每日索引名称时要使用的索引前缀，默认值为： zipkin.</li>
<li><code>ES_DATE_SEPARATOR</code>: 生成每日索引名称时要使用的日期分隔符，默认值为： '-' .</li>
<li><code>ES_INDEX_SHARDS</code>: 索引分片数。每个碎片及其副本分配给群集中的一台机器。增加碎片的数量集群中的机器将提高读写性能。无法更改现有索引的碎片数量，但可以更改新的每日索引。默认为 5</li>
<li><code>ES_INDEX_REPLICAS</code>: 索引碎片副本数。相对条件下数值越大读性能越好，写性能越差。默认值为 1 。设置为 0 意味着机器故障很大可能会导致数据丢失。</li>
<li><code>ES_ENSURE_TEMPLATES</code>: 缺失时安装Zipkin索引模板。将此设置为 false ，当索引模板与预期不匹配时，会导致数据损坏。如果如果将其设置为 true ，则会自动处理数据故障或迁移问题，而不是依靠人工手动来解决。默认为true</li>
<li><code>ES_USERNAME</code> and <code>ES_PASSWORD</code>: Elasticsearch基本身份验证，默认为空字符串。当X-Pack安全（以前称为Shield）就位时使用。</li>
<li><code>ES_CREDENTIALS_FILE</code>: ES 认证凭据文件位置, 包含以下属性，该文件优先级大于 ES_USERNAME 与 ES_PASSWORD 配置
<ul>
<li><code>zipkin.storage.elasticsearch.username</code>：用户名</li>
<li><code>zipkin.storage.elasticsearch.password</code>：密码</li>
</ul>
</li>
<li><code>ES_CREDENTIALS_REFRESH_INTERVAL</code>: 定期刷新 <code>ES_CREDENTIALS_FILE</code> 文件周期（单位：秒），默认值为：1</li>
<li><code>ES_HTTP_LOGGING</code>: 设置后，配置 Elasticsearch API 的 HTTP 日志记录，包含：Options are BASIC, HEADERS, BODY</li>
<li><code>ES_SSL_NO_VERIFY</code>: 如果为true，则禁用服务器密钥证书链的验证。这不适合生产。默认为false。</li>
<li><code>ES_TEMPLATE_PRIORITY</code>: 可组合索引模板的优先级值。这仅适用于ES 7.8或更高版本。必须设置为0才能使用可组合模板</li>
</ul>
</div>
<p>使用示例：</p>
<p>简单连接 ES :</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch <span>ES_HOSTS</span><span>=</span>http://myhost:9200 java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><p>记录 ES http 请求日志:</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch <span>ES_HTTP_LOGGING</span><span>=</span>BASIC java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h4 id="使用自定义密钥库或信任库-ssl"> 使用自定义密钥库或信任库 (SSL)</h4>
<p>如果您的 Elasticsearch 端点自定义 SSL 配置（例如自签名）证书，您可以使用以下任何 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#T6" target="_blank" rel="noopener noreferrer">JSSE 属性子集<i>Content not supported</i></a> 连接。</p>
<ul>
<li>javax.net.ssl.keyStore</li>
<li>javax.net.ssl.keyStorePassword</li>
<li>javax.net.ssl.keyStoreType</li>
<li>javax.net.ssl.trustStore</li>
<li>javax.net.ssl.trustStorePassword</li>
<li>javax.net.ssl.trustStoreType</li>
</ul>
<p>使用示例：</p>
<div><pre><code>$ <span>JAVA_OPTS</span><span>=</span><span>'-Djavax.net.ssl.keyStore=keystore.p12 -Djavax.net.ssl.keyStorePassword=keypassword -Djavax.net.ssl.keyStoreType=PKCS12 -Djavax.net.ssl.trustStore=truststore.p12 -Djavax.net.ssl.trustStorePassword=trustpassword -Djavax.net.ssl.trustStoreType=PKCS12'</span>
$ <span>STORAGE_TYPE</span><span>=</span>elasticsearch java <span>$JAVA_OPTS</span> -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在该场景下，这些映射到属性 <code>prefixed zipkin.storage.elasticsearch.ssl.</code>，这会影响用于连接到 Elasticsearch 的 Armeria 客户端。</p>
<p>上述属性允许最常见的 SSL 开箱即用的设置。如果您需要更多定制，请提交 <a href="https://github.com/openzipkin/zipkin/issues/2774" target="_blank" rel="noopener noreferrer">issue<i>Content not supported</i></a></p>
<h4 id="自动创建索引"> 自动创建索引</h4>
<p>当需要的时候 Zipkin 自动创建 ES 索引。 Elasticsearch 默认 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#index-creation" target="_blank" rel="noopener noreferrer">允许<i>Content not supported</i></a> 自动创建索引, 你可以在集群中验证这个设置: <code>action.auto_create_index: false</code>.</p>
<h4 id="mysql-存储"> MySQL 存储</h4>
<p>Zipkin 的 MySQL 存储组件支持 5.7 版本
当 <code>STORAGE_TYPE</code> 设置为 <code>mysql</code> 时，以下属性生效：</p>
<ul>
<li><code>MYSQL_DB</code>: MySQL 使用数据库，默认为 &quot;zipkin&quot;.</li>
<li><code>MYSQL_USER</code> and <code>MYSQL_PASS</code>: MySQL 认证信息, 默认值为空.</li>
<li><code>MYSQL_HOST</code>: 默认值为 localhost</li>
<li><code>MYSQL_TCP_PORT</code>: 默认值为 3306</li>
<li><code>MYSQL_MAX_CONNECTIONS</code>:  MySQL 最大连接数, defaults to 10</li>
<li><code>MYSQL_USE_SSL</code>: 需要 <code>javax.net.ssl.trustStore</code> and <code>javax.net.ssl.trustStorePassword</code>, 默认为 false.</li>
</ul>
<p>注意：不建议将此模块用于生产用途。使用前，需要进行以下环境配置：</p>
<div><pre><code><span># Barracuda supports compression (In AWS RDS, this must be assigned in a parameter group)</span>
$ mysql -uroot -e <span>"SET GLOBAL innodb_file_format=Barracuda"</span>
<span># This command should work even in RDS, and return "Barracuda"</span>
$ mysql -uroot -e <span>"show global variables like 'innodb_file_format'"</span>

<span># install the schema and indexes</span>
<span># sql 文件获取：https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql</span>
$ mysql -uroot -e <span>"create database if not exists zipkin"</span>
$ mysql -uroot -Dzipkin <span>&lt;</span> zipkin-storage/mysql-v1/src/main/resources/mysql.sql
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>或者，您可以 <code>MYSQL_JDBC_URL</code> 自己使用并指定完整的 JDBC url。请注意，使用上述单独设置构建的 URL 还将包含以下参数： <code>?autoReconnect=true&amp;useSSL=false&amp;useUnicode=yes&amp;characterEncoding=UTF-8</code>。</p>
<p>示例用法：</p>
<div><pre><code>$ <span>STORAGE_TYPE</span><span>=</span>mysql <span>MYSQL_USER</span><span>=</span>root java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="throttled-存储-实验性"> Throttled 存储 (实验性)</h3>
<p>这些设置可用于帮助调整 Zipkin 将数据刷新到另一个底层 <code>StorageComponent</code> （例如 Elasticsearch）的速率：</p>
<ul>
<li><code>STORAGE_THROTTLE_ENABLED</code>: Enables throttling</li>
<li><code>STORAGE_THROTTLE_MIN_CONCURRENCY</code>: Minimum number of Threads to use for writing to storage.</li>
<li><code>STORAGE_THROTTLE_MAX_CONCURRENCY</code>: Maximum number of Threads to use for writing to storage.</li>
<li><code>STORAGE_THROTTLE_MAX_QUEUE_SIZE</code>: How many messages to buffer while all Threads are writing data before abandoning a message (0 = no buffering).</li>
</ul>
<p>由于此功能是实验性的，因此不建议在生产环境中运行此功能。</p>
<h2 id="收集器-2"> 收集器</h2>
<h3 id="http-收集器"> HTTP 收集器</h3>
<p>HTTP 收集器默认启用。 他支持 <code>POST /api/v1/spans</code> and <code>POST /api/v2/spans</code>.
HTTP 收集器默支持以下配置:</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_HTTP_ENABLED</code></td>
<td><code>zipkin.collector.http.enabled</code></td>
<td><code>false</code> 禁用 HTTP 收集器。默认为 <code>true</code></td>
</tr>
</tbody>
</table>
<h3 id="scribe-legacy-collector"> Scribe (Legacy) Collector</h3>
<p>支持 Scribe 的收集器在 <code>COLLECTOR_SCRIBE_ENABLED=true</code> 时启用. 不鼓励新站点使用此收集器，因为 Scribe 是一种存档技术。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_PORT</code></td>
<td><code>zipkin.collector.scribe.port</code></td>
<td>监听 thrift RPC scribe 请求的端口。默认为 9410</td>
</tr>
<tr>
<td><code>SCRIBE_CATEGORY</code></td>
<td><code>zipkin.collector.scribe.category</code></td>
<td>类别 zipkin 将从中消耗。默认为 <code>zipkin</code></td>
</tr>
</tbody>
</table>
<h3 id="activemq-收集器"> ActiveMQ 收集器</h3>
<p>Zipkin 的 ActiveMQ 收集器组件支持 v5.x 版本，当配置 <code>ACTIVEMQ_URL</code> 值时启用，支持以下属性配置</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_ACTIVEMQ_ENABLED</code></td>
<td><code>zipkin.collector.activemq.enabled</code></td>
<td><code>false</code> 禁用 ActiveMQ 收集器。默认为 <code>true</code>.</td>
</tr>
<tr>
<td><code>ACTIVEMQ_URL</code></td>
<td><code>zipkin.collector.activemq.url</code></td>
<td><a href="https://activemq.apache.org/uri-protocols" target="_blank" rel="noopener noreferrer">Connection URL<i>Content not supported</i></a> 连接设置, 例如 <code>tcp://localhost:61616</code> 或 <code>failover:(tcp://localhost:61616,tcp://remotehost:61616)</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_QUEUE</code></td>
<td><code>zipkin.collector.activemq.queue</code></td>
<td>从中收集消息的队列名称。 默认为 <code>zipkin</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_CLIENT_ID_PREFIX</code></td>
<td><code>zipkin.collector.activemq.client-id-prefix</code></td>
<td>队列使用者的客户端ID前缀。默认为 <code>zipkin</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_CONCURRENCY</code></td>
<td><code>zipkin.collector.activemq.concurrency</code></td>
<td>并发消费数量。 默认为 <code>1</code></td>
</tr>
<tr>
<td><code>ACTIVEMQ_USERNAME</code></td>
<td><code>zipkin.collector.activemq.username</code></td>
<td>ActiveMQ 连接用户名</td>
</tr>
<tr>
<td><code>ACTIVEMQ_PASSWORD</code></td>
<td><code>zipkin.collector.activemq.password</code></td>
<td>ActiveMQ 连接密码</td>
</tr>
</tbody>
</table>
<p>示例用法：</p>
<div><pre><code>$ <span>ACTIVEMQ_URL</span><span>=</span>tcp://localhost:61616 java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="kafka-收集器"> Kafka 收集器</h3>
<p>Zipkin 的 Kafka 收集器组件支持 v0.10+ 版本，当配置 <code>KAFKA_BOOTSTRAP_SERVERS</code> 值时启用，支持以下属性配置</p>
<p>关于 kafka 的新消费者配置请看 <a href="https://kafka.apache.org/documentation/#newconsumerconfigs" target="_blank" rel="noopener noreferrer">这里<i>Content not supported</i></a>.</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>New Consumer Config</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLLECTOR_KAFKA_ENABLED</code></td>
<td>N/A</td>
<td><code>false</code> 禁用 Kafka 收集器。默认为 <code>true</code>.</td>
</tr>
<tr>
<td><code>KAFKA_BOOTSTRAP_SERVERS</code></td>
<td>bootstrap.servers</td>
<td>以逗号分隔的连接配置列表, 例如： 127.0.0.1:9092。无默认值</td>
</tr>
<tr>
<td><code>KAFKA_GROUP_ID</code></td>
<td>group.id</td>
<td>此进程所代表的消费组。默认为 <code>zipkin</code></td>
</tr>
<tr>
<td><code>KAFKA_TOPIC</code></td>
<td>N/A</td>
<td>kafka 消费者 topic 配置。默认为 <code>zipkin</code></td>
</tr>
<tr>
<td><code>KAFKA_STREAMS</code></td>
<td>N/A</td>
<td>topic 消费线程数。默认为  <code>1</code></td>
</tr>
</tbody>
</table>
<p>示例用法：</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h4 id="其他的-kafka-消费者属性配置"> 其他的 kafka 消费者属性配置</h4>
<p>您可能需要设置其他 <a href="https://kafka.apache.org/documentation/#newconsumerconfigs" target="_blank" rel="noopener noreferrer">Kafka 消费者属性<i>Content not supported</i></a>，除了由收集器定义的具有显式属性的那些。在这种情况下，您需要在该属性名称前面加上前缀 <code>zipkin.collector.kafka.overrides</code> 并将其作为系统属性参数传递。
例如，要覆盖 <code>auto.offset.reset</code> 属性, 你需要设置一个名为 <code>zipkin.collector.kafka.overrides.auto.offset.reset</code> 的属性:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    java -Dzipkin.collector.kafka.overrides.auto.offset.reset<span>=</span>latest -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="详细示例"> 详细示例</h4>
<p>针对在 Docker 中运行的 Kafka 的示例：</p>
<div><pre><code>$ <span>export</span> <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span><span>$(</span>docker-machine <span>ip</span> `docker-machine active`<span>)</span></span>
<span># 后台运行 kafka</span>
$ docker run -d -p <span>9092</span>:9092 <span>\</span>
    --env <span>ADVERTISED_HOST</span><span>=</span><span>$KAFKA_BOOTSTRAP_SERVERS</span> <span>\</span>
    --env <span>AUTO_CREATE_TOPICS</span><span>=</span>true <span>\</span>
    spotify/kafka
<span># 通过 $KAFKA_BOOTSTRAP_SERVERS 环境变脸启动 zipkin 服务</span>
$ java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>多个 bootstrap servers 配置:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span>broker1.local:9092,broker2.local:9092 <span>\</span>
    java -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>备用 topic 名称配置:</p>
<div><pre><code>$ <span>KAFKA_BOOTSTRAP_SERVERS</span><span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    java -Dzipkin.collector.kafka.topic<span>=</span>zapkin,zipken -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>将 bootstrap servers 指定为系统属性，而不是环境变量:</p>
<div><pre><code>$ java -Dzipkin.collector.kafka.bootstrap-servers<span>=</span><span>127.0</span>.0.1:9092 <span>\</span>
    -jar zipkin.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="rabbitmq-收集器"> RabbitMQ 收集器</h3>
<p>当设置 <code>addresses</code> 或 <code>uri</code> 的时候， <a href="../zipkin-collector/rabbitmq">RabbitMQ 收集器</a> 会启动</p>
<p>示例用法：</p>
<div><pre><code>$ <span>RABBIT_ADDRESSES</span><span>=</span>localhost java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><h3 id="grpc-收集器-实验性"> gRPC 收集器 (实验性)</h3>
<p>您可以通过设置 <code>COLLECTOR_GRPC_ENABLED=true</code> 启用 gRPC 收集器端点。 <code>zipkin.proto3.SpanService/Report</code> 端点会和普通 http 服务一样运行。</p>
<p>示例用法：</p>
<div><pre><code>$ <span>COLLECTOR_GRPC_ENABLED</span><span>=</span>true java -jar zipkin.jar
</code></pre>
<div><span>1</span><br></div></div><p>由于此服务是实验性的，因此不建议在生产环境中运行此服务。</p>
<h2 id="自我追踪"> 自我追踪</h2>
<p>存在自我跟踪以帮助解决 zipkin 服务器的性能问题。在生产部署应该将自我跟踪的应将采样率从 1.0 (100%) 降低到更小的速率，例如 0.001（0.1% 或千分之一）。</p>
<p>当配置 <code>zipkin.self-tracing.enabled=true</code>, Zipkin 将自动启动对服务 &quot;zipkin-server&quot; 的 API 的调用进行自我追踪</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELF_TRACING_ENABLED</td>
<td>zipkin.self-tracing.enabled</td>
<td>设置为 true 以启用自我跟踪。默认为 false</td>
</tr>
<tr>
<td>SELF_TRACING_SAMPLE_RATE</td>
<td>zipkin.self-tracing.sample-rate</td>
<td>要保留的自我跟踪的百分比，默认为始终采样 (1.0)。</td>
</tr>
<tr>
<td>SELF_TRACING_FLUSH_INTERVAL</td>
<td>zipkin.self-tracing.flush-interval</td>
<td>将自跟踪数据刷新到存储的时间间隔（以秒为单位）。默认为 1</td>
</tr>
</tbody>
</table>
<h3 id="_128-位跟踪-id"> 128 位跟踪 ID</h3>
<p>Zipkin 支持 64 位和 128 位跟踪标识符，通常序列化为 16 或 32 个字符的十六进制字符串。默认情况下，向 zipkin 报告的具有相同跟踪 ID 的跨度将被考虑在同一跟踪中。</p>
<p>例如， <code>463ac35c9f6413ad48485a3953bb6124</code> 是 128 位的跟踪 ID，而 <code>48485a3953bb6124</code> 是 64 位的。</p>
<p>注意：跟踪中的跨度（或父）ID 是 64 位的，无论其跟踪 ID 的长度或值如何</p>
<h4 id="从-64-位迁移到-128-位跟踪-id"> 从 64 位迁移到 128 位跟踪 ID</h4>
<p>除非您在所有应用程序都支持时仅发出 128 位跟踪，否则将应用程序从 64 位跟踪 ID 更新到 128 位跟踪 ID 的过程会导致混合状态。这种混合状态通过设置 <code>STRICT_TRACE_ID=false</code> 来缓解。如下所述，迁移完成后，删除 <code>STRICT_TRACE_ID=false</code> 设置，或者将其设置为 true</p>
<p>以下是一些跟踪ID，它们可以帮助您了解此设置过程中发生的情况。</p>
<ul>
<li>Trace ID A: 463ac35c9f6413ad48485a3953bb6124</li>
<li>Trace ID B: 48485a3953bb6124</li>
<li>Trace ID C: 463ac35c9f6413adf1a48a8cff464e0e</li>
<li>Trace ID D: 463ac35c9f6413ad</li>
</ul>
<p>在 64 位环境中，跟踪 ID 看起来像上面的 B 或 D。当应用程序升级到 128 位检测并决定创建 128 位跟踪时，其跟踪 ID 将类似于上面的 A 或 C。</p>
<p>尚不支持 128 位的应用程序通常只保留跟踪 ID 最右边的 16 个字符。发生这种情况时，同一跟踪可能会报告为跟踪 ID A 或跟踪 ID B。</p>
<p>默认情况下，Zipkin 会认为这些是不同的跟踪 ID，因为它们是不同的字符串。在从 64 位到 128 位跟踪 ID 的转换过程中，跨度将出现在两个 ID 之间。例如，它可能以跟踪 ID A 开始，但下一跃点可能会将其截断为跟踪 ID B。这会使系统无法用于执行升级的应用程序。</p>
<p>解决此问题的一种方法是在所有应用程序都支持之前不使用 128 位跟踪 ID。这以协调为代价防止了混合情况。另一种方法是设置 <code>STRICT_TRACE_ID=false</code></p>
<p>当设置 <code>STRICT_TRACE_ID=false</code> ，在对跟踪进行分组或检索时，只考虑 32 个字符的跟踪 ID 中最右边的 16 个。此设置应仅在从 64 位跟踪 ID 转换到 128 位跟踪 ID 时应用，并在转换完成后删除。</p>
<p>请查看 <a href="https://github.com/openzipkin/b3-propagation/issues/6" target="_blank" rel="noopener noreferrer">https://github.com/openzipkin/b3-propagation/issues/6<i>Content not supported</i></a> 了解 128 位跟踪标识符上已知开源库的状态。</p>
<p>查看源码 <code>zipkin2.storage.StorageComponent.Builder</code> 了解更多信息</p>
<h2 id="tls-ssl"> TLS/SSL</h2>
<p>如果需要，可以使 Zipkin-server 与 TLS 一起运行：</p>
<div><pre><code><span># assuming you generate the key like this</span>
keytool -genkeypair -alias mysite -keyalg RSA -keysize <span>2048</span> -storetype PKCS12 -keystore zipkin.p12 -validity <span>3650</span>

java -jar zipkin.jar --armeria.ssl.key-store<span>=</span>zipkin.p12 --armeria.ssl.key-store-type<span>=</span>PKCS12 --armeria.ssl.key-store-password<span>=</span><span>123123</span> --armeria.ssl.key-alias<span>=</span>mysite  --armeria.ssl.enabled<span>=</span>true --armeria.ports<span>[</span><span>0</span><span>]</span>.port<span>=</span><span>9411</span> --armeria.ports<span>[</span><span>0</span><span>]</span>.protocols<span>[</span><span>0</span><span>]</span><span>=</span>https
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="运行在-docker-中"> 运行在 Docker 中</h2>
<p>zipkin-server 的发布版本以 <code>openzipkin/zipkin</code> 发布在 <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub<i>Content not supported</i></a> 。点击 <a href="https://github.com/openzipkin/docker-zipkin" target="_blank" rel="noopener noreferrer">docker-zipkin<i>Content not supported</i></a> 查看详情</p>
<h2 id="本地构建"> 本地构建</h2>
<p>要从源码构建和运行服务器，请输入以下内容</p>
<div><pre><code><span># Build the server and also make its dependencies</span>
$ ./mvnw -T1C -q --batch-mode -DskipTests --also-make -pl zipkin-server clean package
<span># Run the server</span>
$ java -jar ./zipkin-server/target/zipkin-server-*exec.jar
<span># or Run the slim server</span>
$ java -jar ./zipkin-server/target/zipkin-server-*slim.jar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>mycat</title>
      <link>https://list-jiang.github.io/middleware/database/mycat/</link>
      <guid>https://list-jiang.github.io/middleware/database/mycat/</guid>
      <source url="https://list-jiang.github.io/rss.xml">mycat</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>数据库中间件</title>
      <link>https://list-jiang.github.io/middleware/database/</link>
      <guid>https://list-jiang.github.io/middleware/database/</guid>
      <source url="https://list-jiang.github.io/rss.xml">数据库中间件</source>
      <category>database</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="数据库中间件"> 数据库中间件</h2>
<ul>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener noreferrer">Shared Jdbc<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>ShardingSphere</title>
      <link>https://list-jiang.github.io/middleware/database/sharding-sphere/</link>
      <guid>https://list-jiang.github.io/middleware/database/sharding-sphere/</guid>
      <source url="https://list-jiang.github.io/rss.xml">ShardingSphere</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>kafka</title>
      <link>https://list-jiang.github.io/middleware/mq/kafka/info/</link>
      <guid>https://list-jiang.github.io/middleware/mq/kafka/info/</guid>
      <source url="https://list-jiang.github.io/rss.xml">kafka</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>Apache Kafka 是一个开源分布式事件流平台，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用程序。</p>
<h2 id="核心能力"> 核心能力</h2>
<ul>
<li><strong>高吞吐量</strong> 使用延迟低至 2 毫秒的机器集群以网络有限的吞吐量传递消息。</li>
<li><strong>可扩展</strong> 将生产集群扩展到一千个代理、每天数万亿条消息、PB 级数据、数十万个分区。弹性扩展和收缩存储和处理。</li>
<li><strong>永久存储</strong> 将数据流安全地存储在分布式、持久、容错的集群中。</li>
<li><strong>高可用性</strong> 在可用区域上有效地扩展集群或跨地理区域连接单独的集群。</li>
</ul>
<h2 id="生态系统"> 生态系统</h2>
<ul>
<li><strong>内置流处理</strong> 使用事件时间和精确一次处理，通过连接、聚合、过滤器、转换等处理事件流。</li>
<li><strong>几乎可连接任何软件</strong> Kafka 开箱即用的 Connect 接口与数百个事件源和事件接收器集成，包括 Postgres、JMS、Elasticsearch、AWS S3 等。</li>
<li><strong>丰富客户端库</strong> 使用大量编程语言读取、写入和处理事件流。</li>
<li><strong>大型生态系统开源工具</strong> 大型开源工具生态系统：利用大量社区驱动的工具。</li>
</ul>
<h2 id="信任和易用性"> 信任和易用性</h2>
<ul>
<li><strong>关键任务</strong> 通过保证排序、零消息丢失和高效的一次性处理来支持任务关键型用例。</li>
<li><strong>被成千上万的组织信任</strong> 从互联网巨头到汽车制造商再到证券交易所，成千上万的组织都在使用 Kafka。超过 500 万次独特的终身下载。</li>
<li><strong>庞大的用户社区</strong> Kafka 是 Apache 软件基金会五个最活跃的项目之一，在世界各地有数百场聚会。</li>
<li><strong>丰富的在线资源</strong> 丰富的文档、在线培训、指导教程、视频、示例项目、Stack Overflow 等。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>kafka</title>
      <link>https://list-jiang.github.io/middleware/mq/kafka/quick-start/</link>
      <guid>https://list-jiang.github.io/middleware/mq/kafka/quick-start/</guid>
      <source url="https://list-jiang.github.io/rss.xml">kafka</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>第一步：获取 KAFKA</p>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.1.0/kafka_2.13-3.1.0.tgz" target="_blank" rel="noopener noreferrer">下载<i>Content not supported</i></a> 最新的 Kafka 版本并解压：</p>
<div><pre><code>$ <span>tar</span> -xzf kafka_2.13-3.1.0.tgz
$ <span>cd</span> kafka_2.13-3.1.0
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<div><p>第二步：启动KAFKA环境</p>
<p><em>注意：您的本地环境必须安装 Java 8+。</em></p>
<p>运行以下命令以按正确顺序启动所有服务：</p>
<div><pre><code><span># Start the ZooKeeper service</span>
<span># Note: Soon, ZooKeeper will no longer be required by Apache Kafka.</span>
$ bin/zookeeper-server-start.sh config/zookeeper.properties
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>打开另一个终端会话并运行：</p>
<div><pre><code><span># Start the Kafka broker service</span>
$ bin/kafka-server-start.sh config/server.properties
成功启动所有服务后，您将拥有一个基本的 Kafka 环境运行并可以使用。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></div>
<div><p>第 3 步：创建一个主题来存储您的事件</p>
<p>Kafka 是一个分布式事件流平台，可让您跨多台机器 读取、写入、存储和处理 事件（在文档中也称为记录或消息）。</p>
<p>示例事件包括支付交易、手机的地理位置更新、运输订单、物联网设备或医疗设备的传感器测量等等。这些事件被组织并存储在 主题中。非常简化，主题类似于文件系统中的文件夹，事件是该文件夹中的文件。</p>
<p>因此，在您编写第一个事件之前，您必须创建一个主题。打开另一个终端会话并运行：</p>
<div><pre><code>$ bin/kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092
</code></pre>
<div><span>1</span><br></div></div><p>Kafka 的所有命令行工具都有其他选项：运行 <code>kafka-topics.sh</code> 不带任何参数的命令以显示使用信息。例如，它还可以显示新主题的 <a href="https://kafka.apache.org/documentation/#intro_concepts_and_terms" target="_blank" rel="noopener noreferrer">分区数等详细信息<i>Content not supported</i></a>：</p>
<div><pre><code>$ bin/kafka-topics.sh --describe --topic quickstart-events --bootstrap-server localhost:9092
Topic:quickstart-events  PartitionCount:1    ReplicationFactor:1 Configs:
 Topic: quickstart-events Partition: <span>0</span>    Leader: <span>0</span>   Replicas: <span>0</span> Isr: <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></div>
<div><p>第 4 步：将一些事件写入主题</p>
<p>Kafka 客户端通过网络与 Kafka 代理通信以写入（或读取）事件。一旦收到，代理将以持久和容错的方式存储事件，只要您需要 - 甚至永远。</p>
<p>运行控制台生产者客户端将一些事件写入您的主题。默认情况下，您输入的每一行都会导致将一个单独的事件写入主题。</p>
<div><pre><code>$ bin/kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092
This is my first event
This is my second event
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>您可以随时停止生产者客户端 <code>Ctrl-C</code> 。</p>
</div>
<div><p>第 5 步：阅读事件</p>
<p>打开另一个终端会话并运行控制台使用者客户端以读取您刚刚创建的事件：</p>
<div><pre><code>$ bin/kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092
This is my first event
This is my second event
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>您可以随时停止消费者客户端 <code>Ctrl-C</code> 。</p>
<p>随意尝试：例如，切换回您的生产者终端（上一步）以编写其他事件，并查看这些事件如何立即显示在您的消费者终端中。</p>
<p>因为事件被持久地存储在 Kafka 中，所以它们可以被尽可能多的消费者多次读取。您可以通过打开另一个终端会话并再次重新运行上一个命令来轻松验证这一点。</p>
</div>
<div><p>第 6 步：使用 KAFKA CONNECT 将数据作为事件流导入/导出</p>
<p>您可能在现有系统（如关系数据库或传统消息传递系统）中拥有大量数据，以及许多已经使用这些系统的应用程序。 <a href="https://kafka.apache.org/documentation/#connect" target="_blank" rel="noopener noreferrer">Kafka Connect<i>Content not supported</i></a> 允许您不断地将来自外部系统的数据摄取到 Kafka 中，反之亦然。因此很容易将现有系统与 Kafka 集成。为了使这个过程更容易，有数百个这样的连接器随时可用。</p>
<p>查看 <a href="https://kafka.apache.org/documentation/#connect" target="_blank" rel="noopener noreferrer">Kafka Connect<i>Content not supported</i></a> 部分 ，了解有关如何将数据持续导入和导出 Kafka 的更多信息。</p>
</div>
<div><p>第 7 步：使用 KAFKA STREAMS 处理您的事件</p>
<p>一旦您的数据作为事件存储在 Kafka 中，您就可以使用 Java/Scala 的 <a href="https://kafka.apache.org/documentation/streams" target="_blank" rel="noopener noreferrer">Kafka Streams<i>Content not supported</i></a> 客户端库处理数据。它允许您实现关键任务的实时应用程序和微服务，其中输入和/或输出数据存储在 Kafka 主题中。Kafka Streams 将在客户端编写和部署标准 Java 和 Scala 应用程序的简单性与 Kafka 的服务器端集群技术的优势相结合，使这些应用程序具有高度可扩展性、弹性、容错性和分布式性。该库支持一次性处理、有状态操作和聚合、窗口化、连接、基于事件时间的处理等等。</p>
<p>为了让您初步了解，以下是实现流行 <code>WordCount</code> 算法的方法：</p>
<div><pre><code><span>KStream</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> textLines <span>=</span> builder<span>.</span><span>stream</span><span>(</span><span>"quickstart-events"</span><span>)</span><span>;</span>

<span>KTable</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Long</span><span>></span></span> wordCounts <span>=</span> textLines
            <span>.</span><span>flatMapValues</span><span>(</span>line <span>-></span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>line<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span><span>)</span><span>)</span>
            <span>.</span><span>groupBy</span><span>(</span><span>(</span>keyIgnored<span>,</span> word<span>)</span> <span>-></span> word<span>)</span>
            <span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>

wordCounts<span>.</span><span>toStream</span><span>(</span><span>)</span><span>.</span><span>to</span><span>(</span><span>"output-topic"</span><span>,</span> <span>Produced</span><span>.</span><span>with</span><span>(</span><span>Serdes<span>.</span>String</span><span>(</span><span>)</span><span>,</span> <span>Serdes<span>.</span>Long</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Kafka Streams 演示 和应用程序开发教程 演示了如何从头到尾编写和运行这样的流应用程序 。</p>
</div>
<div><p>第 8 步：终止 KAFKA 环境</p>
<p>现在您已经完成了快速入门，请随意拆除 Kafka 环境，或者继续玩。</p>
<ol>
<li>使用 <code>Ctrl-C</code> 停止生产者和消费者客户端。</li>
<li>使用 <code>Ctrl-C</code> 停止 Kafka 代理。</li>
<li>最后，使用 <code>Ctrl-C</code> 停止 ZooKeeper 服务器。
如果您还想删除本地 Kafka 环境的任何数据，包括您在此过程中创建的任何事件，请运行以下命令：</li>
</ol>
<div><pre><code>$ <span>rm</span> -rf /tmp/kafka-logs /tmp/zookeeper
</code></pre>
<div><span>1</span><br></div></div></div>
<div><p>恭喜！</p>
<p>您已成功完成 Apache Kafka 快速入门。</p>
<p>要了解更多信息，我们建议执行以下后续步骤：</p>
<p>通读 <a href="https://kafka.apache.org/intro" target="_blank" rel="noopener noreferrer">简介<i>Content not supported</i></a> ，了解 Kafka 在高层次上的工作原理、主要概念以及与其他技术的比较。要更详细地了解 Kafka，请参阅 <a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener noreferrer">官网文档<i>Content not supported</i></a>。
浏览 <a href="https://kafka.apache.org/powered-by" target="_blank" rel="noopener noreferrer">用例<i>Content not supported</i></a> ，了解我们全球社区中的其他用户如何从 Kafka 中获得价值。
加入 <a href="https://kafka.apache.org/events" target="_blank" rel="noopener noreferrer">当地的 Kafka 聚会小组<i>Content not supported</i></a> ， 观看 <a href="https://kafka-summit.org/past-events/" target="_blank" rel="noopener noreferrer">Kafka 峰会<i>Content not supported</i></a> （Kafka 社区的主要会议）的演讲。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>kafka</title>
      <link>https://list-jiang.github.io/middleware/mq/kafka/</link>
      <guid>https://list-jiang.github.io/middleware/mq/kafka/</guid>
      <source url="https://list-jiang.github.io/rss.xml">kafka</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍</h2>
<p>Apache Kafka 是一个开源分布式事件流平台，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用程序。</p>
<ul>
<li><a href="https://kafka.apache.org/" target="_blank" rel="noopener noreferrer">官网地址<i>Content not supported</i></a></li>
<li><a href="./info.html">介绍</a></li>
<li><a href="./quick-start.html">入门案例</a></li>
<li><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener noreferrer">官方完整文档<i>Content not supported</i></a></li>
</ul>
<div><p>建议</p>
<p>随便写了下介绍与机翻了下入门案例，建议观看 <a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener noreferrer">官方完整文档<i>Content not supported</i></a> 。网上很多博客与教学视频都是垃圾，还大言不惭的说是 XXXX 年最新。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>rabbitmq</title>
      <link>https://list-jiang.github.io/middleware/mq/rabbitmq/</link>
      <guid>https://list-jiang.github.io/middleware/mq/rabbitmq/</guid>
      <source url="https://list-jiang.github.io/rss.xml">rabbitmq</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>消息队列</title>
      <link>https://list-jiang.github.io/middleware/mq/</link>
      <guid>https://list-jiang.github.io/middleware/mq/</guid>
      <source url="https://list-jiang.github.io/rss.xml">消息队列</source>
      <pubDate>Wed, 23 Feb 2022 07:50:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="消息队列"> 消息队列</h2>
<ul>
<li><a href="./kafka/">Apache kafka</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>rocketmq</title>
      <link>https://list-jiang.github.io/middleware/mq/rocketmq/</link>
      <guid>https://list-jiang.github.io/middleware/mq/rocketmq/</guid>
      <source url="https://list-jiang.github.io/rss.xml">rocketmq</source>
      <category>mq</category>
      <pubDate>Wed, 23 Feb 2022 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>中间件</title>
      <link>https://list-jiang.github.io/middleware/</link>
      <guid>https://list-jiang.github.io/middleware/</guid>
      <source url="https://list-jiang.github.io/rss.xml">中间件</source>
      <pubDate>Wed, 23 Feb 2022 07:50:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="消息队列"> <a href="./mq/">消息队列</a></h2>
<ul>
<li><a href="./mq/kafka/">Apache kafka</a></li>
</ul>
<h2 id="数据库中间件"> <a href="./database/">数据库中间件</a></h2>
<ul>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener noreferrer">Shared Jdbc<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Resilience4j</title>
      <link>https://list-jiang.github.io/spring/resilience4j/resilience4j/</link>
      <guid>https://list-jiang.github.io/spring/resilience4j/resilience4j/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Resilience4j</source>
      <category>Resilience4j</category>
      <pubDate>Mon, 21 Feb 2022 09:55:40 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下内容，大部分为机翻 + 人工校正。如有错误，还望指正，谢谢！</p>
</blockquote>
<h2 id="介绍"> 介绍</h2>
<p><code>Resilience4j</code> 是一款轻量级，易于使用的容错库，其灵感来自于 <code>Netflix Hystrix</code> ，但是专为 <code>Java 8</code> 和函数式编程而设计。轻量级，因为库只使用了 <a href="https://www.vavr.io/" target="_blank" rel="noopener noreferrer">Vavr<i>Content not supported</i></a> ，它没有任何其他外部依赖下。相比之下， Netflix Hystrix  对 Archaius 具有编译依赖性， <code>Archaius</code> 具有更多的外部库依赖性，例如 Guava 和 Apache Commons Configuration 。<br>
<code>Resilience4j</code> 提供了高阶函数（装饰器）、lambda 表达式或方法引用来增强一下功能接口：断路器、隔离、限流、重试、限时和缓。您可以在任何功能接口、lambda 表达式或方法引用上堆叠多个装饰器。优点是你可以选择你需要的装饰器。</p>
<h3 id="circuitbreaker"> CircuitBreaker</h3>
<p><a href="./../cloud/circuit-breaker.html">断路器，可看这篇</a></p>
<h3 id="bulkhead"> Bulkhead</h3>
<h4 id="介绍-2"> <strong>介绍</strong></h4>
<p>Resilience4j 提供了两种可用于限制并发执行数量的隔板模式实现：</p>
<ul>
<li><code>SemaphoreBulkhead</code> 通过信号量实现</li>
<li><code>FixedThreadPoolBulkhead</code> 通过有界队列和固定线程池实现。</li>
</ul>
<p>使用信号量的 <code>SemaphoreBulkhead</code> 应该可以在各种线程和 I/O 模型中很好地工作。它基于信号量，与 Hystrix 不同，它不提供 “影子” 线程池选项。 由客户端确保正确的线程池大小与隔离配置一致。</p>
<h4 id="创建一个-bulkheadregistry"> <strong>创建一个 BulkheadRegistry</strong></h4>
<p>和 CircuitBreaker 模块一样，该模块提供了一个基于内存的 BulkheadRegistry 和一个 ThreadPoolBulkheadRegistry，可用于管理（创建和检索）Bulkhead 实例。</p>
<div><pre><code><span>BulkheadRegistry</span> bulkheadRegistry <span>=</span> <span>BulkheadRegistry</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>;</span>

<span>ThreadPoolBulkheadRegistry</span> threadPoolBulkheadRegistry <span>=</span> <span>ThreadPoolBulkheadRegistry</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="创建并配置-bulkhead"> <strong>创建并配置 Bulkhead</strong></h4>
<p>您可以提供自定义全局 BulkheadConfig 。为了创建自定义全局 BulkheadConfig ，您可以使用 BulkheadConfig 构建器。您可以使用构建器来配置以下属性。</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxConcurrentCalls</td>
<td>25</td>
<td>隔板允许的最大并行执行量</td>
</tr>
<tr>
<td>maxWaitDuration</td>
<td>0</td>
<td>尝试进入饱和隔板时线程应被阻止的最长时间</td>
</tr>
</tbody>
</table>
<div><pre><code><span>// Create a custom configuration for a Bulkhead</span>
<span>BulkheadConfig</span> config <span>=</span> <span>BulkheadConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
    <span>.</span><span>maxConcurrentCalls</span><span>(</span><span>150</span><span>)</span>
    <span>.</span><span>maxWaitDuration</span><span>(</span><span>Duration</span><span>.</span><span>ofMillis</span><span>(</span><span>500</span><span>)</span><span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

<span>// Create a BulkheadRegistry with a custom global configuration</span>
<span>BulkheadRegistry</span> registry <span>=</span> <span>BulkheadRegistry</span><span>.</span><span>of</span><span>(</span>config<span>)</span><span>;</span>

<span>// Get or create a Bulkhead from the registry - </span>
<span>// bulkhead will be backed by the default config</span>
<span>Bulkhead</span> bulkheadWithDefaultConfig <span>=</span> registry<span>.</span><span>bulkhead</span><span>(</span><span>"name1"</span><span>)</span><span>;</span>

<span>// Get or create a Bulkhead from the registry, </span>
<span>// use a custom configuration when creating the bulkhead</span>
<span>Bulkhead</span> bulkheadWithCustomConfig <span>=</span> registry<span>.</span><span>bulkhead</span><span>(</span><span>"name2"</span><span>,</span> custom<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="创建并配置-threadpoolbulkhead"> <strong>创建并配置 ThreadPoolBulkhead</strong></h4>
<p>您可以提供自定义全局 ThreadPoolBulkheadConfig 。为了创建自定义全局 ThreadPoolBulkheadConfig ，您可以使用 ThreadPoolBulkheadConfig 构建器。您可以使用构建器来配置以下属性。</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxThreadPoolSize</td>
<td><code>Runtime.getRuntime().availableProcessors()</code></td>
<td>配置最大线程池大小。</td>
</tr>
<tr>
<td>coreThreadPoolSize</td>
<td><code>Runtime.getRuntime().availableProcessors() - 1</code></td>
<td>配置核心线程池大小</td>
</tr>
<tr>
<td>queueCapacity</td>
<td>100</td>
<td>配置队列的容量。</td>
</tr>
<tr>
<td>keepAliveDuration</td>
<td>20 [ms]</td>
<td>当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间。</td>
</tr>
</tbody>
</table>
<div><pre><code>
<span>ThreadPoolBulkheadConfig</span> config <span>=</span> <span>ThreadPoolBulkheadConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
  <span>.</span><span>maxThreadPoolSize</span><span>(</span><span>10</span><span>)</span>
  <span>.</span><span>coreThreadPoolSize</span><span>(</span><span>2</span><span>)</span>
  <span>.</span><span>queueCapacity</span><span>(</span><span>20</span><span>)</span>
  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
        
<span>// Create a BulkheadRegistry with a custom global configuration</span>
<span>ThreadPoolBulkheadRegistry</span> registry <span>=</span> <span>ThreadPoolBulkheadRegistry</span><span>.</span><span>of</span><span>(</span>config<span>)</span><span>;</span>

<span>// Get or create a ThreadPoolBulkhead from the registry - </span>
<span>// bulkhead will be backed by the default config</span>
<span>ThreadPoolBulkhead</span> bulkheadWithDefaultConfig <span>=</span> registry<span>.</span><span>bulkhead</span><span>(</span><span>"name1"</span><span>)</span><span>;</span>

<span>// Get or create a Bulkhead from the registry, </span>
<span>// use a custom configuration when creating the bulkhead</span>
<span>ThreadPoolBulkheadConfig</span> custom <span>=</span> <span>BulkheadConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
  <span>.</span><span>maxThreadPoolSize</span><span>(</span><span>5</span><span>)</span>
  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

<span>ThreadPoolBulkhead</span> bulkheadWithCustomConfig <span>=</span> registry<span>.</span><span>bulkhead</span><span>(</span><span>"name2"</span><span>,</span> custom<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id="装饰和执行函数接口"> <strong>装饰和执行函数接口</strong></h4>
<p>你可以猜到 Bulkhead 有各种高阶装饰器功能，就像 CircuitBreaker。你可以用一个 Buikhead 来装饰任意一个 <code>Callable</code> , <code>Supplier</code> , <code>Runnable</code> , <code>Consumer</code> , <code>CheckedRunnable</code> , <code>CheckedSupplier</code> , <code>CheckedConsumer</code> 或 <code>CompletionStage</code></p>
<div><pre><code><span>// Given</span>
<span>Bulkhead</span> bulkhead <span>=</span> <span>Bulkhead</span><span>.</span><span>of</span><span>(</span><span>"name"</span><span>,</span> config<span>)</span><span>;</span>

<span>// When I decorate my function</span>
<span>CheckedFunction0</span><span><span>&lt;</span><span>String</span><span>></span></span> decoratedSupplier <span>=</span> <span>Bulkhead</span>
  <span>.</span><span>decorateCheckedSupplier</span><span>(</span>bulkhead<span>,</span> <span>(</span><span>)</span> <span>-></span> <span>"This can be any method which returns: 'Hello"</span><span>)</span><span>;</span>

<span>// and chain an other function with map</span>
<span>Try</span><span><span>&lt;</span><span>String</span><span>></span></span> result <span>=</span> <span>Try</span><span>.</span><span>of</span><span>(</span>decoratedSupplier<span>)</span>
  <span>.</span><span>map</span><span>(</span>value <span>-></span> value <span>+</span> <span>" world'"</span><span>)</span><span>;</span>

<span>// Then the Try Monad returns a Success&lt;String>, if all functions ran successfully.</span>
<span>assertThat</span><span>(</span>result<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isTrue</span><span>(</span><span>)</span><span>;</span>
<span>assertThat</span><span>(</span>result<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"This can be any method which returns: 'Hello world'"</span><span>)</span><span>;</span>
<span>assertThat</span><span>(</span>bulkhead<span>.</span><span>getMetrics</span><span>(</span><span>)</span><span>.</span><span>getAvailableConcurrentCalls</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>1</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>ThreadPoolBulkheadConfig</span> config <span>=</span> <span>ThreadPoolBulkheadConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
    <span>.</span><span>maxThreadPoolSize</span><span>(</span><span>10</span><span>)</span>
    <span>.</span><span>coreThreadPoolSize</span><span>(</span><span>2</span><span>)</span>
    <span>.</span><span>queueCapacity</span><span>(</span><span>20</span><span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

<span>ThreadPoolBulkhead</span> bulkhead <span>=</span> <span>ThreadPoolBulkhead</span><span>.</span><span>of</span><span>(</span><span>"name"</span><span>,</span> config<span>)</span><span>;</span>

<span>CompletionStage</span><span><span>&lt;</span><span>String</span><span>></span></span> supplier <span>=</span> <span>ThreadPoolBulkhead</span>
    <span>.</span><span>executeSupplier</span><span>(</span>bulkhead<span>,</span> backendService<span>::</span><span>doSomething</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="消费-registryevents"> <strong>消费 RegistryEvents</strong></h4>
<p>您可以在 BulkheadRegistry 上注册事件消费者，并在创建、替换或删除 Bulkhead 时自动发送消息，事件消费者执行操作。</p>
<div><pre><code><span>BulkheadRegistry</span> registry <span>=</span> <span>BulkheadRegistry</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>;</span>
registry<span>.</span><span>getEventPublisher</span><span>(</span><span>)</span>
  <span>.</span><span>onEntryAdded</span><span>(</span>entryAddedEvent <span>-></span> <span>{</span>
    <span>Bulkhead</span> addedBulkhead <span>=</span> entryAddedEvent<span>.</span><span>getAddedEntry</span><span>(</span><span>)</span><span>;</span>
    LOG<span>.</span><span>info</span><span>(</span><span>"Bulkhead {} added"</span><span>,</span> addedBulkhead<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>onEntryRemoved</span><span>(</span>entryRemovedEvent <span>-></span> <span>{</span>
    <span>Bulkhead</span> removedBulkhead <span>=</span> entryRemovedEvent<span>.</span><span>getRemovedEntry</span><span>(</span><span>)</span><span>;</span>
    LOG<span>.</span><span>info</span><span>(</span><span>"Bulkhead {} removed"</span><span>,</span> removedBulkhead<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="消费-bulkheadevents"> <strong>消费 BulkheadEvents</strong></h4>
<p>BulkHead 发出 BulkHeadEvents 流。发出三种类型的事件：允许执行、拒绝执行和完成执行。如果你想消费这些事件，你必须注册一个事件消费者。</p>
<div><pre><code>bulkhead<span>.</span><span>getEventPublisher</span><span>(</span><span>)</span>
    <span>.</span><span>onCallPermitted</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span>
    <span>.</span><span>onCallRejected</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span>
    <span>.</span><span>onCallFinished</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="ratelimiter-限流器"> RateLimiter 限流器</h3>
<h4 id="介绍-3"> <strong>介绍</strong></h4>
<p>限流对于保证服务的 规模化、高可用、高可靠是一种必要的技术。<br>
Resilience4j 提供了一个 RateLimiter，它将从 epoch 开始的所有纳秒分成周期。每个周期都有一个由 RateLimiterConfig.limitRefreshPeriod 配置的持续时间。在每个周期开始时，RateLimiter 将活动权限的数量设置为 RateLimiterConfig.limitForPeriod 。对于 RateLimiter 调用者，它看起来确实像这样，但是对于 AtomicRateLimiter 实现有一些底层优化，如果 RateLimiter 没有被主动使用，则将跳过此刷新。见下图</p>
<p><img src="./img/resilience4j-rate_limiter.png" alt=""></p>
<p>RateLimiter 的默认实现是 <code>AtomicRateLimiter</code> ,通过 AtomicReference 管理其状态。AtomicRateLimiter.State 是完全不可变的，并具有以下字段：</p>
<ul>
<li><code>activeCycle</code> - 上次调用使用的周期数</li>
<li><code>activePermissions</code> - 最后一次通话后可用权限的计数。如果保留了某些权限，则可能为负数</li>
<li><code>nanosToWait</code> - 等待最后一次通话许可的纳秒计数</li>
</ul>
<p>还有一个 <code>SemaphoreBasedRateLimiter</code> 使用 Semaphore 和一个调度程序，它将在每个 <code>RateLimiterConfig#limitRefreshPeriod</code> 之后刷新权限</p>
<h4 id="创建一个-ratelimiterregistry"> <strong>创建一个 RateLimiterRegistry</strong></h4>
<p>和 CircuitBreaker 模块一样，该模块提供了一个基于内存的 RateLimiterRegistry，可用于管理（创建和检索）RateLimiter 实例。</p>
<div><pre><code><span>RateLimiterRegistry</span> rateLimiterRegistry <span>=</span> <span>RateLimiterRegistry</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="创建和配置-ratelimiter"> <strong>创建和配置 RateLimiter</strong></h4>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeoutDuration</td>
<td><code>5 [s]</code></td>
<td>线程等待权限的默认等待时间</td>
</tr>
<tr>
<td>limitRefreshPeriod</td>
<td><code>500 [ns]</code></td>
<td>限制刷新的周期。 在每个周期之后，速率限制器将其权限计数设置回 limitForPeriod 值</td>
</tr>
<tr>
<td>limitForPeriod</td>
<td>50</td>
<td>一个限制刷新周期内可用的权限数</td>
</tr>
</tbody>
</table>
<div><pre><code><span>// 限制某些方法的调用速率不高于 10 req/ms。</span>
<span>RateLimiterConfig</span> config <span>=</span> <span>RateLimiterConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
  <span>.</span><span>limitRefreshPeriod</span><span>(</span><span>Duration</span><span>.</span><span>ofMillis</span><span>(</span><span>1</span><span>)</span><span>)</span>
  <span>.</span><span>limitForPeriod</span><span>(</span><span>10</span><span>)</span>
  <span>.</span><span>timeoutDuration</span><span>(</span><span>Duration</span><span>.</span><span>ofMillis</span><span>(</span><span>25</span><span>)</span><span>)</span>
  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

<span>// Create registry</span>
<span>RateLimiterRegistry</span> rateLimiterRegistry <span>=</span> <span>RateLimiterRegistry</span><span>.</span><span>of</span><span>(</span>config<span>)</span><span>;</span>

<span>// Use registry</span>
<span>RateLimiter</span> rateLimiterWithDefaultConfig <span>=</span> rateLimiterRegistry
  <span>.</span><span>rateLimiter</span><span>(</span><span>"name1"</span><span>)</span><span>;</span>

<span>RateLimiter</span> rateLimiterWithCustomConfig <span>=</span> rateLimiterRegistry
  <span>.</span><span>rateLimiter</span><span>(</span><span>"name2"</span><span>,</span> config<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="装饰和执行函数接口-2"> <strong>装饰和执行函数接口</strong></h4>
<div><pre><code><span>CheckedRunnable</span> restrictedCall <span>=</span> <span>RateLimiter</span>
    <span>.</span><span>decorateCheckedRunnable</span><span>(</span>rateLimiter<span>,</span> backendService<span>::</span><span>doSomething</span><span>)</span><span>;</span>

<span>Try</span><span>.</span><span>run</span><span>(</span>restrictedCall<span>)</span>
    <span>.</span><span>andThenTry</span><span>(</span>restrictedCall<span>)</span>
    <span>.</span><span>onFailure</span><span>(</span><span>(</span><span>RequestNotPermitted</span> throwable<span>)</span> <span>-></span> LOG<span>.</span><span>info</span><span>(</span><span>"Wait before call it again :)"</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以使用 changeTimeoutDuration 和 changeLimitForPeriod 在运行时更改速率限制器参数。
新的超时持续时间不会影响当前正在等待许可的线程。
新限制不会影响当前期间的权限，只会从下一个期间开始应用。</p>
<div><pre><code><span>// Decorate your call to BackendService.doSomething()</span>
<span>CheckedRunnable</span> restrictedCall <span>=</span> <span>RateLimiter</span>
    <span>.</span><span>decorateCheckedRunnable</span><span>(</span>rateLimiter<span>,</span> backendService<span>::</span><span>doSomething</span><span>)</span><span>;</span>

<span>// during second refresh cycle limiter will get 100 permissions</span>
rateLimiter<span>.</span><span>changeLimitForPeriod</span><span>(</span><span>100</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="retry-重试"> Retry 重试</h3>
<p>大致配置流程都是一样的</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxAttempts</td>
<td>2</td>
<td>最大尝试次数（包括作为第一次尝试的初始调用）</td>
</tr>
<tr>
<td>waitDuration</td>
<td><code>500 [ms]</code></td>
<td>重试尝试之间的固定等待时间</td>
</tr>
<tr>
<td>intervalFunction</td>
<td>numOfAttempts -&gt; waitDuration</td>
<td>修改失败后等待间隔的函数。默认情况下，等待时间保持不变。</td>
</tr>
<tr>
<td>intervalBiFunction</td>
<td><code>(numOfAttempts, Either&lt;throwable, result&gt;) -&gt; waitDuration</code></td>
<td>根据尝试次数和结果或异常修改失败后等待间隔的函数。与 intervalFunction 一起使用时会抛出 IllegalStateException。</td>
</tr>
<tr>
<td>retryOnResultPredicate</td>
<td>result -&gt; false</td>
<td>配置一个判断结果是否应该重试的断言。如果结果应该重试，Predicate 必须返回 true，否则它必须返回 false。</td>
</tr>
<tr>
<td>retryExceptionPredicate</td>
<td>throwable -&gt; true</td>
<td>配置一个断言来评估是否应该重试异常。如果应该重试异常，Predicate 必须返回 true，否则它必须返回 false。</td>
</tr>
<tr>
<td>retryExceptions</td>
<td>empty</td>
<td>配置记录为失败并因此重试的 Throwable 类的列表。此参数支持子类型。注意：如果您使用 Checked Exceptions，则必须使用 CheckedSupplier</td>
</tr>
<tr>
<td>ignoreExceptions</td>
<td>empty</td>
<td>配置被忽略并因此不会重试的 Throwable 类的列表。此参数支持子类型。</td>
</tr>
<tr>
<td>failAfterMaxAttempts</td>
<td>false</td>
<td>当重试达到配置的 maxAttempts 并且结果仍未通过 retryOnResultPredicate 时启用或禁用抛出 MaxRetriesExceededException 的布尔值</td>
</tr>
</tbody>
</table>
<h3 id="timelimiter-限时器"> TimeLimiter 限时器</h3>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeoutDuration</td>
<td><code>1 [s]</code></td>
<td>线程执行超时时间</td>
</tr>
<tr>
<td>cancelRunningFuture</td>
<td>true</td>
<td>是否应该在运行的未来调用取消</td>
</tr>
</tbody>
</table>
<h3 id="cache-缓存"> cache 缓存</h3>
<h4 id="创建和配置缓存"> 创建和配置缓存</h4>
<p>下面的示例展示了如何使用 Cache 抽象来装饰 lambda 表达式。缓存抽象将 lambda 表达式的结果放在缓存实例 ( JCache ) 中，并尝试在调用 lambda 表达式之前从缓存中检索先前缓存的结果。如果从分布式缓存中检索缓存失败，则会处理异常并调用 lambda 表达式。</p>
<div><pre><code><span>// Create a CacheContext by wrapping a JCache instance.</span>
<span><span>javax<span>.</span>cache<span>.</span></span>Cache</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> cacheInstance <span>=</span> <span>Caching</span>
  <span>.</span><span>getCache</span><span>(</span><span>"cacheName"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>Cache</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> cacheContext <span>=</span> <span>Cache</span><span>.</span><span>of</span><span>(</span>cacheInstance<span>)</span><span>;</span>

<span>// Decorate your call to BackendService.doSomething()</span>
<span>CheckedFunction1</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> cachedFunction <span>=</span> <span>Decorators</span>
    <span>.</span><span>ofCheckedSupplier</span><span>(</span><span>(</span><span>)</span> <span>-></span> backendService<span>.</span><span>doSomething</span><span>(</span><span>)</span><span>)</span>
    <span>.</span><span>withCache</span><span>(</span>cacheContext<span>)</span>
    <span>.</span><span>decorate</span><span>(</span><span>)</span><span>;</span>
<span>String</span> value <span>=</span> <span>Try</span><span>.</span><span>of</span><span>(</span><span>(</span><span>)</span> <span>-></span> cachedFunction<span>.</span><span>apply</span><span>(</span><span>"cacheKey"</span><span>)</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="使用发出的-cacheevents"> <strong>使用发出的 CacheEvents</strong></h4>
<p>Cache 发出一个 CacheEvents 流。事件可以是缓存命中、缓存未命中或错误。</p>
<div><pre><code>cacheContext<span>.</span><span>getEventPublisher</span><span>(</span><span>)</span>
    <span>.</span><span>onCacheHit</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span>
    <span>.</span><span>onCacheMiss</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span>
    <span>.</span><span>onError</span><span>(</span>event <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="ehcache-示例"> <strong>Ehcache 示例</strong></h4>
<div><pre><code>compile &#39;org.ehcache:ehcache:3.7.1&#39;
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>// Configure a cache (once)</span>
<span>this</span><span>.</span>cacheManager <span>=</span> <span>Caching</span><span>.</span><span>getCachingProvider</span><span>(</span><span>)</span><span>.</span><span>getCacheManager</span><span>(</span><span>)</span><span>;</span>
<span>this</span><span>.</span>cache <span>=</span> <span>Cache</span><span>.</span><span>of</span><span>(</span>cacheManager
    <span>.</span><span>createCache</span><span>(</span><span>"booksCache"</span><span>,</span> <span>new</span> <span>MutableConfiguration</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

<span>// Get books using a cache</span>
<span>List</span><span><span>&lt;</span><span>Book</span><span>></span></span> books <span>=</span> <span>Cache</span><span>.</span><span>decorateSupplier</span><span>(</span>cache<span>,</span> library<span>::</span><span>getBooks</span><span>)</span>
    <span>.</span><span>apply</span><span>(</span>BOOKS_CACHE_KEY<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>使用警告</p>
<p>不建议在生产中使用 JCache参考实现，因为它会导致一些并发问题。使用 Ehcache、Caffeine、Redisson、Hazelcast、Ignite 或其他 JCache 实现。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Spring Cloud Circuit Breaker</title>
      <link>https://list-jiang.github.io/spring/cloud/circuit-breaker/</link>
      <guid>https://list-jiang.github.io/spring/cloud/circuit-breaker/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Spring Cloud Circuit Breaker</source>
      <category>Spring</category>
      <pubDate>Fri, 18 Feb 2022 08:23:15 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="spring-cloud-circuit-breaker"> Spring Cloud Circuit Breaker</h1>
<ul>
<li>官网地址：<a href="https://spring.io/projects/spring-cloud-circuitbreake" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-cloud-circuitbreake<i>Content not supported</i></a></li>
<li>官方案例地址：<a href="https://github.com/spring-cloud-samples/spring-cloud-circuitbreaker-demo" target="_blank" rel="noopener noreferrer">https://github.com/spring-cloud-samples/spring-cloud-circuitbreaker-demo<i>Content not supported</i></a></li>
<li><strong>核心思想还得看这个：</strong><a href="https://resilience4j.readme.io/docs/circuitbreaker" target="_blank" rel="noopener noreferrer">https://resilience4j.readme.io/docs/circuitbreaker<i>Content not supported</i></a></li>
</ul>
<h3 id="介绍"> 介绍</h3>
<p>Spring Cloud 断路器提供了跨不同断路器实现的抽象。它提供了在您的应用程序中使用的一致 API，让您开发人员可以选择最适合您的应用程序需求的断路器实现。</p>
<h3 id="支持的实现"> 支持的实现</h3>
<ul>
<li>
<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener noreferrer">Netfix Hystrix<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://github.com/resilience4j/resilience4j" target="_blank" rel="noopener noreferrer">Resilience4J<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener noreferrer">Sentinel<i>Content not supported</i></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="noopener noreferrer">Spring Retry<i>Content not supported</i></a></p>
</li>
</ul>
<h4 id="相应的引用配置"> 相应的引用配置</h4>
<ul>
<li>
<p>Hystrix - <code>org.springframework.cloud:spring-cloud-starter-netflix-hystrix</code></p>
</li>
<li>
<p>Resilience4J - <code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j</code></p>
</li>
<li>
<p>Reactive Resilience4J - <code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-reactor-resilience4j</code></p>
</li>
<li>
<p>Spring Retry - <code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-spring-retry</code></p>
</li>
<li>
<p>Sentinal - <code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-sentinal</code></p>
</li>
</ul>
<h2 id="极简使用-web"> 极简使用 Web</h2>
<div><pre><code><span>@Service</span>
<span>public</span> <span>static</span> <span>class</span> <span>DemoControllerService</span> <span>{</span>
	<span>private</span> <span>RestTemplate</span> rest<span>;</span>
	<span>private</span> <span>CircuitBreakerFactory</span> cbFactory<span>;</span>

	<span>public</span> <span>DemoControllerService</span><span>(</span><span>RestTemplate</span> rest<span>,</span> <span>CircuitBreakerFactory</span> cbFactory<span>)</span> <span>{</span>
		<span>this</span><span>.</span>rest <span>=</span> rest<span>;</span>
		<span>this</span><span>.</span>cbFactory <span>=</span> cbFactory<span>;</span>
	<span>}</span>
    <span>// 断路器工厂创建一个 slow 实例，调度一个 rest 操作，如果断路抛出异常则执行 fallback 处理操作，需要我们注册一个 path 为 "/fallback" 的 Requestmapping 实例</span>
	<span>public</span> <span>String</span> <span>slow</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> cbFactory<span>.</span><span>create</span><span>(</span><span>"slow"</span><span>)</span><span>.</span><span>run</span><span>(</span><span>(</span><span>)</span> <span>-></span> rest<span>.</span><span>getForObject</span><span>(</span><span>"/slow"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>,</span> throwable <span>-></span> <span>"fallback"</span><span>)</span><span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="极简使用-reactive-web"> 极简使用 Reactive Web</h2>
<div><pre><code><span>@Service</span>
<span>public</span> <span>static</span> <span>class</span> <span>DemoControllerService</span> <span>{</span>
	<span>private</span> <span>ReactiveCircuitBreakerFactory</span> cbFactory<span>;</span>
	<span>private</span> <span>WebClient</span> webClient<span>;</span>


	<span>public</span> <span>DemoControllerService</span><span>(</span><span>WebClient</span> webClient<span>,</span> <span>ReactiveCircuitBreakerFactory</span> cbFactory<span>)</span> <span>{</span>
		<span>this</span><span>.</span>webClient <span>=</span> webClient<span>;</span>
		<span>this</span><span>.</span>cbFactory <span>=</span> cbFactory<span>;</span>
	<span>}</span>

	<span>public</span> <span>Mono</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>slow</span><span>(</span><span>)</span> <span>{</span>
        <span>// webClient 创建一个响应式请求动作，这个动作交由断路器工厂创建一个 slow 实例来触发，有问题断路抛出异常则执行 fallback 处理操作，需要我们注册一个 path 为 "/fallback" 的 Requestmapping 实例</span>
		<span>return</span> webClient<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>uri</span><span>(</span><span>"/slow"</span><span>)</span><span>.</span><span>retrieve</span><span>(</span><span>)</span><span>.</span><span>bodyToMono</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>.</span><span>transform</span><span>(</span>
		it <span>-></span> cbFactory<span>.</span><span>create</span><span>(</span><span>"slow"</span><span>)</span><span>.</span><span>run</span><span>(</span>it<span>,</span> throwable <span>-></span> <span>return</span> <span>Mono</span><span>.</span><span>just</span><span>(</span><span>"fallback"</span><span>)</span><span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>Spring 团队为了推行 resilience4j 也是强， Spring Cloud Circuit Breaker的真正<a href="https://resilience4j.readme.io/docs/circuitbreaker" target="_blank" rel="noopener noreferrer">思想<i>Content not supported</i></a>要看 resilience4j 的文档，我都不知道怎么点进去的，有毒。</p>
</blockquote>
<h1 id="resilience4j"> resilience4j</h1>
<p>resilience4j 文档：<a href="https://resilience4j.readme.io/" target="_blank" rel="noopener noreferrer">https://resilience4j.readme.io/<i>Content not supported</i></a>
以下内容，部分为 google 机翻</p>
<h2 id="circuit-breaker-设计思想"> Circuit Breaker 设计思想</h2>
<p>CircuitBreaker 是通过三个典型状态：<code>CLOSED</code>、<code>OPEN</code> 和 <code>HALF_OPEN</code> 以及<s>两个</s>特殊状态 <code>DISABLED</code> 、和 <code>FORCED_OPEN</code> 实现的</p>
<p><img src="./img/state_machine.jpg" alt="state_machine"></p>
<p>此处，网站文档未及时更新，本人在 <code>io.github.resilience4j:resilience4j-circuitbreaker:1.7.0</code> 版本的 <code>io.github.resilience4j.circuitbreaker.CircuitBreaker.State</code> 看到的状态有六个,漏了 <code>METRICS_ONLY</code> ，文档上只说了五个。<sup></sup></p>
<p><img src="./img/CircuitBreaker-State-Web.jpg" alt=""></p>
<p><img src="./img/CircuitBreaker-State.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>Order，越小的优先级越高</th>
<th>是否发布事件</th>
<th>枚举值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLOSED</td>
<td>0</td>
<td>true</td>
<td>断路器已跳闸，不允许请求通过</td>
</tr>
<tr>
<td>OPEN</td>
<td>1</td>
<td>true</td>
<td>断路器正常运行并允许请求通过</td>
</tr>
<tr>
<td>HALF_OPEN</td>
<td>2</td>
<td>true</td>
<td>断路器已完成其等待间隔并将允许请求</td>
</tr>
<tr>
<td>DISABLED</td>
<td>3</td>
<td>false</td>
<td>断路器未运行（无状态转换，无事件）并允许所有请求通过</td>
</tr>
<tr>
<td>FORCED_OPEN</td>
<td>4</td>
<td>false</td>
<td>断路器没有运行（没有状态转换，没有事件）并且不允许任何请求通过</td>
</tr>
<tr>
<td>METRICS_ONLY</td>
<td>5</td>
<td>true</td>
<td>断路器正在收集指标、发布事件并允许所有请求通过但不转换到其他状态</td>
</tr>
</tbody>
</table>
<p>CircuitBreaker 使用滑动窗口来存储和汇总调用结果，计算故障率进行阈值判定。可以在基于计数的滑动窗口和基于时间的滑动窗口之间进行选择。</p>
<ul>
<li>基于计数的滑动窗口聚合最后 N 次调用的结果。</li>
<li>基于时间的滑动窗口聚合了最后 N 秒的调用结果。</li>
</ul>
<h3 id="状态切换"> 状态切换</h3>
<p>当故障率等于或大于可配置阈值时，CircuitBreaker 的状态从 CLOSED 变为 OPEN 。例如，当超过 50% 的调用失败时，此时不会再蠢蠢的接着发送请求，直接走异常处理逻辑。
过了指定的等待时间后，CircuitBreaker 的状态从 CLOSED 变为 HALF_OPEN。发送指定个请求后，如果失败率或慢速调用率等于或大于配置的阈值，则状态变回 OPEN。如果失败率和慢调用率低于阈值，则状态变回 CLOSED。</p>
<p>默认的情况下，所有的异常都算做失败，计算故障率。但是也支持自定义配置，可配置异常类型断言，判断异常类型。或者有两个异常数组，直接配置这两个数组：
recordExceptions：抛出这个数组里面的异常的就计为失败处理
ignoreExceptions：抛出这个数组里面的异常也算作成功处理
如果异常都不在这两个里面，那么既不算做成功，也不算做失败。这里需要注意的是，故障率计算必须有一个成型的滑动窗口才会计算。例如，计数模式的滑动窗口，如果计数数为 8 ，那么即使失败了 7 次，也不会触发断路器阈值判定。</p>
<div><pre><code>    <span>@Bean</span>
    <span>public</span> <span>Customizer</span><span><span>&lt;</span><span>Resilience4JCircuitBreakerFactory</span><span>></span></span> <span>slowCustomizer</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> factory <span>-></span> factory<span>.</span><span>configure</span><span>(</span>builder <span>-></span> builder<span>.</span><span>circuitBreakerConfig</span><span>(</span><span>CircuitBreakerConfig</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>)</span>
                        <span>.</span><span>timeLimiterConfig</span><span>(</span><span>TimeLimiterConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span><span>.</span><span>timeoutDuration</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>4</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>)</span> <span>// 超过4秒没有响应就认为请求失败</span>
                        <span>.</span><span>circuitBreakerConfig</span><span>(</span><span>CircuitBreakerConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
                                <span>.</span><span>minimumNumberOfCalls</span><span>(</span><span>100</span><span>)</span> <span>// 最小失败率计算呼叫次数，只有呼叫次数大于这个值才会计算失败率</span>
                                <span>.</span><span>failureRateThreshold</span><span>(</span><span>30f</span><span>)</span> <span>// 失败率阈值设置，如果大于 30% 的失败了，就启动断路器</span>
                                <span>.</span><span>waitDurationInOpenState</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>30</span><span>)</span><span>)</span> <span>// 断路器打开后保持 30 秒后切换为半开状态，又可以有限的发送请求</span>
                                <span>.</span><span>permittedNumberOfCallsInHalfOpenState</span><span>(</span><span>20</span><span>)</span> <span>// 在半开状态允许调用，调用 20 次后重新计算阈值，判断断路器打不打开</span>
                                <span>.</span><span>recordExceptions</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span> <span>// 设定计算失败数的异常，默认统计所有的异常</span>
                                <span>.</span><span>ignoreExceptions</span><span>(</span><span>IllegalArgumentException</span><span>.</span><span>class</span><span>)</span> <span>// 设定不计算失败数的异常，即不再 record 里面的也不在 ignore 里面的就不纳入故障率统计</span>
                                <span>.</span><span>build</span><span>(</span><span>)</span><span>)</span>
                <span>,</span> <span>"slow"</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>断路器支持另外两种特殊状态，DISABLED（始终允许访问）和 FORCED_OPEN（始终拒绝访问）。在这两种状态下，不会生成断路器事件（除了状态转换），也不会记录任何指标。退出这些状态的唯一方法是触发状态转换或重置断路器。</p>
<div><p>警告</p>
<p>断路器是线程安全的，如下所示：</p>
<ul>
<li>断路器的状态存储在 AtomicReference 中</li>
<li>CircuitBreaker 使用原子操作来更新具有无副作用函数的状态。</li>
<li>滑动窗口内状态的更新与读取是同步的</li>
</ul>
</div>
<p>这意味着应该保证原子性，并且只有一个线程能够在某个时间点更新状态或滑动窗口。</p>
<p>但是 CircuitBreaker 不会同步函数调用。这意味着函数调用本身不是关键部分的一部分。否则，CircuitBreaker 会带来巨大的性能损失和瓶颈。缓慢的函数调用会对整体性能/吞吐量产生巨大的负面影响。</p>
<p>如果有 20 个并发线程请求执行某个函数的权限，并且 CircuitBreaker 的状态为关闭，则允许所有线程调用该函数。即使滑动窗口大小为 15。滑动窗口并不意味着只允许 15 个调用并发运行。如果要限制并发线程数，请使用 Bulkhead。您可以将 Bulkhead 和 CircuitBreaker 结合使用。</p>
<p><strong>带有 1 个线程的示例：</strong></p>
<p><img src="./img/circuit-breaker-Thread1.png" alt=""></p>
<p><strong>带有 3 个线程的示例：</strong></p>
<p><img src="./img/circuit-breaker-Multiplethreads.png" alt=""></p>
<h2 id="创建断路器注册表"> 创建断路器注册表</h2>
<p>Resilience4j 带有一个基于 ConcurrentHashMap 的内存，它提供线程安全和原子性保证。您可以使用 CircuitBreakerRegistry 管理（创建和检索）CircuitBreaker 实例。您可以为所有 CircuitBreaker 实例创建一个具有全局默认值的 CircuitBreakerRegistry，如下所示。CircuitBreakerRegistryCircuitBreakerConfig</p>
<div><pre><code><span>CircuitBreakerRegistry</span> circuitBreakerRegistry <span>=</span> <span>CircuitBreakerRegistry</span><span>.</span><span>ofDefaults</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="创建和配置断路器"> 创建和配置断路器</h2>
<p>您可以提供自己的自定义全局. 为了创建自定义全局 CircuitBreakerConfig，您可以使用 CircuitBreakerConfig 构建器。您可以使用构建器来配置以下属性。CircuitBreakerConfig</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>failureRateThreshold</td>
<td>50</td>
<td>以百分比配置失败率阈值。<br>当故障率等于或大于阈值时，CircuitBreaker 转换为打开并开始短路呼叫。</td>
</tr>
<tr>
<td>slowCallRateThreshold</td>
<td>100</td>
<td>以百分比配置阈值。当呼叫持续时间大于等于或大于阈值 <code>slowCallDurationThreshold</code> 时，CircuitBreaker 将呼叫视为慢速呼叫。 当慢速呼叫的百分比等于或大于阈值时，CircuitBreaker 转换为打开并开始短路呼叫。</td>
</tr>
<tr>
<td>slowCallDurationThreshold</td>
<td>60000 [毫秒]</td>
<td>配置持续时间阈值，超过该阈值呼叫被视为慢速并提高慢速呼叫率。</td>
</tr>
<tr>
<td>permittedNumberOfCallsInHalfOpenState</td>
<td>10</td>
<td>配置断路器半开时允许的呼叫数。</td>
</tr>
<tr>
<td>maxWaitDurationInHalfOpenState</td>
<td>0 [ms]</td>
<td>配置最大等待持续时间，该持续时间控制断路器在切换到打开之前可以保持在半开状态的最长时间。<br>值 0 表示断路器将在 HalfOpen 状态下无限等待，直到所有允许的调用都已完成。</td>
</tr>
<tr>
<td>slidingWindowType</td>
<td>COUNT_BASED</td>
<td>配置用于在CircuitBreaker关闭时记录调用结果的滑动窗口类型。<br>滑动窗口可以是基于计数或基于时间的。<br>如果滑动窗口是 <code>COUNT_BASED</code> ，则记录和汇总 <code>slipWindowSize</code> 次的调用。<br>如果滑动窗口是 <code>TIME_BASED</code> ，则记录和汇总 <code>slidingWindowSize</code> 秒的调用。</td>
</tr>
<tr>
<td>slidingWindowSize</td>
<td>100</td>
<td>配置用于在 CircuitBreaker 关闭时记录调用结果的滑动窗口的大小。</td>
</tr>
<tr>
<td>minimumNumberOfCalls</td>
<td>100</td>
<td>配置在 CircuitBreaker 计算错误率或慢速调用率之前所需的最小调用次数（每个滑动窗口周期）。<br>例如，如果 minimumNumberOfCalls 为 10，则必须记录至少 10 次呼叫，然后才能计算失败率。<br>如果仅记录了 9 个呼叫，即使所有 9 个呼叫都失败，CircuitBreaker 也不会转换为打开状态。</td>
</tr>
<tr>
<td>waitDurationInOpenState</td>
<td>60000 [ms]</td>
<td>断路器在从打开转换为半打开之前应等待的时间。</td>
</tr>
<tr>
<td>automaticTransitionFromOpenToHalfOpenEnabled</td>
<td>false</td>
<td>如果设置为 true，则意味着 CircuitBreaker 将自动从打开状态转换为半打开状态，无需调用即可触发转换。一旦 waitDurationInOpenState 通过，就会创建一个线程来监视 CircuitBreakers 的所有实例以将它们转换为 HALF_OPEN。<br>然而，如果设置为 false，则只有在调用时才会发生到 HALF_OPEN 的转换，即使在 waitDurationInOpenState 被传递之后也是如此。这里的优点是没有线程监视所有 CircuitBreaker 的状态。</td>
</tr>
<tr>
<td>recordExceptions</td>
<td>空数组</td>
<td>记录为失败并因此增加失败率的异常列表。<br>任何匹配或从列表之一继承的异常都算作失败。 如果您指定异常列表，则所有其他异常都算成功，除非它们被 <code>ignoreExceptions</code> 配置明确忽略。</td>
</tr>
<tr>
<td>ignoreExceptions</td>
<td>空数组</td>
<td>被忽略且既不视为失败也不视为成功的异常列表。<br>任何匹配或从列表之一继承的异常都不会被视为失败或成功，即使异常被 <code>recordExceptions</code> 配置。</td>
</tr>
<tr>
<td>recordFailurePredicate 失败计数断言</td>
<td>throwable -&gt; true 默认匹配所有异常</td>
<td>一个自定义断言，用于评估是否应将异常记录为失败。<br>如果异常应计为失败，则断言必须返回 true；如果异常应计为成功，则断言必须返回 false。<br>除非异常被 <code>ignoreExceptions</code> 配置显式忽略。</td>
</tr>
<tr>
<td>ignoreExceptionPredicate 忽略异常断言</td>
<td>throwable -&gt; false 默认不匹配所有异常</td>
<td>一个自定义断言，用于评估是否应忽略异常并且既不计为失败也不计为成功。<br>如果应忽略异常，断言必须返回 true;如果异常应计为失败，则断言必须返回 false。</td>
</tr>
</tbody>
</table>
<h3 id="常用代码"> 常用代码</h3>
<div><pre><code><span>// Create a custom configuration for a CircuitBreaker</span>
<span>CircuitBreakerConfig</span> circuitBreakerConfig <span>=</span> <span>CircuitBreakerConfig</span><span>.</span><span>custom</span><span>(</span><span>)</span>
  <span>.</span><span>failureRateThreshold</span><span>(</span><span>50</span><span>)</span>
  <span>.</span><span>slowCallRateThreshold</span><span>(</span><span>50</span><span>)</span>
  <span>.</span><span>waitDurationInOpenState</span><span>(</span><span>Duration</span><span>.</span><span>ofMillis</span><span>(</span><span>1000</span><span>)</span><span>)</span>
  <span>.</span><span>slowCallDurationThreshold</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>2</span><span>)</span><span>)</span>
  <span>.</span><span>permittedNumberOfCallsInHalfOpenState</span><span>(</span><span>3</span><span>)</span>
  <span>.</span><span>minimumNumberOfCalls</span><span>(</span><span>10</span><span>)</span>
  <span>.</span><span>slidingWindowType</span><span>(</span><span>SlidingWindowType</span><span>.</span>TIME_BASED<span>)</span>
  <span>.</span><span>slidingWindowSize</span><span>(</span><span>5</span><span>)</span>
  <span>.</span><span>recordException</span><span>(</span>e <span>-></span> INTERNAL_SERVER_ERROR
                 <span>.</span><span>equals</span><span>(</span><span>getResponse</span><span>(</span><span>)</span><span>.</span><span>getStatus</span><span>(</span><span>)</span><span>)</span><span>)</span>
  <span>.</span><span>recordExceptions</span><span>(</span><span>IOException</span><span>.</span><span>class</span><span>,</span> <span>TimeoutException</span><span>.</span><span>class</span><span>)</span>
  <span>.</span><span>ignoreExceptions</span><span>(</span><span>BusinessException</span><span>.</span><span>class</span><span>,</span> <span>OtherBusinessException</span><span>.</span><span>class</span><span>)</span>
  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

<span>// Create a CircuitBreakerRegistry with a custom global configuration</span>
<span>CircuitBreakerRegistry</span> circuitBreakerRegistry <span>=</span> <span>CircuitBreakerRegistry</span><span>.</span><span>of</span><span>(</span>circuitBreakerConfig<span>)</span><span>;</span>

<span>// Get or create a CircuitBreaker from the CircuitBreakerRegistry </span>
<span>// with the global default configuration</span>
<span>CircuitBreaker</span> circuitBreakerWithDefaultConfig <span>=</span> circuitBreakerRegistry<span>.</span><span>circuitBreaker</span><span>(</span><span>"name1"</span><span>)</span><span>;</span>

<span>// Get or create a CircuitBreaker from the CircuitBreakerRegistry </span>
<span>// with a custom configuration</span>
<span>CircuitBreaker</span> circuitBreakerWithCustomConfig <span>=</span> circuitBreakerRegistry <span>.</span><span>circuitBreaker</span><span>(</span><span>"name2"</span><span>,</span> circuitBreakerConfig<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>Spring cloud 版本为 <code>2020.0.0</code>，浏览网站时间为 2022/02/21 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>WSL</title>
      <link>https://list-jiang.github.io/code/linux/WSL/</link>
      <guid>https://list-jiang.github.io/code/linux/WSL/</guid>
      <source url="https://list-jiang.github.io/rss.xml">WSL</source>
      <description>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。
</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre>
<div><span>1</span><br></div></div><h2 id="重启-wsl"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>归档和备份</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/archiving/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/archiving/</guid>
      <source url="https://list-jiang.github.io/rss.xml">归档和备份</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="归档和备份"> 归档和备份</h1>
<h2 id="gzip"> gzip</h2>
<p>gzip 程序用来压缩文件，原文件的压缩版(添加 <code>gz</code> 后缀名)会替代原文件。gunzip 程序用来还原压缩版本。</p>
<div><pre><code><span>gzip</span> foo.txt
gunzip foo.txt.gz
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>gzip</code> 的参数如下。</p>
<ul>
<li>-c 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。</li>
<li>-d 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.</li>
<li>-f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。</li>
<li>-h 显示用法信息。也可用--help 选项来指定。</li>
<li>-l 列出每个被压缩文件的压缩数据。也可用--list 选项。</li>
<li>-r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。</li>
<li>-t 测试压缩文件的完整性。也可用--test 选项来指定。</li>
<li>-v 显示压缩过程中的信息。也可用--verbose 选项来指定。</li>
<li>-number 设置压缩指数。number 是一个在 1(最快，最小压缩)到 9(最慢，最大压缩)之间的整数。数值 1 和 9 也可以各自用--fast 和--best 选项来表示。默认值是整数 6。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code><span># 查看解压缩后的内容</span>
$ gunzip -c foo.txt <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zcat</code> 程序等同于带有-c 选项的 gunzip 命令。它可以像 <code>cat</code> 命令那样，用来查看 <code>gzip</code> 压缩文件。</p>
<div><pre><code>zcat foo.txt.gz <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="bzip2"> bzip2</h2>
<p><code>bzip2</code> 程序与 <code>gzip</code> 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 <code>gzip</code>。由 <code>bzip2</code> 压缩的文件，用扩展名 <code>.bz2</code> 表示。</p>
<div><pre><code><span>bzip2</span> foo.txt
bunzip2 foo.txt.bz2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>gzip 程序的所有选项(除了 <code>-r</code>)，bzip2 程序同样也支持。同样有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p>
<h2 id="zip"> zip</h2>
<p><code>zip</code> 程序既是压缩工具，也是一个打包工具，读取和写入.zip 文件。</p>
<div><pre><code><span>zip</span> options zipfile file<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>它的用法如下。</p>
<div><pre><code><span># 将指定目录压缩成zip文件</span>
$ <span>zip</span> -r playground.zip playground
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>zip</code> 与 <code>tar</code> 命令有一个相反之处。如果压缩文件已存在，其将被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。</p>
<p>解压使用 <code>unzip</code> 命令。</p>
<div><pre><code><span>unzip</span> <span>..</span>/playground.zip
</code></pre>
<div><span>1</span><br></div></div><p><code>unzip</code> 命令的参数如下。</p>
<ul>
<li><code>-l</code> 列出文件包中的内容而不解压</li>
<li><code>-v</code> 显示冗余信息</li>
<li><code>-p</code> 输出发送到标准输出</li>
</ul>
<div><pre><code><span>unzip</span> -p ls-etc.zip <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="tar"> tar</h2>
<p><code>tar</code> 是 tape archive 的简称，原来是一款制作磁带备份的工具，现在主要用于打包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。</p>
<p><code>tar</code> 程序的语法如下。</p>
<div><pre><code><span>tar</span> mode<span>[</span>options<span>]</span> pathname<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>tar 支持以下模式。</p>
<ul>
<li>c 表示 create，为文件和／或目录列表创建归档文件。</li>
<li>x 抽取归档文件。</li>
<li>r 追加具体的路径到归档文件的末尾。</li>
<li>t 列出归档文件的内容。</li>
</ul>
<p>支持的参数如下。</p>
<ul>
<li>f 表示 file，用来指定生成的文件。</li>
</ul>
<p>模式和参数可以写在一起，而且不需要开头的短横线。注意，必须首先指定模式，然后才是其它的选项。</p>
<div><pre><code><span># 创建子目录的tar包</span>
$ <span>tar</span> cf playground.tar playground

<span># 查看tar包内容</span>
$ <span>tar</span> tf playground.tar

<span># 查看更详细的列表信息</span>
$ <span>tar</span> tvf playground.tar

<span># 还原归档文件</span>
$ <span>tar</span> xf playground.tar

<span># 还原单个文件</span>
$ <span>tar</span> xf archive.tar pathname

<span># 还原文件到指定目录</span>
$ <span>tar</span> xvf archive.tar -C /home/me/

<span># 追加文件</span>
$ <span>tar</span> rf archive.tar file.txt

<span># 验证归档文件内容是否正确</span>
$ <span>tar</span> tvfW archive.tar

<span># 支持通配符</span>
$ <span>tar</span> xf <span>..</span>/playground2.tar --wildcards <span>'home/me/playground/\*.txt'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>注意，<code>tar</code> 命令还原的时候，总是还原为相对路径。如果归档的时候，保存的是绝对路径，那么还原的时候，这个绝对路径会整个变成相对路径。</p>
<p><code>find</code> 命令可以与 <code>tar</code> 命令配合使用。</p>
<div><pre><code><span>find</span> playground -name <span>'file.txt'</span> -exec <span>tar</span> rf playground.tar <span>'{}'</span> <span>'+'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令先用 <code>find</code> 程序找到所有名为 <code>file.txt</code> 的文件，然后使用追加模式(<code>r</code>)的 <code>tar</code> 命令，把匹配的文件添加到归档文件 <code>playground.tar</code> 里面。</p>
<p>这种 <code>tar</code> 和 <code>find</code> 的配合使用，可以创建逐渐增加的目录树或者整个系统的备份。通过 <code>find</code> 命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件。</p>
<p>tar 支持压缩功能。</p>
<div><pre><code><span># 打成gzip压缩包</span>
$ <span>tar</span> czvf assets.tar.gz dist

<span># 打成bz2压缩包</span>
$ <span>tar</span> cvfj assets.tar.bz2 dist

<span># 解压 tar.gz 文件</span>
$ <span>tar</span> xzv archive.tar.gz
$ <span>tar</span> xvf archive.tar.gz

<span># 解压bz2压缩包</span>
$ <span>tar</span> xvf archive.tar.bz2

<span># 显示gzip压缩包内容</span>
$ <span>tar</span> tvf archive.tar.gz

<span># 显示bz2压缩包内容</span>
$ <span>tar</span> tvf archive.tar.bz2

<span># 从gzip压缩包取出单个文件</span>
$ <span>tar</span> zxvf archive.tar.gz file.txt

<span># 从bz2压缩包取出单个文件</span>
$ <span>tar</span> jxvf archive.tar.bz2 file.txt

<span># 按通配符取出文件</span>
$ <span>tar</span> zxvf archive.tar.gz --wildcards <span>'*.php'</span>
$ <span>tar</span> jxvf archive.tar.bz2 --wildcards <span>'*.php'</span>

<span># 追加文件到压缩包</span>
$ <span>tar</span> rvf archive.tar.gz xyz.txt
$ <span>tar</span> rvf archive.tar.bz2 xyz.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="rsync"> rsync</h2>
<p><code>rsync</code> 命令用于在多个目录之间、或者本地与远程目录之间同步。字母 <code>r</code> 表示 <code>remote</code>。</p>
<div><pre><code><span>rsync</span> options <span>source</span> destination
</code></pre>
<div><span>1</span><br></div></div><p>source 和 destination 是下列选项之一:</p>
<ul>
<li>一个本地文件或目录</li>
<li>一个远端文件或目录，以 <code>[user@]host:path</code> 的形式存在</li>
<li>一个远端 rsync 服务器，由 <code>rsync://[user@]host[:port]/path</code> 指定</li>
</ul>
<p>注意 source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制。</p>
<p><code>rsync</code> 命令的参数如下。</p>
<ul>
<li><code>-a</code> 递归和保护文件属性</li>
<li><code>-v</code> 冗余输出</li>
<li><code>--delete</code> 删除可能在备份设备中已经存在但却不再存在于源设备中的文件</li>
<li><code>--rsh=ssh</code> 使用 ssh 程序作为远程 shell，目的地必须标注主机名。</li>
</ul>
<div><pre><code><span># 同步两个本地目录</span>
$ <span>rsync</span> -av playground foo

<span># 删除源设备不存在的文件</span>
$ <span>sudo</span> <span>rsync</span> -av --delete /etc /home /usr/local /media/BigDisk/backup

<span># 远程同步</span>
$ <span>sudo</span> <span>rsync</span> -av --delete --rsh<span>=</span>ssh /etc /home /usr/local remote-sys:/backup

<span># 与远程rsync主机同步</span>
$ <span>rsync</span> -av -delete rsync://rsync.gtlib.gatech.edu/path/to/oss fedora-devel
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>异步任务</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/async/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/async/</guid>
      <source url="https://list-jiang.github.io/rss.xml">异步任务</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="异步任务"> 异步任务</h1>
<p>Bash 脚本有时候需要同时执行多个任务。通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办?</p>
<p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程(例如，子脚本)运行结束。</p>
<p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-parent : Asynchronous execution demo (parent)</span>
<span>echo</span> <span>"Parent: starting..."</span>
<span>echo</span> <span>"Parent: launching child script..."</span>
async-child <span>&amp;</span>
<span>pid</span><span>=</span><span>$!</span>
<span>echo</span> <span>"Parent: child (PID= <span>$pid</span>) launched."</span>
<span>echo</span> <span>"Parent: continuing..."</span>
<span>sleep</span> <span>2</span>
<span>echo</span> <span>"Parent: pausing to wait for child to finish..."</span>
<span>wait</span> <span>$pid</span>
<span>echo</span> <span>"Parent: child is finished. Continuing..."</span>
<span>echo</span> <span>"Parent: parent is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>和一个子脚本:</p>
<div><pre><code><span>#!/bin/bash</span>
<span># async-child : Asynchronous execution demo (child)</span>
<span>echo</span> <span>"Child: child is running..."</span>
<span>sleep</span> <span>5</span>
<span>echo</span> <span>"Child: child is done. Exiting."</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p>
<p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出， 意味着父脚本结束。</p>
<p>当执行后，父子脚本产生如下输出:</p>
<div><pre><code>$ async-parent
Parent: starting<span>..</span>.
Parent: launching child script<span>..</span>.
Parent: child <span>(</span>PID<span>=</span> <span>6741</span><span>)</span> launched.
Parent: continuing<span>..</span>.
Child: child is running<span>..</span>.
Parent: pausing to <span>wait</span> <span>for</span> child to finish<span>..</span>.
Child: child is done. Exiting.
Parent: child is finished. Continuing<span>..</span>.
Parent: parent is done. Exiting.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Shell 的命令</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/command/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/command/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Shell 的命令</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="shell-的命令"> Shell 的命令</h1>
<h2 id="命令的类别"> 命令的类别</h2>
<p>Bash 可以使用的命令分成四类。</p>
<ul>
<li>可执行程序</li>
<li>Shell 提供的命令</li>
<li>Shell 函数</li>
<li>前三类命令的别名</li>
</ul>
<h2 id="type-whatis"> type, whatis</h2>
<p><code>type</code> 命令可以显示命令类型。</p>
<div><pre><code><span>type</span> <span>command</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是几个例子。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>

$ <span>type</span> <span>ls</span>
<span>ls</span> is aliased to `ls --color<span>=</span>tty'

$ <span>type</span> <span>cp</span>
<span>cp</span> is /bin/cp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>whatis</code> 命令显示指定命令的描述。</p>
<div><pre><code>$ whatis <span>ls</span>
<span>ls</span> <span>(</span><span>1</span><span>)</span> - list directory contents
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="apropos"> apropos</h2>
<p><code>apropos</code> 命令返回符合搜索条件的命令列表。</p>
<div><pre><code>$ <span>apropos</span> floppy
create_floppy_devices <span>(</span><span>8</span><span>)</span> - udev callout to create all possible
<span>fdformat</span> <span>(</span><span>8</span><span>)</span> - Low-level formats a floppy disk
floppy <span>(</span><span>8</span><span>)</span> - <span>format</span> floppy disks
gfloppy <span>(</span><span>1</span><span>)</span> - a simple floppy formatter <span>for</span> the GNOME
mbadblocks <span>(</span><span>1</span><span>)</span> - tests a floppy disk, and marks the bad
mformat <span>(</span><span>1</span><span>)</span> - <span>add</span> an MSDOS filesystem to a low-level
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="alias-unalias"> alias, unalias</h2>
<p><code>alias</code> 命令用来为命令起别名。</p>
<div><pre><code>$ <span>alias</span> <span>foo</span><span>=</span><span>'cd /usr; ls; cd -'</span>

$ <span>type</span> foo
foo is aliased to `cd /usr<span>;</span> <span>ls</span> <span>;</span> <span>cd</span> -'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令指定 <code>foo</code> 为三个命令的别名。以后，执行 <code>foo</code> 就相当于一起执行这三条命令。</p>
<p>注意，默认情况下，别名只在当前 Session 有效。当前 Session 结束时，这些别名就会消失。</p>
<p><code>alias</code> 命令不加参数时，显示所有有效的别名。</p>
<div><pre><code>$ <span>alias</span>
<span>alias</span> l.<span>=</span><span>'ls -d .* --color=tty'</span>
<span>alias</span> <span>ll</span><span>=</span><span>'ls -l --color=tty'</span>
<span>alias</span> <span>ls</span><span>=</span><span>'ls --color=tty'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>unalias</code> 命令用来取消别名。</p>
<div><pre><code>$ <span>unalias</span> foo
$ <span>type</span> foo
bash: type: foo: not found
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="which"> which</h2>
<p><code>which</code> 命令显示可执行程序的路径。</p>
<div><pre><code>$ <span>which</span> <span>ls</span>
/bin/ls
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>which</code> 命令用于 Shell 内置命令时(比如 <code>cd</code>)，将没有任何输出。</p>
<h2 id="help-man"> help，man</h2>
<p><code>help</code> 命令用于查看 Shell 内置命令的帮助信息，<code>man</code> 命令用于查看可执行命令的帮助信息。</p>
<div><pre><code><span>help</span> <span>cd</span>
<span>man</span> <span>ls</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>man</code> 里面的文档一共有 8 类，如果同一个命令，匹配多个文档，<code>man</code> 命令总是返回第一个匹配。如果想看指定类型的文档，命令可以采用下面的形式。</p>
<div><pre><code><span>man</span> <span>5</span> <span>passwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="script"> script</h2>
<p><code>script</code> 命令会将输入的命令和它的输出，都保存进一个文件。</p>
<div><pre><code>script <span>[</span>file<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，则所有结果会保存进当前目录下 <code>typescript</code> 文件。结束录制的时候，可以按下 <code>Ctrl + d</code>。</p>
<h2 id="export"> export</h2>
<p><code>export</code> 命令用于将当前进程的变量，输出到所有子进程。</p>
<h2 id="命令的连续执行"> 命令的连续执行</h2>
<p>多个命令可以写在一起。</p>
<p>Bash 提供三种方式，定义它们如何执行。</p>
<div><pre><code><span># 第一个命令执行完，执行第二个命令</span>
command1<span>;</span> command2

<span># 只有第一个命令成功执行完(退出码0)，才会执行第二个命令</span>
command1 <span>&amp;&amp;</span> command2

<span># 只有第一个命令执行失败(退出码非0)，才会执行第二个命令</span>
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种执行方法的退出码，都是最后一条执行的命令的退出码。</p>
<p>bash 允许把命令组合在一起。可以通过两种方式完成；要么用一个 group 命令，要么用一个子 shell。这里是每种方式的语法示例:</p>
<p>组命令:</p>
<div><pre><code><span>{</span> command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span> <span>..</span>.<span>]</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>子 shell</p>
<div><pre><code><span>(</span>command1<span>;</span> command2<span>;</span> <span>[</span>command3<span>;</span><span>..</span>.<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式， 花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。</p>
<p>那么组命令和子 shell 命令对什么有好处呢? 它们都是用来管理重定向的。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>使用一个子 shell 是相似的。</p>
<div><pre><code><span>(</span>ls -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>)</span> <span>></span> output.txt
</code></pre>
<div><span>1</span><br></div></div><p>组命令和子 shell 真正闪光的地方是与管道线相结合。当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一个流是很有用的。组命令和子 shell 使这种操作变得很简单。</p>
<div><pre><code><span>{</span> <span>ls</span> -l<span>;</span> <span>echo</span> <span>"Listing of foo.txt"</span><span>;</span> <span>cat</span> foo.txt<span>;</span> <span>}</span> <span>|</span> <span>lpr</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr 的输入，以便产生一个打印报告。</p>
<p>虽然组命令和子 shell 看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个很重要的不同。然而，一个组命令在当前 shell 中执行它的所有命令，而一个子 shell(顾名思义)在当前 shell 的一个 子副本中执行它的命令。这意味着运行环境被复制给了一个新的 shell 实例。当这个子 shell 退出时，环境副本会消失， 所以在子 shell 环境(包括变量赋值)中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell， 组命令比子 shell 更受欢迎。组命令运行很快并且占用的内存也少。</p>
<p>当我们发现管道线中的一个 read 命令 不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线:</p>
<div><pre><code><span>echo</span> <span>"foo"</span> <span>|</span> <span>read</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>该 REPLY 变量的内容总是为空，是因为这个 read 命令在一个子 shell 中执行，所以它的 REPLY 副本会被毁掉， 当该子 shell 终止的时候。因为管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题。幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式:</p>
<p>一种适用于产生标准输出的进程:</p>
<div><pre><code><span>&lt;</span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>另一种适用于接受标准输入的进程:</p>
<div><pre><code><span>></span><span>(</span>list<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>这里的 list 是一串命令列表:</p>
<p>为了解决我们的 read 命令问题，我们可以雇佣进程替换，像这样。</p>
<div><pre><code><span>read</span> <span>&lt;</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
<span>echo</span> <span>$REPLY</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>进程替换允许我们把一个子 shell 的输出结果当作一个用于重定向的普通文件。事实上，因为它是一种展开形式，我们可以检验它的真实值:</p>
<div><pre><code><span>[</span>me@linuxbox ~<span>]</span>$ <span>echo</span> <span>&lt;</span><span>(</span><span>echo</span> <span>"foo"</span><span>)</span>
/dev/fd/63
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过使用 echo 命令，查看展开结果，我们看到子 shell 的输出结果，由一个名为 /dev/fd/63 的文件提供。</p>
]]></content:encoded>
    </item>
    <item>
      <title>alias</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/alias/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/alias/</guid>
      <source url="https://list-jiang.github.io/rss.xml">alias</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="alias"> alias</h1>
<p><code>alias</code> 命令用于设置别名。通常用于在 Bash 设置文件中，设置别名。</p>
<div><pre><code><span>alias</span> <span>dockerlogin</span><span>=</span><span>'ssh www-data@adnan.local -p2222'</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>awk</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/awk/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/awk/</guid>
      <source url="https://list-jiang.github.io/rss.xml">awk</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="awk"> awk</h1>
<p><a href="https://en.wikipedia.org/wiki/AWK" target="_blank" rel="noopener noreferrer"><code>awk</code><i>Content not supported</i></a>是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。</p>
<p>它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，<code>awk</code> 可能是最方便的工具。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201811/bg2018110702.jpg" alt="Book"></p>
<p><code>awk</code> 其实不仅仅是工具软件，还是一种编程语言。不过，这里只介绍它的命令行用法，对于大多数场合，应该足够用了。</p>
<h2 id="基本用法"> 基本用法</h2>
<p><code>awk</code> 的基本用法就是下面的形式。</p>
<div><pre><code><span># 格式</span>
$ <span>awk</span> 动作 文件名

<span># 示例</span>
$ <span>awk</span> <span>'{print $0}'</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面示例中，<code>demo.txt</code> 是 <code>awk</code> 所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作 <code>print $0</code>。其中，<code>print</code> 是打印命令，<code>$0</code> 代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。</p>
<p>下面，我们先用标准输入(stdin)演示上面这个例子。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $0}'</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>print $0</code> 就是把标准输入 <code>this is a test</code>，重新打印了一遍。</p>
<p><code>awk</code> 会根据空格和制表符，将每一行分成若干字段，依次用<code>$1</code>、<code>$2</code>、<code>$3</code> 代表第一个字段、第二个字段、第三个字段等等。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $3}'</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>$3</code> 代表 <code>this is a test</code> 的第三个字段 <code>a</code>。</p>
<p>下面，为了便于举例，我们把<code>/etc/passwd</code> 文件保存成 <code>demo.txt</code>。</p>
<div><pre><code>root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个文件的字段分隔符是冒号(<code>:</code>)，所以要用 <code>-F</code> 参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print $1 }'</span> demo.txt
root
daemon
bin
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="变量"> 变量</h2>
<p>除了<code>$ + 数字</code>表示某个字段，<code>awk</code> 还提供其他一些变量。</p>
<p>变量 <code>NF</code> 表示当前行有多少个字段，因此<code>$NF</code> 就代表最后一个字段。</p>
<div><pre><code>$ <span>echo</span> <span>'this is a test'</span> <span>|</span> <span>awk</span> <span>'{print $NF}'</span>
<span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(NF-1)</code> 代表倒数第二个字段。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print $1, $(NF-1)}'</span> demo.txt
root /root
daemon /usr/sbin
bin /bin
sys /dev
<span>sync</span> /bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p>
<p>变量 <code>NR</code> 表示当前处理的是第几行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{print NR ") " $1}'</span> demo.txt
<span>1</span><span>)</span> root
<span>2</span><span>)</span> daemon
<span>3</span><span>)</span> bin
<span>4</span><span>)</span> sys
<span>5</span><span>)</span> <span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>print</code> 命令里面，如果原样输出字符，要放在双引号里面。</p>
<p><code>awk</code> 的其他内置变量如下。</p>
<blockquote>
<ul>
<li><code>FILENAME</code>: 当前文件名</li>
<li><code>FS</code>: 字段分隔符，默认是空格和制表符。</li>
<li><code>RS</code>: 行分隔符，用于分割每一行，默认是换行符。</li>
<li><code>OFS</code>: 输出字段的分隔符，用于打印时分隔字段，默认为空格。</li>
<li><code>ORS</code>: 输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li>
<li><code>OFMT</code>: 数字输出的格式，默认为<code>％.6g</code>。</li>
</ul>
</blockquote>
<h2 id="函数"> 函数</h2>
<p><code>awk</code> 还提供了一些内置函数，方便对原始数据的处理。</p>
<p>函数 <code>toupper()</code> 用于将字符转为大写。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{ print toupper($1) }'</span> demo.txt
ROOT
DAEMON
BIN
SYS
SYNC
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，第一个字段输出时都变成了大写。</p>
<p>其他常用函数如下。</p>
<blockquote>
<ul>
<li><code>tolower()</code>: 字符转为小写。</li>
<li><code>length()</code>: 返回字符串长度。</li>
<li><code>substr()</code>: 返回子字符串。</li>
<li><code>sin()</code>: 正弦。</li>
<li><code>cos()</code>: 余弦。</li>
<li><code>sqrt()</code>: 平方根。</li>
<li><code>rand()</code>: 随机数。</li>
</ul>
</blockquote>
<p><code>awk</code> 内置函数的完整列表，可以查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din" target="_blank" rel="noopener noreferrer">手册<i>Content not supported</i></a>。</p>
<h2 id="条件"> 条件</h2>
<p><code>awk</code> 允许指定输出条件，只输出符合条件的行。</p>
<p>输出条件要写在动作的前面。</p>
<div><pre><code><span>awk</span> <span>'条件 动作'</span> 文件名
</code></pre>
<div><span>1</span><br></div></div><p>请看下面的例子。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'/usr/ {print $1}'</span> demo.txt
root
daemon
bin
sys
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>print</code> 命令前面是一个正则表达式，只输出包含 <code>usr</code> 的行。</p>
<p>下面的例子只输出奇数行，以及输出第三行以后的行。</p>
<div><pre><code><span># 输出奇数行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR % 2 == 1 {print $1}'</span> demo.txt
root
bin
<span>sync</span>

<span># 输出第三行以后的行</span>
$ <span>awk</span> -F <span>':'</span> <span>'NR >3 {print $1}'</span> demo.txt
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>下面的例子输出第一个字段等于指定值的行。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'$1 == "root" {print $1}'</span> demo.txt
root

$ <span>awk</span> -F <span>':'</span> <span>'$1 == "root" || $1 == "bin" {print $1}'</span> demo.txt
root
bin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="if-语句"> if 语句</h2>
<p><code>awk</code> 提供了 <code>if</code> 结构，用于编写复杂的条件。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if ($1 > "m") print $1}'</span> demo.txt
root
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码输出第一个字段的第一个字符大于 <code>m</code> 的行。</p>
<p><code>if</code> 结构还可以指定 <code>else</code> 部分。</p>
<div><pre><code>$ <span>awk</span> -F <span>':'</span> <span>'{if ($1 > "m") print $1; else print "---"}'</span> demo.txt
root
---
---
sys
<span>sync</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://gregable.com/2010/09/why-you-should-know-just-little-awk.html" target="_blank" rel="noopener noreferrer">An Awk tutorial by Example<i>Content not supported</i></a>, Greg Grothaus</li>
<li><a href="https://likegeeks.com/awk-command/" target="_blank" rel="noopener noreferrer">30 Examples for Awk Command in Text Processing<i>Content not supported</i></a>, Mokhtar Ebrahim</li>
</ul>
]]></content:encoded>
      <enclosure url="https://www.wangbase.com/blogimg/asset/201811/bg2018110702.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>cal</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/cal/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/cal/</guid>
      <source url="https://list-jiang.github.io/rss.xml">cal</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cal"> cal</h1>
<p><code>cal</code> 命令显示本月的日历。</p>
<div><pre><code><span>cal</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>cat</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/cat/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/cat/</guid>
      <source url="https://list-jiang.github.io/rss.xml">cat</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cat"> cat</h1>
<p><code>cat</code> 命令用于显示一个文本文件的内容。</p>
<p><code>cat - &gt;&gt; filename</code> 用于向一个现有文件的尾部追加内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>clear</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/clear/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/clear/</guid>
      <source url="https://list-jiang.github.io/rss.xml">clear</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="clear"> clear</h1>
<p><code>clear</code> 命令用来清除当前屏幕的显示，运行后会只留下一个提示符。</p>
<div><pre><code><span>clear</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>cp 命令</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/cp/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/cp/</guid>
      <source url="https://list-jiang.github.io/rss.xml">cp 命令</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cp-命令"> cp 命令</h1>
<p><code>cp</code> 命令用于复制文件。</p>
<h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数只复制那些目标目录里面还不存在的文件，以及那些虽然存在、但是比源目录对应文件更陈旧的文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>cut</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/cut/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/cut/</guid>
      <source url="https://list-jiang.github.io/rss.xml">cut</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="cut"> cut</h1>
<p><code>cut</code> 命令用于在命令行输出文本文件的指定位置的内容。</p>
<p>它的使用格式如下。</p>
<div><pre><code><span>cut</span> OPTION <span>[</span>FILE<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果没有指定文件名，将读取标准输入。</p>
<p><code>-b</code> 参数用来指定读取的字节。</p>
<div><pre><code><span># 输出前三个字节</span>
$ <span>cut</span> file1.txt -b1,2,3

<span># 输出前十个字节</span>
$ <span>cut</span> file1.txt -b1-10

<span># 输出从第5个字节开始的所有字节</span>
$ <span>cut</span> file1.txt -b5-

<span># 输出前5个字节</span>
$ <span>cut</span> file1.txt -b-5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>-c</code> 参数用来指定读取的字符，用法与 <code>-b</code> 一样。有的字符是多字节字符，这时候就应该用 <code>-c</code> 代替 <code>-b</code>。</p>
<p><code>-d</code> 参数用来指定分隔符，默认分隔符为制表符。</p>
<p><code>-f</code> 参数用来指定字段。</p>
<div><pre><code><span># 指定每一行的分隔符为逗号，</span>
<span># 输出第一和第三个字段</span>
$ <span>cut</span> file1.txt -d, -f1,3

<span># 输出第一、第二、第四和第五个字段</span>
$ <span>cut</span> -f <span>1</span>-2,4-5 data.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>date</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/date/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/date/</guid>
      <source url="https://list-jiang.github.io/rss.xml">date</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="date"> date</h1>
<p><code>date</code> 命令显示当前的日期和时间。</p>
<div><pre><code><span>date</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>dd</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/dd/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/dd/</guid>
      <source url="https://list-jiang.github.io/rss.xml">dd</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="dd"> dd</h1>
<p><code>dd</code> 命令用于复制磁盘或文件系统。</p>
<h2 id="复制磁盘"> 复制磁盘</h2>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示将<code>/dev/sda</code> 磁盘复制到<code>/dev/sdb</code> 设备。参数 <code>if</code> 表示来源地，<code>of</code> 表示目的地。</p>
<p>除了复制，<code>dd</code> 还允许将磁盘做成一个镜像文件。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda <span>of</span><span>=</span>/home/username/sdadisk.img
</code></pre>
<div><span>1</span><br></div></div><p><code>dd</code> 还可以复制单个分区。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>/dev/sda2 <span>of</span><span>=</span>/home/username/partition2.img <span>bs</span><span>=</span><span>4096</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，参数 <code>bs</code> 表示单次拷贝的字节数(bytes)。</p>
<p>要将镜像文件复原，也很简单。</p>
<div><pre><code><span>dd</span> <span>if</span><span>=</span>sdadisk.img <span>of</span><span>=</span>/dev/sdb
</code></pre>
<div><span>1</span><br></div></div><h2 id="清除数据"> 清除数据</h2>
<p><code>dd</code> 也可以用于清除磁盘数据。</p>
<div><pre><code><span># 磁盘数据写满 0</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/zero <span>of</span><span>=</span>/dev/sda1

<span># 磁盘数据写满随机字符</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>of</span><span>=</span>/dev/sda1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="监控进展"> 监控进展</h2>
<p>磁盘的复制通常需要很久，为了监控进展，可以使用 Pipe Viewer 工具软件。如果没有安装这个软件，可以使用下面的命令安装。</p>
<div><pre><code><span>sudo</span> <span>apt</span> <span>install</span> <span>pv</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后，来源地和目的地之间插入广告，就可以看到进展了。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>/dev/urandom <span>|</span> <span>pv</span> <span>|</span> <span>dd</span> <span>of</span><span>=</span>/dev/sda1
<span>4</span>,14MB <span>0</span>:00:05 <span>[</span> 98kB/s<span>]</span> <span>[</span>      <span>&lt;=</span><span>></span>                  <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li>David Clinton, <a href="https://opensource.com/article/18/7/how-use-dd-linux" target="_blank" rel="noopener noreferrer">How to use dd in Linux without destroying your disk<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>df</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/df/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/df/</guid>
      <source url="https://list-jiang.github.io/rss.xml">df</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="df"> df</h1>
<p><code>df</code> 命令显示磁盘信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>du</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/du/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/du/</guid>
      <source url="https://list-jiang.github.io/rss.xml">du</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="du"> du</h1>
<p><code>du</code> 命令显示某个文件或目录的磁盘使用量。</p>
<div><pre><code><span>du</span> filename
</code></pre>
<div><span>1</span><br></div></div><p><code>-h</code> 参数将返回的大小显示为人类可读的格式，即显示单位为 K、M、G 等。</p>
<p><code>-s</code> 参数表示总结(summarize)。</p>
<p><code>-x</code> 参数表示不显示不在当前分区的目录，通常会忽略<code>/dev</code>、<code>/proc</code>、<code>/sys</code> 等目录。</p>
<p><code>-c</code> 参数表示显示当前目录总共占用的空间大小。</p>
<div><pre><code><span># 显示根目录下各级目录占用的空间大小</span>
$ <span>sudo</span> <span>du</span> -shxc /*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--exclude</code> 参数用于排除某些目录或文件。</p>
<div><pre><code><span>sudo</span> <span>du</span> -shxc /* --exclude<span>=</span>proc
<span>sudo</span> <span>du</span> -sh --exclude<span>=</span>*.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>--max-depth</code> 参数用于设定目录大小统计到第几层。如果设为 <code>-–max-depth=0</code>，那么等同于 <code>-s</code> 参数。</p>
<div><pre><code><span>sudo</span> <span>du</span> /home/ -hc --max-depth<span>=</span><span>2</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>egrep</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/egrep/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/egrep/</guid>
      <source url="https://list-jiang.github.io/rss.xml">egrep</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="egrep"> egrep</h1>
<p><code>egrep</code> 命令用于显示匹配正则模式的行，与 <code>grep -E</code> 命令等价。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
sed diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, sed
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>egrep</code> 命令显示包括 <code>Lorem</code> 或 <code>dolor</code> 的行。</p>
<div><pre><code>$ <span>egrep</span> <span>'(Lorem|dolor)'</span> example.txt
<span># 或者</span>
$ <span>grep</span> -E <span>'(Lorem|dolor)'</span> example.txt
Lorem ipsum
dolor sit amet,
et dolore magna
duo dolores et ea
sanctus est Lorem
ipsum dolor sit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>export</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/export/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/export/</guid>
      <source url="https://list-jiang.github.io/rss.xml">export</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="export"> export</h1>
<p><code>export</code> 命令用于向子 Shell 输出变量。</p>
<div><pre><code><span>export</span> <span>hotellogs</span><span>=</span><span>"/workspace/hotel-api/storage/logs"</span>
</code></pre>
<div><span>1</span><br></div></div><p>然后执行下面的命令，新建一个子 Shell。</p>
<div><pre><code><span>bash</span>
<span>cd</span> hotellogs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行结果会进入 <code>hotellogs</code> 变量指向的目录。</p>
<p><code>export</code> 命令还可以显示所有环境变量。</p>
<div><pre><code>$ <span>export</span>
<span><span>SHELL</span></span><span>=</span>/bin/zsh
<span>AWS_HOME</span><span>=</span>/Users/adnanadnan/.aws
<span><span>LANG</span></span><span>=</span>en_US.UTF-8
<span>LC_CTYPE</span><span>=</span>en_US.UTF-8
<span>LESS</span><span>=</span>-R
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果想查看单个变量，使用 <code>echo $VARIABLE_NAME</code>。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/usr/bin/zsh
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>file</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/file/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/file/</guid>
      <source url="https://list-jiang.github.io/rss.xml">file</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="file"> file</h1>
<p><code>file</code> 命令用来某个文件的类型。</p>
<div><pre><code>$ <span>file</span> index.html
 index.html: HTML document, ASCII text
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>file 工具可以对所给的文件一行简短的介绍，它用文件后缀、头部信息和一些其他的线索来判断文件。您在检查一堆您不熟悉的文件时使用 find 非常方便:</p>
<div><pre><code>$ <span>find</span> -exec <span>file</span> <span>{</span><span>}</span> <span>\</span><span>;</span>
.:            directory
./hanoi:      Perl script, ASCII text executable
./.hanoi.swp: Vim swap file, version <span>7.3</span>
./factorial:  Perl script, ASCII text executable
./bits.c:     C source, ASCII text
./bits:       ELF <span>32</span>-bit LSB executable, Intel <span>80386</span>, version <span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>find</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/find/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/find/</guid>
      <source url="https://list-jiang.github.io/rss.xml">find</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="find"> find</h1>
<p><code>find</code> 命令用于寻找文件，会包括当前目录的所有下级目录。</p>
<p>如果不带任何参数，<code>find</code> 文件会列出当前目录的所有文件，甚至还包括相对路径。如果把结果导入 <code>sort</code> 效果更好。</p>
<div><pre><code>$ <span>find</span> <span>|</span> <span>sort</span>
<span>.</span>
./Makefile
./README
./build
./client.c
./client.h
./common.h
./project.c
./server.c
./server.h
./tests
./tests/suite1.pl
./tests/suite2.pl
./tests/suite3.pl
./tests/suite4.pl
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果想要 <code>ls -l</code> 样式的列表，只要在 <code>find</code> 后面加上 <code>-ls</code>。</p>
<div><pre><code><span>find</span> -ls
</code></pre>
<div><span>1</span><br></div></div><p><code>find</code> 有它自己的一套复杂的过滤语句。下面列举的是一些最常用的您可以用以获取某些文件列表的过滤器:</p>
<ul>
<li><code>find -name '*.c'</code> —— 查找符合某 shell 式样式的文件名的文件。用 iname 开启大小写不敏感搜索。</li>
<li><code>find -path '_test_'</code> —— 查找符合某 shell 式样式的路径的文件。用 ipath 开启大小写不敏感搜索。</li>
<li><code>find -mtime -5</code> —— 查找近五天内编辑过的文件。您也可以用 +5 来查找五天之前编辑过的文件。</li>
<li><code>find -newer server.c</code> —— 查找比 server.c 更新的文件。</li>
<li><code>find -type d</code> —— 查找所有文件夹。如果想找出所有文件，那就用 <code>-type f</code>；找符号连接就用 <code>-type l</code>。</li>
</ul>
<p>要注意，上面提到的这些过滤器都是可以组合使用的，例如找出近两天内编辑过的 C 源码:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -mtime -2
</code></pre>
<div><span>1</span><br></div></div><p>默认情况下， find 对搜索结果所采取的动作只是简单地通过标准输出输出一个列表，然而其实还有其他一些有用的后续动作。</p>
<ul>
<li>-ls —— 如前文，提供了一种类 ls -l 式的列表。</li>
<li>-delete —— 删除符合查找条件的文件。</li>
<li>-exec —— 对搜索结果里的每个文件都运行某个命令， <code>{}</code> 会被替换成适当的文件名，并且命令用 <code>\;</code> 终结。</li>
</ul>
<div><pre><code><span>find</span> -name <span>'*.pl'</span> -exec perl -c <span>{</span><span>}</span> <span>\</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>您也可以使用 <code>+</code> 作为终止符来对所有结果运行一次命令。我还发现一个我经常使用的小技巧，就是用 <code>find</code> 生成一个文件列表，然后在 Vim 的垂直分窗中编辑:</p>
<div><pre><code><span>find</span> -name <span>'*.c'</span> -exec <span>vim</span> <span>{</span><span>}</span> +
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>fmt</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/fmt/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/fmt/</guid>
      <source url="https://list-jiang.github.io/rss.xml">fmt</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="fmt"> fmt</h1>
<p><code>fmt</code> 命令用于对文本指定样式。</p>
<p>下面是 <code>example.txt</code> 的内容，是非常长的一行。</p>
<div><pre><code>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
</code></pre>
<div><span>1</span><br></div></div><p><code>fmt</code> 可以将其输出为每行 80 个字符。</p>
<div><pre><code><span>cat</span> example.txt <span>|</span> <span>fmt</span> -w <span>20</span>
Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>grep</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/grep/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/grep/</guid>
      <source url="https://list-jiang.github.io/rss.xml">grep</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="grep"> grep</h1>
<p><code>grep</code> 命令用于文件内容的搜索，返回所有匹配的行。</p>
<div><pre><code><span>grep</span> pattern filename
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>grep</span> admin /etc/passwd
_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false
_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false
_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般情况下，应该使用 <code>grep -R</code>，递归地找出当前目录下符合 <code>someVar</code> 的文件。</p>
<div><pre><code><span>grep</span> -FR <span>'someVar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>別忘了大小不敏感的参数，因为 grep 默认搜索是大小写敏感的。</p>
<div><pre><code><span>grep</span> -iR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>也可以用 <code>grep -l</code> 光打印出符合条件的文件名而非文件内容选段。</p>
<div><pre><code><span>grep</span> -lR <span>'somevar'</span> <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果您写的脚本或批处理任务需要上面的输出内容，可以使用 while 和 read 来处理文件名中的空格和其他特殊字符:</p>
<div><pre><code><span>grep</span> -lR someVar <span>|</span> <span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r <span>file</span><span>;</span> <span>do</span>
    <span>head</span> <span>"<span>$file</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果您在您的项目里使用了版本控制软件，它通常会在 .svn， .git， .hg 目录下包含一些元数据。您也可以很容易地用 grep -v 把这些目录移出搜索范围，当然得用 grep -F 指定一个恰当且确定的字符串，即要移除的目录名:</p>
<div><pre><code><span>grep</span> -R <span>'someVar'</span> <span>.</span> <span>|</span> <span>grep</span> -vF <span>'.svn'</span>
</code></pre>
<div><span>1</span><br></div></div><p>部分版本的 grep 包含了 --exclude 和 --exclude-dir 选项，这看起来更加易读。</p>
<h2 id="参数"> 参数</h2>
<p><code>-i</code> 参数表示忽略大小写。</p>
<p><code>-r</code> 表示搜索某个目录下面的所有文件。</p>
<div><pre><code><span>grep</span> -r admin /etc/
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 过滤包含某个词的行，即 <code>grep</code> 的逆操作。</p>
<div><pre><code><span># 显示所有包含 vim，但不包含 grep 的行</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vim</span> <span>|</span> <span>grep</span> -v <span>grep</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>gunzip</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/gunzip/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/gunzip/</guid>
      <source url="https://list-jiang.github.io/rss.xml">gunzip</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="gunzip"> gunzip</h1>
<p><code>gunzip</code> 命令用于解压 <code>gzip</code> 命令压缩的文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>gzcat</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/gzcat/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/gzcat/</guid>
      <source url="https://list-jiang.github.io/rss.xml">gzcat</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="gzcat"> gzcat</h1>
<p><code>gzcat</code> 命令用于查看一个 <code>gz</code> 文件，但并不实际解压它。</p>
<div><pre><code>gzcat filename
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>gzip</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/gzip/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/gzip/</guid>
      <source url="https://list-jiang.github.io/rss.xml">gzip</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="gzip"> gzip</h1>
<p><code>gzip</code> 命令用于压缩文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>kill</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/kill/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/kill/</guid>
      <source url="https://list-jiang.github.io/rss.xml">kill</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="kill"> kill</h1>
<p><code>kill</code> 命令用户终止指定进程。</p>
<div><pre><code><span>kill</span> PID
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>killall</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/killall/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/killall/</guid>
      <source url="https://list-jiang.github.io/rss.xml">killall</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="killall"> killall</h1>
<p><code>killall</code> 命令终止给定名字的一系列相关进程。</p>
<div><pre><code><span>killall</span> processname
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>last</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/last/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/last/</guid>
      <source url="https://list-jiang.github.io/rss.xml">last</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="last"> last</h1>
<p><code>last</code> 命令显示用户登录系统的记录。</p>
<div><pre><code>last
</code></pre>
<div><span>1</span><br></div></div><p><code>last</code> 命令后面加上用户名，会显示该用户上次登录的信息。</p>
<div><pre><code>last yourUsername
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>lpq</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/lpq/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/lpq/</guid>
      <source url="https://list-jiang.github.io/rss.xml">lpq</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="lpq"> lpq</h1>
<p><code>lpq</code> 命令显示打印机队列。</p>
<div><pre><code>$ lpq
Rank    Owner   Job     File<span>(</span>s<span>)</span>                         Total Size
active  adnanad <span>59</span>      demo                            <span>399360</span> bytes
1st     adnanad <span>60</span>      <span>(</span>stdin<span>)</span>                         <span>0</span> bytes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>lpr</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/lpr/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/lpr/</guid>
      <source url="https://list-jiang.github.io/rss.xml">lpr</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="lpr"> lpr</h1>
<p><code>lpr</code> 命令用于打印文件。</p>
<div><pre><code><span>lpr</span> filename
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ls</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/ls/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/ls/</guid>
      <source url="https://list-jiang.github.io/rss.xml">ls</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="ls"> ls</h1>
<p><code>ls</code> 命令用于列出当前目录里面的文件和子目录。</p>
<h2 id="参数"> 参数</h2>
<ul>
<li>a: 列出隐藏文件</li>
<li>l: 以长格式列出文件</li>
<li>t: 按最后编辑日期排序，最新的最先。这在某个大目录里找出最近修改的文件列表时很有用，比如将结果导入( pipe ) head 或者 sed 10q。或许加上 -l 会效果更好。当然如果您想获取最旧的文件列表，只要加 -r 反转列表即可。</li>
<li>X: 按文件类型分类。这在多语言或多后缀的项目中特别方便，比如头文件和源文件分开，或区分开源文件和生成文件或目录。</li>
<li>v: 按照文件名里的版本号排序。</li>
<li>S: 按文件大小排序。</li>
<li>R: 递归地列举文件。这个选项和 -l 组合使用并将结果导出到 less 效果很好。</li>
</ul>
<p>可以把结果导出给类似 vim 的进程。</p>
<div><pre><code><span>ls</span> -XR <span>|</span> <span>vim</span> -
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>nl</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/nl/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/nl/</guid>
      <source url="https://list-jiang.github.io/rss.xml">nl</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="nl"> nl</h1>
<p><code>nl</code> 命令用于显示行号。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Lorem ipsum
dolor sit amet,
consetetur
sadipscing elitr,
<span>sed</span> diam nonumy
eirmod tempor
invidunt ut labore
et dolore magna
aliquyam erat, <span>sed</span>
diam voluptua. At
vero eos et
accusam et justo
duo dolores et ea
rebum. Stet clita
kasd gubergren,
no sea takimata
sanctus est Lorem
ipsum dolor sit
amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><code>nl</code> 命令让上面这段文本显示行号。</p>
<div><pre><code>$ <span>nl</span> -s<span>". "</span> example.txt
     <span>1</span>. Lorem ipsum
     <span>2</span>. dolor sit amet,
     <span>3</span>. consetetur
     <span>4</span>. sadipscing elitr,
     <span>5</span>. <span>sed</span> diam nonumy
     <span>6</span>. eirmod tempor
     <span>7</span>. invidunt ut labore
     <span>8</span>. et dolore magna
     <span>9</span>. aliquyam erat, <span>sed</span>
    <span>10</span>. diam voluptua. At
    <span>11</span>. vero eos et
    <span>12</span>. accusam et justo
    <span>13</span>. duo dolores et ea
    <span>14</span>. rebum. Stet clita
    <span>15</span>. kasd gubergren,
    <span>16</span>. no sea takimata
    <span>17</span>. sanctus est Lorem
    <span>18</span>. ipsum dolor sit
    <span>19</span>. amet.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><code>-s</code> 参数表示行号的后缀。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ps</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/ps/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/ps/</guid>
      <source url="https://list-jiang.github.io/rss.xml">ps</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="ps"> ps</h1>
<p><code>ps</code> 命令列出当前正在执行的进程信息。</p>
<p>由于进程很多，所以为了快速找到某个进程，一般与 <code>grep</code> 配合使用。</p>
<div><pre><code><span># 找出正在运行 vim 的进程</span>
$ <span>ps</span> <span>|</span> <span>grep</span> <span>vi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-u</code> 参数列出指定用户拥有的进程。</p>
<div><pre><code><span>ps</span> -u yourusername
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>scp</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/scp/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/scp/</guid>
      <source url="https://list-jiang.github.io/rss.xml">scp</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="scp"> scp</h1>
<h2 id="基本用法"> 基本用法</h2>
<p><code>scp</code> 是 secure copy 的缩写，用来在两台主机之间加密传送文件。它的底层是 SSH 协议，默认端口是 22。</p>
<p>它主要用于以下三种复制操作。</p>
<ul>
<li>从本地系统到远程系统。</li>
<li>从远程系统到本地系统。</li>
<li>在本地系统的两个远程系统之间。</li>
</ul>
<p>使用 <code>scp</code> 传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p>
<p><code>scp</code> 的语法类似 <code>cp</code> 的语法。</p>
<p>注意，如果传输的文件在本机和远程系统，有相同的名称和位置，<code>scp</code> 会在没有警告的情况下覆盖文件。</p>
<h3 id="本地文件复制到远程系统"> 本地文件复制到远程系统</h3>
<p>复制本机文件到远程系统的基本语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> SourceFile user@host:directory/TargetFile

<span># 示例</span>
$ <span>scp</span> file.txt remote_username@10.10.0.2:/remote/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录。</p>
<div><pre><code><span># 将本机的 documents 目录拷贝到远程主机，</span>
<span># 会在远程主机创建 documents 目录</span>
$ <span>scp</span> -r documents username@server_ip:/path_to_remote_directory

<span># 将本机整个目录拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/

<span># 将本机目录下的所有内容拷贝到远程目录下</span>
$ <span>scp</span> -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="远程文件复制到本地"> 远程文件复制到本地</h3>
<p>从远程主机复制文件到本地的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host:directory/SourceFile TargetFile

<span># 示例</span>
$ <span>scp</span> remote_username@10.10.0.2:/remote/file.txt /local/directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是复制整个目录的例子。</p>
<div><pre><code><span># 拷贝一个远程目录到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/

<span># 拷贝远程目录下的所有内容，到本机目录下</span>
$ <span>scp</span> -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/
$ <span>scp</span> -r user@host:directory/SourceFolder TargetFolder
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="两个远程系统之间的复制"> 两个远程系统之间的复制</h3>
<p>本机发出指令，从远程主机 A 拷贝到远程主机 B 的语法如下。</p>
<div><pre><code><span># 语法</span>
$ <span>scp</span> user@host1:directory/SourceFile user@host2:directory/SourceFile

<span># 示例</span>
$ <span>scp</span> user1@host1.com:/files/file.txt user2@host2.com:/files
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>系统将提示您输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p>
<h2 id="参数"> 参数</h2>
<p><code>-P</code> 用来指定远程主机的 SSH 端口。如果远程主机使用非默认端口 22，可以在命令中指定。</p>
<div><pre><code><span>scp</span> -P <span>2222</span> user@host:directory/SourceFile TargetFile
</code></pre>
<div><span>1</span><br></div></div><p><code>-p</code> 参数用来保留修改时间(modification time)、访问时间(access time)、文件状态(mode)等原始文件的信息。</p>
<div><pre><code><span>scp</span> -C -p ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数用来限制传输数据的带宽速率，单位是 Kbit/sec。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p>
<div><pre><code><span>scp</span> -l <span>80</span> yourusername@yourserver:/home/yourusername/* <span>.</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>scp</code> 命令占用的带宽限制为每秒 80K 比特位，即每秒 10K 字节。</p>
<p><code>-c</code> 参数用来指定加密算法。</p>
<div><pre><code><span>scp</span> -c blowfish some_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p>上面代码指定加密算法为 <code>blowfish</code>。</p>
<p><code>-C</code> 表示是否在传输时压缩文件。</p>
<div><pre><code><span>scp</span> -c blowfish -C local_file your_username@remotehost.edu:~
</code></pre>
<div><span>1</span><br></div></div><p><code>-q</code> 参数用来关闭显示拷贝的进度条。</p>
<div><pre><code><span>scp</span> -q Label.pdf mrarianto@202.x.x.x:.
</code></pre>
<div><span>1</span><br></div></div><p><code>-F</code> 参数用来指定 ssh_config 文件。</p>
<div><pre><code><span>scp</span> -F /home/pungki/proxy_ssh_config Label.pdf
</code></pre>
<div><span>1</span><br></div></div><p><code>-v</code> 参数用来显示详细的输出。</p>
<div><pre><code><span>scp</span> -v ~/test.txt root@192.168.1.3:/root/help2356.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-i</code> 参数用来指定密钥。</p>
<div><pre><code><span>scp</span> -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-r</code> 参数表示是否以递归方式复制目录。</p>
]]></content:encoded>
    </item>
    <item>
      <title>sed</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/sed/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/sed/</guid>
      <source url="https://list-jiang.github.io/rss.xml">sed</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="sed"> sed</h1>
<p><code>sed</code> 命令用于对文本进行过滤和变形处理。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello This is a Test <span>1</span> <span>2</span> <span>3</span> <span>4</span>
replace all spaces with hyphens
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>sed</code> 命令将所有的空格换成连词线 <code>-</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/ /-/g'</span> example.txt
Hello-This-is-a-Test-1-2-3-4
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令将数字换成字母 <code>d</code>。</p>
<div><pre><code>$ <span>sed</span> <span>'s/[0-9]/d/g'</span> example.txt
Hello This is a Test d d d d
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>sort</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/sort/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/sort/</guid>
      <source url="https://list-jiang.github.io/rss.xml">sort</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="sort"> sort</h1>
<p><code>sort</code> 命令用于文本文件的排序。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>f
b
c
g
a
e
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行 <code>sort</code> 命令对其进行排序。</p>
<div><pre><code>$ <span>sort</span> example.txt
a
b
c
d
e
f
g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-R</code> 参数表示随机排序。</p>
<div><pre><code><span>sort</span> -R example.txt
b
d
a
c
g
e
f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>tr</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/tr/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/tr/</guid>
      <source url="https://list-jiang.github.io/rss.xml">tr</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="tr"> tr</h1>
<p><code>tr</code> 命令用于按照给定模式转换文本。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>Hello World Foo Bar Baz<span>!</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>tr</code> 命令可以将所有小写字母转换为大写字母。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>'a-z'</span> <span>'A-Z'</span>
HELLO WORLD FOO BAR BAZ<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>tr</code> 命令还可以将所有空格转为换行符。</p>
<div><pre><code>$ <span>cat</span> example.txt <span>|</span> <span>tr</span> <span>' '</span> <span>'\n'</span>
Hello
World
Foo
Bar
Baz<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>uname</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/uname/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/uname/</guid>
      <source url="https://list-jiang.github.io/rss.xml">uname</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="uname"> uname</h1>
<p><code>uname</code> 命令用来显示内核信息。</p>
<div><pre><code><span>uname</span> -a
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>uniq</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/uniq/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/uniq/</guid>
      <source url="https://list-jiang.github.io/rss.xml">uniq</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="uniq"> uniq</h1>
<p><code>uniq</code> 用于过滤掉重复的行，该命令只对排序后的文件有效。</p>
<p>下面是 <code>example.txt</code> 文件的内容。</p>
<div><pre><code>a
a
b
a
b
c
d
c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>对该文件进行排序后，再过滤掉重复的行。</p>
<div><pre><code>$ <span>sort</span> example.txt <span>|</span> <span>uniq</span>
a
b
c
d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="参数"> 参数</h2>
<p><code>-c</code> 参数会显示每行一共出现了多少次。</p>
<div><pre><code><span>sort</span> example.txt <span>|</span> <span>uniq</span> -c
    <span>3</span> a
    <span>2</span> b
    <span>2</span> c
    <span>1</span> d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>uptime</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/uptime/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/uptime/</guid>
      <source url="https://list-jiang.github.io/rss.xml">uptime</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="uptime"> uptime</h1>
<p><code>uptime</code> 命令显示本次开机运行的时间。</p>
]]></content:encoded>
    </item>
    <item>
      <title>w</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/w/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/w/</guid>
      <source url="https://list-jiang.github.io/rss.xml">w</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="w"> w</h1>
<p><code>w</code> 命令显示当期谁在线。</p>
]]></content:encoded>
    </item>
    <item>
      <title>wc</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/wc/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/wc/</guid>
      <source url="https://list-jiang.github.io/rss.xml">wc</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="wc"> wc</h1>
<p><code>wc</code> 命令返回某个文件的行数、词数和字符数。</p>
<div><pre><code>$ <span>wc</span> demo.txt
<span>7459</span>   <span>15915</span>  <span>398400</span> demo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>7459</code> 是行数，<code>15915</code> 是词数，<code>398400</code> 是字符数。</p>
]]></content:encoded>
    </item>
    <item>
      <title>whereis</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/whereis/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/whereis/</guid>
      <source url="https://list-jiang.github.io/rss.xml">whereis</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="whereis"> whereis</h1>
<p><code>whereis</code> 用来显示某个命令的位置。如果有多个程序符合条件，会全部列出。</p>
<div><pre><code>$ <span>whereis</span> node
/usr/bin/node /usr/sbin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>which</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/which/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/which/</guid>
      <source url="https://list-jiang.github.io/rss.xml">which</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="which"> which</h1>
<p><code>which</code> 命令根据 <code>PATH</code> 环境变量指定的顺序，返回最早发现某个命令的位置。即不指定路径时，实际执行的命令的完整路径。</p>
<div><pre><code>$ <span>which</span> node
/usr/bin/node
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>who</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/commands/who/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/commands/who/</guid>
      <source url="https://list-jiang.github.io/rss.xml">who</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="who"> who</h1>
<p><code>who</code> 命令显示已经登录的用户。</p>
<h2 id="参数"> 参数</h2>
<p><code>-b</code> 参数显示上一次系统启动的时间。</p>
<div><pre><code>$ <span>who</span> -b
system boot  <span>2017</span>-06-20 <span>17</span>:41
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>标准 I/O</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/deleted/stdio/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/deleted/stdio/</guid>
      <source url="https://list-jiang.github.io/rss.xml">标准 I/O</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="标准-i-o"> 标准 I/O</h1>
<h2 id="echo"> echo</h2>
<p><code>echo</code> 命令用于将指定内容输出到显示屏(标准输出)。</p>
<div><pre><code>$ <span>echo</span> this is a <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-e</code> 解释转义字符。</li>
<li><code>-n</code> 不输出行尾的换行符</li>
</ul>
<div><pre><code>$ <span>echo</span> <span>"a<span title="\n">\n</span>b"</span>
a<span>\</span>nb

$ <span>echo</span> -e <span>"a<span title="\n">\n</span>b"</span>
a
b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，如果不加 <code>-e</code> 参数，<code>\n</code> 就会按字面形式输出；加了以后，就被解释成了换行符。</p>
<p>引号之中可以包括多个换行符，即可以输出多行文本。</p>
<div><pre><code><span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="read"> read</h2>
<p><code>read</code> 命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，读取文件中的一行数据。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的 variable 用来存储输入数值的一个或多个变量名。如果没有提供变量名，shell 变量 <code>REPLY</code> 会包含数据行。</p>
<p>基本上，read 会把来自标准输入的字段赋值给具体的变量。</p>
<div><pre><code><span>echo</span> -n <span>"Please enter an integer -> "</span>
<span>read</span> int
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>read</code> 可以给多个变量赋值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-multiple: read multiple values from keyboard</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span> var1 var2 var3 var4 var5
<span>echo</span> <span>"var1 = '<span>$var1</span>'"</span>
<span>echo</span> <span>"var2 = '<span>$var2</span>'"</span>
<span>echo</span> <span>"var3 = '<span>$var3</span>'"</span>
<span>echo</span> <span>"var4 = '<span>$var4</span>'"</span>
<span>echo</span> <span>"var5 = '<span>$var5</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的用法如下。</p>
<div><pre><code>$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e'</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>''</span>
var3 <span>=</span> <span>''</span>
var4 <span>=</span> <span>''</span>
var5 <span>=</span> <span>''</span>

$ read-multiple
Enter one or <span>more</span> values <span>></span> a b c d e f g
var1 <span>=</span> <span>'a'</span>
var2 <span>=</span> <span>'b'</span>
var3 <span>=</span> <span>'c'</span>
var4 <span>=</span> <span>'d'</span>
var5 <span>=</span> <span>'e f g'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果 read 命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入数据则会 被包含到最后一个变量中。</p>
<p>如果 read 命令之后没有列出变量名，则一个 shell 变量 <code>REPLY</code>，将会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的输出结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>read 命令的参数如下。</p>
<ul>
<li><code>-a array</code> 把输入赋值到数组 array 中，从索引号零开始。</li>
<li><code>-d delimiter</code> 用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。</li>
<li><code>-e</code> 使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。</li>
<li><code>-n num</code> 读取 num 个输入字符，而不是整行。</li>
<li><code>-p prompt</code> 为输入显示提示信息，使用字符串 prompt。</li>
<li><code>-r</code> Raw mode. 不把反斜杠字符解释为转义字符。</li>
<li><code>-s</code> Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。</li>
<li><code>-t seconds</code> 超时. 几秒钟后终止输入。read 会返回一个非零退出状态，若输入超时。</li>
<li><code>-u fd</code> 使用文件描述符 fd 中的输入，而不是标准输入。</li>
</ul>
<p><code>-p</code> 的例子。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 和 <code>-s</code> 的例子。</p>
<div><pre><code><span>if</span> <span>read</span> -t <span>10</span> -sp <span>"Enter secret pass phrase > "</span> secret_pass<span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>Secret pass phrase = '<span>$secret_pass</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面这个脚本提示用户输入一个密码，并等待输入 10 秒钟。如果在特定的时间内没有完成输入， 则脚本会退出并返回一个错误。因为包含了一个 -s 选项，所以输入的密码不会出现在屏幕上。</p>
<p>Shell 的内部变量 <code>IFS</code> 可以控制输入字段的分离。例如，这个 /etc/passwd 文件包含的数据行 使用冒号作为字段分隔符。通过把 IFS 的值更改为单个冒号，我们可以使用 read 读取 /etc/passwd 中的内容，并成功地把字段分给不同的变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>
<span>FILE</span><span>=</span>/etc/passwd
<span>read</span> -p <span>"Enter a user name > "</span> user_name
<span>file_info</span><span>=</span><span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>
<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
    <span>echo</span> <span>"User = '<span>$user</span>'"</span>
    <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
    <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
    <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
    <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
    <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
    <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Shell 允许在一个命令之前立即发生一个或多个变量赋值。这些赋值为跟随着的命令更改环境变量。这个赋值的影响是暂时的；只是在命令存在期间改变环境变量。</p>
<p>虽然通常 read 命令接受标准输入，但是您不能这样做:</p>
<div><pre><code><span>echo</span> “foo” <span>|</span> <span>read</span>
</code></pre>
<div><span>1</span><br></div></div><p>我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY 变量 总是为空。为什么会这样?</p>
<p>答案与 shell 处理管道线的方式有关系。在 bash(和其它 shells，例如 sh)中，管道线 会创建子 shell。它们是 shell 的副本，且用来执行命令的环境变量在管道线中。上面示例中，read 命令将在子 shell 中执行。</p>
<p>在类 Unix 的系统中，子 shell 执行的时候，会为进程创建父环境的副本。当进程结束 之后，环境副本就会被破坏掉。这意味着一个子 shell 永远不能改变父进程的环境。read 赋值变量， 然后会变为环境的一部分。在上面的例子中，read 在它的子 shell 环境中，把 foo 赋值给变量 REPLY， 但是当命令退出后，子 shell 和它的环境将被破坏掉，这样赋值的影响就会消失。</p>
<p>使用 here 字符串是解决此问题的一种方法。</p>
<p>下面是生成菜单的一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-menu: a menu driven system information program</span>
<span>clear</span>
<span>echo</span> <span>"
Please Select:

    1. Display System Information
    2. Display Disk Space
    3. Display Home Space Utilization
    0. Quit
"</span>
<span>read</span> -p <span>"Enter selection [0-3] > "</span>

<span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>=~</span> ^<span>[</span><span>0</span>-3<span>]</span>$ <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Program terminated."</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>echo</span> <span>"Hostname: <span>$HOSTNAME</span>"</span>
        <span>uptime</span>
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>2</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>df</span> -h
        <span>exit</span>
    <span>fi</span>
    <span>if</span> <span>[</span><span>[</span> <span>$REPLY</span> <span>==</span> <span>3</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
        <span>if</span> <span>[</span><span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> -eq <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
            <span>echo</span> <span>"Home Space Utilization (All Users)"</span>
            <span>du</span> -sh /home/*
        <span>else</span>
            <span>echo</span> <span>"Home Space Utilization (<span>$USER</span>)"</span>
            <span>du</span> -sh <span>$HOME</span>
        <span>fi</span>
        <span>exit</span>
    <span>fi</span>
<span>else</span>
    <span>echo</span> <span>"Invalid entry."</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>文件操作</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/file-operation/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/file-operation/</guid>
      <source url="https://list-jiang.github.io/rss.xml">文件操作</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文件操作"> 文件操作</h1>
<h2 id="cp"> cp</h2>
<p><code>cp</code> 命令用于将文件(或目录)拷贝到目的地。</p>
<div><pre><code><span># 拷贝单个文件</span>
$ <span>cp</span> <span>source</span> dest

<span># 拷贝多个文件</span>
$ <span>cp</span> source1 source2 source3 dest

<span># -i 目的地有同名文件时会提示确认</span>
$ <span>cp</span> -i file1 file2

<span># -r 递归拷贝，将dir1拷贝到dir2，完成后dir2生成一个子目录dir1</span>
<span># dir2如果不存在，将被创建</span>
<span># 拷贝目录时，该参数是必需的</span>
$ <span>cp</span> -r dir1 dir2

<span># -u --update 只拷贝目的地没有的文件，或者比目的地同名文件更新的文件</span>
$ <span>cp</span> -u *.html destination
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>其他参数</p>
<ul>
<li><code>-a</code> 拷贝时保留所有属性，包括所有者与权限</li>
<li><code>-v</code> 显示拷贝的详细信息</li>
</ul>
<h2 id="mkdir"> mkdir</h2>
<p><code>mkdir</code> 命令用于新建目录。</p>
<div><pre><code><span># 新建多个目录</span>
$ <span>mkdir</span> dir1 dir2 dir3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mv"> mv</h2>
<p><code>mv</code> 命令用于将源文件移动到目的地。</p>
<div><pre><code><span># 移动单个文件</span>
$ <span>mv</span> item1 item2

<span># 移动多个文件</span>
$ <span>mv</span> file1 file2 dir1

<span># 将dir1拷贝进入dir2，完成后dir2将多出一个子目录dir1</span>
<span># 如果dir2不存在，将会被创建</span>
$ <span>mv</span> dir1 dir2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>参数</p>
<ul>
<li><code>-i</code> 覆盖已经存在的文件时，会提示确认</li>
<li><code>-u</code> 只移动目的地不存在的文件，或比目的地更新的文件</li>
</ul>
<h2 id="rm"> rm</h2>
<p><code>rm</code> 命令用于删除文件。</p>
<p>参数。</p>
<ul>
<li><code>-i</code> 文件存在时，会提示确认。</li>
<li><code>-r</code> 递归删除一个子目录</li>
<li><code>-f</code> 如果删除不存在的文件，不报错</li>
<li><code>-v</code> 删除时展示详细信息</li>
</ul>
<h2 id="ln"> ln</h2>
<p><code>ln</code> 命令用于建立链接文件。</p>
<div><pre><code><span># 新建硬链接</span>
$ <span>ln</span> <span>file</span> <span>link</span>

<span># 新建软链接</span>
$ <span>ln</span> -s item <span>link</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>文件系统</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/file/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/file/</guid>
      <source url="https://list-jiang.github.io/rss.xml">文件系统</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文件系统"> 文件系统</h1>
<h2 id="pwd"> pwd</h2>
<p><code>pwd</code> 命令显示列出当前所在的目录。</p>
<div><pre><code><span>pwd</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="cd"> cd</h2>
<p><code>cd</code> 命令用来改变用户所在的目录。</p>
<div><pre><code><span># 进入用户的主目录</span>
$ <span>cd</span>

<span># 进入前一个工作目录</span>
$ <span>cd</span> -

<span># 进入指定用户的主目录</span>
$ <span>cd</span> ~user_name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="ls"> ls</h2>
<p><code>ls</code> 目录可以显示指定目录的内容。不加参数时，显示当前目录的内容。</p>
<div><pre><code><span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令显示当前目录的内容。</p>
<p><code>ls</code> 命令也可以显示指定文件是否存在。</p>
<div><pre><code>$ <span>ls</span> foo.txt
foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-l</code> 参数可以显示文件的详细信息。</p>
<div><pre><code>$ <span>ls</span> -l foo.txt
-rw-rw-r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令输出结果的第一栏，是文件的类型和权限。</p>
<p>文件类型分为以下几种。</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录</li>
<li><code>l</code> 符号链接。注意，对于符号链接文件，剩余的文件属性总是&quot;rwxrwxrwx&quot;。</li>
<li><code>c</code> 字符设备文件，指按照字节流处理数据的设备，比如调制解调器。</li>
<li><code>b</code> 块设备文件，指按照数据块处理数据的设备，比如硬盘。</li>
</ul>
<p>其他参数的用法。</p>
<div><pre><code><span># 显示多个目录的内容</span>
$ <span>ls</span> ~ /usr

<span># -a --all 显示隐藏文件</span>
$ <span>ls</span> -a

<span># -A 与-a类似，但是不显示当前目录和上一级目录两个点文件</span>
$ <span>ls</span> -A

<span># -l 显示详细信息</span>
$ <span>ls</span> -l

<span># -1 单列显示，每行只显示一个文件</span>
$ <span>ls</span> -1

<span># -d 显示当前目录本身，而不是它的内容</span>
<span># 通常与-l配合使用，列出一个目录本身的详细信息</span>
$ <span>ls</span> -dl

<span># -F 目录名之后添加斜杠，可执行文件后面添加星号</span>
$ <span>ls</span> -F

<span># -h 与-l配合使用，将文件大小显示为人类可读的格式</span>

<span># -t 按文件修改时间排序，修改晚的排在前面</span>
$ <span>ls</span> -t

<span># -s 按文件大小排序，</span>

<span># --reverse 显示结果倒序排列</span>
$ <span>ls</span> -lt --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>如果只显示一个目录里面的子目录，不显示文件，可以使用下面这些命令。</p>
<div><pre><code><span># 只显示常规目录</span>
$ <span>ls</span> -d */
$ <span>ls</span> -F <span>|</span> <span>grep</span> /
$ <span>ls</span> -l <span>|</span> <span>grep</span> ^d
$ tree -dL <span>1</span>

<span># 只显示隐藏目录</span>
$ <span>ls</span> -d .*/

<span># 隐藏目录和非隐藏目录都显示</span>
$ <span>find</span> -maxdepth <span>1</span> -type d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另一个简便方法是利用自动补全功能，先键入 <code>cd</code> 命令，然后连按两下 <code>tab</code> 键。</p>
<h2 id="stat"> stat</h2>
<p><code>stat</code> 命令是加强版的 <code>ls</code> 命令，可以显示一个文件的详细信息。</p>
<div><pre><code>$ <span>stat</span> timestamp
File: <span>'timestamp'</span>
Size: <span>0</span> Blocks: <span>0</span> IO Block: <span>4096</span> regular empty <span>file</span>
Device: 803h/2051d Inode: <span>14265061</span> Links: <span>1</span>
Access: <span>(</span>0644/-rw-r--r--<span>)</span> Uid: <span>(</span> <span>1001</span>/ me<span>)</span> Gid: <span>(</span> <span>1001</span>/ me<span>)</span>
Access: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Modify: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
Change: <span>2008</span>-10-08 <span>15</span>:15:39.000000000 -0400
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="touch"> touch</h2>
<p><code>touch</code> 用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个 不存在的文件，则会创建一个空文件。</p>
<div><pre><code><span>touch</span> timestamp
</code></pre>
<div><span>1</span><br></div></div><p>上面命令创建了一个名为 <code>timestamp</code> 空文件。如果该文件已经存在，就会把它的修改时间设置为当前时间。</p>
<div><pre><code><span>mkdir</span> -p playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>
<span>touch</span> playground/dir-<span>{</span>00<span>{</span><span>1</span><span>..</span><span>9</span><span>}</span>,0<span>{</span><span>10</span><span>..</span><span>99</span><span>}</span>,100<span>}</span>/file-<span>{</span>A<span>..</span>Z<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面的命令创建了一个包含一百个子目录，每个子目录中包含了 26 个空文件。</p>
<h2 id="file"> file</h2>
<p><code>file</code> 命令显示指定文件的类型。</p>
<div><pre><code>$ <span>file</span> picture.jpg
picture.jpg: JPEG image data, JFIF standard <span>1.01</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="chmod"> chmod</h2>
<p><code>chmod</code> 命令用于更改文件的权限，是“change mode”的缩写。</p>
<div><pre><code><span>chmod</span> <span>600</span> foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将 <code>foo.txt</code> 的权限改成了 600。</p>
<p><code>chmod</code> 还可以接受四个缩写，为不同的对象单独设置权限。</p>
<ul>
<li><code>u</code> 所有者“user”的简写</li>
<li><code>g</code> 用户组“group”的缩写</li>
<li><code>o</code> 其他所有人“others”的简写</li>
<li><code>a</code> 所有人“all”的简写</li>
</ul>
<div><pre><code><span># 为所有者添加可执行权限</span>
$ <span>chmod</span> u+x foo.txt

<span># 删除所有者的可执行权限</span>
$ <span>chmod</span> u-x foo.txt

<span># 为所有人添加可执行权限，等价于 a+x</span>
$ <span>chmod</span> +x foo.txt

<span># 删除其他人的读权限和写权限。</span>
$ <span>chmod</span> o-rw foo.txt

<span># 设定用户组和其他人的权限是读权限和写权限</span>
$ <span>chmod</span> <span>go</span><span>=</span>rw foo.txt

<span># 为所有者添加执行权限，设定用户组和其他人为读权限和写权限，多种设定用逗号分隔</span>
$ <span>chmod</span> u+x,go<span>=</span>rw foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>添加权限。</p>
<ul>
<li>+x 添加执行权限</li>
<li>+r 设置读权限</li>
<li>+w 设置写权限</li>
<li>+rwx 设置所有读、写和执行权限。</li>
</ul>
<p>删除权限只需将 <code>+</code> 更改为 <code>-</code>，就可以删除任何已设置的指定权限。可以使用 <code>-R</code>(或 <code>--recursive</code>)选项来递归地操作目录和文件。</p>
<p>设置精确权限，可以使用<code>=</code>代替 <code>+</code> 或 <code>-</code> 来实现此操作。如果想为用户、组或其他用户设置不同的权限，可以使用逗号将不同表达式分开(例如 <code>ug=rwx,o=rx</code>)。</p>
<p>由于一共有 3 种可能的权限。也可以使用八进制数代替符号来设置权限。通过这种方式设置的权限最多使用 3 个八进制数。第 1 个数定义用户权限，第 2 个数定义组权限，第 3 个数定义其他权限。这 3 个数中的每一个都通过添加想要的权限设置来构造: 读 (4)、写 (2) 和执行 (1)。</p>
<ul>
<li>rwx 7</li>
<li>rw- 6</li>
<li>r-x 5</li>
<li>r-- 4</li>
<li>-wx 3</li>
<li>-w- 2</li>
<li>--x 1</li>
<li>--- 0</li>
</ul>
<h2 id="umask"> umask</h2>
<p><code>umask</code> 用来查看和设置权限掩码。</p>
<div><pre><code>$ <span>umask</span>
0022
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令显示当前系统之中，默认的文件掩码是 <code>0022</code>，转为二进制就是 <code>000 000 010 010</code>。</p>
<p>可以看到，这个掩码是一个 12 位的二进制数，后面的 9 位分别代表文件三种使用对象的三类权限。只要对应位置上是 <code>1</code>，就表示关闭该项权限，所以 <code>010</code> 就表示关闭读权限。</p>
<p>新建文件时，通常不会带有执行权限，也就是说，新建文件的默认权限是 <code>rw-rw-rw-</code>。如果文件掩码是 <code>0022</code>，那么用户组和其他人的写权限也会被拿掉。</p>
<div><pre><code>$ <span>touch</span> new.txt
$ <span>ls</span> -l new.txt
-rw-r--r-- <span>1</span> me   me   <span>0</span> <span>2016</span>-03-06 <span>14</span>:52 new.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>new.txt</code> 的用户组和其他人的写权限就没了。</p>
<p><code>umask</code> 后面跟着参数，就表示设置权限掩码。</p>
<div><pre><code><span>umask</span> 0000
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将权限掩码设为 <code>0000</code>，实际上就是关闭了权限掩码。</p>
<p><code>umask</code> 命令设置的掩码值只能在当前 Shell 会话中生效，若当前 Shell 会话结束后，则必须重新设置。</p>
<h2 id="du"> du</h2>
<p><code>du</code> 命令用于查看指定目录的大小。</p>
<div><pre><code><span>du</span> -hs /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><p>显示第一层子目录的大小。</p>
<div><pre><code><span>du</span> -h --max-depth<span>=</span><span>1</span> /path/to/folder
</code></pre>
<div><span>1</span><br></div></div><p>参数的含义。</p>
<ul>
<li><code>-h</code> 表示人类可读的格式</li>
<li><code>-s</code> 表示总结信息，否则会显示该目录内所有文件和子目录的信息。</li>
</ul>
<p><code>tree</code> 命令也可以显示子目录大小。</p>
<div><pre><code>tree --du -h /path/to/directory
</code></pre>
<div><span>1</span><br></div></div><h2 id="md5sum"> md5sum</h2>
<p><code>md5sum</code> 命令用来显示一个文件的 md5 校验码。</p>
<div><pre><code>$ md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece    image.iso
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="locate"> locate</h2>
<p><code>locate</code> 程序快速搜索本机的路径名数据库，并且输出每个与给定字符串相匹配的文件名。</p>
<div><pre><code>$ <span>locate</span> bin/zip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>locate</code> 数据库由另一个叫做 <code>updatedb</code> 的程序创建。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，您会发现 目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序， 更改为超级用户身份，在提示符下运行 updatedb 命令。</p>
<p><code>locate</code> 支持正则查找。<code>--regexp</code> 参数支持基本的正则表达式，<code>--regex</code> 参数支持扩展的正则表达式。</p>
<div><pre><code><span>locate</span> --regex <span>'bin/(bz|gz|zip)'</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="find"> find</h2>
<p><code>locate</code> 程序只能依据文件名来查找文件，而 <code>find</code> 程序能基于各种各样的属性，搜索一个给定目录(以及它的子目录)，来查找文件。</p>
<div><pre><code><span># 输出当前目录的所有子目录和文件(含子目录)</span>
$ <span>find</span>
$ <span>find</span> <span>.</span>

<span># 显示当前目录的文件总数</span>
$ <span>find</span> <span>.</span> <span>|</span> <span>wc</span> -l

<span># 当前目录的子目录总数</span>
$ <span>find</span> <span>.</span> -type d <span>|</span> <span>wc</span> -l

<span># 当前目录的文件总数(不含子目录)</span>
$ <span>find</span> <span>.</span> -type f <span>|</span> <span>wc</span> -l

<span># 当前目录的文件名匹配“*.JPG”且大于1M的文件总数</span>
$ <span>find</span> <span>.</span> -type f -name <span>"\*.JPG"</span> -size +1M <span>|</span> <span>wc</span> -l
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><code>-type</code> 参数支持的文件类型。</p>
<ul>
<li><code>b</code> 块设备文件</li>
<li><code>c</code> 字符设备文件</li>
<li><code>d</code> 目录</li>
<li><code>f</code> 普通文件</li>
<li><code>l</code> 符号链接</li>
</ul>
<p><code>-size</code> 参数支持的文件大小类型。</p>
<ul>
<li>b 512 个字节块。如果没有指定单位，则这是默认值。</li>
<li>c 字节</li>
<li>w 两个字节的字</li>
<li>k 千字节</li>
<li>M 兆字节</li>
<li>G 千兆字节</li>
</ul>
<p><code>find</code> 程序支持的查询参数。</p>
<ul>
<li>-cmin n 匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</li>
<li>-cnewer file 匹配的文件和目录的内容或属性最后修改时间早于那些文件。</li>
<li>-ctime n 匹配的文件和目录的内容和属性最后修改时间在 n*24 小时之前。</li>
<li>-empty 匹配空文件和目录。</li>
<li>-group name 匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。</li>
<li>-iname pattern 就像-name 测试条件，但是不区分大小写。</li>
<li>-inum n 匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。</li>
<li>-mmin n 匹配的文件或目录的内容被修改于 n 分钟之前。</li>
<li>-mtime n 匹配的文件或目录的内容被修改于 n*24 小时之前。</li>
<li>-name pattern 用指定的通配符模式匹配的文件和目录。</li>
<li>-newer file 匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。每次您制作一个备份，更新文件(比如说日志)，然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。</li>
<li>-nouser 匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。</li>
<li>-nogroup 匹配的文件和目录不属于一个有效的组。</li>
<li>-perm mode 匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。</li>
<li>-samefile name 相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</li>
<li>-size n 匹配的文件大小为 n。</li>
<li>-type c 匹配的文件类型是 c。</li>
<li>-user name 匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。</li>
<li>-depth 指导 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。</li>
<li>-maxdepth levels 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数</li>
<li>-mindepth levels 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。</li>
<li>-mount 指导 find 程序不要搜索挂载到其它文件系统上的目录。</li>
<li>-regex 指定正则表达式</li>
</ul>
<div><pre><code><span># 找出包括空格或其它不规范字符的文件名或路径名</span>
$ <span>find</span> <span>.</span> -regex <span>'.*[^-\_./0-9a-zA-Z].*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>find</code> 程序还支持逻辑操作符。</p>
<ul>
<li><code>-and</code> 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。注意若没有使用操作符，则默认使用 -and。</li>
<li><code>-or</code> 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</li>
<li><code>-not</code> 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号(!)。</li>
<li><code>()</code> 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。</li>
</ul>
<div><pre><code><span># 或关系</span>
<span>(</span> expression <span>1</span> <span>)</span> -or <span>(</span> expression <span>2</span> <span>)</span>

<span># 找出不是600权限的文件，或者不是700权限的目录</span>
$ <span>find</span> ~ <span>\</span><span>(</span> -type f -not -perm 0600 <span>\</span><span>)</span> -or <span>\</span><span>(</span> -type d -not -perm 0700 <span>\</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>find</code> 程序的逻辑表达式，具有“短路运算”的特点，即对于 <code>expr1 -operator expr2</code> 这个表达式，<code>expr2</code> 不一定执行。这是为了提高运行速度。</p>
<ul>
<li>expr1 为真，且操作符为 <code>-and</code>，expr2 总是执行</li>
<li>expr1 为假，且操作符为 <code>-and</code>，expr2 从不执行</li>
<li>expr1 为真，且操作符为 <code>-or</code>，expr2 从不执行</li>
<li>expr1 为假，且操作符为 <code>-or</code>，expr2 总是执行</li>
</ul>
<p>为了方便执行一些常见操作，<code>find</code> 程序定义了一些预定义操作。</p>
<ul>
<li>-delete 删除当前匹配的文件。</li>
<li>-ls 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。</li>
<li>-print 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</li>
<li>-quit 一旦找到一个匹配，退出。</li>
</ul>
<div><pre><code><span># 找到匹配的文件，并显示在标准输出</span>
<span># -print 是默认操作，可以省略</span>
$ <span>find</span> <span>.</span> -print

<span># 删除后缀名为BAK的文件</span>
<span># 执行 delete 操作前，最好先执行 print 操作，确认要删除哪些文件</span>
$ <span>find</span> <span>.</span> -type f -name <span>'*.BAK'</span> -delete
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>预定义操作可以与逻辑表达式，结合使用。</p>
<div><pre><code><span>find</span> ~ -type f -and -name <span>'*.BAK'</span> -and -print
</code></pre>
<div><span>1</span><br></div></div><p>除了预定义操作以外，用户还可以使用 <code>-exec</code> 参数自定义操作。</p>
<div><pre><code>-exec <span>command</span> <span>{</span><span>}</span> <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，<code>command</code> 是一个命令行命令，<code>{}</code> 用来指代当前路径，分号表示命令结束。</p>
<div><pre><code><span># 预定义的 -delete 操作，等同于下面的操作</span>
-exec <span>rm</span> <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-exec</code> 使用时，每次找到一个匹配的文件，会启动一个新的指定命令的实例。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> <span>';'</span>
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令，<code>ls</code> 程序可能会被调用多次。</p>
<div><pre><code><span>ls</span> -l file1
<span>ls</span> -l file2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果想改成 <code>ls</code> 程序只调用一次，要把 <code>find</code> 命令里面的分号，改成加号。</p>
<div><pre><code>$ <span>ls</span> -l file1 file2
<span># 相当于</span>
$ <span>find</span> ~ -type f -name <span>'foo*'</span> -exec <span>ls</span> -l <span>'{}'</span> +
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="xargs"> xargs</h2>
<p><code>xargs</code> 命令从标准输入接受输入，并把输入转换为一个特定命令的参数列表。</p>
<div><pre><code><span>find</span> ~ -type f -name <span>'foo\*'</span> -print <span>|</span> <span>xargs</span> <span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>主机管理</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/host/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/host/</guid>
      <source url="https://list-jiang.github.io/rss.xml">主机管理</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="主机管理"> 主机管理</h1>
<h2 id="hostname-命令"> hostname 命令</h2>
<p><code>hostname</code> 命令返回当前服务器的主机名。</p>
<div><pre><code><span>hostname</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>硬件操作</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/hardware/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/hardware/</guid>
      <source url="https://list-jiang.github.io/rss.xml">硬件操作</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="硬件操作"> 硬件操作</h1>
<h2 id="df"> df</h2>
<p><code>df</code> 命令查看硬盘信息。</p>
<div><pre><code>$ <span>df</span>
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/sda2 <span>15115452</span> <span>5012392</span> <span>9949716</span> <span>34</span>% /
/dev/sda5 <span>59631908</span> <span>26545424</span> <span>30008432</span> <span>47</span>% /home
/dev/sda1 <span>147764</span> <span>17370</span> <span>122765</span> <span>13</span>% /boot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="free"> free</h2>
<p><code>free</code> 命令查看内存占用情况。</p>
<div><pre><code>$ <span>free</span>
 total used <span>free</span> shared buffers cached
Mem: <span>513712</span> <span>503976</span> <span>9736</span> <span>0</span> <span>5312</span> <span>122916</span>
-/+ buffers/cache: <span>375748</span> <span>137964</span>
Swap: <span>1052248</span> <span>104712</span> <span>947536</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="硬盘"> 硬盘</h2>
<p>文件<code>/etc/fstab</code> 配置系统启动时要挂载的设备。</p>
<div><pre><code>LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>输出结果一共有 6 个字段，含义依次如下。</p>
<ul>
<li>设备名: 与物理设备相关联的设备文件(或设备标签)的名字，比如说<code>/dev/hda1</code>(第一个 IDE 通道上第一个主设备分区)。</li>
<li>挂载点: 设备所连接到的文件系统树的目录。</li>
<li>文件系统类型: Linux 允许挂载许多文件系统类型。</li>
<li>选项: 文件系统可以通过各种各样的选项来挂载。</li>
<li>频率: 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。</li>
<li>次序: 一位数字，指定 fsck 命令按照什么次序来检查文件系统。</li>
</ul>
<h2 id="mount"> mount</h2>
<p><code>mount</code> 不带参数时，显示当前挂载的文件系统。</p>
<div><pre><code>$ <span>mount</span>
/dev/sda2 on / <span>type</span> ext3 <span>(</span>rw<span>)</span>
proc on /proc <span>type</span> proc <span>(</span>rw<span>)</span>
sysfs on /sys <span>type</span> sysfs <span>(</span>rw<span>)</span>
devpts on /dev/pts <span>type</span> devpts <span>(</span>rw,gid<span>=</span><span>5</span>,mode<span>=</span><span>620</span><span>)</span>
/dev/sda5 on /home <span>type</span> ext3 <span>(</span>rw<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个列表的格式是: 设备 on 挂载点 type 文件系统类型(可选的)。</p>
<p><code>mount</code> 带参数时，用于将设备文件挂载到挂载点，<code>-t</code> 参数用来指定文件系统类型。</p>
<div><pre><code>$ <span>mount</span> -t iso9660 /dev/hdc /mnt/cdrom

<span># 挂载一个iso文件</span>
$ <span>mount</span> -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="umount"> umount</h2>
<p><code>umount</code> 命令用来卸载设备。</p>
<div><pre><code><span>umount</span> <span>[</span>设备名<span>]</span>

<span>umount</span> /dev/hdc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="fdisk"> fdisk</h2>
<p><code>fdisk</code> 命令用于格式化磁盘。</p>
<div><pre><code><span>sudo</span> <span>umount</span> /dev/sdb1
<span>sudo</span> <span>fdisk</span> /dev/sdb
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="mkfs"> mkfs</h2>
<p><code>mkfs</code> 命令用于在一个设备上新建文件系统。</p>
<div><pre><code><span>sudo</span> <span>mkfs</span> -t ext3 /dev/sdb1
<span>sudo</span> <span>mkfs</span> -t vfat /dev/sdb1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="fsck"> fsck</h2>
<p><code>fsck</code> 命令用于检查(修复)文件系统。</p>
<div><pre><code><span>sudo</span> <span>fsck</span> /dev/sdb1
</code></pre>
<div><span>1</span><br></div></div><h2 id="dd"> dd</h2>
<p><code>dd</code> 命令用于将大型数据块，从一个磁盘复制到另一个磁盘。</p>
<div><pre><code>$ <span>dd</span> <span>if</span><span>=</span>input_file <span>of</span><span>=</span>output_file <span>[</span>bs<span>=</span>block_size <span>[</span>count<span>=</span>blocks<span>]</span><span>]</span>

<span># 将 /dev/sdb 的所有数据复制到 /dev/sdc</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>/dev/sdc

<span># 将 /dev/sdb 的所有数据拷贝到一个镜像文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/sdb <span>of</span><span>=</span>flash_drive.img

<span># 从cdrom制作一个iso文件</span>
$ <span>dd</span> <span>if</span><span>=</span>/dev/cdrom <span>of</span><span>=</span>ubuntu.iso
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="dmidecode"> dmidecode</h2>
<p><code>dmidecode</code> 命令用于输出 BIOS 信息。</p>
<div><pre><code><span>sudo</span> dmidecode
</code></pre>
<div><span>1</span><br></div></div><p>以上命令会输出全部 BIOS 信息。为了便于查看，往往需要指定所需信息的类别。</p>
<ul>
<li>0 BIOS</li>
<li>1 System</li>
<li>2 Base Board</li>
<li>3 Chassis 4 Processor</li>
<li>5 Memory Controller</li>
<li>6 Memory Module</li>
<li>7 Cache</li>
<li>8 Port Connector</li>
<li>9 System Slots</li>
<li>10 On Board Devices</li>
<li>11 OEM Strings</li>
<li>12 System Configuration Options</li>
<li>13 BIOS Language</li>
<li>14 Group Associations</li>
<li>15 System Event Log</li>
<li>16 Physical Memory Array</li>
<li>17 Memory Device</li>
<li>18 32-bit Memory Error</li>
<li>19 Memory Array Mapped Address</li>
<li>20 Memory Device Mapped Address</li>
<li>21 Built-in Pointing Device</li>
<li>22 Portable Battery</li>
<li>23 System Reset</li>
<li>24 Hardware Security</li>
<li>25 System Power Controls</li>
<li>26 Voltage Probe</li>
<li>27 Cooling Device</li>
<li>28 Temperature Probe</li>
<li>29 Electrical Current Probe</li>
<li>30 Out-of-band Remote Access</li>
<li>31 Boot Integrity Services</li>
<li>32 System Boot</li>
<li>33 64-bit Memory Error</li>
<li>34 Management Device</li>
<li>35 Management Device Component</li>
<li>36 Management Device Threshold Data</li>
<li>37 Memory Channel</li>
<li>38 IPMI Device</li>
<li>39 Power Supply</li>
</ul>
<p>查看内存信息的命令如下。</p>
<div><pre><code>$ <span>sudo</span> dmidecode -t <span>17</span>
<span># 或者</span>
$ dmidecode --type <span>17</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>以下是其他一些选项。</p>
<div><pre><code><span># 查看BIOS信息</span>
$ <span>sudo</span> dmidecode –t <span>0</span>

<span># 查看CPU信息</span>
$ <span>sudo</span> dmidecode -t <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>dmidecode</code> 也支持关键词查看，关键词与类别的对应关系如下。</p>
<ul>
<li>bios 0, 13</li>
<li>system 1, 12, 15, 23, 32</li>
<li>baseboard 2, 10</li>
<li>chassis 3</li>
<li>processor 4</li>
<li>memory 5, 6, 16, 17</li>
<li>cache 7</li>
<li>connector 8</li>
<li>slot 9</li>
</ul>
<p>查看系统信息的命令如下。</p>
<div><pre><code><span>sudo</span> dmidecode -t system
</code></pre>
<div><span>1</span><br></div></div><h2 id="lspci"> lspci</h2>
<p><code>lspci</code> 命令列出本机的所有 PCI 设备。</p>
<div><pre><code>lspci
</code></pre>
<div><span>1</span><br></div></div><p>该命令输出信息的格式如下。</p>
<div><pre><code>03:00.0 Unassigned class <span>[</span>ff00<span>]</span>: Realtek Semiconductor Co., Ltd. RTS5209 PCI Express Card Reader <span>(</span>rev 01<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>输出信息一共分成三个字段。</p>
<ul>
<li>Field 1: PCI bus slot 的编号</li>
<li>Field 2: PCI slot 的名字</li>
<li>Field 3: 设备名和厂商名</li>
</ul>
<p>如果想查看更详细信息，可以使用下面的命令。</p>
<div><pre><code>lspci -vmm
</code></pre>
<div><span>1</span><br></div></div><h2 id="lsusb"> lsusb</h2>
<p><code>lsusb</code> 命令用于操作 USB 端口。</p>
<p>下面命令列出本机所有 USB 端口。</p>
<div><pre><code>lsusb
</code></pre>
<div><span>1</span><br></div></div><p>它的输出格式如下。</p>
<div><pre><code>Bus 002 Device 003: ID 0781:5567 SanDisk Corp. Cruzer Blade
</code></pre>
<div><span>1</span><br></div></div><p>各个字段的含义如下。</p>
<ul>
<li>Bus 002 : bus 编号</li>
<li>Device 003: bus 002 连接的第三个设备</li>
<li>ID 0781:5567: 当前设备的编号，冒号前是厂商编号，冒号后是设备编号</li>
<li>SanDisk Corp. Cruzer Blade: 厂商和设备名</li>
</ul>
<p>找出本机有多少个 USB 接口可用。</p>
<div><pre><code>$ <span>find</span> /dev/bus/
/dev/bus/
/dev/bus/usb
/dev/bus/usb/002
/dev/bus/usb/002/006
/dev/bus/usb/002/005
/dev/bus/usb/002/004
/dev/bus/usb/002/002
/dev/bus/usb/002/001
/dev/bus/usb/001
/dev/bus/usb/001/007
/dev/bus/usb/001/003
/dev/bus/usb/001/002
/dev/bus/usb/001/001
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>查看某个 USB 设备的详细情况。</p>
<div><pre><code>lsusb -D /dev/bus/usb/002/005
</code></pre>
<div><span>1</span><br></div></div><p>查看所有设备的详细情况。</p>
<div><pre><code>lsusb -v
</code></pre>
<div><span>1</span><br></div></div><p>查看 USB 端口的版本。</p>
<div><pre><code>lsusb -v <span>|</span> <span>grep</span> -i bcdusb
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>命名管道</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/named-pipe/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/named-pipe/</guid>
      <source url="https://list-jiang.github.io/rss.xml">命名管道</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="命名管道"> 命名管道</h1>
<p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。</p>
<p>命令管道的行为类似于文件，但实际上形成了先入先出(FIFO)的缓冲。和普通(未命令的)管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西:</p>
<div><pre><code>process1 <span>></span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>和</p>
<div><pre><code>process2 <span>&lt;</span> named_pipe
</code></pre>
<div><span>1</span><br></div></div><p>表现出来就像这样:</p>
<div><pre><code>process1 <span>|</span> process2
</code></pre>
<div><span>1</span><br></div></div><h2 id="设置一个命名管道"> 设置一个命名管道</h2>
<p>使用 mkfifo 命令能够创建命令管道:</p>
<div><pre><code>$ <span>mkfifo</span> pipe1
$ <span>ls</span> -l pipe1
prw-r--r-- <span>1</span> me me <span>0</span> <span>2009</span>-07-17 06:41 pipe1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p>
<h2 id="使用命名管道"> 使用命名管道</h2>
<p>为了演示命名管道是如何工作的，我们将需要两个终端窗口(或用两个虚拟控制台代替)。在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道:</p>
<div><pre><code><span>ls</span> -l <span>></span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。使用第二个终端窗口，我们输入这个命令。</p>
<div><pre><code><span>cat</span> <span>&lt;</span> pipe1
</code></pre>
<div><span>1</span><br></div></div><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p>
]]></content:encoded>
    </item>
    <item>
      <title>进程管理</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/process/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/process/</guid>
      <source url="https://list-jiang.github.io/rss.xml">进程管理</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="进程管理"> 进程管理</h1>
<h2 id="ps"> ps</h2>
<p><code>ps</code> 命令用来列出进程信息。</p>
<div><pre><code>$ <span>ps</span>
PID TTY           TIME CMD
<span>5198</span> pts/1    00:00:00 <span>bash</span>
<span>10129</span> pts/1   00:00:00 <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不带任何参数时，<code>ps</code> 只列出与当前 Session 相关的进程。输出结果中，<code>PID</code> 是进程 ID、<code>TTY</code> 是进程的终端号(如果显示<code>?</code>，则表示进程没有终端)，<code>TIME</code> 是消耗的 CPU 时间，<code>CMD</code> 是触发进程的命令。</p>
<p><code>x</code> 参数列出所有进程的详细信息，包括不在当前 Session 的信息。</p>
<div><pre><code>$ <span>ps</span> x
PID TTY   STAT   TIME COMMAND
<span>2799</span> ?    Ssl    <span>0</span>:00 /usr/libexec/bonobo-activation-server –ac
<span>2820</span> ?    Sl     <span>0</span>:01 /usr/libexec/evolution-data-server-1.10 --
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这时的输出结果，会多出 <code>STAT</code> 一栏，表示状态。它的各种值如下。</p>
<ul>
<li><code>R</code> 正在运行或准备运行</li>
<li><code>S</code> 正在睡眠，即没有运行，正在等待一个事件唤醒</li>
<li><code>D</code> 不可中断睡眠。进程正在等待 I/O，比如磁盘驱动器的 I/O</li>
<li><code>T</code> 已停止，即进程停止运行</li>
<li><code>Z</code> “僵尸”进程。即这是一个已经终止的子进程，但父进程还没有清空它(没有把子进程从进程表中删除)</li>
<li><code>&lt;</code> 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。</li>
<li><code>N</code> 低优先级进程。一个低优先级进程(一个“好”进程)只有当其它高优先级进程执行之后，才会得到处理器时间。</li>
</ul>
<p><code>aux</code> 参数可以显示更多信息。</p>
<div><pre><code>$ <span>ps</span> aux
<span>USER</span>   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     <span>1</span>   <span>0.0</span>   <span>0.0</span>    <span>2136</span>    <span>644</span>  ?     Ss     Mar05   <span>0</span>:31  init
root     <span>2</span>   <span>0.0</span>   <span>0.0</span>       <span>0</span>      <span>0</span>  ?     S<span>&amp;</span>lt<span>;</span>     Mar05   <span>0</span>:00  <span>[</span>kt<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出结果包含的列的含义如下。</p>
<ul>
<li><code>USER</code> 用户 ID，表示进程的所有者</li>
<li><code>%CPU</code> 百分比表示的 CPU 使用率</li>
<li><code>%MEM</code> 百分比表示的内存使用率</li>
<li><code>VSZ</code> 虚拟内存大小</li>
<li><code>RSS</code> 进程占用的物理内存的大小，以千字节为单位。</li>
<li><code>START</code> 进程运行的起始时间。若超过 24 小时，则用天表示。</li>
</ul>
<h2 id="top"> top</h2>
<p><code>top</code> 命令可以查看机器的当前状态。</p>
<div><pre><code><span>top</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的输出结果分为两部分，最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p>
<p>输出结果是动态更新的，默认每三分钟更新一次。</p>
<h2 id="jobs"> jobs</h2>
<p><code>jobs</code> 命令用来查看后台任务。</p>
<div><pre><code>$ <span>jobs</span>
<span>[</span><span>1</span><span>]</span>+ Running            xlogo <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>输出结果之中，每个后台任务会有一个编号。上面结果中，<code>xlogo</code> 的编号是 <code>1</code>，<code>+</code> 表示正在运行。</p>
<h2 id="fg"> fg</h2>
<p><code>fg</code> 命令用于将后台任务切换到前台。</p>
<div><pre><code><span>fg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>fg</code> 命令之后，跟随着一个百分号和工作序号，用来指定切换哪一个后台任务。如果只有一个后台任务，那么 <code>fg</code> 命令可以不带参数。</p>
<h2 id="bg"> bg</h2>
<p><code>bg</code> 命令用于将一个暂停的前台任务，转移到后台。只有暂停的任务，才能使用 <code>bg</code> 命令，因为正在运行的任务，命令行是无法输入的。</p>
<div><pre><code><span>bg</span> %1
</code></pre>
<div><span>1</span><br></div></div><p><code>Ctrl + z</code> 可以暂停正在运行的前台任务。</p>
<h2 id="kill"> kill</h2>
<p><code>kill</code> 命令用于杀死进程。它的参数是进程 ID。</p>
<div><pre><code><span>kill</span> <span>28401</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>kill</code> 命令的实质是操作系统向进程发送信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT(中断)的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP(终端停止)的信号。</p>
<p><code>kill</code> 命令可以用来向进程发送指定信号。</p>
<div><pre><code><span>kill</span> <span>[</span>-signal<span>]</span> PID
</code></pre>
<div><span>1</span><br></div></div><p>下面是常见信号。</p>
<ul>
<li>HUP: 编号 1，表示挂起。发送这个信号到前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</li>
<li>INT: 编号 2，中断。实现和 <code>Ctrl-c</code> 一样的功能，由终端发送。通常，它会终止一个程序。</li>
<li>KILL: 编号 9，杀死。进程可能选择忽略这个信号。所以，操作系统不发送该信号到目标进程，而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</li>
<li>TERM: 编号 15，终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。</li>
<li>CONT: 编号 18，继续。在停止一段时间后，进程恢复运行。</li>
<li>STOP: 编号 19，停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</li>
<li>QUIT: 编号 3，退出</li>
<li>SEGV: 编号 11，段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。</li>
<li>TSTP: 编号 20，终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</li>
<li>WINCH: 编号 28，改变窗口大小。当改变窗口大小时，系统会发送这个信号。一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</li>
</ul>
<p><code>-l</code> 参数可以列出所有信号。</p>
<div><pre><code><span>kill</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="killall"> killall</h2>
<p><code>killall</code> 命令用于向指定的程序或用户发送信号。</p>
<div><pre><code><span>killall</span> <span>[</span>-u user<span>]</span> <span>[</span>-signal<span>]</span> name
</code></pre>
<div><span>1</span><br></div></div><h2 id="其他进程相关命令"> 其他进程相关命令</h2>
<ul>
<li><code>pstree</code> 输出树型结构的进程列表，这个列表展示了进程间父/子关系。</li>
<li><code>vmstat</code> 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。为了看到连续的显示结果，则在命令名后加上延时的时间(以秒为单位)。例如，“vmstat 5”。终止输出，按下 Ctrl-c 组合键。</li>
<li><code>xload</code> 一个图形界面程序，可以画出系统负载的图形。</li>
<li><code>tload</code> 与 <code>xload</code> 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>重定向</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/redirection/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/redirection/</guid>
      <source url="https://list-jiang.github.io/rss.xml">重定向</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="重定向"> 重定向</h1>
<p>重定向指的是将命令行输出写入指定位置。</p>
<ul>
<li><code>cmd1 | cmd2</code>: Pipe; take standard output of cmd1 as standard input to cmd2.</li>
<li><code>&gt; file</code>: Direct standard output to file.</li>
<li><code>&lt; file</code>: Take standard input from file.</li>
<li><code>&gt;&gt; file</code>: Direct standard output to file; append to file if it already exists.</li>
<li><code>&gt;| file</code>: Force standard output to file even if noclobber is set.</li>
<li><code>n&gt;| file</code>: Force output to file from file descriptor n even if noclobber is set.</li>
<li><code>&lt;&gt; file</code>: Use file as both standard input and standard output.</li>
<li><code>n&lt;&gt; file</code>: Use file as both input and output for file descriptor n.</li>
<li><code>&lt;&lt; label</code>: Here-document; see text.</li>
<li><code>n &gt; file</code>: Direct file descriptor n to file.</li>
<li><code>n &lt; file</code>: Take file descriptor n from file.</li>
<li><code>n &gt;&gt; file</code>: Direct file descriptor n to file; append to file if it already exists.</li>
<li><code>n&gt;&amp;</code>: Duplicate standard output to file descriptor n.</li>
<li><code>n&lt;&amp;</code>: Duplicate standard input from file descriptor n.</li>
<li><code>n&gt;&amp;m</code>: File descriptor  n is made to be a copy of the output file descriptor.</li>
<li><code>n&lt;&amp;m</code>: File descriptor  n is made to be a copy of the input file descriptor.</li>
<li><code>&amp;&gt;file</code>: Directs standard output and standard error to file.</li>
<li><code>&lt;&amp;-</code>: Close the standard input.</li>
<li><code>&gt;&amp;-</code>: Close the standard output.</li>
<li><code>n&gt;&amp;-</code>: Close the output from file descriptor  n.</li>
<li><code>n&lt;&amp;-</code>: Close the input from file descriptor  n.</li>
<li><code>n&gt;&amp;word</code>: If  n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. As a special case, if n is omitted, and word does not expand to one or more digits, the standard output and standard error are redirected as described previously.</li>
<li><code>n&lt;&amp;word</code>: If word expands to one or more digits, the file descriptor denoted by  n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.</li>
<li><code>n&gt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard output (file descriptor 1) if n is not specified.</li>
<li><code>n&lt;&amp;digit-</code>: Moves the file descriptor digit to file descriptor  n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.</li>
</ul>
<p><code>&gt;</code> 用来将标准输出重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果重定向后的指定文件已经存在，就会被覆盖，不会有任何提示。</p>
<p>如果命令没有任何输出，那么重定向之后，得到的是一个长度为 <code>0</code> 的文件。因此，<code>&gt;</code> 具有创建新文件或改写现存文件、将其改为长度 <code>0</code> 的作用。</p>
<div><pre><code><span>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>&gt;&gt;</code> 用来将标准输出重定向追加到指定文件。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>>></span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>2&gt;</code> 用来将标准错误重定向到指定文件。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> ls-error.txt
</code></pre>
<div><span>1</span><br></div></div><p>标准输出和标准错误，可以重定向到同一个文件。</p>
<div><pre><code>$ <span>ls</span> -l /bin/usr <span>></span> ls-output.txt <span><span>2</span>></span><span>&amp;1</span>
<span># 或者</span>
$ <span>ls</span> -l /bin/usr <span>&amp;></span> ls-output.txt

<span># 追加到同一个文件</span>
$ <span>ls</span> -l /bin/usr <span>&amp;>></span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如果不希望输出错误信息，可以将它重定向到一个特殊文件<code>/dev/null</code>。</p>
<div><pre><code><span>ls</span> -l /bin/usr <span><span>2</span>></span> /dev/null
</code></pre>
<div><span>1</span><br></div></div><p><code>|</code> 用于将一个命令的标准输出，重定向到另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> -l /usr/bin <span>|</span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>不要将<code>&gt;</code> 与 <code>|</code> 混淆。</p>
<div><pre><code><span>ls</span> <span>></span> <span>less</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会在当前目录，生成一个名为 <code>less</code> 的文本文件。</p>
<p>下面是标准错误重定向的一个例子。</p>
<div><pre><code><span>invalid_input</span> <span>(</span><span>)</span> <span>{</span>
    <span>echo</span> <span>"Invalid input '<span>$REPLY</span>'"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>}</span>
<span>read</span> -p <span>"Enter a single item > "</span>
<span>[</span><span>[</span> -z <span>$REPLY</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> invalid_input
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="tee"> tee</h2>
<p><code>tee</code> 命令用于同时将标准输出重定向到文件，以及另一个命令的标准输入。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>tee</span> ls.txt <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="命令替换"> 命令替换</h2>
<p>命令替换(command substitution)指的是将一个命令的输出，替换进入另一个命令。<code>$(command)</code> 表示命令替换，另一种写法是使用反引号。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>ls</span><span>)</span></span>
<span># 或者</span>
$ <span>echo</span> <span><span>`</span><span>ls</span><span>`</span></span>

$ <span>ls</span> -l <span><span>$(</span><span>which</span> <span>cp</span><span>)</span></span>
<span># 或者</span>
$ <span>ls</span> -l <span><span>`</span><span>which</span> <span>cp</span><span>`</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="basename"> basename</h2>
<p><code>basename</code> 命令清除 一个路径名的开头部分，只留下一个文件的基本名称。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># file_info: simple file information program</span>
<span>PROGNAME</span><span>=</span><span><span>$(</span><span>basename</span> $0<span>)</span></span>
<span>if</span> <span>[</span><span>[</span> -e <span>$1</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Type:"</span>
    <span>file</span> <span>$1</span>
    <span>echo</span> -e <span>"<span title="\n">\n</span>File Status:"</span>
    <span>stat</span> <span>$1</span>
<span>else</span>
    <span>echo</span> <span>"<span>$PROGNAME</span>: usage: <span>$PROGNAME</span> file"</span> <span>></span><span>&amp;2</span>
    <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>正则表达式</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/regex/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/regex/</guid>
      <source url="https://list-jiang.github.io/rss.xml">正则表达式</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="正则表达式"> 正则表达式</h1>
<p><code>正则表达式</code>是表达文本模式的方法。</p>
<ul>
<li><code>.</code>: 匹配任何单个字符。</li>
<li><code>?</code>: 上一项是可选的，最多匹配一次。</li>
<li><code>*</code>: 前一项将被匹配零次或多次。</li>
<li><code>+</code>: 前一项将被匹配一次或多次。</li>
<li><code>{N}</code>: 上一项完全匹配 N 次。</li>
<li><code>{N，}</code>: 前一项匹配 N 次或多次。</li>
<li><code>{N，M}</code>: 前一项至少匹配 N 次，但不超过 M 次。</li>
<li><code>--</code>: 表示范围，如果它不是列表中的第一个或最后一个，也不是列表中某个范围的终点。</li>
<li><code>^</code>: 匹配行首的空字符串；也代表不在列表范围内的字符。</li>
<li><code>$</code>: 匹配行尾的空字符串。</li>
<li><code>\b</code>: 匹配单词边缘的空字符串。</li>
<li><code>\B</code>: 匹配空字符串，前提是它不在单词的边缘。</li>
<li><code>\&lt;</code>: 匹配单词开头的空字符串。</li>
<li><code>\&gt;</code>: 匹配单词末尾的空字符串。</li>
</ul>
<h2 id="元字符"> 元字符</h2>
<p><code>元字符</code>是表示特殊函数的字符，包括以下这些 <code>^ $ . [ ] { } - ? * + ( ) | \\</code>。除了元字符，其他字符在正则表达式中，都表示原来的含义。</p>
<ul>
<li><code>.</code> 匹配任意字符，但不含空字符</li>
<li><code>^</code> 匹配文本行开头</li>
<li><code>$</code> 匹配文本行结尾</li>
</ul>
<div><pre><code><span>grep</span> -h <span>'.zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在文件中查找包含正则表达式“.zip”的文本行。注意，上面命令不会匹配 <code>zip</code> 程序，因为 <code>zip</code> 只有三个字符，而 <code>.zip</code> 要求四个字符。</p>
<div><pre><code><span>grep</span> -h <span>'^zip'</span> dirlist*.txt
<span>grep</span> -h <span>'zip$'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“zip”(例如，zip 独占一行)的匹配行。注意正则表达式‘^$’(行首和行尾之间没有字符)会匹配空行。</p>
<h2 id="方括号"> 方括号</h2>
<p>方括号之中的字符，表示可以任意匹配其中的一个。</p>
<div><pre><code><span>grep</span> -h <span>'[bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含字符串“bzip”或者“gzip”的任意行。</p>
<p>注意，元字符放入方括号之中，会失去其特殊含义。但有两种情况除外，<code>^</code> 在方括号的开头，表示否定，否则只是一个普通字符，表示原义。</p>
<div><pre><code><span>grep</span> -h <span>'[^bg]zip'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配不以 <code>b</code> 或 <code>g</code> 开头的 <code>zip</code> 字符串。注意，上面命令不会匹配 <code>zip</code>，因为一个否定的字符集仍然要求存在一个字符。</p>
<p><code>-</code> 在方括号之中表示一个字符区域。</p>
<div><pre><code><span>grep</span> -h <span>'^[A-Z]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配所有以大写字母开头的文本行。类似的，<code>^[A-Za-z0-9]</code> 表示以大写字母、小写字母、数字开头的文本行。</p>
<p>注意，连字号如果不构成一个字符区域，则表示其本来的含义。</p>
<div><pre><code><span>grep</span> -h <span>'[-AZ]'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。</p>
<h2 id="预定义字符类"> 预定义字符类</h2>
<p>由于 <code>locale</code> 设置不同，Shell 展开正则表达式 <code>[A-Z]</code> 时，可能不是解释为所有大写字母，而是解释为包括所有字母的字典顺序。</p>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span>A-Z<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令在某些发行版里面，会返回所有大写字母或小写字母开头的文件。</p>
<p>为了避免这个问题，可以使用正则表达式的预定义字符类。</p>
<ul>
<li><code>[:alnum:]</code> 字母数字字符。在 ASCII 中，等价于: <code>[A-Za-z0-9]</code></li>
<li><code>[:word:]</code> 与 <code>[:alnum:]</code> 相同, 但增加了下划线字符。</li>
<li><code>[:alpha:]</code> 字母字符。在 ASCII 中，等价于 <code>[A-Za-z]</code></li>
<li><code>[:blank:]</code> 包含空格和 tab 字符。</li>
<li><code>[:cntrl:]</code> ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。</li>
<li><code>[:digit:]</code> 数字 0 到 9</li>
<li><code>[:graph:]</code> 可视字符。在 ASCII 中，它包含 33 到 126 的字符。</li>
<li><code>[:lower:]</code> 小写字母。</li>
<li><code>[:punct:]</code> 标点符号字符。</li>
<li><code>[:print:]</code> 可打印的字符。等于 <code>[:graph:]</code> 中的所有字符，再加上空格字符。</li>
<li><code>[:space:]</code> 空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed.在 ASCII 中， 等价于 <code>[ \t\r\n\v\f]</code></li>
<li><code>[:upper:]</code> 大写字母。</li>
<li><code>[:xdigit:]</code> 用来表示十六进制数字的字符。在 ASCII 中，等价于 <code>[0-9A-Fa-f]</code></li>
</ul>
<div><pre><code><span>ls</span> /usr/sbin/<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回所有大写字母开头的文件名。</p>
<h2 id="选择"> 选择</h2>
<p><code>|</code> 表示匹配一系列字符串之中的一个。注意与方括号区分，方括号表示匹配一系列字符之中的一个。</p>
<div><pre><code>$ <span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
AAA
$ <span>echo</span> <span>"BBB"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
BBB
$ <span>echo</span> <span>"CCC"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB'</span>
$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面代码中，<code>AAA|BBB</code> 表示匹配字符串 <code>AAA</code> 或者是字符串 <code>BBB</code>。<code>grep</code> 程序使用 <code>-E</code> 参数，表示按照正则表达式规则匹配。并且，这个正则表达式放在单引号之中，为的是阻止 Shell 把 <code>|</code> 解释为管道操作符。</p>
<p><code>|</code> 可以多个连用，也可以与其他正则规则结合使用。</p>
<div><pre><code><span>echo</span> <span>"AAA"</span> <span>|</span> <span>grep</span> -E <span>'AAA|BBB|CCC'</span>

<span>grep</span> -Eh <span>'^(bz|gz|zip)'</span> dirlist*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="量词操作符"> 量词操作符</h2>
<p>量词操作符表示一个元素被匹配的次数。</p>
<ul>
<li><code>?</code> 匹配前面的元素出现 0 次或 1 次</li>
<li><code>*</code> 匹配前面的元素出现 0 次或多次</li>
<li><code>+</code> 匹配前面的元素出现 1 次或多次</li>
<li><code>{n}</code> 匹配前面的元素出现了 <code>n</code> 次</li>
<li><code>{n,m}</code> 匹配前面的元素它至少出现了 <code>n</code> 次，但是不多于 <code>m</code> 次</li>
<li><code>{n,}</code> 匹配前面的元素至少出现了 <code>n</code> 次</li>
<li><code>{,m}</code> 匹配前面的元素，如果它出现的次数不多于 m 次。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>系统信息</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/system/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/system/</guid>
      <source url="https://list-jiang.github.io/rss.xml">系统信息</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="系统信息"> 系统信息</h1>
<h2 id="uname"> uname</h2>
<p><code>uname</code> 命令返回当前机器的信息。</p>
<div><pre><code><span># 内核的版本</span>
$ <span>uname</span> -r
<span>3.2</span>.0-24-virtual

<span># CPU 架构</span>
$ <span>uname</span> -m
x86_64
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果要了解操作系统的版本，可以查看<code>/etc/issue</code> 文件。</p>
<div><pre><code>$ <span>cat</span> /etc/issue
Debian GNU/Linux <span>9</span> <span>\</span>n <span>\</span>l
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="service"> service</h2>
<p><code>service</code> 命令可以查看当前正在运行的服务。</p>
<div><pre><code>$ <span>service</span> --status-all
 <span>[</span> + <span>]</span>  apache2
 <span>[</span> ? <span>]</span>  atd
 <span>[</span> - <span>]</span>  bootlogd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>+</code> 表示正在运行，<code>-</code> 表示已经停止，<code>?</code>表示 <code>service</code> 命令不了解相关信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>文本处理</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/text/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/text/</guid>
      <source url="https://list-jiang.github.io/rss.xml">文本处理</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="文本处理"> 文本处理</h1>
<h2 id="cat"> cat</h2>
<p><code>cat</code> 可以文件的内容，显示在标准输出。</p>
<div><pre><code>$ <span>cat</span> text1
<span>1</span> apple
<span>2</span> pear
<span>3</span> banana
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>它也可以同时输出多个文件内容。</p>
<div><pre><code><span>cat</span> text1 text2
</code></pre>
<div><span>1</span><br></div></div><p>它与重定向结合，就可以合并多个文件。</p>
<div><pre><code><span># 合并文本文件</span>
$ <span>cat</span> text* <span>></span> text.all

<span># 合并二进制文件</span>
$ <span>cat</span> movie.mpeg.0* <span>></span> movie.mpeg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果调用 <code>cat</code> 命令时没有任何参数，它将读取标准输入，然后显示到标准输出。按下 <code>Ctrl + d</code>，将会结束 <code>cat</code> 读取标准输入。利用这一点，可以将键盘输入写入指定文件，按下 <code>Ctrl + d</code> 结束输入。</p>
<div><pre><code><span>cat</span> <span>></span> lazy_dog.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-n</code> 输出结果显示行号</li>
<li><code>-s</code> 将多个连续的空白行，输出为一行</li>
<li><code>-A</code> 输出结果中显示控制符，比如 Tab 键显示为 <code>^I</code>，行尾显示<code>$</code></li>
</ul>
<p><code>cat</code> 支持 Here document，显示多行文本。</p>
<div><pre><code><span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;HTML>
         &lt;HEAD>
                &lt;TITLE><span>$TITLE</span>&lt;/TITLE>
         &lt;/HEAD>
         &lt;BODY>
                &lt;H1><span>$TITLE</span>&lt;/H1>
                &lt;P><span>$TIME_STAMP</span>&lt;/P>
         &lt;/BODY>
&lt;/HTML>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Here document 常在脚本当中作为输入的手段。</p>
<div><pre><code>$ <span>sort</span> -k2 <span>&lt;&lt;</span>END
<span>></span> <span>1</span> apple
<span>></span> <span>2</span> pear
<span>></span> <span>3</span> banana
<span>></span> END
<span>1</span> apple
<span>3</span> banana
<span>2</span> pear
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果使用 <code>&lt;&lt;-</code> 代替 <code>&lt;&lt;</code>，行首的 tab 键将被剥离。</p>
<h2 id="nl"> nl</h2>
<p><code>nl</code> 命令为文本文件添加行号，显示在标准输出。</p>
<div><pre><code><span>nl</span> example.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="sort"> sort</h2>
<p><code>sort</code> 命令将文本文件的所有行排序后输出。</p>
<div><pre><code><span>sort</span> file1.txt file2.txt file3.txt <span>></span> final_sorted_list.txt
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-b</code> <code>--ignore-leading-blanks</code> 默认情况下，排序用的是每行的第一个字符。这个参数忽略每行开头的空格，从第一个非空白字符开始排序。</li>
<li><code>-f</code> <code>--ignore-case</code> 让排序不区分大小写。</li>
<li><code>-n</code> <code>--numeric-sort</code> 按照数值排序，而不是字符值，用于行首是数值的情况。</li>
<li><code>-r</code> <code>--reverse</code> 按相反顺序排序。结果按照降序排列，而不是升序。</li>
<li><code>-k</code> <code>--key=field1[,field2]</code> 指定按照每行的第几个字段(从 1 开始)排序，而不是按照行首字符排序。该属性可以多个连用，用于指定多重排序标准，还可以指定每个字段指定排序标准，这些值与全局属性一致，比如 b(忽略开头的空格)，n(数值排序)，r(逆向排序)等等。</li>
<li><code>-m</code> <code>--merge</code> 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</li>
<li><code>-o</code> <code>--output=file</code> 把排好序的输出结果发送到文件，而不是标准输出。</li>
<li><code>-t</code> <code>--field-separator=char</code> 定义字段分隔字符。默认情况下，字段由空格或制表符分隔。</li>
<li><code>-u</code> 输出结果中删除重复行</li>
</ul>
<div><pre><code><span>sort</span> --key<span>=</span><span>1,1</span> --key<span>=</span>2n distros.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，第一个 <code>--key</code> 指定第一排序标准是只用第一字段(<code>1,1</code>)，也可以指定使用第一字段第一个字符(<code>1.1</code>)；第二排序标准是第二字段，按数值排序。</p>
<h2 id="uniq"> uniq</h2>
<p><code>uniq</code> 命令在排序后的行中，删除所有重复的行，保证所有输出没有重复。</p>
<div><pre><code><span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span>
</code></pre>
<div><span>1</span><br></div></div><p>它的参数如下。</p>
<ul>
<li><code>-c</code> 输出所有的重复行，并且每行开头显示重复的次数。</li>
<li><code>-d</code> 只输出重复行，而不是不重复的文本行。</li>
<li><code>-f n</code> 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。</li>
<li><code>-i</code> 在比较文本行的时候忽略大小写。</li>
<li><code>-s n</code> 跳过(忽略)每行开头的 n 个字符。</li>
<li><code>-u</code> 只是输出独有的文本行。这是默认的。</li>
<li><code>-V</code> 按照版本号排序。</li>
</ul>
<p><code>-V</code> 参数可以按版本号排列(从小到大)。</p>
<div><pre><code>$ <span>sort</span> -V input.txt
<span>1.0</span>.15
<span>1.3</span>.0
<span>2.1</span>.2
<span>3.0</span>.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>-rV</code> 参数可以按版本号逆序排列。</p>
<div><pre><code>$ <span>sort</span> -rV input.txt
<span>3.0</span>.0
<span>2.1</span>.2
<span>1.3</span>.0
<span>1.0</span>.15
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="cut"> cut</h2>
<p><code>cut</code> 程序用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。</p>
<p>它的参数如下。</p>
<ul>
<li><code>-c char_list</code> 抽取指定范围的文本</li>
<li><code>-f field_list</code> 抽取指定字段，字段之间可以 tab 分隔也可以逗号分隔</li>
<li><code>-d delim_char</code> 指定字段分隔符，默认是 tab 键</li>
<li><code>--complement</code> 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</li>
</ul>
<div><pre><code><span># 抽取每行的第三个字段</span>
$ <span>cut</span> -f <span>3</span> distros.txt

<span># 抽取每行的第7到第10个字符</span>
$ <span>cut</span> -c <span>7</span>-10 distros.txt

<span># 抽取每行的第23个到结尾的字符1</span>
$ <span>cut</span> -c <span>23</span>- distros.txt

<span># 指定字段分隔符为冒号</span>
$ <span>cut</span> -d <span>':'</span> -f <span>1</span> /etc/passwd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="paste"> paste</h2>
<p><code>paste</code> 程序将多个文本文件按行合并，即每一行都由原来文本文件的每一行组成，显示在标准输出。</p>
<div><pre><code><span>paste</span> distros-dates.txt distros-versions.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="wc"> wc</h2>
<p><code>wc</code> 命令输出一个文本文件的统计信息(word count)，一共有三个值，分别为行数、词数和字节数。</p>
<div><pre><code>$ <span>wc</span> ls-output.txt
 <span>7902</span> <span>64566</span> <span>503634</span> ls-output.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果使用 <code>-l</code> 参数，则只输出行数。</p>
<div><pre><code>$ <span>ls</span> /bin /usr/bin <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span> <span>|</span> <span>wc</span> -l
 <span>2728</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="head"> head</h2>
<p><code>head</code> 命令返回文本文件的头部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>head</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><h2 id="tail"> tail</h2>
<p><code>tail</code> 命令返回文本文件的尾部，默认显示 10 行。</p>
<p><code>-n</code> 参数指定显示的行数。</p>
<div><pre><code><span>tail</span> -n <span>5</span> ls-output.txt
</code></pre>
<div><span>1</span><br></div></div><p><code>-f</code> 会实时追加显示新增的内容，常用于实时监控日志，按 <code>Ctrl + c</code> 停止。</p>
<div><pre><code><span>tail</span> -f /var/log/messages
</code></pre>
<div><span>1</span><br></div></div><h2 id="grep"> grep</h2>
<p><code>grep</code> 程序用于在指定文件之中，搜索符合某个模式的行，并把搜索结果输出到标准输出。</p>
<div><pre><code><span>grep</span> keyword foo.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出 <code>foo.txt</code> 之中匹配 <code>keyword</code> 的行。</p>
<p><code>grep</code> 程序可以同时搜索多个文件。</p>
<div><pre><code><span>grep</span> keyword f*.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出多个文件中匹配 <code>keyword</code> 的行。</p>
<p><code>-l</code> 参数输出匹配的文件名，而不是文件行。</p>
<div><pre><code><span>grep</span> -l bzip dirlist*.txt
</code></pre>
<div><span>1</span><br></div></div><p>如果想搜索文件名，而不是文件内容，可以使用重定向。</p>
<div><pre><code><span>ls</span> /usr/bin <span>|</span> <span>grep</span> <span>zip</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会输出<code>/usr/bin</code> 目录中，文件名中包含子字符串 <code>zip</code> 的所有文件。</p>
<p>参数的含义。</p>
<ul>
<li><code>-c</code> 或 <code>--count</code> 输出匹配的数量，而不是匹配的文本行。如果使用了 <code>-v</code>，则输出不匹配的数量。</li>
<li><code>-h</code> 或 <code>--no-filename</code> 应用于多文件搜索，不在每行匹配的文本前，输出文件名</li>
<li><code>-i</code> 或 <code>--ignore-case</code> 忽略大小写</li>
<li><code>-l</code> 或 <code>--files-with-matches</code> 输出包含匹配项的文件名，而不是文本行本身</li>
<li><code>-L</code> 或 <code>--files-without-match</code> 类似于 <code>-l</code>，但输出不包含匹配项的文件名</li>
<li><code>-n</code> 或 <code>--line-number</code> 每个匹配行之前输出其对应的行号</li>
<li><code>-v</code> 或 <code>--invert-match</code> 只返回不符合模式的行</li>
</ul>
<h2 id="sed"> sed</h2>
<p><code>sed</code> 是一个强大的文本编辑工具。</p>
<div><pre><code><span># 输出前5行</span>
$ <span>sed</span> -n <span>'1,5p'</span> distros.txt

<span># 输出包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/p'</span> distros.txt

<span># 输出不包含指定内容的行</span>
$ <span>sed</span> -n <span>'/SUSE/!p'</span> distros.txt

<span># 替换内容(只替换第一个)</span>
$ <span>sed</span> <span>'s/regexp/replacement/'</span> distros.txt

<span># 替换内容(全局替换)</span>
$ <span>sed</span> <span>'s/regexp/replacement/g'</span> distros.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>时间管理</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/time/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/time/</guid>
      <source url="https://list-jiang.github.io/rss.xml">时间管理</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="时间管理"> 时间管理</h1>
<h2 id="date-命令"> date 命令</h2>
<p><code>date</code> 命令用于输出当前时间</p>
<div><pre><code>$ <span>date</span>
<span>2016</span>年 03月 <span>14</span>日 星期一 <span>17</span>:32:35 CST
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>date</code> 命令后面用加号(<code>+</code>)指定显示的格式。</p>
<div><pre><code>$ <span>date</span> +%d_%b_%Y
10_Sep_2018

$ <span>date</span> +%D
09/10/18

$ <span>date</span> +%F-%T
<span>2018</span>-09-10-11:09:51
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>完整的格式参数如下。</p>
<ul>
<li>%a 星期名的缩写(Sun)</li>
<li>%A 星期名的全称(Sunday)</li>
<li>%b 月份的缩写(Jan)</li>
<li>%B 月份的全称(January)</li>
<li>%c 日期和时间(Thu Mar 3 23:05:25 2005)</li>
<li>%C 世纪，就是年份数省略后两位(20)</li>
<li>%d 一个月的第几天(01)</li>
<li>%D 日期，等同于<code>%m/%d/%y</code></li>
<li>%e 一个月的第几天，用空格补零，等同于<code>%_d</code></li>
<li>%F 完整的日期，等同于<code>%Y-%m-%d</code></li>
<li>%g last two digits of year of ISO week number (see %G)</li>
<li>%G year of ISO week number (see %V); normally useful only with %V</li>
<li>%h 等同于<code>%b</code></li>
<li>%H 小时(00..23)</li>
<li>%I 小时(01..12)</li>
<li>%j day of year (001..366)</li>
<li>%k hour ( 0..23)</li>
<li>%l hour ( 1..12)</li>
<li>%m month (01..12)</li>
<li>%M minute (00..59)</li>
<li>%N nanoseconds (000000000..999999999)</li>
<li>%p locale’s equivalent of either AM or PM; blank if not known</li>
<li>%P like %p, but lower case</li>
<li>%r locale’s 12-hour clock time (e.g., 11:11:04 PM)</li>
<li>%R 24-hour hour and minute; same as %H:%M</li>
<li>%s seconds since 1970-01-01 00:00:00 UTC</li>
<li>%S second (00..60)</li>
<li>%T time; same as %H:%M:%S</li>
<li>%u day of week (1..7); 1 is Monday</li>
<li>%U week number of year, with Sunday as first day of week (00..53)</li>
<li>%V ISO week number, with Monday as first day of week (01..53)</li>
<li>%w day of week (0..6); 0 is Sunday</li>
<li>%W week number of year, with Monday as first day of week (00..53)</li>
<li>%x locale’s date representation (e.g., 12/31/99)</li>
<li>%X locale’s time representation (e.g., 23:13:48)</li>
<li>%y last two digits of year (00..99)</li>
<li>%Y year</li>
<li>%z +hhmm numeric timezone (e.g., -0400)</li>
<li>%😒 +hh:mm numeric timezone (e.g., -04:00)</li>
<li>%:😒 +hh:mm:ss numeric time zone (e.g., -04:00:00)</li>
<li>%Z alphabetic time zone abbreviation (e.g., EDT)</li>
</ul>
<h2 id="cal-命令"> cal 命令</h2>
<p><code>cal</code> 命令用于显示日历。不带有参数时，显示的是当前月份。</p>
<div><pre><code>$ <span>cal</span>
      三月 <span>2016</span>
日 一 二 三 四 五 六
       <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>  <span>5</span>
 <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span> <span>12</span>
<span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span> <span>19</span>
<span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span> <span>26</span>
<span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>用户管理</title>
      <link>https://list-jiang.github.io/code/linux/bash/archives/user/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/archives/user/</guid>
      <source url="https://list-jiang.github.io/rss.xml">用户管理</source>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="用户管理"> 用户管理</h1>
<h2 id="id"> id</h2>
<p><code>id</code> 命令用于查看指定用户的用户名和组名。</p>
<div><pre><code>$ <span>id</span>
<span>uid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>gid</span><span>=</span><span>500</span><span>(</span>me<span>)</span> <span>groups</span><span>=</span><span>500</span><span>(</span>me<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>id</code> 输出结果分为三个部分，分别是 UID(用户编号和用户名)、GID(组编号和组名)，groups(用户所在的所有组)。</p>
<p>用户帐户的信息，存放在<code>/etc/passwd</code> 文件里面；用户组的信息，存放在<code>/etc/group</code> 文件里面。</p>
<div><pre><code><span># 返回UID</span>
$ <span>id</span> -u <span>[</span>UserName<span>]</span>

<span># 返回GID</span>
$ <span>id</span> -g <span>[</span>UserName<span>]</span>

<span># 返回用户名</span>
$ <span>id</span> -un <span>[</span>UserName<span>]</span>

<span># 返回组名</span>
$ <span>id</span> -gn <span>[</span>UserName<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的命令，如果省略用户名，则返回当前用户的信息。</p>
<h2 id="su"> su</h2>
<p><code>su</code> 命令允许您以另一个用户的身份，启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。</p>
<div><pre><code><span>su</span> otherUser
</code></pre>
<div><span>1</span><br></div></div><p>执行上面的命令以后，系统会提示输入密码。通过以后，就以另一个用户身份在执行命令了。</p>
<p>如果不加用户名，则表示切换到 root 用户。</p>
<div><pre><code><span>su</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>-l</code> 参数表示启动一个需要登录的新的 Shell，这意味着工作目录会切换到该用户的主目录。它的缩写形式是 <code>-</code>。</p>
<div><pre><code><span>su</span> -
</code></pre>
<div><span>1</span><br></div></div><p>上面命令表示，切换到 root 用户的身份，且工作目录也切换到 root 用户的主目录。</p>
<p><code>-c</code> 参数表示只以其他用户的身份，执行单个命令，而不是启动一个新的 Session。</p>
<div><pre><code>$ <span>su</span> -c <span>'command'</span>

<span># 实例</span>
$ <span>su</span> -c <span>'ls -l /root/*'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="sudo"> sudo</h2>
<p><code>sudo</code> 命令很类似 <code>su</code> 命令，但有几点差别。</p>
<ul>
<li>对于管理员来说，<code>sudo</code> 命令的可配置性更高</li>
<li><code>sudo</code> 命令通常只用于执行单个命令，而不是开启另一个 Session。</li>
<li><code>sudo</code> 命令不要求超级用户的密码，而是用户使自己的密码来认证。</li>
</ul>
<p><code>sudo</code> 的设置在文件<code>/etc/sudoers</code> 之中。</p>
<p><code>-l</code> 参数列出用户拥有的所有权限。</p>
<div><pre><code><span>sudo</span> -l
</code></pre>
<div><span>1</span><br></div></div><h2 id="chown"> chown</h2>
<p><code>chown</code> 命令用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p>
<div><pre><code><span>chown</span> <span>[</span>owner<span>]</span><span>[</span>:<span>[</span>group<span>]</span><span>]</span> <span>file</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一些例子。</p>
<div><pre><code><span># 更改文件所有者</span>
$ <span>sudo</span> <span>chown</span> bob foo.txt

<span># 更改文件所有者和用户组</span>
$ <span>sudo</span> <span>chown</span> bob:users foo.txt

<span># 更改用户组</span>
$ <span>sudo</span> <span>chown</span> :admins foo.txt

<span># 更改文件所有者和用户组(用户 bob 登录系统时，所属的用户组)</span>
$ <span>sudo</span> <span>chown</span> bob: foo.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="chgrp"> chgrp</h2>
<p><code>chgrp</code> 命令更改用户组，用法与 <code>chown</code> 命令类似。</p>
<h2 id="useradd"> useradd</h2>
<p><code>useradd</code> 命令用来新增用户。</p>
<div><pre><code><span>useradd</span> -G admin -d /home/bill -s /bin/bash -m bill
</code></pre>
<div><span>1</span><br></div></div><p>上面命令新增用户 <code>bill</code>，参数 <code>-G</code> 指定用户所在的组，参数 <code>d</code> 指定用户的主目录，参数 <code>s</code> 指定用户的 Shell，参数 <code>m</code> 表示如果该目录不存在，则创建该目录。</p>
<h2 id="usermod"> usermod</h2>
<p><code>usermod</code> 命令用来修改用户的各项属性。</p>
<div><pre><code><span>usermod</span> -g sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的主要用户组为 <code>sales</code>。</p>
<div><pre><code><span>usermod</span> -G sales jerry
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令修改用户 <code>jerry</code> 属于的次要用户组为 <code>sales</code>。</p>
<h2 id="adduser"> adduser</h2>
<p><code>adduser</code> 命令用来将一个用户加入用户组。</p>
<div><pre><code><span>sudo</span> adduser username grouptoadd
</code></pre>
<div><span>1</span><br></div></div><h2 id="groupadd"> groupadd</h2>
<p><code>groupadd</code> 命令用来新建一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupadd</span> group1
<span>sudo</span> adduser foobar group1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="groupdel"> groupdel</h2>
<p><code>groupdel</code> 命令用来删除一个用户组。</p>
<div><pre><code><span>sudo</span> <span>groupdel</span> group1
</code></pre>
<div><span>1</span><br></div></div><h2 id="passwd"> passwd</h2>
<p><code>passwd</code> 命令用于修改密码。</p>
<div><pre><code><span># 修改自己的密码</span>
$ <span>passwd</span>

<span># 修改其他用户的密码</span>
$ <span>sudo</span> <span>passwd</span> <span>[</span>user<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash 的算术运算</title>
      <link>https://list-jiang.github.io/code/linux/bash/arithmetic/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/arithmetic/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 的算术运算</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="算术表达式"> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>
$ <span>echo</span> <span>$foo</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>
<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>
<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div><pre><code>$ <span>i</span><span>=</span><span>0</span>
$ <span>echo</span> <span>$i</span>
<span>0</span>
$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>
<span>0</span>
$ <span>echo</span> <span>$i</span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>
<span>2</span>
$ <span>echo</span> <span>$i</span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>
<span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>
<span>75</span>
<span># 等同于</span>
$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>
<span>75</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>
bash: 语法错误
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div><pre><code>$ <span>number</span><span>=</span><span>2</span>
$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> "hello" <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
$ <span>echo</span> <span><span>$((</span> "hello" <span>*</span> <span>2</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>hello</span><span>=</span><span>3</span>
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="数值的进制"> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>
<span>255</span>
$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>
<span>255</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2 id="位运算"> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>
<span>64</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>
<span>19</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>
<span>18</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="逻辑运算"> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div><pre><code>$ <span>a</span><span>=</span><span>0</span>
$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算"> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span>$a</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>
$ <span>echo</span> <span><span>$((</span>foo<span>*=</span><span>2</span><span>))</span></span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-=</span><span>1</span><span>)</span> <span>))</span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="求值运算"> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>
<span>12</span>
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2 id="expr-命令"> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>
$ <span>expr</span> <span>$foo</span> + <span>2</span>
<span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>
expr: 非整数参数
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数组</title>
      <link>https://list-jiang.github.io/code/linux/bash/array/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/array/</guid>
      <source url="https://list-jiang.github.io/rss.xml">数组</source>
      <description>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>

<h2 id="创建数组"> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val
array<span>[</span><span>1</span><span>]</span><span>=</span>val
array<span>[</span><span>2</span><span>]</span><span>=</span>val
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>

<span># 等同于</span>

<span>ARRAY</span><span>=</span><span>(</span>
  value1
  value2
  value3
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>
<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>

<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>
<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>只为某些值指定位置，也是可以的。</p>
<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div><pre><code><span>declare</span> -a ARRAYNAME
</code></pre>
<div><span>1</span><br></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div><pre><code><span>read</span> -a dice
</code></pre>
<div><span>1</span><br></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2 id="读取数组"> 读取数组</h2>
<h3 id="读取单个元素"> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a

$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>
a

$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>
a<span>[</span><span>0</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3 id="读取所有成员"> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>"<span>${names<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>"water skiing"</span> canoeing <span>"white-water rafting"</span> surfing <span>)</span>
$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>*<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"${activities[@]"</span> diving <span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置"> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div><pre><code>$ <span>declare</span> -a foo
$ <span>foo</span><span>=</span>A
$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>
A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo}</span>
a
$ <span>echo</span> <span>$foo</span>
a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2 id="数组的长度"> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>
<span>1</span>

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo
$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2 id="提取数组序号"> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>
  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="提取数组成员"> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>
bananas
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>
bananas cucumbers dates
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>
eggs fajitas grapes
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员"> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c

$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="删除数组"> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f

$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>foo</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
b c d e f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div><pre><code>$ <span>unset</span> ARRAY

$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>
<span>&lt;</span>--no output--<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="关联数组"> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div><pre><code><span>declare</span> -A colors
colors<span>[</span><span>"red"</span><span>]</span><span>=</span><span>"#ff0000"</span>
colors<span>[</span><span>"green"</span><span>]</span><span>=</span><span>"#00ff00"</span>
colors<span>[</span><span>"blue"</span><span>]</span><span>=</span><span>"#0000ff"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div><pre><code><span>echo</span> <span>${colors<span>[</span>"blue"<span>]</span>}</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>条件判断</title>
      <link>https://list-jiang.github.io/code/linux/bash/condition/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/condition/</guid>
      <source url="https://list-jiang.github.io/rss.xml">条件判断</source>
      <description>本章介绍 Bash 脚本的条件判断语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>

<h2 id="if-结构"> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>
  commands
<span>[</span>elif commands<span>;</span> <span>then</span>
  commands<span>..</span>.<span>]</span>
<span>[</span>else
  commands<span>]</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>"foo"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Hello foo."</span>
<span>else</span>
  <span>echo</span> <span>"You are not foo."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div><pre><code><span>if</span> <span>true</span>
<span>then</span>
  <span>echo</span> <span>'hello world'</span>
<span>fi</span>

<span>if</span> <span>false</span>
<span>then</span>
  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world

$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>"It's true."</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hi
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>if</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>1</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"2"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>2</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>3</span>
<span>else</span>
    <span>echo</span> 输入不符合要求
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2 id="test-命令"> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div><pre><code><span># 写法一</span>
<span>test</span> expression

<span># 写法二</span>
<span>[</span> expression <span>]</span>

<span># 写法三</span>
<span>[</span><span>[</span> expression <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div><pre><code>$ <span>test</span> -f /etc/hosts
$ <span>echo</span> <span>$?</span>
<span>0</span>

$ <span>[</span> -f /etc/hosts <span>]</span>
$  <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div><pre><code><span># 写法一</span>
<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法二</span>
<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法三</span>
<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="判断表达式"> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断"> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>FILE</span><span>=~</span>/.bashrc

<span>if</span> <span>[</span> -e <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span> -f <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a regular file."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -d <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a directory."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -r <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is readable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -w <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is writable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -x <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is executable/searchable."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span>$FILE</span> does not exist"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>
<h3 id="字符串判断"> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>ANSWER</span><span>=</span>maybe

<span>if</span> <span>[</span> -z <span>"<span>$ANSWER</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"There is no answer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"yes"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is YES."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"no"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is NO."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"maybe"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is MAYBE."</span>
<span>else</span>
  <span>echo</span> <span>"The answer is UNKNOWN."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>
<h3 id="整数判断"> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span> -z <span>"<span>$INT</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is empty."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is zero."</span>
<span>else</span>
  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is negative."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is positive."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is even."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is odd."</span>
  <span>fi</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断"> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div><pre><code><span>[</span><span>[</span> string1 <span>=~</span> regex <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is an integer."</span>
  <span>exit</span> <span>0</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算"> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>MIN_VAL</span><span>=</span><span>1</span>
<span>MAX_VAL</span><span>=</span><span>100</span>

<span>INT</span><span>=</span><span>50</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is out of range."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
<span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is in range."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断"> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>fi</span>
It is true.
$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>else</span> <span>echo</span> <span>"it is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"foo is <span>$foo</span>"</span><span>;</span> <span>fi</span>
foo is <span>5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span><span>else</span> <span>echo</span> <span>"It is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is zero."</span>
  <span>else</span>
    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is negative."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is positive."</span>
    <span>fi</span>
    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is even."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is odd."</span>
    <span>fi</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="./arithmetic.html">Bash 的算术运算</a> 一章。</p>
<h3 id="普通命令的逻辑运算"> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
command1 <span>||</span> command2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>
  <span>command</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个示例。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>filename</span><span>=</span><span>$1</span>
<span>word1</span><span>=</span><span>$2</span>
<span>word2</span><span>=</span><span>$3</span>

<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>
<span>then</span>
  <span>echo</span> <span>"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>"<span>$dir_name</span>"</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 等同于</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"No such directory: '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>cd</span> <span>"<span>$dir_name</span>"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Cannot cd to '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>
  <span>echo</span> <span>"File deletion failed. Check results"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="case-结构"> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div><pre><code><span>case</span> expression <span>in</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  <span>..</span>.
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>
    <span>;</span><span>;</span>
  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>
    <span>;</span><span>;</span>
  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>
    <span>;</span><span>;</span>
  * <span>)</span> <span>echo</span> 输入不符合要求
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>

<span>case</span> <span>"<span>$OS</span>"</span> <span>in</span>
  FreeBSD<span>)</span> <span>echo</span> <span>"This is FreeBSD"</span> <span>;</span><span>;</span>
  Darwin<span>)</span> <span>echo</span> <span>"This is Mac OSX"</span> <span>;</span><span>;</span>
  AIX<span>)</span> <span>echo</span> <span>"This is AIX"</span> <span>;</span><span>;</span>
  Minix<span>)</span> <span>echo</span> <span>"This is Minix"</span> <span>;</span><span>;</span>
  Linux<span>)</span> <span>echo</span> <span>"This is Linux"</span> <span>;</span><span>;</span>
  *<span>)</span> <span>echo</span> <span>"Failed to identify this OS"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个字母或数字 > "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>"输入了字母 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>"输入了数字 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  * <span>)</span>                         <span>echo</span> <span>"输入不符合要求"</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>read</span> -n <span>1</span> -p <span>"Type a character > "</span>
<span>echo</span>
<span>case</span> <span>$REPLY</span> <span>in</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is upper case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is lower case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is alphabetic."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a digit."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a visible character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a punctuation symbol."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a whitespace character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>"'<span>$REPLY</span>' is a hexadecimal digit."</span> <span>;</span><span>;</span><span>&amp;</span>
<span>esac</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div><pre><code>$ test.sh
Type a character <span>></span> a
<span>'a'</span> is lower case.
<span>'a'</span> is alphabetic.
<span>'a'</span> is a visible character.
<span>'a'</span> is a hexadecimal digit.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line<i>Content not supported</i></a>, William Shotts</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>脚本除错</title>
      <link>https://list-jiang.github.io/code/linux/bash/debug/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/debug/</guid>
      <source url="https://list-jiang.github.io/rss.xml">脚本除错</source>
      <description>本章介绍如何对 Shell 脚本除错。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>

<h2 id="常见错误"> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>dir_name</span><span>=</span>/path/not/exist

<span>cd</span> <span>$dir_name</span>
<span>rm</span> *
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-的-x-参数"> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div><pre><code><span># script.sh</span>
<span>echo</span> hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div><pre><code>$ <span>bash</span> -x script.sh
+ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div><pre><code><span>#! /bin/bash -x</span>
<span># trouble: script to demonstrate common errors</span>

<span>number</span><span>=</span><span>1</span>
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number is equal to 1."</span>
<span>else</span>
  <span>echo</span> <span>"Number is not equal to 1."</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div><pre><code>$ trouble
+ <span>number</span><span>=</span><span>1</span>
+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
+ <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'$LINENO + '</span>
$ trouble
<span>5</span> + <span>number</span><span>=</span><span>1</span>
<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="./set.html">set 命令</a> 一章。</p>
<h2 id="环境变量"> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno"> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"This is line <span>$LINENO</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div><pre><code>$ ./test.sh
This is line <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="funcname"> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>

<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div><pre><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3 id="bash-source"> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3 id="bash-lineno"> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>

  func2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: <span>BASH_LINENO</span> is <span>7</span>
func1: FUNCNAME is func1
func1: <span>BASH_SOURCE</span> is main.sh
func2: <span>BASH_LINENO</span> is <span>8</span>
func2: FUNCNAME is func2
func2: <span>BASH_SOURCE</span> is lib1.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的模式扩展</title>
      <link>https://list-jiang.github.io/code/linux/bash/expansion/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/expansion/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 的模式扩展</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介"> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div><pre><code>$ <span>set</span> -o noglob
<span># 或者</span>
$ <span>set</span> -f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面的命令可以重新打开扩展。</p>
<div><pre><code>$ <span>set</span> +o noglob
<span># 或者</span>
$ <span>set</span> +f
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="波浪线扩展"> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div><pre><code>$ <span>echo</span> ~
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div><pre><code><span># 进入 /home/me/foo 目录</span>
$ <span>cd</span> ~/foo
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div><pre><code>$ <span>echo</span> ~foo
/home/foo

$ <span>echo</span> ~root
/root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div><pre><code>$ <span>echo</span> ~nonExistedUser
~nonExistedUser
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div><pre><code>$ <span>cd</span> ~/foo
$ <span>echo</span> ~+
/home/me/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="字符扩展"> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> ?.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> ??.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div><pre><code><span># 当前目录有 a.txt 文件</span>
$ <span>echo</span> ?.txt
a.txt

<span># 当前目录为空目录</span>
$ <span>echo</span> ?.txt
?.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2 id="字符扩展-2"> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> *.txt
a.txt b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div><pre><code><span>ls</span> *
</code></pre>
<div><span>1</span><br></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> a*.txt
a.txt ab.txt

$ <span>ls</span> *b*
b.txt ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div><pre><code><span># 显示所有隐藏文件</span>
$ <span>echo</span> .*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div><pre><code><span># 当前目录不存在 c 开头的文件</span>
$ <span>echo</span> c*.txt
c*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div><pre><code><span># 子目录有一个 a.txt</span>
<span># 无效的写法</span>
$ <span>ls</span> *.txt

<span># 有效的写法</span>
$ <span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2 id="方括号扩展"> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt b.txt

<span># 只存在文件 a.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
ls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>
$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?
aba bbb
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展"> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt
a.txt
b.txt
c.txt

<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt
report1.txt
report2.txt
report3.txt
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt
report4.txt report5.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2 id="大括号扩展"> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>
<span>1</span> <span>2</span> <span>3</span>

$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g
dag deg <span>dig</span> dug dog

$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt
ls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>
<span>{</span><span>1</span> , <span>2</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>

<span># 等同于</span>
<span># cp a.log a.log.bak</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>大括号可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>
jpg jpeg png

$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b
aA1b aA2b aB3b aB4b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>
<span>cat</span> dawg dg <span>dig</span> dog doug dug
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>
<span>cat</span> dog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div><pre><code><span># 不存在 a.txt 和 b.txt</span>
$ <span>echo</span> <span>[</span>ab<span>]</span>.txt
<span>[</span>ab<span>]</span>.txt

$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt
a.txt b.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2 id="start-end-扩展-2"> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>
a b c

$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g
dag dbg dcg ddg

$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span>

$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这种简写形式支持逆序。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>
c b a

$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>
<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>
<span>{</span>a1<span>..</span>3c<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>
01 02 03 04 05

$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>
001 002 003 004 005
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>
<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="变量扩展"> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="./variable.html">Bash 变量</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>
<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2 id="子命令扩展"> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展"> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="./arithmetic.html">Bash 的算术运算</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="字符类"> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div><pre><code><span># 不存在以大写字母开头的文件</span>
$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点"> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div><pre><code>$ <span>ls</span> a*.txt
ab.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div><pre><code><span># 不存在 r 开头的文件名</span>
$ <span>echo</span> r*
r*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div><pre><code>$ <span>ls</span> *.csv
ls: *.csv: No such <span>file</span> or directory
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div><pre><code><span>ls</span> */*.txt
</code></pre>
<div><span>1</span><br></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div><pre><code>$ <span>touch</span> <span>'fo*'</span>
$ <span>ls</span>
fo*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2 id="量词语法"> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt
abctxt abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>
abc abcdef
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>
abc.php abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>
abc.txt abc.txt.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div><pre><code><span># 没有 abc 开头的文件名</span>
$ <span>ls</span> abc?<span>(</span>def<span>)</span>
ls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div><pre><code><span># 打开某个参数</span>
$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>

<span># 关闭某个参数</span>
$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>

<span># 查询某个参数关闭还是打开</span>
$ <span>shopt</span> <span>[</span>optionname<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div><pre><code>$ <span>ls</span> *
abc.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div><pre><code>$ <span>shopt</span> -s dotglob
$ <span>ls</span> *
abc.txt .config
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div><pre><code>$ <span>rm</span> b*
rm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div><pre><code>$ <span>shopt</span> -s nullglob
$ <span>rm</span> b*
rm: 缺少操作数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div><pre><code>$ <span>shopt</span> -s failglob
$ <span>rm</span> b*
bash: 无匹配: b*
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div><pre><code><span>shopt</span> -u extglob
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div><pre><code>$ <span>shopt</span> -s nocaseglob
$ <span>ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span>(</span>x86<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div><pre><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div><pre><code>$ <span>shopt</span> -s globstar
$ <span>ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again<i>Content not supported</i></a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 函数</title>
      <link>https://list-jiang.github.io/code/linux/bash/function/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/function/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 函数</source>
      <description>本章介绍 Bash 函数的用法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 函数的用法。</p>

<h2 id="简介"> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div><pre><code><span># 第一种</span>
<span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>

<span># 第二种</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"Hello <span>$1</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div><pre><code>$ hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> -n <span>"Today's date is: "</span>
  <span>date</span> +<span>"%A, %B %-d, %Y"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div><pre><code><span>unset</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div><pre><code><span>declare</span> -f
</code></pre>
<div><span>1</span><br></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div><pre><code><span>declare</span> -f functionName
</code></pre>
<div><span>1</span><br></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div><pre><code><span>declare</span> -F
</code></pre>
<div><span>1</span><br></div></div><h2 id="参数变量"> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>function</span> <span>alice</span> <span>{</span>
  <span>echo</span> <span>"alice: <span>$@</span>"</span>
  <span>echo</span> <span>"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>"</span>
  <span>echo</span> <span>"<span>$#</span> arguments"</span>

<span>}</span>

alice <span>in</span> wonderland
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>运行该脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
alice: <span>in</span> wonderland
test.sh: <span>in</span> wonderland
<span>2</span> arguments
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用方法如下。</p>
<div><pre><code>$ log_msg <span>"This is sample log message"</span>
<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="return-命令"> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>
  <span>return</span> <span>10</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div><pre><code>$ func_return_value
$ <span>echo</span> <span>"Value returned by function is: <span>$?</span>"</span>
Value returned by <span>function</span> is: <span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div><pre><code><span>function</span> <span>name</span> <span>{</span>
  commands
  <span>return</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="全局变量和局部变量-local-命令"> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div><pre><code><span>foo</span><span>=</span><span>1</span>

<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>2</span>
<span>}</span>

<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>local</span> foo
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script<i>Content not supported</i></a>, by Pradeep Kumar</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的基本语法</title>
      <link>https://list-jiang.github.io/code/linux/bash/grammar/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/grammar/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 的基本语法</source>
      <description>本章介绍 Bash 的最基本语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>

<h2 id="echo-命令"> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div><pre><code>$ <span>echo</span> hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div><pre><code>$ <span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3 id="n-参数"> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div><pre><code>$ <span>echo</span> -n hello world
hello world$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b
a
b

$ <span>echo</span> -n a<span>;</span><span>echo</span> b
ab
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3 id="e-参数"> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div><pre><code>$ <span>echo</span> <span>"Hello<span title="\n">\n</span>World"</span>
Hello<span>\</span>nWorld

<span># 双引号的情况</span>
$ <span>echo</span> -e <span>"Hello<span title="\n">\n</span>World"</span>
Hello
World

<span># 单引号的情况</span>
$ <span>echo</span> -e <span>'Hello\nWorld'</span>
Hello
World
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式"> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div><pre><code><span>ls</span> -l
</code></pre>
<div><span>1</span><br></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div><pre><code><span># 短形式</span>
$ <span>ls</span> -r

<span># 长形式</span>
$ <span>ls</span> --reverse
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div><pre><code>$ <span>echo</span> foo bar

<span># 等同于</span>
$ <span>echo</span> foo <span>\</span>
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="空格"> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div><pre><code><span>command</span> foo bar
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div><pre><code>$ <span>echo</span> this is a     <span>test</span>
this is a <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号"> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div><pre><code><span>clear</span><span>;</span> <span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-和"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div><pre><code>Command1 <span>&amp;&amp;</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div><pre><code>Command1 <span>||</span> Command2
</code></pre>
<div><span>1</span><br></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2 id="type-命令"> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div><pre><code>$ <span>type</span> <span>echo</span>
<span>echo</span> is a shell <span>builtin</span>
$ <span>type</span> <span>ls</span>
<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div><pre><code>$ <span>type</span> -a <span>echo</span>
<span>echo</span> is shell <span>builtin</span>
<span>echo</span> is /usr/bin/echo
<span>echo</span> is /bin/echo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div><pre><code>$ <span>type</span> -t <span>bash</span>
<span>file</span>
$ <span>type</span> -t <span>if</span>
keyword
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2 id="快捷键"> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="./readline.html">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 简介</title>
      <link>https://list-jiang.github.io/code/linux/bash/intro/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/intro/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 简介</source>
      <description>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>

<h2 id="shell-的含义"> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell-的种类"> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div><pre><code><span>cat</span> /etc/shells
</code></pre>
<div><span>1</span><br></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境"> 命令行环境</h2>
<h3 id="终端模拟器"> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符"> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div><pre><code><span>[</span>user@hostname<span>]</span> $
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3 id="进入和退出方法"> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div><pre><code><span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div><pre><code>$ <span>pwd</span>
/home/me
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div><pre><code>$ pwe
bash: pwe: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="shell-和-bash-的历史"> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div><pre><code>$ <span>bash</span> --version
GNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>

<span># 或者</span>
$ <span>echo</span> <span>$BASH_VERSION</span>
<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>循环</title>
      <link>https://list-jiang.github.io/code/linux/bash/loop/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/loop/</guid>
      <source url="https://list-jiang.github.io/rss.xml">循环</source>
      <description>Bash 提供三种循环语法 for、while 和 until。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>

<h2 id="while-循环"> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2 id="until-循环"> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div><pre><code><span>until</span> condition
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
^C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>until</span> <span>[</span> <span>"<span>$number</span>"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2 id="for-in-循环"> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>
  <span>ls</span> -l <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>count</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>
  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>
  <span>echo</span> <span>"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>

<span># 等同于</span>

<span>for</span> <span>filename</span> <span>in</span> <span>"<span>$@</span>"</span> <span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2 id="for-循环"> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div><pre><code><span><span>((</span> expression1 <span>))</span></span>
<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>
  commands
  <span><span>((</span> expression3 <span>))</span></span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>
<span>do</span>
  <span>read</span> var
  <span>if</span> <span>[</span> <span>"<span>$var</span>"</span> <span>=</span> <span>"."</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2 id="break-continue"> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>
<span>do</span>
  <span>echo</span> <span>"number is <span>$number</span>"</span>
  <span>if</span> <span>[</span> <span>"<span>$number</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>read</span> -p <span>"What file do you want to test?"</span> filename
<span>do</span>
  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"The file does not exist."</span>
    <span>continue</span>
  <span>fi</span>

  <span>echo</span> <span>"You entered a valid file.."</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2 id="select-结构"> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div><pre><code><span>select</span> name
<span>[</span>in list<span>]</span>
<span>do</span>
  commands
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># select.sh</span>

<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton
<span>do</span>
  <span>echo</span> <span>"You have chosen <span>$brand</span>"</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div><pre><code>$ ./select.sh
<span>1</span><span>)</span> Samsung
<span>2</span><span>)</span> Sony
<span>3</span><span>)</span> iphone
<span>4</span><span>)</span> symphony
<span>5</span><span>)</span> Walton
<span>#?</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Which Operating System do you like?"</span>

<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span>do</span>
  <span>case</span> <span>$os</span> <span>in</span>
    <span>"Ubuntu"</span><span>|</span><span>"LinuxMint"</span><span>)</span>
      <span>echo</span> <span>"I also use <span>$os</span>."</span>
    <span>;</span><span>;</span>
    <span>"Windows8"</span> <span>|</span> <span>"Windows10"</span> <span>|</span> <span>"WindowsXP"</span><span>)</span>
      <span>echo</span> <span>"Why don't you try Linux?"</span>
    <span>;</span><span>;</span>
    *<span>)</span>
      <span>echo</span> <span>"Invalid entry."</span>
      <span>break</span>
    <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command<i>Content not supported</i></a>, Fahmida Yesmin</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>mktemp 命令，trap 命令</title>
      <link>https://list-jiang.github.io/code/linux/bash/mktemp/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/mktemp/</guid>
      <source url="https://list-jiang.github.io/rss.xml">mktemp 命令，trap 命令</source>
      <description>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 /tmp 目录里面创建文件或目录，这样做有很多弊端，使用 mktemp 命令是最安全的做法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>

<h2 id="临时文件的安全问题"> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div><pre><code>$ <span>touch</span> /tmp/info.txt
$ <span>ls</span> -l /tmp/info.txt
-rw-r--r-- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>17</span>:12 /tmp/info.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法"> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div><pre><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span>ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="mktemp-命令的参数"> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div><pre><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div><pre><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div><pre><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="trap-命令"> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div><pre><code>$ <span>trap</span> -l
 <span>1</span><span>)</span> SIGHUP  <span>2</span><span>)</span> SIGINT  <span>3</span><span>)</span> SIGQUIT  <span>4</span><span>)</span> SIGILL  <span>5</span><span>)</span> SIGTRAP
 <span>6</span><span>)</span> SIGABRT  <span>7</span><span>)</span> SIGBUS  <span>8</span><span>)</span> SIGFPE  <span>9</span><span>)</span> SIGKILL <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV <span>12</span><span>)</span> SIGUSR2 <span>13</span><span>)</span> SIGPIPE <span>14</span><span>)</span> SIGALRM <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT <span>17</span><span>)</span> SIGCHLD <span>18</span><span>)</span> SIGCONT <span>19</span><span>)</span> SIGSTOP <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN <span>22</span><span>)</span> SIGTTOU <span>23</span><span>)</span> SIGURG <span>24</span><span>)</span> SIGXCPU <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM <span>27</span><span>)</span> SIGPROF <span>28</span><span>)</span> SIGWINCH <span>29</span><span>)</span> SIGIO <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS <span>34</span><span>)</span> SIGRTMIN <span>35</span><span>)</span> SIGRTMIN+1 <span>36</span><span>)</span> SIGRTMIN+2 <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4 <span>39</span><span>)</span> SIGRTMIN+5 <span>40</span><span>)</span> SIGRTMIN+6 <span>41</span><span>)</span> SIGRTMIN+7 <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9 <span>44</span><span>)</span> SIGRTMIN+10 <span>45</span><span>)</span> SIGRTMIN+11 <span>46</span><span>)</span> SIGRTMIN+12 <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14 <span>49</span><span>)</span> SIGRTMIN+15 <span>50</span><span>)</span> SIGRTMAX-14 <span>51</span><span>)</span> SIGRTMAX-13 <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11 <span>54</span><span>)</span> SIGRTMAX-10 <span>55</span><span>)</span> SIGRTMAX-9 <span>56</span><span>)</span> SIGRTMAX-8 <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 <span>59</span><span>)</span> SIGRTMAX-5 <span>60</span><span>)</span> SIGRTMAX-4 <span>61</span><span>)</span> SIGRTMAX-3 <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1 <span>64</span><span>)</span> SIGRTMAX
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><code>trap</code> 的命令格式如下。</p>
<div><pre><code><span>trap</span> <span>[</span>动作<span>]</span> <span>[</span>信号1<span>]</span> <span>[</span>信号2<span>]</span> <span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div><pre><code><span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>ls</span> /etc <span>></span> <span>$TMPFILE</span>
<span>if</span> <span>grep</span> -qi <span>"kernel"</span> <span>$TMPFILE</span><span>;</span> <span>then</span>
  <span>echo</span> <span>'find'</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div><pre><code><span>function</span> <span>egress</span> <span>{</span>
  command1
  command2
  command3
<span>}</span>

<span>trap</span> egress EXIT
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts<i>Content not supported</i></a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly<i>Content not supported</i></a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令提示符</title>
      <link>https://list-jiang.github.io/code/linux/bash/prompt/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/prompt/</guid>
      <source url="https://list-jiang.github.io/rss.xml">命令提示符</source>
      <description>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>

<h2 id="环境变量-ps1"> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div><pre><code><span>echo</span> <span>$PS1</span>
</code></pre>
<div><span>1</span><br></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div><pre><code><span>[</span>user@host ~<span>]</span>$ <span>echo</span> <span>$PS1</span>
<span>[</span><span>\</span>u@<span>\</span>h <span>\</span>W<span>]</span><span>\</span>$
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div><pre><code>$ <span><span>PS1</span></span><span>=</span><span>"\A \h \$ "</span>
<span>17</span>:33 <span>host</span> $
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色"> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$'</span>
</code></pre>
<div><span>1</span><br></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$\[\033[00m\]'</span>
</code></pre>
<div><span>1</span><br></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;41m\]&lt;\u@\h \W>\$\[\033[0m\] '</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="环境变量-ps2-ps3-ps4"> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
> world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"hello world"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div><pre><code>$ <span>bash</span> -x test.sh
+ <span>echo</span> <span>'hello world'</span>
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>引号和转义</title>
      <link>https://list-jiang.github.io/code/linux/bash/quotation/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/quotation/</guid>
      <source url="https://list-jiang.github.io/rss.xml">引号和转义</source>
      <description>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>

<h2 id="转义"> 转义</h2>
<p>某些字符在 Bash 里面有特殊含义(比如<code>$</code>、<code>&amp;</code>、<code>*</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>$date</span>

$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，输出 <code>$date</code> 不会有任何结果，因为 <code>$</code> 是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”(escape)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>$date</span>
<span>$date</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面命令中，只有在特殊字符 <code>$</code> 前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线 (<code>\\</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>\</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>: 响铃</li>
<li><code>\b</code>: 退格</li>
<li><code>\n</code>: 换行</li>
<li><code>\r</code>: 回车</li>
<li><code>\t</code>: 制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<div><pre><code>$ <span>echo</span> a<span>\</span>tb
atb

$ <span>echo</span> -e <span>"a<span title="\t">\t</span>b"</span>
a        b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div><pre><code>$ <span>mv</span> <span>\</span>
/path/to/foo <span>\</span>
/path/to/bar

<span># 等同于</span>
$ <span>mv</span> /path/to/foo /path/to/bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号"> 单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号 (<code>*</code>)、美元符号( <code>$</code>)、反斜杠 (<code>\</code>)等。</p>
<div><pre><code>$ <span>echo</span> <span>'*'</span>
*

$ <span>echo</span> <span>'$USER'</span>
<span>$USER</span>

$ <span>echo</span> <span>'$((2+2))'</span>
<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>

$ <span>echo</span> <span>'$(echo foo)'</span>
<span><span>$(</span><span>echo</span> foo<span>)</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号 (<code>$</code>)，然后再对里层的单引号转义。</p>
<div><pre><code><span># 不正确</span>
$ <span>echo</span> it<span>'s

# 不正确
$ echo '</span>it<span>\</span>'s<span>'

# 正确
$ echo $'</span>it<span>\</span>'s'
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div><pre><code>$ <span>echo</span> <span>"it's"</span>
it's
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="双引号"> 双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外: 美元符号(<code>$</code>)、反引号(<code>`</code>)和反斜杠(<code>\</code>)。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"*"</span>
*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，通配符 <code>*</code> 放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"<span>$SHELL</span>"</span>
/bin/bash

$ <span>echo</span> <span>"<span><span>`</span><span>date</span><span>`</span></span>"</span>
Mon Jan <span>27</span> <span>13</span>:33:18 CST <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div><pre><code>$ <span>echo</span> <span>"I'd say: <span title="\&quot;">\"</span>hello!<span title="\&quot;">\"</span>"</span>
I'd say: <span>"hello!"</span>

$ <span>echo</span> <span>"<span title="\\">\\</span>"</span>
<span>\</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
world"</span>
hello
world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code> 命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div><pre><code><span>ls</span> <span>"two words.txt"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>two words.txt</code> 是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div><pre><code>$ <span>echo</span> <span>"this is a     test"</span>
this is a     <span>test</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div><pre><code><span># 单行输出</span>
$ <span>echo</span> <span><span>$(</span><span>cal</span><span>)</span></span>
一月 <span>2020</span> 日 一 二 三 四 五 六 <span>1</span> <span>2</span> <span>3</span> <span>..</span>. <span>31</span>

<span># 原始格式输出</span>
$ <span>echo</span> <span>"<span><span>$(</span><span>cal</span><span>)</span></span>"</span>
      一月 <span>2020</span>
日 一 二 三 四 五 六
          <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>
 <span>5</span>  <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span>
<span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span>
<span>19</span> <span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span>
<span>26</span> <span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面例子中，如果 <code>$(cal)</code> 不放在双引号之中，<code>echo</code> 就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here-文档"> Here 文档</h2>
<p>Here 文档(here document)是一种输入多行字符串的方法，格式如下。</p>
<div><pre><code><span>&lt;&lt;</span> <span>token
text
token</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>它的格式分成开始标记(<code>&lt;&lt; token</code>)和结束标记(<code>token</code>)。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>_example_
<span>$foo</span>
"<span>$foo</span>"
'<span>$foo</span>'
_example_</span>

hello world
<span>"hello world"</span>
<span>'hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span>$foo</span>
<span>"<span>$foo</span>"</span>
<span>'$foo'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面例子中，Here 文档的开始标记(<code>_example_</code>)放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>command</span> <span>&lt;&lt;</span> <span>token
  string
token</span>

<span># 等同于</span>

$ <span>echo</span> string <span>|</span> <span>command</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面代码中，Here 文档相当于 <code>echo</code> 命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如 <code>echo</code> 命令就不能用 Here 文档作为参数。</p>
<div><pre><code>$ <span>echo</span> <span>&lt;&lt;</span> <span>_example_
hello
_example_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子不会有任何输出，因为 Here 文档对于 <code>echo</code> 命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here-字符串"> Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串(Here string)，使用三个小于号(<code>&lt;&lt;&lt;</code>)表示。</p>
<div><pre><code><span>&lt;&lt;&lt;</span> string
</code></pre>
<div><span>1</span><br></div></div><p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 <code>cat</code> 命令只接受标准输入传入的字符串。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;&lt;</span> <span>'hi there'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'hi there'</span> <span>|</span> <span>cat</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div><pre><code>$ md5sum <span>&lt;&lt;&lt;</span> <span>'ddd'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'ddd'</span> <span>|</span> md5sum
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，<code>md5sum</code> 命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即 <code>md5sum ddd</code> 里面的 <code>ddd</code> 会被解释成文件名。这时就可以用 Here 字符串，将字符串传给 <code>md5sum</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>read 命令</title>
      <link>https://list-jiang.github.io/code/linux/bash/read/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/read/</guid>
      <source url="https://list-jiang.github.io/rss.xml">read 命令</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="用法"> 用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用 <code>read</code> 命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code> 命令的格式如下。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法中，<code>options</code> 是参数选项，<code>variable</code> 是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>下面是一个例子 <code>demo.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>read</span> text
<span>echo</span> <span>"您的输入: <span>$text</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量 <code>text</code>，在下一行显示出来。</p>
<div><pre><code>$ <span>bash</span> demo.sh
输入一些文本 <span>></span> 您好，世界
您的输入: 您好，世界
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 可以接受用户输入的多个值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> Please, enter your firstname and lastname
<span>read</span> FN LN
<span>echo</span> <span>"Hi! <span>$LN</span>, <span>$FN</span> !"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，<code>read</code> 根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于 <code>read</code> 命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果 <code>read</code> 命令之后没有定义变量名，那么环境变量 <code>REPLY</code> 会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>read</code> 命令除了读取键盘输入，可以用来读取文件。</p>
<div><pre><code><span>while</span> <span>read</span> myline
<span>do</span>
  <span>echo</span> <span>"<span>$myline</span>"</span>
<span>done</span> <span>&lt;</span> <span>$filename</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子通过 <code>read</code> 命令，读取一个文件的内容。<code>done</code> 命令后面的定向符 <code>&lt;</code>，将文件导向 <code>read</code> 命令，每次读取一行，存入变量 <code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数"> 参数</h2>
<p><code>read</code> 命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-t</code> 参数</strong></p>
<p><code>read</code> 命令的 <code>-t</code> 参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>if</span> <span>read</span> -t <span>3</span> response<span>;</span> <span>then</span>
  <span>echo</span> <span>"用户已经输入了"</span>
<span>else</span>
  <span>echo</span> <span>"用户没有输入"</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code> 根据命令的返回值，转入 <code>else</code> 代码块，继续往下执行。</p>
<p>环境变量 <code>TMOUT</code> 也可以起到同样作用，指定 <code>read</code> 命令等待用户输入的时间(单位为秒)。</p>
<div><pre><code><span>TMOUT</span><span>=</span><span>3</span>
<span>read</span> response
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子也是等待 3 秒，如果用户还没有输入，就会超时。</p>
</li>
<li>
<p><strong><code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数指定用户输入的提示信息。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，先显示 <code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
</li>
<li>
<p><strong><code>-a</code> 参数</strong></p>
<p><code>-a</code> 参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div><pre><code>$ <span>read</span> -a people
alice duchess dodo
$ <span>echo</span> <span>${people<span>[</span>2<span>]</span>}</span>
dodo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，用户输入被赋值给一个数组 <code>people</code>，这个数组的 2 号成员就是 <code>dodo</code>。</p>
</li>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div><pre><code>$ <span>read</span> -n <span>3</span> letter
abcdefghij
$ <span>echo</span> <span>$letter</span>
abc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，变量 <code>letter</code> 只包含 3 个字母。</p>
</li>
<li>
<p><strong>-e 参数</strong></p>
<p><code>-e</code> 参数允许用户输入的时候，使用 <code>readline</code> 库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> Please input the path to the file:

<span>read</span> -e fileName

<span>echo</span> <span>$fileName</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>read</code> 命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是 <code>read</code> 命令的输入默认不支持 <code>readline</code> 库的功能。<code>-e</code> 参数就可以允许用户使用自动补全。</p>
</li>
<li>
<p><strong>其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>: 定义字符串 <code>delimiter</code> 的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>: raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>: 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>: 使用文件描述符 <code>fd</code> 作为输入。</li>
</ul>
</li>
</ol>
<h2 id="ifs-变量"> IFS 变量</h2>
<p><code>read</code> 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 <code>IFS</code>(内部字段分隔符，Internal Field Separator 的缩写)，修改分隔标志。</p>
<p><code>IFS</code> 的默认值是空格、Tab 符号、换行符号，通常取第一个(即空格)。</p>
<p>如果把 <code>IFS</code> 定义成冒号(<code>:</code>)或分号(<code>;</code>)，就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>

<span>FILE</span><span>=</span>/etc/passwd

<span>read</span> -p <span>"Enter a username > "</span> user_name
<span>file_info</span><span>=</span><span>"<span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>"</span>

<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
  <span>echo</span> <span>"User = '<span>$user</span>'"</span>
  <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
  <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
  <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
  <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
  <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
  <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>上面例子中，<code>IFS</code> 设为冒号，然后用来分解 <code>/etc/passwd</code> 文件的一行。<code>IFS</code> 的赋值命令和 <code>read</code> 命令写在一行，这样的话，<code>IFS</code> 的改变仅对后面的命令生效，该命令执行后 <code>IFS</code> 会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div><pre><code><span>OLD_IFS</span><span>=</span><span>"<span>$IFS</span>"</span>
<span><span>IFS</span></span><span>=</span><span>":"</span>
<span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
<span><span>IFS</span></span><span>=</span><span>"<span>$OLD_IFS</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>另外，上面例子中，<code>&lt;&lt;&lt;</code> 是 Here 字符串，用于将变量值转为标准输入，因为 <code>read</code> 命令只能解析标准输入。</p>
<p>如果 <code>IFS</code> 设为空字符串，就等同于将整行读入一个变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>input</span><span>=</span><span>"/path/to/txt/file"</span>
<span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r line
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>
<span>done</span> <span>&lt;</span> <span>"<span>$input</span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的命令可以逐行读取文件，每一行存入变量 <code>line</code>，打印出来以后再读取下一行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 行操作</title>
      <link>https://list-jiang.github.io/code/linux/bash/readline/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/readline/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 行操作</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介"> 简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div><pre><code><span>set</span> -o <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面的命令可以改回 Emacs 快捷键。</p>
<div><pre><code><span>set</span> -o emacs
</code></pre>
<div><span>1</span><br></div></div><p>如果想永久性更改编辑模式(Emacs / Vi)，可以将命令写在 <code>~/.inputrc</code> 文件，这个文件是 Readline 的配置文件。</p>
<div><pre><code><span>set</span> editing-mode <span>vi</span>
</code></pre>
<div><span>1</span><br></div></div><p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div><pre><code><span>bash</span> --noediting
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>--noediting</code> 参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动"> 光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>: 移到行首。</li>
<li><code>Ctrl + b</code>: 向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>: 移到行尾。</li>
<li><code>Ctrl + f</code>: 向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>: 移动到当前单词的词尾。</li>
<li><code>Alt + b</code>: 移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕"> 清除屏幕</h2>
<p><code>Ctrl + l</code> 快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与 <code>clear</code> 命令作用相同。</p>
<h2 id="编辑操作"> 编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>: 删除光标位置的字符(delete)。</li>
<li><code>Ctrl + w</code>: 删除光标前面的单词。</li>
<li><code>Ctrl + t</code>: 光标位置的字符与它前面一位的字符交换位置(transpose)。</li>
<li><code>Alt + t</code>: 光标位置的词与它前面一位的词交换位置(transpose)。</li>
<li><code>Alt + l</code>: 将光标位置至词尾转为小写(lowercase)。</li>
<li><code>Alt + u</code>: 将光标位置至词尾转为大写(uppercase)。</li>
</ul>
<p>使用 <code>Ctrl + d</code> 的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>: 剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>: 剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>: 剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>: 剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>: 在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全"> 自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入 <code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为 <code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以 <code>$</code> 开头，则按下 Tab 键会补全变量；如果以 <code>~</code> 开头，则补全用户名；如果以 <code>@</code> 开头，则补全主机名(hostname)，主机名以列在 <code>/etc/hosts</code> 文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab: 完成自动补全。</li>
<li><code>Alt + ?</code>: 列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>: 尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>: 先按 <code>Ctrl + x</code>，再按 <code>/</code>，等同于 <code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>: 命令补全。</li>
<li><code>Ctrl + x !</code>: 先按 <code>Ctrl + x</code>，再按 <code>!</code>，等同于 <code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>: 用户名补全。</li>
<li><code>Ctrl + x ~</code>: 先按 <code>Ctrl + x</code>，再按 <code>~</code>，等同于 <code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>: 变量名补全。</li>
<li><code>Ctrl + x $</code>: 先按 <code>Ctrl + x</code>，再按 <code>$</code>，等同于 <code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>: 主机名补全。</li>
<li><code>Ctrl + x @</code>: 先按 <code>Ctrl + x</code>，再按 <code>@</code>，等同于 <code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>: 在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>: 尝试用 <code>.bash_history</code> 里面以前执行命令，进行补全。</li>
</ul>
<p>上面的 <code>Alt</code> 键也可以用 ESC 键代替。</p>
<h2 id="操作历史"> 操作历史</h2>
<h3 id="基本用法"> 基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 <code>~/.bash_history</code> 文件，该文件默认储存 500 个操作。</p>
<p>环境变量 <code>HISTFILE</code> 总是指向这个文件。</p>
<div><pre><code>$ <span>echo</span> <span>$HISTFILE</span>
/home/me/.bash_history
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>有了操作历史以后，就可以使用方向键的 <code>↑</code> 和 <code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div><pre><code>$ <span>echo</span> Hello World
Hello World

$ <span>echo</span> Goodbye
Goodbye

$ <span>!</span>e
<span>echo</span> Goodbye
Goodbye
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>!e</code> 表示找出操作历史之中，最近的那一条以 <code>e</code> 开头的命令并执行。Bash 会先输出那一条命令 <code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code> 也会执行最近一条以 <code>echo</code> 开头的命令。</p>
<div><pre><code>$ <span>!</span>echo
<span>echo</span> Goodbye
Goodbye

$ <span>!</span>echo H
<span>echo</span> Goodbye H
Goodbye H

$ <span>!</span>echo H G
<span>echo</span> Goodbye H G
Goodbye H G
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意，<code>!string</code> 语法只会匹配命令，不会匹配参数。所以 <code>!echo H</code> 不会执行 <code>echo Hello World</code>，而是会执行 <code>echo Goodbye</code>，并把参数 <code>H</code> 附加在这条命令之后。同理，<code>!echo H G</code> 也是等同于 <code>echo Goodbye</code> 命令之后附加 <code>H G</code>。</p>
<p>最后，按下 <code>Ctrl + r</code> 会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history-命令"> history 命令</h3>
<p><code>history</code> 命令能显示操作历史，即 <code>.bash_history</code> 文件的内容。</p>
<div><pre><code>$ <span>history</span>
<span>..</span>.
<span>498</span> <span>echo</span> Goodbye
<span>499</span> <span>ls</span> ~
<span>500</span> <span>cd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>使用该命令，而不是直接读取 <code>.bash_history</code> 文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量 <code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div><pre><code>$ <span>export</span> <span>HISTTIMEFORMAT</span><span>=</span><span>'%F %T  '</span>
$ <span>history</span>
<span>1</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>cat</span> /etc/issue
<span>2</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>clear</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>%F</code> 相当于 <code>%Y - %m - %d</code>，<code>%T</code> 相当于 <code>%H : %M : %S</code>。</p>
<p>只要设置 <code>HISTTIMEFORMAT</code> 这个环境变量，就会在 <code>.bash_history</code> 文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量 <code>HISTSIZE</code> 等于 0。</p>
<div><pre><code><span>export</span> <span><span>HISTSIZE</span></span><span>=</span><span>0</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果 <code>HISTSIZE=0</code> 写入用户主目录的 <code>~/.bashrc</code> 文件，那么就不会保留该用户的操作历史。如果写入 <code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合 <code>grep</code> 命令搜索操作历史。</p>
<div><pre><code><span>history</span> <span>|</span> <span>grep</span> /usr/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令返回 <code>.bash_history</code> 文件里面，那些包含 <code>/usr/bin</code> 的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用 <code>感叹号 + 编号</code> 执行该命令。如果想要执行 <code>.bash_history</code> 里面的第 8 条命令，可以像下面这样操作。</p>
<div><pre><code><span>!</span><span>8</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>history</code> 命令的 <code>-c</code> 参数可以清除操作历史。</p>
<div><pre><code><span>history</span> -c
</code></pre>
<div><span>1</span><br></div></div><h3 id="相关快捷键"> 相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>: 显示上一个命令，与向上箭头效果相同(previous)。</li>
<li><code>Ctrl + n</code>: 显示下一个命令，与向下箭头效果相同(next)。</li>
<li><code>Alt + &lt;</code>: 显示第一个命令。</li>
<li><code>Alt + &gt;</code>: 显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>: 执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>: 执行上一个命令。</li>
<li><code>!n</code>: 执行历史文件里面行号为 <code>n</code> 的命令。</li>
<li><code>!-n</code>: 执行当前命令之前 <code>n</code> 条的命令。</li>
<li><code>!string</code>: 执行最近一个以指定字符串 <code>string</code> 开头的命令。</li>
<li><code>!?string</code>: 执行最近一条包含字符串 <code>string</code> 的命令。</li>
<li><code>^string1^string2</code>: 执行最近一条包含 <code>string1</code> 的命令，将其替换成 <code>string2</code>。</li>
</ul>
<h2 id="其他快捷键"> 其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>: 等同于回车键(LINEFEED)。</li>
<li><code>Ctrl + m</code>: 等同于回车键(CARRIAGE RETURN)。</li>
<li><code>Ctrl + o</code>: 等同于回车键，并展示操作历史的下一个命令。</li>
<li><code>Ctrl + v</code>: 将下一个输入的特殊字符变成字面量，比如回车变成 <code>^M</code>。</li>
<li><code>Ctrl + [</code>: 等同于 ESC。</li>
<li><code>Alt + .</code>: 插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>: 等同于 <code>Alt + .</code>。</li>
</ul>
<p>上面的 <code>Alt + .</code> 快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div><pre><code><span>mkdir</span> foo_bar
<span>cd</span> <span>#按下 Alt + .</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，在 <code>cd</code> 命令后按下 <code>Alt + .</code>，就会自动插入 <code>foo_bar</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 教程</title>
      <link>https://list-jiang.github.io/code/linux/bash/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 教程</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./intro.html">简介</a></p>
</li>
<li>
<p><a href="./grammar.html">基本语法</a></p>
</li>
<li>
<p><a href="./expansion.html">模式扩展</a></p>
</li>
<li>
<p><a href="./quotation.html">引号和转义</a></p>
</li>
<li>
<p><a href="./variable.html">变量</a></p>
</li>
<li>
<p><a href="./string.html">字符串操作</a></p>
</li>
<li>
<p><a href="./arithmetic.html">算术运算</a></p>
</li>
<li>
<p><a href="./readline.html">行操作</a></p>
</li>
<li>
<p><a href="./stack.html">目录堆栈</a></p>
</li>
<li>
<p><a href="./script.html">脚本入门</a></p>
</li>
<li>
<p><a href="./read.html">read 命令</a></p>
</li>
<li>
<p><a href="./condition.html">条件判断</a></p>
</li>
<li>
<p><a href="./loop.html">循环</a></p>
</li>
<li>
<p><a href="./function.html">函数</a></p>
</li>
<li>
<p><a href="./array.html">数组</a></p>
</li>
<li>
<p><a href="./set.html">set 命令</a></p>
</li>
<li>
<p><a href="./debug.html">脚本除错</a></p>
</li>
<li>
<p><a href="./mktemp.html">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="./startup.html">启动环境</a></p>
</li>
<li>
<p><a href="./prompt.html">命令提示符</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 脚本入门</title>
      <link>https://list-jiang.github.io/code/linux/bash/script/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/script/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 脚本入门</source>
      <description>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。
脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>

<h2 id="shebang-行"> Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code> 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 <code>/bin/sh</code> 或 <code>/bin/bash</code>。</p>
<div><pre><code><span>#!/bin/sh</span>
<span># 或者</span>
<span>#!/bin/bash</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>#!</code> 与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录 <code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令使用 <code>env</code> 命令(这个命令总是在 <code>/usr/bin</code> 目录)，返回 Bash 可执行文件的位置。<code>env</code> 命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是 <code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div><pre><code>./script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是脚本文件名。脚本通常使用 <code>.sh</code> 后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div><pre><code>$ /bin/sh ./script.sh
<span># 或者</span>
$ <span>bash</span> ./script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="执行权限和路径"> 执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div><pre><code><span># 给所有用户执行权限</span>
$ <span>chmod</span> +x script.sh

<span># 给所有用户读权限和执行权限</span>
$ <span>chmod</span> +rx script.sh
<span># 或者</span>
$ <span>chmod</span> <span>755</span> script.sh

<span># 只给脚本拥有者读权限和执行权限</span>
$ <span>chmod</span> u+rx script.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>脚本的权限通常设为 <code>755</code> (拥有者有所有权限，其他人有读和执行权限)或者 <code>700</code>(只有拥有者可以执行)。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径(比如 <code>path/script.sh</code>)。如果将脚本放在环境变量 <code>$PATH</code> 指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个 <code>~/bin</code> 子目录，专门存放可执行脚本，然后把 <code>~/bin</code> 加入 <code>$PATH</code>。</p>
<div><pre><code><span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:~/bin
</code></pre>
<div><span>1</span><br></div></div><p>上面命令改变环境变量 <code>$PATH</code>，将 <code>~/bin</code> 添加到 <code>$PATH</code> 的末尾。可以将这一行加到 <code>~/.bashrc</code> 文件里面，然后重新加载一次 <code>.bashrc</code>，这个配置就可以生效了。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre>
<div><span>1</span><br></div></div><p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div><pre><code>script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面命令没有指定脚本路径，因为 <code>script.sh</code> 在 <code>$PATH</code> 指定的目录中。</p>
<h2 id="env-命令"> env 命令</h2>
<p><code>env</code> 命令总是指向 <code>/usr/bin/env</code> 文件，或者说，这个二进制文件总是在目录 <code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code> 这个语法的意思是，让 Shell 查找 <code>$PATH</code> 环境变量里面第一个匹配的 <code>NAME</code>。如果您不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code> 的意思就是，返回 <code>bash</code> 可执行文件的位置，前提是 <code>bash</code> 的路径是在 <code>$PATH</code> 里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env node</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>env</code> 命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>: 不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>: 从环境变量中删除一个变量。</li>
<li><code>--help</code>: 显示帮助。</li>
<li><code>--version</code>: 输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div><pre><code><span>env</span> -i /bin/sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="注释"> 注释</h2>
<p>Bash 脚本中，<code>#</code> 表示注释，可以放在行首，也可以放在行尾。</p>
<div><pre><code><span># 本行是注释</span>
<span>echo</span> <span>'Hello World!'</span>

<span>echo</span> <span>'Hello World!'</span> <span># 井号后面的部分也是注释</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数"> 脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div><pre><code>script.sh word1 word2 word3
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，<code>script.sh</code> 是一个脚本文件，<code>word1</code>、<code>word2</code> 和 <code>word3</code> 是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>: 脚本文件名，即 <code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>: 对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>: 参数的总数。</li>
<li><code>$@</code>: 全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 全部的参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>注意，如果命令是 <code>command -o foo bar</code>，那么 <code>-o</code> 是 <code>$1</code>，<code>foo</code> 是 <code>$2</code>，<code>bar</code> 是 <code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># script.sh</span>

<span>echo</span> <span>"全部参数: "</span> <span>$@</span>
<span>echo</span> <span>"命令行参数数量: "</span> <span>$#</span>
<span>echo</span> <span>'$0 = '</span> <span>$0</span>
<span>echo</span> <span>'$1 = '</span> <span>$1</span>
<span>echo</span> <span>'$2 = '</span> <span>$2</span>
<span>echo</span> <span>'$3 = '</span> <span>$3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ ./script.sh a b c
全部参数: a b c
命令行参数数量: <span>3</span>
<span>$0</span> <span>=</span>  script.sh
<span>$1</span> <span>=</span>  a
<span>$2</span> <span>=</span>  b
<span>$3</span> <span>=</span>  c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>用户可以输入任意数量的参数，利用 <code>for</code> 循环，可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>$@</code> 返回一个全部参数的列表，然后使用 <code>for</code> 循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div><pre><code>./script.sh <span>"a b"</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面例子中，Bash 会认为 <code>&quot;a b&quot;</code> 是一个参数，<code>$1</code> 会返回 <code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令"> shift 命令</h2>
<p><code>shift</code> 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数 (<code>$1</code>)，使得后面的参数向前一位，即 <code>$2</code> 变成 <code>$1</code>、<code>$3</code> 变成 <code>$2</code>、<code>$4</code> 变成 <code>$3</code>，以此类推。</p>
<p><code>while</code> 循环结合 <code>shift</code> 命令，也可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"一共输入了 <span>$#</span> 个参数"</span>

<span>while</span> <span>[</span> <span>"<span>$1</span>"</span> <span>!=</span> <span>""</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"剩下 <span>$#</span> 个参数"</span>
  <span>echo</span> <span>"参数: <span>$1</span>"</span>
  <span>shift</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，<code>shift</code> 命令每次移除当前第一个参数，从而通过 <code>while</code> 循环遍历所有参数。</p>
<p><code>shift</code> 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 <code>1</code>。</p>
<div><pre><code><span>shift</span> <span>3</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令移除前三个参数，原来的 <code>$4</code> 变成 <code>$1</code>。</p>
<h2 id="getopts-命令"> getopts 命令</h2>
<p><code>getopts</code> 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 <code>while</code> 循环一起使用，取出脚本所有的带有前置连词线 (<code>-</code>) 的参数。</p>
<div><pre><code><span>getopts</span> optstring name
</code></pre>
<div><span>1</span><br></div></div><p>它带有两个参数。第一个参数 <code>optstring</code> 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 <code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有 <code>-a</code> 可以带有参数值，而 <code>-l</code> 和 <code>-h</code> 是开关参数，那么 <code>getopts</code> 的第一个参数写成 <code>lha:</code>，顺序不重要。注意，<code>a</code> 后面有一个冒号，表示该参数带有参数值，<code>getopts</code> 规定带有参数值的配置项参数，后面必须带有一个冒号 (<code>:</code>)。<code>getopts</code> 的第二个参数 <code>name</code> 是一个变量名，用来保存当前取到的配置项参数，即 <code>l</code>、<code>h</code> 或 <code>a</code>。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>while</span> <span>getopts</span> <span>'lha:'</span> OPTION<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>$OPTION</span>"</span> <span>in</span>
    l<span>)</span>
      <span>echo</span> <span>"linuxconfig"</span>
      <span>;</span><span>;</span>

    h<span>)</span>
      <span>echo</span> <span>"h stands for h"</span>
      <span>;</span><span>;</span>

    a<span>)</span>
      <span>avalue</span><span>=</span><span>"<span>$OPTARG</span>"</span>
      <span>echo</span> <span>"The value provided is <span>$OPTARG</span>"</span>
      <span>;</span><span>;</span>
    ?<span>)</span>
      <span>echo</span> <span>"script usage: <span><span>$(</span><span>basename</span> $0<span>)</span></span> [-l] [-h] [-a somevalue]"</span> <span>></span><span>&amp;2</span>
      <span>exit</span> <span>1</span>
      <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>shift</span> <span>"<span><span>$((</span>$OPTIND <span>-</span> <span>1</span><span>))</span></span>"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>上面例子中，<code>while</code> 循环不断执行 <code>getopts 'lha:' OPTION</code> 命令，每次执行就会读取一个连词线参数(以及对应的参数值)，然后进入循环体。变量 <code>OPTION</code> 保存的是，当前处理的那一个连词线参数(即 <code>l</code>、<code>h</code> 或 <code>a</code>)。如果用户输入了没有指定的参数(比如 <code>-x</code>)，那么 <code>OPTION</code> 等于 <code>?</code>。循环体内使用 <code>case</code> 判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如 <code>-a foo</code>，那么处理 <code>a</code> 参数的时候，环境变量 <code>$OPTARG</code> 保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code> 就会执行失败，从而退出 <code>while</code> 循环。比如，<code>getopts</code> 可以解析 <code>command -l foo</code>，但不可以解析 <code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如 <code>command -lh</code>，<code>getopts</code> 也可以正确处理。</p>
<p>变量 <code>$OPTIND</code> 在 <code>getopts</code> 开始执行前是 <code>1</code>，然后每次执行就会加 <code>1</code>。等到退出 <code>while</code> 循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code> 就是已经处理的连词线参数个数，使用 <code>shift</code> 命令将这些参数移除，保证后面的代码可以用 <code>$1</code>、<code>$2</code> 等处理命令的主参数。</p>
<h2 id="配置项参数终止符"> 配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 <code>--</code>。</p>
<div><pre><code><span>myPath</span><span>=</span><span>"~/docs"</span>
<span>ls</span> -- <span>$myPath</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>--</code> 强制变量 <code>$myPath</code> 只能当作实体参数(即路径名)解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div><pre><code>$ <span>myPath</span><span>=</span><span>"-l"</span>
$ <span>ls</span> -- <span>$myPath</span>
ls: 无法访问<span>'-l'</span><span>:</span> 没有那个文件或目录
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，变量 <code>myPath</code> 的值为 <code>-l</code>，不是路径。但是，<code>--</code> 强制 <code>$myPath</code> 只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="exit-命令"> exit 命令</h2>
<p><code>exit</code> 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div><pre><code><span>exit</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code> 命令后面可以跟参数，该参数就是退出状态。</p>
<div><pre><code><span># 退出值为0(成功)</span>
$ <span>exit</span> <span>0</span>

<span># 退出值为1(失败)</span>
$ <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code> 表示正常，<code>1</code> 表示发生错误，<code>2</code> 表示用法不对，<code>126</code> 表示不是可执行脚本，<code>127</code> 表示命令没有发现。如果脚本被信号 <code>N</code> 终止，则退出值为 <code>128 + N</code>。简单来说，只要退出值非 0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> <span>!=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"根用户才能执行当前脚本"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面的例子中，<code>id -u</code> 命令返回用户的 ID，一旦用户的 ID 不等于 <code>0</code>(根用户的 ID)，脚本就会退出，并且退出码为 <code>1</code>，表示运行失败。</p>
<p><code>exit</code> 与 <code>return</code> 命令的差别是，<code>return</code> 命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code> 是整个脚本的退出，如果在函数之中调用 <code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果"> 命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code> 表示执行成功，非 <code>0</code> (通常是 <code>1</code>)表示执行失败。环境变量 <code>$?</code> 可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div><pre><code><span>cd</span> <span>$some_directory</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"无法切换目录!"</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，<code>cd $some_directory</code> 这个命令如果执行成功(返回值等于 <code>0</code>)，就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 <code>1</code>，表示执行失败。</p>
<p>由于 <code>if</code> 可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div><pre><code><span>if</span> <span>cd</span> <span>$some_directory</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"Could not change directory! Aborting."</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>更简洁的写法是利用两个逻辑运算符 <code>&amp;&amp;</code>(且)和 <code>||</code>(或)。</p>
<div><pre><code><span># 第一步执行成功，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 第一步执行失败，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="source-命令"> source 命令</h2>
<p><code>source</code> 命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div><pre><code><span>source</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><p><code>source</code> 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code> 命令执行脚本时，不需要 <code>export</code> 变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>
<span>echo</span> <span>$foo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面脚本输出 <code>$foo</code> 变量的值。</p>
<div><pre><code><span># 当前 Shell 新建一个变量 foo</span>
$ <span>foo</span><span>=</span><span>1</span>

<span># 打印输出 1</span>
$ <span>source</span> test.sh
<span>1</span>

<span># 打印输出空字符串</span>
$ <span>bash</span> test.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>上面例子中，当前 Shell 的变量 <code>foo</code> 并没有 <code>export</code>，所以直接执行无法读取，但是 <code>source</code> 执行可以读取。</p>
<p><code>source</code> 命令的另一个用途，是在脚本内部加载外部库。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>source</span> ./lib.sh

function_from_lib
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面脚本在内部使用 <code>source</code> 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code> 有一个简写形式，可以使用一个点 (<code>.</code>) 来表示。</p>
<div><pre><code><span>.</span> .bashrc
</code></pre>
<div><span>1</span><br></div></div><h2 id="别名-alias-命令"> 别名，alias 命令</h2>
<p><code>alias</code> 命令用来为一个命令指定别名，这样更便于记忆。下面是 <code>alias</code> 的格式。</p>
<div><pre><code><span>alias</span> <span>NAME</span><span>=</span>DEFINITION
</code></pre>
<div><span>1</span><br></div></div><p>上面命令中，<code>NAME</code> 是别名的名称，<code>DEFINITION</code> 是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为 <code>grep</code> 命令起一个 <code>search</code> 的别名。</p>
<div><pre><code><span>alias</span> <span>search</span><span>=</span>grep
</code></pre>
<div><span>1</span><br></div></div><p><code>alias</code> 也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个 <code>today</code> 的命令。</p>
<div><pre><code>$ <span>alias</span> <span>today</span><span>=</span><span>'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span>6</span>, <span>2020</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>有时为了防止误删除文件，可以指定 <code>rm</code> 命令的别名。</p>
<div><pre><code><span>alias</span> <span>rm</span><span>=</span><span>'rm -i'</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令指定 <code>rm</code> 命令是 <code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code> 定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div><pre><code>$ <span>alias</span> <span>echo</span><span>=</span><span>'echo It says: '</span>
$ <span>echo</span> hello world
It says: hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，别名定义了 <code>echo</code> 命令的前两个参数，等同于修改了 <code>echo</code> 命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在 <code>~/.bashrc</code> 的末尾。另外，只能为命令定义别名，为其他部分(比如很长的路径)定义别名是无效的。</p>
<p>直接调用 <code>alias</code> 命令，可以显示所有别名。</p>
<div><pre><code><span>alias</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>unalias</code> 命令可以解除别名。</p>
<div><pre><code><span>unalias</span> lt
</code></pre>
<div><span>1</span><br></div></div><h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options" target="_blank" rel="noopener noreferrer">How to use getopts to parse a script options<i>Content not supported</i></a>, Egidio Docile</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>set 命令</title>
      <link>https://list-jiang.github.io/code/linux/bash/set/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/set/</guid>
      <source url="https://list-jiang.github.io/rss.xml">set 命令</source>
      <description>set 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 set 的基本用法，帮助您写出更安全的 Bash 脚本。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>

<h2 id="简介"> 简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div><pre><code><span>bash</span> script.sh
</code></pre>
<div><span>1</span><br></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code> 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">官方手册<i>Content not supported</i></a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div><pre><code><span>set</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-u"> set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh

bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -u

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p>
<div><pre><code><span>set</span> -o nounset
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-x"> set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -x

<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>执行上面的脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
+ <span>echo</span> bar
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p>
<div><pre><code><span>set</span> -o xtrace
</code></pre>
<div><span>1</span><br></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>1</span>

<span>set</span> -x
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number equals 1"</span>
<span>else</span>
  <span>echo</span> <span>"Number does not equal 1"</span>
<span>fi</span>
<span>set</span> +x
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash-的错误处理"> Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div><pre><code><span>command</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div><pre><code><span># 写法一</span>
<span>command</span> <span>||</span> <span>{</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>}</span>

<span># 写法二</span>
<span>if</span> <span>!</span> <span>command</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>

<span># 写法三</span>
<span>command</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-e"> set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p>
<div><pre><code><span>set</span> +e
command1
command2
<span>set</span> -e
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

foo <span>||</span> <span>true</span>
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p>
<p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p>
<div><pre><code><span>set</span> -o errexit
</code></pre>
<div><span>1</span><br></div></div><h2 id="set-o-pipefail"> set -o pipefail</h2>
<p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p>
<p>请看下面这个例子。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -eo pipefail

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>运行后，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p>
<h2 id="其他参数"> 其他参数</h2>
<p><code>set</code> 命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p>
<h2 id="set-命令总结"> set 命令总结</h2>
<p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p>
<div><pre><code><span># 写法一</span>
<span>set</span> -euxo pipefail

<span># 写法二</span>
<span>set</span> -eux
<span>set</span> -o pipefail
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div><pre><code><span>bash</span> -euxo pipefail script.sh
</code></pre>
<div><span>1</span><br></div></div><h2 id="shopt-命令"> shopt 命令</h2>
<p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p>
<p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div><pre><code><span>shopt</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p>
<div><pre><code>$ <span>shopt</span> globstar
globstar  off
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p>
<ol>
<li>
<p><strong><code>-s</code></strong></p>
<p><code>-s</code> 用来打开某个参数。</p>
<div><pre><code><span>shopt</span> -s optionNameHere
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-u</code></strong></p>
<p><code>-u</code> 用来关闭某个参数。</p>
<div><pre><code><span>shopt</span> -u optionNameHere
</code></pre>
<div><span>1</span><br></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div><pre><code><span>shopt</span> -u histappend
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong><code>-q</code></strong></p>
<p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p>
<div><pre><code>$ <span>shopt</span> -q globstar
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p>
<div><pre><code><span>if</span> <span>shopt</span> -q globstar<span>;</span> <span>then</span>
  <span>..</span>.
<span>if</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">The Set built-in<i>Content not supported</i></a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/" target="_blank" rel="noopener noreferrer">Safer bash scripts with 'set -euxo pipefail’<i>Content not supported</i></a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener noreferrer">Writing Robust Bash Shell Scripts<i>Content not supported</i></a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录堆栈</title>
      <link>https://list-jiang.github.io/code/linux/bash/stack/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/stack/</guid>
      <source url="https://list-jiang.github.io/rss.xml">目录堆栈</source>
      <description>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>

<h2 id="cd"> cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code> 命令可以返回前一次的目录。</p>
<div><pre><code><span># 当前目录是 /path/to/foo</span>
$ <span>cd</span> bar

<span># 重新回到 /path/to/foo</span>
$ <span>cd</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，用户原来所在的目录是 <code>/path/to/foo</code>，进入子目录 <code>bar</code> 以后，使用 <code>cd -</code> 可以回到原来的目录。</p>
<h2 id="pushd-popd"> pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用 <code>pushd</code> 命令和 <code>popd</code> 命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code> 命令的用法类似 <code>cd</code> 命令，可以进入指定的目录。</p>
<div><pre><code><span>pushd</span> <span>dirname</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面命令会进入目录 <code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用 <code>pushd</code> 命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用 <code>pushd</code> 命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code> 命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录(即原来的第二条目录)。</p>
<p>下面是一个例子。</p>
<div><pre><code><span># 当前处在主目录，堆栈为空</span>
$ <span>pwd</span>
/home/me

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>pushd</span> ~/foo

<span># 进入 /etc</span>
<span># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span>pushd</span> /etc

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>popd</span>

<span># 进入 /home/me</span>
<span># 当前堆栈为 /home/me</span>
$ <span>popd</span>

<span># 目录不变，当前堆栈为空</span>
$ <span>popd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这两个命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 的参数表示仅操作堆栈，不改变目录。</p>
<div><pre><code><span>popd</span> -n
</code></pre>
<div><span>1</span><br></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
</li>
<li>
<p><strong>整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录(从 0 开始)，作为操作对象。这时不会切换目录。</p>
<div><pre><code><span># 从栈顶算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> +3

<span># 从栈底算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> -3

<span># 删除从栈顶算起的3号目录(从0开始)</span>
$ <span>popd</span> +3

<span># 删除从栈底算起的3号目录(从0开始)</span>
$ <span>popd</span> -3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面例子的整数编号都是从 0 开始计算，<code>popd +0</code> 是删除第一个目录，<code>popd +1</code> 是删除第二个，<code>popd -0</code> 是删除最后一个目录，，<code>popd -1</code> 是删除倒数第二个。</p>
</li>
<li>
<p><strong>目录参数</strong></p>
<p><code>pushd</code> 可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div><pre><code><span>pushd</span> <span>dir</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>popd</code> 没有这个参数。</p>
</li>
</ol>
<h2 id="dirs-命令"> dirs 命令</h2>
<p><code>dirs</code> 命令可以显示目录堆栈的内容，一般用来查看 <code>pushd</code> 和 <code>popd</code> 操作后的结果。</p>
<div><pre><code><span>dirs</span>
</code></pre>
<div><span>1</span><br></div></div><p>它有以下参数。</p>
<ul>
<li><code>-c</code>: 清空目录栈。</li>
<li><code>-l</code>: 用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>: 每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>: 每行一个条目，每个条目之前显示位置编号(从 0 开始)。</li>
<li><code>+N</code>: <code>N</code> 为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>: <code>N</code> 为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 启动环境</title>
      <link>https://list-jiang.github.io/code/linux/bash/startup/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/startup/</guid>
      <source url="https://list-jiang.github.io/rss.xml">Bash 启动环境</source>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="session"> Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session(对话)。</p>
<p>Session 有两种类型: 登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-session"> 登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>: 所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code> 目录里面所有 <code>.sh</code> 文件</li>
<li><code>~/.bash_profile</code>: 用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>: 如果 <code>~/.bash_profile</code> 没找到，则尝试执行这个脚本(C shell 的初始化脚本)。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>: 如果<code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都没找到，则尝试读取这个脚本(Bourne shell 和 Korn shell 的初始化脚本)。</li>
</ul>
<p>Linux 发行版更新的时候，会更新 <code>/etc</code> 里面的文件，比如 <code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在 <code>/etc/profile.d</code> 目录里面新建 <code>.sh</code> 脚本。</p>
<p>如果想修改您个人的登录环境，一般是写在 <code>~/.bash_profile</code> 里面。下面是一个典型的 <code>.bash_profile</code> 文件。</p>
<div><pre><code><span># .bash_profile</span>
<span><span>PATH</span></span><span>=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$HOME</span>/bin

<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>MANPATH</span><span>=</span>/usr/man:/usr/X11/man
<span>EDITOR</span><span>=</span>/usr/bin/vi
<span><span>PS1</span></span><span>=</span><span>'\h:\w\$ '</span>
<span><span>PS2</span></span><span>=</span><span>'> '</span>

<span>if</span> <span>[</span> -f ~/.bashrc <span>]</span><span>;</span> <span>then</span>
<span>.</span> ~/.bashrc
<span>fi</span>

<span>export</span> <span>PATH</span>
<span>export</span> EDITOR
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了 <code>~/.bashrc</code>。</p>
<p><code>bash</code> 命令的 <code>--login</code> 参数，会强制执行登录 Session 会执行的脚本。</p>
<div><pre><code><span>bash</span> --login
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--noprofile</code> 参数，会跳过上面这些 Profile 脚本。</p>
<div><pre><code><span>bash</span> --noprofile
</code></pre>
<div><span>1</span><br></div></div><h3 id="非登录-session"> 非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行 <code>bash</code> 命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>: 对全体用户有效。</li>
<li><code>~/.bashrc</code>: 仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code> 通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以 <code>~/.bashrc</code> 也是每次执行脚本都会执行的。</p>
<p><code>bash</code> 命令的 <code>--norc</code> 参数，可以禁止在非登录 Session 执行 <code>~/.bashrc</code> 脚本。</p>
<div><pre><code><span>bash</span> --norc
</code></pre>
<div><span>1</span><br></div></div><p><code>bash</code> 命令的 <code>--rcfile</code> 参数，指定另一个脚本代替 <code>.bashrc</code>。</p>
<div><pre><code><span>bash</span> --rcfile testrc
</code></pre>
<div><span>1</span><br></div></div><h3 id="bash-logout"> .bash_logout</h3>
<p><code>~/.bash_logout</code> 脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项"> 启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>: 不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>: 输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>: 每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div><pre><code><span>bash</span> -n scriptname
<span>bash</span> -v scriptname
<span>bash</span> -x scriptname
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="键盘绑定"> 键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为 <code>/etc/inputrc</code>，您可以在主目录创建自己的键盘绑定文件 <code>.inputrc</code> 文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div><pre><code><span>$include</span> /etc/inputrc
</code></pre>
<div><span>1</span><br></div></div><p><code>.inputrc</code> 文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code> 表示将 <code>Ctrl + t</code> 绑定为运行 <code>pwd</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>字符串操作</title>
      <link>https://list-jiang.github.io/code/linux/bash/string/</link>
      <guid>https://list-jiang.github.io/code/linux/bash/string/</guid>
      <source url="https://list-jiang.github.io/rss.xml">字符串操作</source>
      <description>本章介绍 Bash 字符串操作的语法。
</description>
      <category>Linux</category>
      <pubDate>Fri, 18 Feb 2022 02:39:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>

<h2 id="字符串的长度"> 字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div><pre><code><span>${<span>#</span>varname}</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name
$ <span>echo</span> <span>${<span>#</span>myPath}</span>
<span>29</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>大括号 <code>{}</code> 是必需的，否则 Bash 会将 <code>$#</code> 理解成脚本的参数个数，将变量名理解成文本。</p>
<div><pre><code>$ <span>echo</span> <span>$#</span>myvar
0myvar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，Bash 将 <code>$#</code> 和 <code>myvar</code> 分开解释了。</p>
<h2 id="子字符串"> 子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div><pre><code><span>${varname<span>:</span>offset<span>:</span>length}</span>
</code></pre>
<div><span>1</span><br></div></div><p>上面语法的含义是返回变量 <code>$varname</code> 的子字符串，从位置 <code>offset</code> 开始(从 <code>0</code> 开始计算)，长度为 <code>length</code>。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4<span>:</span>4}</span>
foot
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子返回字符串 <code>frogfootman</code> 从 4 号位置开始的长度为 4 的子字符串 <code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span>${"hello"<span>:</span>2<span>:</span>3}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 不是变量名，导致 Bash 报错。</p>
<p>如果省略 <code>length</code>，则从位置 <code>offset</code> 开始，一直返回到字符串的结尾。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4}</span>
footman
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子是返回变量 <code>count</code> 从 4 号位置一直到结尾的子字符串。</p>
<p>如果 <code>offset</code> 为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与 <code>${variable:-word}</code> 的变量的设置默认值语法混淆。这时，如果还指定 <code>length</code>，则 <code>length</code> 不能小于零。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>"This string is long."</span>
$ <span>echo</span> <span>${foo<span>:</span> -5}</span>
long.
$ <span>echo</span> <span>${foo<span>:</span> -5<span>:</span>2}</span>
lo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>offset</code> 为 <code>-5</code>，表示从倒数第 5 个字符开始截取，所以返回 <code>long.</code>。如果指定长度为 <code>2</code>，则返回 <code>lo</code>。</p>
<h2 id="搜索和替换"> 搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<h3 id="字符串头部的模式匹配"> 字符串头部的模式匹配</h3>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>#</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>##</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串开头的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<p>匹配模式 <code>pattern</code> 可以使用 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>#</span><span>/</span>*<span>/</span>}</span>
cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>##</span><span>/</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配的模式是 <code>/*/</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>/home/</code>，最长匹配是 <code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>##</span>*<span>/</span>}</span>
long.file.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>*/</code> 匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>*-}</span>
<span>456</span>-1414
$ <span>echo</span> <span>${phone<span>##</span>*-}</span>
<span>1414</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>444}</span>
<span>555</span>-456-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面例子中，原始字符串里面无法匹配模式 <code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>#</span>JPG<span>/</span>jpg}</span>
jpg.JPG
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串头部，所以返回 <code>jpg.JPG</code>。</p>
<h3 id="字符串尾部的模式匹配"> 字符串尾部的模式匹配</h3>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%%</span>pattern}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法会删除变量字符串结尾的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span>.*}</span>
/home/cam/book/long.file

$ <span>echo</span> <span>${path<span>%%</span>.*}</span>
/home/cam/book/long
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，匹配模式是 <code>.*</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>.name</code>，最长匹配是 <code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span><span>/</span>*}</span>
/home/cam/book
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，模式 <code>/*</code> 匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div><pre><code>$ <span>file</span><span>=</span>foo.png
$ <span>echo</span> <span>${file<span>%</span>.png}</span>.jpg
foo.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将文件的后缀名，从 <code>.png</code> 改成了 <code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>%</span>-*}</span>
<span>555</span>-456
$ <span>echo</span> <span>${phone<span>%%</span>-*}</span>
<span>555</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>%</span>JPG<span>/</span>jpg}</span>
JPG.jpg
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串尾部，所以返回 <code>JPG.jpg</code>。</p>
<h3 id="任意位置的模式匹配"> 任意位置的模式匹配</h3>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，但仅替换第一个匹配</span>
<span>${variable<span>/</span>pattern<span>/</span>string}</span>

<span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，所有匹配都替换</span>
<span>${variable<span>/</span><span>/</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面两种语法都是最长匹配(贪婪匹配)下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/foo.name

$ <span>echo</span> <span>${path<span>/</span><span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>上面例子中，前一个命令只替换了第一个 <code>foo</code>，后一个命令将两个 <code>foo</code> 都替换了。</p>
<p>下面的例子将分隔符从 <code>:</code> 换成换行符。</p>
<div><pre><code>$ <span>echo</span> -e <span>${<span>PATH</span><span>/</span><span>/</span><span>:</span><span>/</span>'\n'}</span>
/usr/local/bin
/usr/bin
/bin
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面例子中，<code>echo</code> 命令的 <code>-e</code> 参数，表示将替换后的字符串的 <code>\n</code> 字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>/</span>5?4<span>/</span>-}</span>
<span>55</span>-56-1414
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面的例子将 <code>5-4</code> 替换成 <code>-</code>。</p>
<p>如果省略了 <code>string</code> 部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>.*<span>/</span>}</span>
/home/cam/foo/foo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>上面例子中，第二个斜杠后面的 <code>string</code> 部分省略了，所以模式 <code>.*</code> 匹配的部分 <code>.name</code> 被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="改变大小写"> 改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div><pre><code><span># 转为大写</span>
<span>${varname<span>^^</span>}</span>

<span># 转为小写</span>
<span>${varname<span>,,</span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span>heLLo
$ <span>echo</span> <span>${foo<span>^^</span>}</span>
HELLO
$ <span>echo</span> <span>${foo<span>,,</span>}</span>
hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
  </channel>
</rss>